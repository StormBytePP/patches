Backported the whole libgomp from master to 9.2.0 to solve the race condition issue at commit:

https://github.com/gcc-mirror/gcc/commit/3d9bf16ac2ce6643e4240cdd0c65f7aabc4aae61

diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index 958572a54c0..6b16bf34b17 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,15 +1,1143 @@
-2019-08-12  Release Manager
+2019-12-13  Julian Brown  <julian@codesourcery.com>
+
+	PR libgomp/92881
+
+	* libgomp.h (gomp_remove_var_async): Add prototype.
+	* oacc-mem.c (delete_copyout): Call gomp_remove_var_async instead of
+	gomp_remove_var.
+	* target.c (gomp_unref_tgt): Change return type to bool, indicating
+	whether target_mem_desc was unmapped.
+	(gomp_unref_tgt_void): New.
+	(gomp_remove_var): Reimplement in terms of...
+	(gomp_remove_var_internal): ...this new helper function.
+	(gomp_remove_var_async): New, implemented using above helper function.
+	(gomp_unmap_vars_internal): Use gomp_unref_tgt_void instead of
+	gomp_unref_tgt.
+
+2019-12-13  Andrew Stubbs  <ams@codesourcery.com>
+
+	* testsuite/libgomp.oacc-c-c++-common/acc_prof-init-1.c: Handle gcn.
+	* testsuite/libgomp.oacc-c-c++-common/acc_prof-kernels-1.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/asyncwait-nop-1.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/function-not-offloaded.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/async_queue-1.c: Disable on GCN.
+	* testsuite/libgomp.oacc-c-c++-common/tile-1.c: Likewise.
+
+2019-12-13  Tobias Burnus  <tobias@codesourcery.com>
+
+	* openacc.f90 (module openacc_kinds): Use 'PUBLIC' to mark all symbols
+	as public except for the 'use â€¦, only' imported symbol, which is
+	private.
+	(module openacc): Default to 'PRIVATE' to exclude openacc_internal; mark
+	all symbols from module openacc_kinds as PUBLIC; add missing PUBLIC
+	attributes for acc_copyout_finalize and acc_delete_finalize.
+
+2019-12-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92899
+	* testsuite/libgomp.fortran/atomic1.f90: New test.
+
+2019-12-11  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR libgomp/92843
+	* oacc-mem.c (present_create_copy, delete_copyout): Fix dynamic
+	reference counting for structured 'REFCOUNT_INFINITY'.  Add some
+	assertions.
+	(goacc_insert_pointer, goacc_remove_pointer): Adjust accordingly.
+	* testsuite/libgomp.oacc-c-c++-common/pr92843-1.c: New file.
+	* testsuite/libgomp.oacc-c-c++-common/clauses-1.c: Fix OpenACC.
+	* testsuite/libgomp.oacc-c-c++-common/lib-82.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/nested-1.c: Likewise.
+
+	* oacc-parallel.c (find_pointer, GOACC_enter_exit_data): Move...
+	* oacc-mem.c: ... here.
+	(gomp_acc_insert_pointer, gomp_acc_remove_pointer): Rename to
+	'goacc_insert_pointer', 'goacc_remove_pointer', and make 'static'.
+	* libgomp.h (gomp_acc_insert_pointer, gomp_acc_remove_pointer):
+	Remove.
+	* libgomp_g.h: Update.
+
+	* oacc-parallel.c (GOACC_wait, goacc_wait): Move...
+	* oacc-async.c: ... here.
+	* oacc-int.h (goacc_wait): Declare.
+	* libgomp_g.h: Update
+
+	PR libgomp/92854
+	* testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-1.c:
+	New file.
+	* testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-2.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-3.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-1.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-2.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-3.c:
+	Likewise.
+
+2019-12-11  Thomas Schwinge  <thomas@codesourcery.com>
+	    Julian Brown  <julian@codesourcery.com>
+
+	* target.c (gomp_load_image_to_device, omp_target_associate_ptr):
+	Initialize 'dynamic_refcount' whenever we initialize 'refcount'.
+
+2019-12-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	* omp_lib.h.in: Fix spelling of function declaration
+	omp_get_cancell(l)ation.
+	* libgomp.texi (acc_is_present, acc_async_test, acc_async_test_all):
+	Fix typos.
+	* env.c: Fix comment typos.
+	* oacc-host.c: Likewise.
+	* ordered.c: Likewise.
+	* task.c: Likewise.
+	* team.c: Likewise.
+	* config/gcn/task.c: Likewise.
+	* config/gcn/team.c: Likewise.
+	* config/nvptx/task.c: Likewise.
+	* config/nvptx/team.c: Likewise.
+	* plugin/plugin-gcn.c: Likewise.
+	* testsuite/libgomp.fortran/jacobi.f: Likewise.
+	* testsuite/libgomp.hsa.c/tiling-2.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/enter_exit-lib.c: Likewise.
+
+2019-12-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.oacc-fortran/optional-cache.f95: Add 'dg-do run'.
+	* testsuite/libgomp.oacc-fortran/optional-reduction.f90: Remove
+	unnecessary 'dg-additional-options "-w"'.
+
+2019-12-09  Thomas Schwinge  <thomas@codesourcery.com>
+	    Julian Brown  <julian@codesourcery.com>
+
+	PR libgomp/92116
+	PR libgomp/92877
+
+	* oacc-mem.c (lookup_dev): Reimplement.  Adjust all users.
+	* libgomp.h (struct acc_dispatch_t): Remove 'data_environ' member.
+	Adjust all users.
+	* testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4-2.c:
+	Remove XFAIL.
+	* testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/pr92877-1.c: New file.
+
+2019-12-09  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR libgomp/92503
+	* oacc-mem.c (acc_free): Error out instead of 'acc_unmap_data'.
+	* testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-1.c: New
+	file.
+	* testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-2.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-3-2.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-3.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4-2.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/clauses-1.c: Adjust.
+	* testsuite/libgomp.oacc-c-c++-common/context-1.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/context-2.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/context-3.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/context-4.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/lib-13.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/lib-14.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/lib-18.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/lib-91.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/nested-1.c: Likewise.
+
+	PR libgomp/92840
+	* oacc-mem.c (acc_map_data): Clarify reference counting behavior.
+	(acc_unmap_data): Add error case for 'REFCOUNT_INFINITY'.
+	* testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-1.c:
+	New file.
+	* testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-2.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-3.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/clauses-1.c: Adjust.
+	* testsuite/libgomp.oacc-c-c++-common/nested-1.c: Adjust.
+
+	PR libgomp/92511
+	* testsuite/libgomp.oacc-c-c++-common/copyin-devptr-1.c: Remove
+	this file...
+	* testsuite/libgomp.oacc-c-c++-common/copyin-devptr-2.c: ..., and
+	this file...
+	* testsuite/libgomp.oacc-c-c++-common/lib-22.c: ..., and this
+	file...
+	* testsuite/libgomp.oacc-c-c++-common/lib-30.c: ..., and this
+	file...
+	* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c:
+	... with their content moved into, and extended in this new file.
+	* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-a.c:
+	New file.
+	* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-p.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-a.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-2.c:
+	Likewise.
+
+	* testsuite/libgomp.oacc-c-c++-common/map-data-1.c: New file.
+
+	PR libgomp/92854
+	* testsuite/libgomp.oacc-c-c++-common/pr92854-1.c: New file.
+
+	* testsuite/libgomp.oacc-c-c++-common/host_data-6.c: New file.
+
+	* target.c (gomp_exit_data): Use 'gomp_remove_var'.
+
+2019-12-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.fortran/use_device_addr-3.f90: Make 'stop' codes
+	unique.
+	* testsuite/libgomp.fortran/use_device_addr-4.f90: Ditto.
+	* testsuite/libgomp.fortran/use_device_ptr-optional-2.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/declare-5.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/optional-data-copyin-by-value.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/optional-firstprivate.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/optional-update-host.f90: Ditto.
+
+2019-12-06  Kwok Cheung Yeung  <kcy@codesourcery.com>
+
+	* config/accel/proc.c (omp_get_num_procs): Apply ialias macro.
+
+2019-12-06  Tobias Burnus  <tobias@codesourcery.com>
+	    Kwok Cheung Yeung <kcy@codesourcery.com>
+
+	* oacc-mem.c (update_dev_host, gomp_acc_insert_pointer): Just return
+	if input it a NULL pointer.
+	* testsuite/libgomp.oacc-c-c++-common/lib-43.c: Remove; dependent on
+	diagnostic of NULL pointer.
+	* testsuite/libgomp.oacc-c-c++-common/lib-47.c: Ditto.
+	* testsuite/libgomp.fortran/optional-map.f90: New.
+	* testsuite/libgomp.fortran/use_device_addr-1.f90
+	(test_dummy_opt_callee_1_absent): New.
+	(test_dummy_opt_call_1): Call it.
+	* testsuite/libgomp.fortran/use_device_addr-2.f90: Likewise.
+	* testsuite/libgomp.fortran/use_device_addr-3.f90: Likewise.
+	* testsuite/libgomp.fortran/use_device_addr-4.f90: Likewise.
+	* testsuite/libgomp.oacc-fortran/optional-cache.f95: New.
+	* testsuite/libgomp.oacc-fortran/optional-data-copyin-by-value.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-data-copyin.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-data-copyout.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-data-enter-exit.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-declare.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-firstprivate.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-host_data.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-nested-calls.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-private.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-reduction.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-update-device.f90: New.
+	* testsuite/libgomp.oacc-fortran/optional-update-host.f90: New.
+
+2019-12-05  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.oacc-fortran/error_stop-1.f: Also don't
+	expect dg-output of 'Error termination.' for GCN.
+	* testsuite/libgomp.oacc-fortran/error_stop-2.f: Likewise.
+	* testsuite/libgomp.oacc-fortran/error_stop-3.f: Likewise.
+
+2019-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/92756
+	* testsuite/libgomp.fortran/teams1.f90: New test.
+	* testsuite/libgomp.fortran/teams2.f90: New test.
+
+2019-12-03  Frederik Harwath  <frederik@codesourcery.com>
+
+	* oacc-init.c (acc_known_device_type): Add function.
+	(unknown_device_type_error): Add function.
+	(name_of_acc_device_t): Change to call unknown_device_type_error
+	on unknown type.
+	(resolve_device): Use acc_known_device_type.
+	(acc_init): Fail if acc_device_t argument is not valid.
+	(acc_shutdown): Likewise.
+	(acc_get_num_devices): Likewise.
+	(acc_set_device_type): Likewise.
+	(acc_get_device_num): Likewise.
+	(acc_set_device_num): Likewise.
+	(acc_on_device): Add comment that argument validity is not checked.
+
+2019-12-03  Andrew Stubbs  <ams@codesourcery.com>
+
+	* testsuite/lib/libgomp.exp (offload_target_to_openacc_device_type):
+	Recognize amdgcn.
+	(check_effective_target_openacc_amdgcn_accel_present): New proc.
+	(check_effective_target_openacc_amdgcn_accel_selected): New proc.
+	* testsuite/libgomp.oacc-c++/c++.exp: Add support for amdgcn.
+	* testsuite/libgomp.oacc-c/c.exp: Likewise.
+	* testsuite/libgomp.oacc-fortran/fortran.exp: Likewise.
+
+2019-12-03  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR libgomp/91938
+	* configure.tgt: Avoid IE tls on *-*-musl*.
+
+2019-11-29  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.oacc-fortran/declare-5.f90: Extend by
+	adding a common-block test case.
+
+2019-11-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60228
+	* testsuite/libgomp.c++/udr-20.C: New test.
+	* testsuite/libgomp.c++/udr-21.C: New test.
+
+2019-11-27  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* testsuite/lib/libgomp.exp
+	(check_effective_target_offload_target_nvptx): New proc.
+	* testsuite/libgomp.fortran/target-print-1.f90: Use it with
+	'dg-skip-if'.
+	* testsuite/libgomp.oacc-fortran/print-1.f90: Likewise.
+	* testsuite/libgomp.fortran/target-print-1-nvptx.f90: New file.
+	* testsuite/libgomp.oacc-fortran/print-1-nvptx.f90: Likewise.
+
+2019-11-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libgomp.c/pr39591-1.c: Rename err to e.
+	* testsuite/libgomp.c/pr39591-2.c: Likewise.
+	* testsuite/libgomp.c/pr39591-3.c: Likewise.
+	* testsuite/libgomp.c/private-1.c: Likewise.
+	* testsuite/libgomp.c/task-1.c: Likewise.
+	* testsuite/libgomp.c/task-5.c: Renamed err to serr.
+
+2019-11-20  Julian Brown  <julian@codesourcery.com>
+
+	* plugin/plugin-gcn.c (wait_for_queue_nonfull): Don't lock/unlock
+	aq->mutex here.
+	(queue_push_launch): Lock aq->mutex before calling
+	wait_for_queue_nonfull.
+	(queue_push_callback): Likewise.
+	(queue_push_asyncwait): Likewise.
+	(queue_push_placeholder): Likewise.
+
+2019-11-20  Julian Brown  <julian@codesourcery.com>
+
+	* plugin/plugin-gcn.c (hsa_memory_copy_wrapper): New.
+	(copy_data, GOMP_OFFLOAD_host2dev): Use above function.
+	(GOMP_OFFLOAD_dev2host, GOMP_OFFLOAD_dev2dev): Check hsa_memory_copy
+	return code.
+
+2019-11-20  Julian Brown  <julian@codesourcery.com>
+
+	PR libgomp/92511
+
+	* oacc-mem.c (present_create_copy): Fix device pointer return value in
+	case of "present" subarray.  Use tgt->tgt_start instead of tgt->to_free
+	in non-present/create case.
+	(delete_copyout): Change error condition to fail only on copies outside
+	of mapped block.  Adjust error message accordingly.
+	* testsuite/libgomp.oacc-c-c++-common/copyin-devptr-1.c: New test.
+	* testsuite/libgomp.oacc-c-c++-common/copyin-devptr-2.c: New test.
+	* testsuite/libgomp.oacc-c-c++-common/lib-20.c: Adjust expected error
+	message.
+	* testsuite/libgomp.oacc-c-c++-common/lib-23.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/lib-22.c: Allow test to pass now.
+	* testsuite/libgomp.oacc-c-c++-common/lib-30.c: Likewise.
+
+2019-11-20  Maciej W. Rozycki  <macro@wdc.com>
+
+	* testsuite/lib/libgomp.exp (libgomp_init): Add flags to find
+	libatomic in build-tree testing.
+
+2019-11-18  Maciej W. Rozycki  <macro@wdc.com>
+
+	* testsuite/Makefile.in: Regenerate.
+
+2019-11-15  Andrew Stubbs  <ams@codesourcery.com>
+
+	* testsuite/libgomp.c/target-print-1.c: New file.
+	* testsuite/libgomp.fortran/target-print-1.f90: New file.
+	* testsuite/libgomp.oacc-c/print-1.c: New file.
+	* testsuite/libgomp.oacc-fortran/print-1.f90: New file.
+
+2019-11-13  Andrew Stubbs  <ams@codesourcery.com>
+	    Kwok Cheung Yeung  <kcy@codesourcery.com>
+	    Julian Brown  <julian@codesourcery.com>
+	    Tom de Vries  <tom@codesourcery.com>
+
+	* plugin/Makefrag.am: Add amdgcn plugin support.
+	* plugin/configfrag.ac: Likewise.
+	* plugin/plugin-gcn.c: New file.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2019-11-13  Andrew Stubbs  <ams@codesourcery.com>
+
+	* config/gcn/team.c (gomp_gcn_enter_kernel): Set up the team arena
+	and use team_malloc variants.
+	(gomp_gcn_exit_kernel): Use team_free.
+	* libgomp.h (TEAM_ARENA_SIZE): Define.
+	(TEAM_ARENA_START): Define.
+	(TEAM_ARENA_FREE): Define.
+	(TEAM_ARENA_END): Define.
+	(team_malloc): New function.
+	(team_malloc_cleared): New function.
+	(team_free): New function.
+	* team.c (gomp_new_team): Initialize and use team_malloc.
+	(free_team): Use team_free.
+	(gomp_free_thread): Use team_free.
+	(gomp_pause_host): Use team_free.
+	* work.c (gomp_init_work_share): Use team_malloc.
+	(gomp_fini_work_share): Use team_free.
+
+2019-11-13  Andrew Stubbs  <ams@codesourcery.com>
+	    Kwok Cheung Yeung  <kcy@codesourcery.com>
+	    Julian Brown  <julian@codesourcery.com>
+	    Tom de Vries  <tom@codesourcery.com>
+
+	* Makefile.am (libgomp_la_SOURCES): Add oacc-target.c.
+	* Makefile.in: Regenerate.
+	* config.h.in (PLUGIN_GCN): Add new undef.
+	* config/accel/openacc.f90 (acc_device_gcn): New parameter.
+	* config/gcn/affinity-fmt.c: New file.
+	* config/gcn/bar.c: New file.
+	* config/gcn/bar.h: New file.
+	* config/gcn/doacross.h: New file.
+	* config/gcn/icv-device.c: New file.
+	* config/gcn/oacc-target.c: New file.
+	* config/gcn/simple-bar.h: New file.
+	* config/gcn/target.c: New file.
+	* config/gcn/task.c: New file.
+	* config/gcn/team.c: New file.
+	* config/gcn/time.c: New file.
+	* configure.ac: Add amdgcn*-*-*.
+	* configure: Regenerate.
+	* configure.tgt: Add amdgcn*-*-*.
+	* libgomp-plugin.h (offload_target_type): Add OFFLOAD_TARGET_TYPE_GCN.
+	* libgomp.h (gcn_thrs): Add amdgcn variant.
+	(set_gcn_thrs): Likewise.
+	(gomp_thread): Likewise.
+	* oacc-int.h (goacc_thread): Likewise.
+	* oacc-target.c: New file.
+	* openacc.f90 (acc_device_gcn): New parameter.
+	* openacc.h (acc_device_t): Add acc_device_gcn.
+	* team.c (gomp_free_pool_helper): Add amdgcn support.
+
+2019-11-13  Andrew Stubbs  <ams@codesourcery.com>
+	    Julian Brown  <julian@codesourcery.com>
+
+	* libgomp-plugin.h (GOMP_OFFLOAD_openacc_async_construct): Add int
+	parameter.
+	* oacc-async.c (lookup_goacc_asyncqueue): Pass device number to the
+	queue constructor.
+	* oacc-host.c (host_openacc_async_construct): Add device parameter.
+	* plugin/plugin-nvptx.c (GOMP_OFFLOAD_openacc_async_construct): Add
+	device parameter.
+
+2019-11-13  Andrew Stubbs  <ams@codesourcery.com>
+
+	* configure.tgt (nvptx*-*-*): Add "accel" directory.
+	* config/nvptx/libgomp-plugin.c: Move ...
+	* config/accel/libgomp-plugin.c: ... to here.
+	* config/nvptx/lock.c: Move ...
+	* config/accel/lock.c: ... to here.
+	* config/nvptx/mutex.c: Move ...
+	* config/accel/mutex.c: ... to here.
+	* config/nvptx/mutex.h: Move ...
+	* config/accel/mutex.h: ... to here.
+	* config/nvptx/oacc-async.c: Move ...
+	* config/accel/oacc-async.c: ... to here.
+	* config/nvptx/oacc-cuda.c: Move ...
+	* config/accel/oacc-cuda.c: ... to here.
+	* config/nvptx/oacc-host.c: Move ...
+	* config/accel/oacc-host.c: ... to here.
+	* config/nvptx/oacc-init.c: Move ...
+	* config/accel/oacc-init.c: ... to here.
+	* config/nvptx/oacc-mem.c: Move ...
+	* config/accel/oacc-mem.c: ... to here.
+	* config/nvptx/oacc-plugin.c: Move ...
+	* config/accel/oacc-plugin.c: ... to here.
+	* config/nvptx/omp-lock.h: Move ...
+	* config/accel/omp-lock.h: ... to here.
+	* config/nvptx/openacc.f90: Move ...
+	* config/accel/openacc.f90: ... to here.
+	* config/nvptx/pool.h: Move ...
+	* config/accel/pool.h: ... to here.
+	* config/nvptx/proc.c: Move ...
+	* config/accel/proc.c: ... to here.
+	* config/nvptx/ptrlock.c: Move ...
+	* config/accel/ptrlock.c: ... to here.
+	* config/nvptx/ptrlock.h: Move ...
+	* config/accel/ptrlock.h: ... to here.
+	* config/nvptx/sem.c: Move ...
+	* config/accel/sem.c: ... to here.
+	* config/nvptx/sem.h: Move ...
+	* config/accel/sem.h: ... to here.
+	* config/nvptx/thread-stacksize.h: Move ...
+	* config/accel/thread-stacksize.h: ... to here.
+
+2019-11-12  Maciej W. Rozycki  <macro@codesourcery.com>
+	    Tobias Burnus  <tobias@codesourcery.com>
+	    Frederik Harwath  <frederik@codesourcery.com>
+	    Thomas Schwinge  <thomas@codesourcery.com>
+
+	libgomp/
+	* testsuite/libgomp.oacc-c-c++-common/parallel-dims.c: New test.
+	* testsuite/libgomp.oacc-fortran/parallel-dims-aux.c: New test.
+	* testsuite/libgomp.oacc-fortran/parallel-dims.f89: New test.
+
+2019-11-11  Tobias Burnus  <tobias@codesourcery.com>
+	    Kwok Cheung Yeung  <kcy@codesourcery.com>
+
+	* testsuite/libgomp.fortran/use_device_ptr-optional-1.f90: Extend.
+	* testsuite/libgomp.fortran/use_device_ptr-optional-2.f90: New.
+
+2019-11-11  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* testsuite/libgomp.fortran/target9.f90: Specify 'dg-do run'.
+
+	* testsuite/libgomp.fortran/use_device_addr-3.f90: Specify 'dg-do
+	run'.
+	* testsuite/libgomp.fortran/use_device_addr-4.f90: Likewise.
+	* testsuite/libgomp.fortran/use_device_ptr-1.f90: Likewise.
+
+2019-11-06  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-1.c:
+	Add expected warnings about missing reduction clauses.
+	* testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-2.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-3.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-4.c:
+	Likewise.
+
+2019-11-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.fortran/pr66199-1.f90: Remove
+	'dg-do run' (implies torture test) as 'dg-options "O2"' is used.
+	* testsuite/libgomp.fortran/pr66199-2.f90: Ditto.
+	* testsuite/libgomp.fortran/taskloop2.f90: Ditto.
+	* testsuite/libgomp.fortran/taskloop3.f90: Ditto.
+	* testsuite/libgomp.fortran/taskloop4.f90: Ditto.
+
+2019-11-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92305
+	* testsuite/libgomp.fortran/allocatable2.f90: Use
+	unique numbers with 'stop'.
+	* testsuite/libgomp.fortran/use_device_addr-1.f90: Ditto.
+	* testsuite/libgomp.fortran/use_device_addr-2.f90: Ditto.
+	* testsuite/libgomp.fortran/use_device_ptr-1.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/lib-15.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/pset-1.f90: Ditto.
+
+2019-11-01  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.fortran/use_device_addr-1.f90 (test_nullptr_1,
+	test_dummy_opt_nullptr_callee_1): Add present but unallocated test.
+	* testsuite/libgomp.fortran/use_device_addr-2.f90: Likewise.
+	* testsuite/libgomp.fortran/use_device_addr-3.f90: New.
+	* testsuite/libgomp.fortran/use_device_addr-4.f90: New.
+	* testsuite/testsuite/libgomp.fortran/use_device_ptr-1.f90: New.
+
+2019-10-30  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.fortran/target9.f90: New.
+
+2019-10-30  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.fortran/aligned1.f03: Replace 'STOP' by 'stop'.
+	* testsuite/libgomp.fortran/alloc-comp-1.f90: Ditto.
+	* testsuite/libgomp.fortran/alloc-comp-2.f90: Ditto.
+	* testsuite/libgomp.fortran/alloc-comp-3.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable1.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable10.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable11.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable12.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable2.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable3.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable4.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable5.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable6.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable7.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable8.f90: Ditto.
+	* testsuite/libgomp.fortran/allocatable9.f90: Ditto.
+	* testsuite/libgomp.fortran/associate1.f90: Ditto.
+	* testsuite/libgomp.fortran/associate2.f90: Ditto.
+	* testsuite/libgomp.fortran/associate3.f90: Ditto.
+	* testsuite/libgomp.fortran/async_io_4.f90: Ditto.
+	* testsuite/libgomp.fortran/async_io_5.f90: Ditto.
+	* testsuite/libgomp.fortran/async_io_6.f90: Ditto.
+	* testsuite/libgomp.fortran/async_io_7.f90: Ditto.
+	* testsuite/libgomp.fortran/cancel-do-1.f90: Ditto.
+	* testsuite/libgomp.fortran/cancel-do-2.f90: Ditto.
+	* testsuite/libgomp.fortran/cancel-parallel-1.f90: Ditto.
+	* testsuite/libgomp.fortran/cancel-sections-1.f90: Ditto.
+	* testsuite/libgomp.fortran/cancel-taskgroup-2.f90: Ditto.
+	* testsuite/libgomp.fortran/character1.f90: Ditto.
+	* testsuite/libgomp.fortran/character2.f90: Ditto.
+	* testsuite/libgomp.fortran/collapse1.f90: Ditto.
+	* testsuite/libgomp.fortran/collapse2.f90: Ditto.
+	* testsuite/libgomp.fortran/collapse3.f90: Ditto.
+	* testsuite/libgomp.fortran/collapse4.f90: Ditto.
+	* testsuite/libgomp.fortran/crayptr1.f90: Ditto.
+	* testsuite/libgomp.fortran/crayptr2.f90: Ditto.
+	* testsuite/libgomp.fortran/crayptr3.f90: Ditto.
+	* testsuite/libgomp.fortran/declare-simd-1.f90: Ditto.
+	* testsuite/libgomp.fortran/declare-simd-3.f90: Ditto.
+	* testsuite/libgomp.fortran/declare-target-2.f90: Ditto.
+	* testsuite/libgomp.fortran/depend-1.f90: Ditto.
+	* testsuite/libgomp.fortran/depend-2.f90: Ditto.
+	* testsuite/libgomp.fortran/depend-3.f90: Ditto.
+	* testsuite/libgomp.fortran/do1.f90: Ditto.
+	* testsuite/libgomp.fortran/do2.f90: Ditto.
+	* testsuite/libgomp.fortran/do_concurrent_5.f90: Ditto.
+	* testsuite/libgomp.fortran/doacross1.f90: Ditto.
+	* testsuite/libgomp.fortran/doacross2.f90: Ditto.
+	* testsuite/libgomp.fortran/doacross3.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/array_sections-3.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/array_sections-4.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/async_target-1.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/async_target-2.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/declare_target-1.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/declare_target-2.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/declare_target-3.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/declare_target-4.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/declare_target-5.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/device-1.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/device-2.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/device-3.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/simd-1.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/simd-2.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/simd-3.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/simd-4.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/simd-5.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/simd-6.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/simd-7.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/simd-8.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target-1.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target-2.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target-3.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target-4.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target-5.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target_data-1.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target_data-2.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target_data-3.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target_data-4.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target_data-5.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target_data-6.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target_data-7.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target_update-1.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/target_update-2.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/task_dep-1.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/task_dep-2.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/task_dep-3.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/task_dep-4.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/task_dep-5.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/teams-2.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/teams-3.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/teams-4.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/teams-5.f90: Ditto.
+	* testsuite/libgomp.fortran/examples-4/teams-6.f90: Ditto.
+	* testsuite/libgomp.fortran/lastprivate1.f90: Ditto.
+	* testsuite/libgomp.fortran/lastprivate2.f90: Ditto.
+	* testsuite/libgomp.fortran/lib1.f90: Ditto.
+	* testsuite/libgomp.fortran/lib4.f90: Ditto.
+	* testsuite/libgomp.fortran/lock-1.f90: Ditto.
+	* testsuite/libgomp.fortran/lock-2.f90: Ditto.
+	* testsuite/libgomp.fortran/nested1.f90: Ditto.
+	* testsuite/libgomp.fortran/nestedfn1.f90: Ditto.
+	* testsuite/libgomp.fortran/nestedfn2.f90: Ditto.
+	* testsuite/libgomp.fortran/nestedfn3.f90: Ditto.
+	* testsuite/libgomp.fortran/nestedfn4.f90: Ditto.
+	* testsuite/libgomp.fortran/nestedfn5.f90: Ditto.
+	* testsuite/libgomp.fortran/omp_atomic1.f90: Ditto.
+	* testsuite/libgomp.fortran/omp_atomic2.f90: Ditto.
+	* testsuite/libgomp.fortran/omp_atomic3.f90: Ditto.
+	* testsuite/libgomp.fortran/omp_atomic4.f90: Ditto.
+	* testsuite/libgomp.fortran/omp_atomic5.f90: Ditto.
+	* testsuite/libgomp.fortran/omp_cond1.f: Ditto.
+	* testsuite/libgomp.fortran/omp_cond2.f: Ditto.
+	* testsuite/libgomp.fortran/omp_cond3.F90: Ditto.
+	* testsuite/libgomp.fortran/omp_cond4.F90: Ditto.
+	* testsuite/libgomp.fortran/omp_parse1.f90: Ditto.
+	* testsuite/libgomp.fortran/omp_parse2.f90: Ditto.
+	* testsuite/libgomp.fortran/omp_parse3.f90: Ditto.
+	* testsuite/libgomp.fortran/omp_parse4.f90: Ditto.
+	* testsuite/libgomp.fortran/openmp_version-1.f: Ditto.
+	* testsuite/libgomp.fortran/openmp_version-2.f90: Ditto.
+	* testsuite/libgomp.fortran/parloops-exit-first-loop-alt-2.f95: Ditto.
+	* testsuite/libgomp.fortran/parloops-exit-first-loop-alt.f95: Ditto.
+	* testsuite/libgomp.fortran/pointer1.f90: Ditto.
+	* testsuite/libgomp.fortran/pointer2.f90: Ditto.
+	* testsuite/libgomp.fortran/pr25219.f90: Ditto.
+	* testsuite/libgomp.fortran/pr27395-1.f90: Ditto.
+	* testsuite/libgomp.fortran/pr27395-2.f90: Ditto.
+	* testsuite/libgomp.fortran/pr27416-1.f90: Ditto.
+	* testsuite/libgomp.fortran/pr27916-1.f90: Ditto.
+	* testsuite/libgomp.fortran/pr27916-2.f90: Ditto.
+	* testsuite/libgomp.fortran/pr28390.f: Ditto.
+	* testsuite/libgomp.fortran/pr29629.f90: Ditto.
+	* testsuite/libgomp.fortran/pr32550.f90: Ditto.
+	* testsuite/libgomp.fortran/pr33880.f90: Ditto.
+	* testsuite/libgomp.fortran/pr34020.f90: Ditto.
+	* testsuite/libgomp.fortran/pr35130.f90: Ditto.
+	* testsuite/libgomp.fortran/pr42162.f90: Ditto.
+	* testsuite/libgomp.fortran/pr46753.f90: Ditto.
+	* testsuite/libgomp.fortran/pr48894.f90: Ditto.
+	* testsuite/libgomp.fortran/pr49792-1.f90: Ditto.
+	* testsuite/libgomp.fortran/pr49792-2.f90: Ditto.
+	* testsuite/libgomp.fortran/pr63938-1.f90: Ditto.
+	* testsuite/libgomp.fortran/pr63938-2.f90: Ditto.
+	* testsuite/libgomp.fortran/pr65597.f90: Ditto.
+	* testsuite/libgomp.fortran/pr66199-1.f90: Ditto.
+	* testsuite/libgomp.fortran/pr71014.f90: Ditto.
+	* testsuite/libgomp.fortran/pr81304.f90: Ditto.
+	* testsuite/libgomp.fortran/pr81841.f90: Ditto.
+	* testsuite/libgomp.fortran/pr84418-1.f90: Ditto.
+	* testsuite/libgomp.fortran/pr84418-2.f90: Ditto.
+	* testsuite/libgomp.fortran/procptr1.f90: Ditto.
+	* testsuite/libgomp.fortran/recursion1.f90: Ditto.
+	* testsuite/libgomp.fortran/reduction1.f90: Ditto.
+	* testsuite/libgomp.fortran/reduction2.f90: Ditto.
+	* testsuite/libgomp.fortran/reduction3.f90: Ditto.
+	* testsuite/libgomp.fortran/reduction4.f90: Ditto.
+	* testsuite/libgomp.fortran/reduction5.f90: Ditto.
+	* testsuite/libgomp.fortran/reduction6.f90: Ditto.
+	* testsuite/libgomp.fortran/reference1.f90: Ditto.
+	* testsuite/libgomp.fortran/reference2.f90: Ditto.
+	* testsuite/libgomp.fortran/retval1.f90: Ditto.
+	* testsuite/libgomp.fortran/retval2.f90: Ditto.
+	* testsuite/libgomp.fortran/sharing1.f90: Ditto.
+	* testsuite/libgomp.fortran/sharing2.f90: Ditto.
+	* testsuite/libgomp.fortran/simd1.f90: Ditto.
+	* testsuite/libgomp.fortran/simd2.f90: Ditto.
+	* testsuite/libgomp.fortran/simd3.f90: Ditto.
+	* testsuite/libgomp.fortran/simd4.f90: Ditto.
+	* testsuite/libgomp.fortran/simd5.f90: Ditto.
+	* testsuite/libgomp.fortran/simd6.f90: Ditto.
+	* testsuite/libgomp.fortran/simd7.f90: Ditto.
+	* testsuite/libgomp.fortran/stack.f90: Ditto.
+	* testsuite/libgomp.fortran/strassen.f90: Ditto.
+	* testsuite/libgomp.fortran/tabs1.f90: Ditto.
+	* testsuite/libgomp.fortran/tabs2.f: Ditto.
+	* testsuite/libgomp.fortran/target1.f90: Ditto.
+	* testsuite/libgomp.fortran/target2.f90: Ditto.
+	* testsuite/libgomp.fortran/target3.f90: Ditto.
+	* testsuite/libgomp.fortran/target4.f90: Ditto.
+	* testsuite/libgomp.fortran/target5.f90: Ditto.
+	* testsuite/libgomp.fortran/target6.f90: Ditto.
+	* testsuite/libgomp.fortran/target7.f90: Ditto.
+	* testsuite/libgomp.fortran/target8.f90: Ditto.
+	* testsuite/libgomp.fortran/task1.f90: Ditto.
+	* testsuite/libgomp.fortran/task2.f90: Ditto.
+	* testsuite/libgomp.fortran/task3.f90: Ditto.
+	* testsuite/libgomp.fortran/task4.f90: Ditto.
+	* testsuite/libgomp.fortran/taskgroup1.f90: Ditto.
+	* testsuite/libgomp.fortran/taskloop1.f90: Ditto.
+	* testsuite/libgomp.fortran/taskloop2.f90: Ditto.
+	* testsuite/libgomp.fortran/taskloop3.f90: Ditto.
+	* testsuite/libgomp.fortran/taskloop4.f90: Ditto.
+	* testsuite/libgomp.fortran/threadprivate1.f90: Ditto.
+	* testsuite/libgomp.fortran/threadprivate2.f90: Ditto.
+	* testsuite/libgomp.fortran/threadprivate3.f90: Ditto.
+	* testsuite/libgomp.fortran/threadprivate4.f90: Ditto.
+	* testsuite/libgomp.fortran/udr1.f90: Ditto.
+	* testsuite/libgomp.fortran/udr10.f90: Ditto.
+	* testsuite/libgomp.fortran/udr11.f90: Ditto.
+	* testsuite/libgomp.fortran/udr12.f90: Ditto.
+	* testsuite/libgomp.fortran/udr13.f90: Ditto.
+	* testsuite/libgomp.fortran/udr14.f90: Ditto.
+	* testsuite/libgomp.fortran/udr15.f90: Ditto.
+	* testsuite/libgomp.fortran/udr2.f90: Ditto.
+	* testsuite/libgomp.fortran/udr3.f90: Ditto.
+	* testsuite/libgomp.fortran/udr4.f90: Ditto.
+	* testsuite/libgomp.fortran/udr5.f90: Ditto.
+	* testsuite/libgomp.fortran/udr6.f90: Ditto.
+	* testsuite/libgomp.fortran/udr7.f90: Ditto.
+	* testsuite/libgomp.fortran/udr8.f90: Ditto.
+	* testsuite/libgomp.fortran/udr9.f90: Ditto.
+	* testsuite/libgomp.fortran/vla1.f90: Ditto.
+	* testsuite/libgomp.fortran/vla2.f90: Ditto.
+	* testsuite/libgomp.fortran/vla3.f90: Ditto.
+	* testsuite/libgomp.fortran/vla4.f90: Ditto.
+	* testsuite/libgomp.fortran/vla5.f90: Ditto.
+	* testsuite/libgomp.fortran/vla6.f90: Ditto.
+	* testsuite/libgomp.fortran/vla7.f90: Ditto.
+	* testsuite/libgomp.fortran/vla8.f90: Ditto.
+	* testsuite/libgomp.fortran/workshare1.f90: Ditto.
+	* testsuite/libgomp.fortran/workshare2.f90: Ditto.
+
+2019-10-30  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.fortran/target-simd.f90: Use stop not abort.
+	* testsuite/libgomp.fortran/use_device_ptr-optional-1.f90:
+	Ditto; add 'dg-do run' for torture testing.
+	* testsuite/libgomp.fortran/lastprivate1.f90:  Add 'dg-do run'.
+	* testsuite/libgomp.fortran/lastprivate2.f90: Ditto.
+	* testsuite/libgomp.fortran/nestedfn4.f90: Ditto.
+	* testsuite/libgomp.fortran/pr25219.f90: Ditto.
+	* testsuite/libgomp.fortran/pr28390.f: Ditto.
+	* testsuite/libgomp.fortran/pr35130.f90: Ditto.
+	* testsuite/libgomp.fortran/pr90779.f90: Ditto.
+	* testsuite/libgomp.fortran/task2.f90: Ditto.
+	* testsuite/libgomp.fortran/taskgroup1.f90: Ditto.
+	* testsuite/libgomp.fortran/taskloop1.f90: Ditto.
+	* testsuite/libgomp.fortran/use_device_addr-1.f90: Ditto.
+	* testsuite/libgomp.fortran/use_device_addr-2.f90: Ditto.
+	* testsuite/libgomp.fortran/workshare1.f90: Ditto.
+	* testsuite/libgomp.fortran/workshare2.f90: Ditto.
+
+2019-10-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.oacc-fortran/abort-1.f90: Add 'dg-do run'.
+	* testsuite/libgomp.oacc-fortran/abort-2.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/acc_on_device-1-1.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/acc_on_device-1-2.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/acc_on_device-1-3.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/lib-1.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/common-block-1.f90:
+	Use 'stop' not abort().
+	* testsuite/libgomp.oacc-fortran/common-block-2.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/common-block-3.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/data-1.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/data-2.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/data-5.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/dummy-array.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/gemm-2.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/gemm.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/host_data-2.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/host_data-3.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/host_data-4.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-collapse-3.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-collapse-4.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-independent.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-loop-1.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-map-1.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-parallel-loop-data-enter-exit.f95:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-1.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-2.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-3.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-6.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-vector-1.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-vector-2.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-worker-1.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-worker-2.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-worker-3.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-worker-4.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-worker-5.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-worker-6.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-private-vars-worker-7.f90:
+	Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-reduction-1.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/lib-12.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/lib-13.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/lib-14.f90: Ditto.
+	* testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction-2.f90:
+	Likewise and also add 'dg-do run'.
+	* testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction.f90:
+	Ditto.
+
+2019-10-25  Cesar Philippidis <cesar@codesourcery.com>
+	    Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.oacc-fortran/common-block-1.f90: New test.
+	* testsuite/libgomp.oacc-fortran/common-block-2.f90: New test.
+	* testsuite/libgomp.oacc-fortran/common-block-3.f90: New test.
+
+2019-10-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/92081
+	* testsuite/libgomp.fortran/target-simd.f90: Iterate from 1 rather
+	than 0.
+
+2019-10-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.fortran/use_device_addr-1.f90: New.
+	* testsuite/libgomp.fortran/use_device_addr-2.f90: New.
+
+2019-10-09  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/92036
+	* testsuite/libgomp.oacc-c-c++-common/data-firstprivate-1.c: New
+	file.
+
+2019-10-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR testsuite/91884
+	* testsuite/libgomp.fortran/fortran.exp: Conditionally
+	add -lquadmath.
+	* testsuite/libgomp.oacc-fortran/fortran.exp: Ditto.
 
-	* GCC 9.2.0 released.
+2019-10-09  Jakub Jelinek  <jakub@redhat.com>
 
-2019-08-01  Jakub Jelinek  <jakub@redhat.com>
+	PR libgomp/92028
+	* target.c (gomp_map_vars_internal): Readd the previous
+	GOMP_MAP_USE_DEVICE_PTR handling code in the first loop,
+	though do that just in the !not_found_cnt case.
 
-	Backported from mainline
-	2019-07-31  Jakub Jelinek  <jakub@redhat.com>
+2019-10-08  Tobias Burnus  <tobias@codesourcery.com>
+
+	* gfortran.dg/gomp/target-simd.f90: New.
+
+2019-10-02  Julian Brown  <julian@codesourcery.com>
+	    Cesar Philippidis  <cesar@codesourcery.com>
+
+	* libgomp.h (OFFSET_INLINED, OFFSET_POINTER, OFFSET_STRUCT): Define.
+	* target.c (FIELD_TGT_EMPTY): Define.
+	(gomp_map_val): Use OFFSET_* macros instead of magic constants.  Write
+	as switch instead of list of ifs.
+	(gomp_map_vars_internal): Use OFFSET_* and FIELD_TGT_EMPTY macros.
+
+2019-10-02  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* testsuite/libgomp.oacc-c-c++-common/loop-default.h: Remove alloca.h
+	include. Replace alloca () with __builtin_alloca ().
+	* testsuite/libgomp.oacc-c-c++-common/loop-dim-default.c: Likewise.
+
+2019-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.ac: Remove GCC_HEADER_STDINT(gstdint.h).
+	* libgomp.h: Include <stdint.h> instead of "gstdint.h".
+	* oacc-parallel.c: Don't include "libgomp_g.h".
+	* plugin/plugin-hsa.c: Include <stdint.h> instead of "gstdint.h".
+	* plugin/plugin-nvptx.c: Don't include "gstdint.h".
+	* aclocal.m4: Regenerated.
+	* config.h.in: Regenerated.
+	* configure: Regenerated.
+	* Makefile.in: Regenerated.
+
+2019-09-30  Kwok Cheung Yeung  <kcy@codesourcery.com>
+
+	* libgomp_g.h: Include stdint.h instead of gstdint.h.
+
+2019-09-27  Maciej W. Rozycki  <macro@wdc.com>
+
+	* configure: Regenerate.
+
+2019-09-13  Tobias Burnus  <tobias@codesourcery.com>
+
+	* plugin/plugin-hsa.c (hsa_warn, hsa_fatal, hsa_error): Ensure
+	string is initialized.
+
+2019-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	* configure: Regenerate.
+
+2019-09-03  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	PR other/79543
+	* acinclude.m4 (LIBGOMP_CHECK_LINKER_FEATURES): Fix GNU ld --version
+	scanning to conform to the GNU Coding Standards.
+	* configure: Regenerate.
+
+2019-08-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/91530
+	* testsuite/libgomp.c/scan-21.c: New test.
+	* testsuite/libgomp.c/scan-22.c: New test.
+
+2019-08-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/91530
+	* testsuite/libgomp.c/scan-11.c: Add -msse2 option for sse2_runtime
+	targets.
+	* testsuite/libgomp.c/scan-12.c: Likewise.
+	* testsuite/libgomp.c/scan-13.c: Likewise.
+	* testsuite/libgomp.c/scan-14.c: Likewise.
+	* testsuite/libgomp.c/scan-15.c: Likewise.
+	* testsuite/libgomp.c/scan-16.c: Likewise.
+	* testsuite/libgomp.c/scan-17.c: Likewise.
+	* testsuite/libgomp.c/scan-18.c: Likewise.
+	* testsuite/libgomp.c/scan-19.c: Likewise.
+	* testsuite/libgomp.c/scan-20.c: Likewise.
+	* testsuite/libgomp.c++/scan-9.C: Likewise.
+	* testsuite/libgomp.c++/scan-10.C: Likewise.
+	* testsuite/libgomp.c++/scan-11.C: Likewise.
+	* testsuite/libgomp.c++/scan-12.C: Likewise.
+	* testsuite/libgomp.c++/scan-14.C: Likewise.
+	* testsuite/libgomp.c++/scan-15.C: Likewise.
+	* testsuite/libgomp.c++/scan-13.C: Likewise.  Use sse2_runtime
+	instead of i?86-*-* x86_64-*-* as target for scan-tree-dump-times.
+	* testsuite/libgomp.c++/scan-16.C: Likewise.
+
+2019-08-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/91473
+	* testsuite/libgomp.fortran/appendix-a/a.28.5.f90: Add
+	-std=legacy so invalid code in the test case is accepted.
+
+2019-08-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/91422
+	* testsuite/libgomp.oacc-fortran/routine-7.f90: Correct array
+	dimension.
+
+2019-08-08  Jakub Jelinek  <jakub@redhat.com>
+
+	* target.c (gomp_map_vars_internal): For GOMP_MAP_USE_DEVICE_PTR
+	perform the lookup in the first loop only if !not_found_cnt, otherwise
+	perform lookups for it in the second loop guarded with
+	if (not_found_cnt || has_firstprivate).
+	* testsuite/libgomp.c/target-37.c: New test.
+	* testsuite/libgomp.c++/target-22.C: New test.
+
+2019-08-07  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c/target-18.c (struct S): New type.
+	(foo): Use use_device_addr clause instead of use_device_ptr clause
+	where required by OpenMP 5.0, add further tests for both use_device_ptr
+	and use_device_addr clauses.
+	* testsuite/libgomp.c++/target-9.C (struct S): New type.
+	(foo): Use use_device_addr clause instead of use_device_ptr clause
+	where required by OpenMP 5.0, add further tests for both use_device_ptr
+	and use_device_addr clauses.  Add t and u arguments.
+	(main): Adjust caller.
+
+2019-08-06  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c++/loop-13.C: New test.
+	* testsuite/libgomp.c++/loop-14.C: New test.
+	* testsuite/libgomp.c++/loop-15.C: New test.
+
+2019-07-31  Jakub Jelinek  <jakub@redhat.com>
 
 	PR middle-end/91301
 	* testsuite/libgomp.c++/for-27.C: New test.
 
+2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	* testsuite/libgomp.fortran/reduction4.f90: Update BOZ usage.
+	* testsuite/libgomp.fortran/reduction5.f90: Ditto.
+
+2019-07-20  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c-c++-common/loop-1.c: New test.
+
+2019-07-08  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c++/scan-13.C: Replace xfail with target x86.
+	* testsuite/libgomp.c++/scan-16.C: Likewise.
+
+2019-07-06  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c/scan-19.c: New test.
+	* testsuite/libgomp.c/scan-20.c: New test.
+
+	* testsuite/libgomp.c/scan-11.c: New test.
+	* testsuite/libgomp.c/scan-12.c: New test.
+	* testsuite/libgomp.c/scan-13.c: New test.
+	* testsuite/libgomp.c/scan-14.c: New test.
+	* testsuite/libgomp.c/scan-15.c: New test.
+	* testsuite/libgomp.c/scan-16.c: New test.
+	* testsuite/libgomp.c/scan-17.c: New test.
+	* testsuite/libgomp.c/scan-18.c: New test.
+	* testsuite/libgomp.c++/scan-9.C: New test.
+	* testsuite/libgomp.c++/scan-10.C: New test.
+	* testsuite/libgomp.c++/scan-11.C: New test.
+	* testsuite/libgomp.c++/scan-12.C: New test.
+	* testsuite/libgomp.c++/scan-13.C: New test.
+	* testsuite/libgomp.c++/scan-14.C: New test.
+	* testsuite/libgomp.c++/scan-15.C: New test.
+	* testsuite/libgomp.c++/scan-16.C: New test.
+
+2019-07-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c/scan-9.c: New test.
+	* testsuite/libgomp.c/scan-10.c: New test.
+
+2019-07-03  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c++/scan-1.C: New test.
+	* testsuite/libgomp.c++/scan-2.C: New test.
+	* testsuite/libgomp.c++/scan-3.C: New test.
+	* testsuite/libgomp.c++/scan-4.C: New test.
+	* testsuite/libgomp.c++/scan-5.C: New test.
+	* testsuite/libgomp.c++/scan-6.C: New test.
+	* testsuite/libgomp.c++/scan-7.C: New test.
+	* testsuite/libgomp.c++/scan-8.C: New test.
+	* testsuite/libgomp.c/scan-1.c: New test.
+	* testsuite/libgomp.c/scan-2.c: New test.
+	* testsuite/libgomp.c/scan-3.c: New test.
+	* testsuite/libgomp.c/scan-4.c: New test.
+	* testsuite/libgomp.c/scan-5.c: New test.
+	* testsuite/libgomp.c/scan-6.c: New test.
+	* testsuite/libgomp.c/scan-7.c: New test.
+	* testsuite/libgomp.c/scan-8.c: New test.
+
+2019-06-18  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* testsuite/libgomp.oacc-c++/firstprivate-mappings-1.C: New file.
+	* testsuite/libgomp.oacc-c-c++-common/firstprivate-mappings-1.c:
+	Likewise.
+
+	* testsuite/libgomp.fortran/allocatable3.f90: Add missing results
+	check.
+
+2019-06-18  Cesar Philippidis  <cesar@codesourcery.com>
+
+	* testsuite/libgomp.oacc-fortran/allocatable-array-1.f90: New
+	file.
+
+2019-06-18  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR fortran/90743
+	* oacc-parallel.c (GOACC_parallel_keyed): Handle NULL mapping
+	case.
+	* testsuite/libgomp.fortran/target-allocatable-1-1.f90: New file.
+	* testsuite/libgomp.fortran/target-allocatable-1-2.f90: Likewise.
+	* testsuite/libgomp.oacc-fortran/allocatable-1-1.f90: Likewise.
+	* testsuite/libgomp.oacc-fortran/allocatable-1-2.f90: Likewise.
+
+	PR testsuite/90861
+	* testsuite/libgomp.oacc-c-c++-common/declare-vla.c: Update.
+
+	PR middle-end/90862
+	* testsuite/libgomp.oacc-c-c++-common/declare-1.c: Update.
+
+2019-06-16  Tom de Vries  <tdevries@suse.de>
+
+	PR tree-optimization/89376
+	* testsuite/libgomp.oacc-c-c++-common/pr89376.c: New test.
+
+2019-06-15  Tom de Vries  <tdevries@suse.de>
+
+	PR tree-optimization/89713
+	* testsuite/libgomp.oacc-c-c++-common/pr85381-2.c: Expect no bar.sync.
+	* testsuite/libgomp.oacc-c-c++-common/pr85381-4.c: Same.
+
+2019-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/90779
+	* testsuite/libgomp.c/pr90779.c: New test.
+	* testsuite/libgomp.fortran/pr90779.f90: New test.
+
+2019-06-15  Tom de Vries  <tdevries@suse.de>
+
+	PR tree-optimization/90009
+	* testsuite/libgomp.oacc-c-c++-common/pr90009.c: New test.
+
+2019-06-13  Feng Xue  <fxue@os.amperecomputing.com>
+
+	PR tree-optimization/89713
+	* testsuite/libgomp.oacc-c-c++-common/pr84955-1.c: New test.
+
 2019-06-11  Jakub Jelinek  <jakub@redhat.com>
 
 	PR target/90811
@@ -17,8 +1145,39 @@
 
 2019-06-05  Jakub Jelinek  <jakub@redhat.com>
 
-	Backported from mainline
-	2019-05-27  Jakub Jelinek  <jakub@redhat.com>
+	* testsuite/libgomp.c++/lastprivate-conditional-1.C: New test.
+	* testsuite/libgomp.c++/lastprivate-conditional-2.C: New test.
+
+2019-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-7.c: New test.
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-8.c: New test.
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-9.c: New test.
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-10.c: New test.
+
+2019-05-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac: Call AX_COUNT_CPUS.
+	Substitute CPU_COUNT.
+	* testsuite/Makefile.am (check-am): Use CPU_COUNT as processor
+	count fallback.
+	* aclocal.m4: Regenerate.
+	* configure: Regenerate.
+	* Makefile.in, testsuite/Makefile.in: Regenerate.
+
+2019-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c-c++-common/lastprivate_conditional_4.c: Rename
+	to ...
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-4.c: ... this.
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-5.c: New test.
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-6.c: New test.
+
+2019-05-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c-c++-common/lastprivate_conditional_4.c: New test.
+
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-3.c: New test.
 
 	PR libgomp/90641
 	* work.c (gomp_init_work_share): Instead of aligning final ordered
@@ -32,27 +1191,284 @@
 	* loop-ull.c (GOMP_loop_ull_start): Likewise.
 	* sections.c (GOMP_sections2_start): Likewise.
 
-	2019-05-24  Jakub Jelinek  <jakub@redhat.com>
+2019-05-24  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-1.c: New test.
+	* testsuite/libgomp.c-c++-common/lastprivate-conditional-2.c: New test.
 
 	PR libgomp/90585
-	* plugin/plugin-hsa.c (print_kernel_dispatch, run_kernel): Use PRIu64
-	macro instead of "lu".
+	* plugin/plugin-hsa.c: Include gstdint.h.  Include inttypes.h only if
+	HAVE_INTTYPES_H is defined.
+	(print_uint64_t): New typedef.
+	(PRIu64): Define if HAVE_INTTYPES_H is not defined.
+	(print_kernel_dispatch, run_kernel): Use PRIu64 macro instead of
+	"lu", cast uint64_t HSA_DEBUG and fprintf arguments to print_uint64_t.
 	(release_kernel_dispatch): Likewise.  Cast shadow->debug to uintptr_t
 	before casting to void *.
+	* plugin/plugin-nvptx.c: Include gstdint.h instead of stdint.h.
+	* oacc-mem.c: Don't include config.h nor stdint.h.
+	* target.c: Don't include config.h.
+	* oacc-cuda.c: Likewise.
+	* oacc-host.c: Don't include stdint.h.
 
 2019-05-20  Jakub Jelinek  <jakub@redhat.com>
 
 	PR libgomp/90527
 	* alloc.c (_GNU_SOURCE): Define.
 
+2019-05-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* acc_prof.h: New file.
+	* oacc-profiling.c: Likewise.
+	* Makefile.am (nodist_libsubinclude_HEADERS, libgomp_la_SOURCES):
+	Add these, respectively.
+	* Makefile.in: Regenerate.
+	* env.c (initialize_env): Call goacc_profiling_initialize.
+	* oacc-plugin.c (GOMP_PLUGIN_goacc_thread)
+	(GOMP_PLUGIN_goacc_profiling_dispatch): New functions.
+	* oacc-plugin.h (GOMP_PLUGIN_goacc_thread)
+	(GOMP_PLUGIN_goacc_profiling_dispatch): Declare.
+	* libgomp.map (OACC_2.5.1): Add acc_prof_lookup,
+	acc_prof_register, acc_prof_unregister, and acc_register_library.
+	(GOMP_PLUGIN_1.3): Add GOMP_PLUGIN_goacc_profiling_dispatch, and
+	GOMP_PLUGIN_goacc_thread.
+	* oacc-int.h (struct goacc_thread): Add prof_info, api_info,
+	prof_callbacks_enabled members.
+	(goacc_prof_enabled, goacc_profiling_initialize)
+	(_goacc_profiling_dispatch_p, _goacc_profiling_setup_p)
+	(goacc_profiling_dispatch): Declare.
+	(GOACC_PROF_ENABLED, GOACC_PROFILING_DISPATCH_P)
+	(GOACC_PROFILING_SETUP_P): Define.
+	* oacc-async.c (acc_async_test, acc_async_test_all, acc_wait)
+	(acc_wait_async, acc_wait_all, acc_wait_all_async): Update for
+	OpenACC Profiling Interface.
+	* oacc-cuda.c (acc_get_current_cuda_device)
+	(acc_get_current_cuda_context, acc_get_cuda_stream)
+	(acc_set_cuda_stream): Likewise.
+	* oacc-init.c (acc_init_1, goacc_attach_host_thread_to_device)
+	(acc_init, acc_set_device_type, acc_get_device_type)
+	(acc_get_device_num, goacc_lazy_initialize): Likewise.
+	* oacc-mem.c (acc_malloc, acc_free, memcpy_tofrom_device)
+	(acc_deviceptr, acc_hostptr, acc_is_present, acc_map_data)
+	(acc_unmap_data, present_create_copy, delete_copyout)
+	(update_dev_host): Likewise.
+	* oacc-parallel.c (GOACC_parallel_keyed, GOACC_data_start)
+	(GOACC_data_end, GOACC_enter_exit_data, GOACC_update, GOACC_wait):
+	Likewise.
+	* plugin/plugin-nvptx.c (nvptx_exec, nvptx_alloc, nvptx_free)
+	(GOMP_OFFLOAD_openacc_exec, GOMP_OFFLOAD_openacc_async_exec):
+	Likewise.
+	* libgomp.texi: Update.
+	* testsuite/libgomp.oacc-c-c++-common/acc_prof-dispatch-1.c: New
+	file.
+	* testsuite/libgomp.oacc-c-c++-common/acc_prof-init-1.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_prof-kernels-1.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_prof-valid_bytes-1.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/acc_prof-version-1.c:
+	Likewise.
+
+2019-05-13  Chung-Lin Tang <cltang@codesourcery.com>
+
+	* libgomp-plugin.h (struct goacc_asyncqueue): Declare.
+	(struct goacc_asyncqueue_list): Likewise.
+	(goacc_aq): Likewise.
+	(goacc_aq_list): Likewise.
+	(GOMP_OFFLOAD_openacc_register_async_cleanup): Remove.
+	(GOMP_OFFLOAD_openacc_async_test): Remove.
+	(GOMP_OFFLOAD_openacc_async_test_all): Remove.
+	(GOMP_OFFLOAD_openacc_async_wait): Remove.
+	(GOMP_OFFLOAD_openacc_async_wait_async): Remove.
+	(GOMP_OFFLOAD_openacc_async_wait_all): Remove.
+	(GOMP_OFFLOAD_openacc_async_wait_all_async): Remove.
+	(GOMP_OFFLOAD_openacc_async_set_async): Remove.
+	(GOMP_OFFLOAD_openacc_exec): Adjust declaration.
+	(GOMP_OFFLOAD_openacc_cuda_get_stream): Likewise.
+	(GOMP_OFFLOAD_openacc_cuda_set_stream): Likewise.
+	(GOMP_OFFLOAD_openacc_async_exec): Declare.
+	(GOMP_OFFLOAD_openacc_async_construct): Declare.
+	(GOMP_OFFLOAD_openacc_async_destruct): Declare.
+	(GOMP_OFFLOAD_openacc_async_test): Declare.
+	(GOMP_OFFLOAD_openacc_async_synchronize): Declare.
+	(GOMP_OFFLOAD_openacc_async_serialize): Declare.
+	(GOMP_OFFLOAD_openacc_async_queue_callback): Declare.
+	(GOMP_OFFLOAD_openacc_async_host2dev): Declare.
+	(GOMP_OFFLOAD_openacc_async_dev2host): Declare.
+
+	* libgomp.h (struct acc_dispatch_t): Define 'async' sub-struct.
+	(gomp_acc_insert_pointer): Adjust declaration.
+	(gomp_copy_host2dev): New declaration.
+	(gomp_copy_dev2host): Likewise.
+	(gomp_map_vars_async): Likewise.
+	(gomp_unmap_tgt): Likewise.
+	(gomp_unmap_vars_async): Likewise.
+	(gomp_fini_device): Likewise.
+
+	* oacc-async.c (get_goacc_thread): New function.
+	(get_goacc_thread_device): New function.
+	(lookup_goacc_asyncqueue): New function.
+	(get_goacc_asyncqueue): New function.
+	(acc_async_test): Adjust code to use new async design.
+	(acc_async_test_all): Likewise.
+	(acc_wait): Likewise.
+	(acc_wait_async): Likewise.
+	(acc_wait_all): Likewise.
+	(acc_wait_all_async): Likewise.
+	(goacc_async_free): New function.
+	(goacc_init_asyncqueues): Likewise.
+	(goacc_fini_asyncqueues): Likewise.
+	* oacc-cuda.c (acc_get_cuda_stream): Adjust code to use new async
+	design.
+	(acc_set_cuda_stream): Likewise.
+	* oacc-host.c (host_openacc_exec): Adjust parameters, remove 'async'.
+	(host_openacc_register_async_cleanup): Remove.
+	(host_openacc_async_exec): New function.
+	(host_openacc_async_test): Adjust parameters.
+	(host_openacc_async_test_all): Remove.
+	(host_openacc_async_wait): Remove.
+	(host_openacc_async_wait_async): Remove.
+	(host_openacc_async_wait_all): Remove.
+	(host_openacc_async_wait_all_async): Remove.
+	(host_openacc_async_set_async): Remove.
+	(host_openacc_async_synchronize): New function.
+	(host_openacc_async_serialize): New function.
+	(host_openacc_async_host2dev): New function.
+	(host_openacc_async_dev2host): New function.
+	(host_openacc_async_queue_callback): New function.
+	(host_openacc_async_construct): New function.
+	(host_openacc_async_destruct): New function.
+	(struct gomp_device_descr host_dispatch): Remove initialization of old
+	interface, add initialization of new async sub-struct.
+	* oacc-init.c (acc_shutdown_1): Adjust to use gomp_fini_device.
+	(goacc_attach_host_thread_to_device): Remove old async code usage.
+	* oacc-int.h (goacc_init_asyncqueues): New declaration.
+	(goacc_fini_asyncqueues): Likewise.
+	(goacc_async_copyout_unmap_vars): Likewise.
+	(goacc_async_free): Likewise.
+	(get_goacc_asyncqueue): Likewise.
+	(lookup_goacc_asyncqueue): Likewise.
+	* oacc-mem.c (memcpy_tofrom_device): Adjust code to use new async
+	design.
+	(present_create_copy): Adjust code to use new async design.
+	(delete_copyout): Likewise.
+	(update_dev_host): Likewise.
+	(gomp_acc_insert_pointer): Add async parameter, adjust code to use new
+	async design.
+	(gomp_acc_remove_pointer): Adjust code to use new async design.
+	* oacc-parallel.c (GOACC_parallel_keyed): Adjust code to use new async
+	design.
+	(GOACC_enter_exit_data): Likewise.
+	(goacc_wait): Likewise.
+	(GOACC_update): Likewise.
+	* oacc-plugin.c (GOMP_PLUGIN_async_unmap_vars): Change to assert fail
+	when called, warn as obsolete in comment.
+	* target.c (goacc_device_copy_async): New function.
+	(gomp_copy_host2dev): Remove 'static', add goacc_asyncqueue parameter,
+	add goacc_device_copy_async case.
+	(gomp_copy_dev2host): Likewise.
+	(gomp_map_vars_existing): Add goacc_asyncqueue parameter, adjust code.
+	(gomp_map_pointer): Likewise.
+	(gomp_map_fields_existing): Likewise.
+	(gomp_map_vars_internal): New always_inline function, renamed from
+	gomp_map_vars.
+	(gomp_map_vars): Implement by calling gomp_map_vars_internal.
+	(gomp_map_vars_async): Implement by calling gomp_map_vars_internal,
+	passing goacc_asyncqueue argument.
+	(gomp_unmap_tgt): Remove static, add attribute_hidden.
+	(gomp_unref_tgt): New function.
+	(gomp_unmap_vars_internal): New always_inline function, renamed from
+	gomp_unmap_vars.
+	(gomp_unmap_vars): Implement by calling gomp_unmap_vars_internal.
+	(gomp_unmap_vars_async): Implement by calling
+	gomp_unmap_vars_internal, passing goacc_asyncqueue argument.
+	(gomp_fini_device): New function.
+	(gomp_exit_data): Adjust gomp_copy_dev2host call.
+	(gomp_load_plugin_for_device): Remove old interface, adjust to load
+	new async interface.
+	(gomp_target_fini): Adjust code to call gomp_fini_device.
+
+	* plugin/plugin-nvptx.c (struct cuda_map): Remove.
+	(struct ptx_stream): Remove.
+	(struct nvptx_thread): Remove current_stream field.
+	(cuda_map_create): Remove.
+	(cuda_map_destroy): Remove.
+	(map_init): Remove.
+	(map_fini): Remove.
+	(map_pop): Remove.
+	(map_push): Remove.
+	(struct goacc_asyncqueue): Define.
+	(struct nvptx_callback): Define.
+	(struct ptx_free_block): Define.
+	(struct ptx_device): Remove null_stream, active_streams, async_streams,
+	stream_lock, and next fields.
+	(enum ptx_event_type): Remove.
+	(struct ptx_event): Remove.
+	(ptx_event_lock): Remove.
+	(ptx_events): Remove.
+	(init_streams_for_device): Remove.
+	(fini_streams_for_device): Remove.
+	(select_stream_for_async): Remove.
+	(nvptx_init): Remove ptx_events and ptx_event_lock references.
+	(nvptx_attach_host_thread_to_device): Remove CUDA_ERROR_NOT_PERMITTED
+	case.
+	(nvptx_open_device): Add free_blocks initialization, remove
+	init_streams_for_device call.
+	(nvptx_close_device): Remove fini_streams_for_device call, add
+	free_blocks destruct code.
+	(event_gc): Remove.
+	(event_add): Remove.
+	(nvptx_exec): Adjust parameters and code.
+	(nvptx_free): Likewise.
+	(nvptx_host2dev): Remove.
+	(nvptx_dev2host): Remove.
+	(nvptx_set_async): Remove.
+	(nvptx_async_test): Remove.
+	(nvptx_async_test_all): Remove.
+	(nvptx_wait): Remove.
+	(nvptx_wait_async): Remove.
+	(nvptx_wait_all): Remove.
+	(nvptx_wait_all_async): Remove.
+	(nvptx_get_cuda_stream): Remove.
+	(nvptx_set_cuda_stream): Remove.
+	(GOMP_OFFLOAD_alloc): Adjust code.
+	(GOMP_OFFLOAD_free): Likewise.
+	(GOMP_OFFLOAD_openacc_register_async_cleanup): Remove.
+	(GOMP_OFFLOAD_openacc_exec): Adjust parameters and code.
+	(GOMP_OFFLOAD_openacc_async_test_all): Remove.
+	(GOMP_OFFLOAD_openacc_async_wait): Remove.
+	(GOMP_OFFLOAD_openacc_async_wait_async): Remove.
+	(GOMP_OFFLOAD_openacc_async_wait_all): Remove.
+	(GOMP_OFFLOAD_openacc_async_wait_all_async): Remove.
+	(GOMP_OFFLOAD_openacc_async_set_async): Remove.
+	(cuda_free_argmem): New function.
+	(GOMP_OFFLOAD_openacc_async_exec): New plugin hook function.
+	(GOMP_OFFLOAD_openacc_create_thread_data): Adjust code.
+	(GOMP_OFFLOAD_openacc_cuda_get_stream): Adjust code.
+	(GOMP_OFFLOAD_openacc_cuda_set_stream): Adjust code.
+	(GOMP_OFFLOAD_openacc_async_construct): New plugin hook function.
+	(GOMP_OFFLOAD_openacc_async_destruct): New plugin hook function.
+	(GOMP_OFFLOAD_openacc_async_test): Remove and re-implement.
+	(GOMP_OFFLOAD_openacc_async_synchronize): New plugin hook function.
+	(GOMP_OFFLOAD_openacc_async_serialize): New plugin hook function.
+	(GOMP_OFFLOAD_openacc_async_queue_callback): New plugin hook function.
+	(cuda_callback_wrapper): New function.
+	(cuda_memcpy_sanity_check): New function.
+	(GOMP_OFFLOAD_host2dev): Remove and re-implement.
+	(GOMP_OFFLOAD_dev2host): Remove and re-implement.
+	(GOMP_OFFLOAD_openacc_async_host2dev): New plugin hook function.
+	(GOMP_OFFLOAD_openacc_async_dev2host): New plugin hook function.
+
 2019-05-07  Thomas Schwinge  <thomas@codesourcery.com>
 
 	PR target/87835
 	* testsuite/libgomp.oacc-c-c++-common/pr87835.c: Update.
 
-2019-05-03  Release Manager
+2019-05-06  Thomas Schwinge  <thomas@codesourcery.com>
 
-	* GCC 9.1.0 released.
+	* oacc-parallel.c: Add comments to legacy entry points (GCC 5).
 
 2019-03-27  Kevin Buettner  <kevinb@redhat.com>
 
@@ -5063,7 +6479,7 @@
 	* libgomp_g.h (GOACC_parallel): Remove.
 	(GOACC_parallel_keyed): Declare.
 	* plugin/plugin-nvptx.c (struct targ_fn_launch): New struct.
-	(stuct targ_gn_descriptor): Replace name field with launch field.
+	(struct targ_gn_descriptor): Replace name field with launch field.
 	(nvptx_exec): Lose separate geometry args, take array.  Process
 	dynamic dimensions and adjust.
 	(struct nvptx_tdata): Replace fn_names field with fn_descs.
@@ -5084,7 +6500,7 @@
 2015-09-08  Aditya Kumar  <hiraditya@msn.com>
 	    Sebastian Pop  <s.pop@samsung.com>
 
-	* testsuite/libgomp.graphite/bounds.c (int foo): Modifed test case to
+	* testsuite/libgomp.graphite/bounds.c (int foo): Modified test case to
 	match o/p.
 	* testsuite/libgomp.graphite/force-parallel-1.c (void parloop): Same.
 	* testsuite/libgomp.graphite/force-parallel-4.c: Same.
@@ -5361,7 +6777,7 @@
 	* target.c (struct offload_image_descr): Constify target_data.
 	(gomp_offload_image_to_device): Likewise.
 	(GOMP_offload_register): Likewise.
-	(GOMP_offload_unrefister): Likewise.
+	(GOMP_offload_unregister): Likewise.
 	* plugin/plugin-host.c (GOMP_OFFLOAD_load_image,
 	GOMP_OFFLOAD_unload_image): Constify target data.
 	* plugin/plugin-nvptx.c (struct ptx_image_data): Constify target data.
@@ -6687,7 +8103,7 @@
 2014-12-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
 
 	* testsuite/lib/libgomp.exp: Load target-utils.exp.
-	Move load of target-supportes.exp earlier.
+	Move load of target-supports.exp earlier.
 
 2014-12-10  Ilya Verbin  <ilya.verbin@intel.com>
 
@@ -7174,7 +8590,7 @@
 
 2013-12-17  Andreas Tobler  <andreast@gcc.gnu.org>
 
-	* testsuite/libgomp.c/affinity-1.c: Remove alloca.h inlcude. Replace
+	* testsuite/libgomp.c/affinity-1.c: Remove alloca.h include. Replace
 	alloca () with __builtin_alloca ().
 	* testsuite/libgomp.c/icv-2.c: Add FreeBSD coverage.
 	* testsuite/libgomp.c/lock-3.c: Likewise.
@@ -7334,7 +8750,7 @@
 	(gomp_team_end): Use gomp_managed_threads_lock instead of
 	gomp_remaining_threads_lock.  Use gomp_team_barrier_wait_final instead
 	of gomp_team_barrier_wait.  If team->team_cancelled, call
-	gomp_fini_worshare on ws chain starting at team->work_shares_to_free
+	gomp_fini_workshare on ws chain starting at team->work_shares_to_free
 	rather than thr->ts.work_share.
 	(initialize_team): Don't call gomp_sem_init here.
 	* sections.c (GOMP_parallel_sections_start): Adjust gomp_team_start
@@ -9805,7 +11221,7 @@
 	PR libgomp/30546
 	* configure.ac: Add check for makeinfo
 	* Makefile.am: Redefined target libgomp.info, build libgomp.info only
-	if an appropiate version of makeinfo is found.
+	if an appropriate version of makeinfo is found.
 	* aclocal.m4: Regenerated.
 	* configure: Regenerated.
 	* Makefile.in: Regenerated.
@@ -10709,7 +12125,7 @@
 
 	* configure.ac: Determine whether -pthread or -lpthread is needed.
 	* Makefile.am (libgomp_la_LDFLAGS): Remove explicit -lpthread.
-	* Makefine.in, configure: Rebuild.
+	* Makefile.in, configure: Rebuild.
 
 2005-09-28  Richard Henderson  <rth@redhat.com>
 
diff --git a/libgomp/Makefile.am b/libgomp/Makefile.am
index 062fded0805..669b9e4defd 100644
--- a/libgomp/Makefile.am
+++ b/libgomp/Makefile.am
@@ -65,7 +65,7 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c error.c \
 	proc.c sem.c bar.c ptrlock.c time.c fortran.c affinity.c target.c \
 	splay-tree.c libgomp-plugin.c oacc-parallel.c oacc-host.c oacc-init.c \
 	oacc-mem.c oacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \
-	affinity-fmt.c teams.c
+	affinity-fmt.c teams.c oacc-profiling.c oacc-target.c
 
 include $(top_srcdir)/plugin/Makefrag.am
 
@@ -74,7 +74,7 @@ libgomp_la_SOURCES += openacc.f90
 endif
 
 nodist_noinst_HEADERS = libgomp_f.h
-nodist_libsubinclude_HEADERS = omp.h openacc.h
+nodist_libsubinclude_HEADERS = omp.h openacc.h acc_prof.h
 if USE_FORTRAN
 nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod \
 	openacc_lib.h openacc.f90 openacc.mod openacc_kinds.mod
diff --git a/libgomp/Makefile.in b/libgomp/Makefile.in
index c7e63f120fd..3d772ee3007 100644
--- a/libgomp/Makefile.in
+++ b/libgomp/Makefile.in
@@ -16,7 +16,7 @@
 
 # Plugins for offload execution, Makefile.am fragment.
 #
-# Copyright (C) 2014-2018 Free Software Foundation, Inc.
+# Copyright (C) 2014-2019 Free Software Foundation, Inc.
 #
 # Contributed by Mentor Embedded.
 #
@@ -120,10 +120,12 @@ host_triplet = @host@
 target_triplet = @target@
 @PLUGIN_NVPTX_TRUE@am__append_1 = libgomp-plugin-nvptx.la
 @PLUGIN_HSA_TRUE@am__append_2 = libgomp-plugin-hsa.la
-@USE_FORTRAN_TRUE@am__append_3 = openacc.f90
+@PLUGIN_GCN_TRUE@am__append_3 = libgomp-plugin-gcn.la
+@USE_FORTRAN_TRUE@am__append_4 = openacc.f90
 subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/ax_count_cpus.m4 \
 	$(top_srcdir)/../config/depstand.m4 \
 	$(top_srcdir)/../config/enable.m4 \
 	$(top_srcdir)/../config/futex.m4 \
@@ -131,7 +133,6 @@ am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
 	$(top_srcdir)/../config/lthostflags.m4 \
 	$(top_srcdir)/../config/multi.m4 \
 	$(top_srcdir)/../config/override.m4 \
-	$(top_srcdir)/../config/stdint.m4 \
 	$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../ltoptions.m4 \
 	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
 	$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \
@@ -180,15 +181,26 @@ am__installdirs = "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(infodir)" \
 	"$(DESTDIR)$(toolexeclibdir)"
 LTLIBRARIES = $(toolexeclib_LTLIBRARIES)
 am__DEPENDENCIES_1 =
+@PLUGIN_GCN_TRUE@libgomp_plugin_gcn_la_DEPENDENCIES = libgomp.la \
+@PLUGIN_GCN_TRUE@	$(am__DEPENDENCIES_1)
+@PLUGIN_GCN_TRUE@am_libgomp_plugin_gcn_la_OBJECTS =  \
+@PLUGIN_GCN_TRUE@	libgomp_plugin_gcn_la-plugin-gcn.lo
+libgomp_plugin_gcn_la_OBJECTS = $(am_libgomp_plugin_gcn_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+libgomp_plugin_gcn_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(libgomp_plugin_gcn_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libgomp_plugin_gcn_la_LDFLAGS) $(LDFLAGS) -o $@
+@PLUGIN_GCN_TRUE@am_libgomp_plugin_gcn_la_rpath = -rpath \
+@PLUGIN_GCN_TRUE@	$(toolexeclibdir)
 @PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_DEPENDENCIES = libgomp.la \
 @PLUGIN_HSA_TRUE@	$(am__DEPENDENCIES_1)
 @PLUGIN_HSA_TRUE@am_libgomp_plugin_hsa_la_OBJECTS =  \
 @PLUGIN_HSA_TRUE@	libgomp_plugin_hsa_la-plugin-hsa.lo
 libgomp_plugin_hsa_la_OBJECTS = $(am_libgomp_plugin_hsa_la_OBJECTS)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-am__v_lt_1 = 
 libgomp_plugin_hsa_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(libgomp_plugin_hsa_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
@@ -217,7 +229,7 @@ am_libgomp_la_OBJECTS = alloc.lo atomic.lo barrier.lo critical.lo \
 	target.lo splay-tree.lo libgomp-plugin.lo oacc-parallel.lo \
 	oacc-host.lo oacc-init.lo oacc-mem.lo oacc-async.lo \
 	oacc-plugin.lo oacc-cuda.lo priority_queue.lo affinity-fmt.lo \
-	teams.lo $(am__objects_1)
+	teams.lo oacc-profiling.lo oacc-target.lo $(am__objects_1)
 libgomp_la_OBJECTS = $(am_libgomp_la_OBJECTS)
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -265,7 +277,8 @@ AM_V_FCLD = $(am__v_FCLD_@AM_V@)
 am__v_FCLD_ = $(am__v_FCLD_@AM_DEFAULT_V@)
 am__v_FCLD_0 = @echo "  FCLD    " $@;
 am__v_FCLD_1 = 
-SOURCES = $(libgomp_plugin_hsa_la_SOURCES) \
+SOURCES = $(libgomp_plugin_gcn_la_SOURCES) \
+	$(libgomp_plugin_hsa_la_SOURCES) \
 	$(libgomp_plugin_nvptx_la_SOURCES) $(libgomp_la_SOURCES)
 AM_V_DVIPS = $(am__v_DVIPS_@AM_V@)
 am__v_DVIPS_ = $(am__v_DVIPS_@AM_DEFAULT_V@)
@@ -365,6 +378,7 @@ CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CPU_COUNT = @CPU_COUNT@
 CUDA_DRIVER_INCLUDE = @CUDA_DRIVER_INCLUDE@
 CUDA_DRIVER_LIB = @CUDA_DRIVER_LIB@
 CYGPATH_W = @CYGPATH_W@
@@ -427,6 +441,10 @@ PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PERL = @PERL@
+PLUGIN_GCN = @PLUGIN_GCN@
+PLUGIN_GCN_CPPFLAGS = @PLUGIN_GCN_CPPFLAGS@
+PLUGIN_GCN_LDFLAGS = @PLUGIN_GCN_LDFLAGS@
+PLUGIN_GCN_LIBS = @PLUGIN_GCN_LIBS@
 PLUGIN_HSA = @PLUGIN_HSA@
 PLUGIN_HSA_CPPFLAGS = @PLUGIN_HSA_CPPFLAGS@
 PLUGIN_HSA_LDFLAGS = @PLUGIN_HSA_LDFLAGS@
@@ -526,7 +544,8 @@ libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include
 AM_CPPFLAGS = $(addprefix -I, $(search_path))
 AM_CFLAGS = $(XCFLAGS)
 AM_LDFLAGS = $(XLDFLAGS) $(SECTION_LDFLAGS) $(OPT_LDFLAGS)
-toolexeclib_LTLIBRARIES = libgomp.la $(am__append_1) $(am__append_2)
+toolexeclib_LTLIBRARIES = libgomp.la $(am__append_1) $(am__append_2) \
+	$(am__append_3)
 nodist_toolexeclib_HEADERS = libgomp.spec
 
 # -Wc is only a libtool option.
@@ -551,7 +570,8 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c \
 	affinity.c target.c splay-tree.c libgomp-plugin.c \
 	oacc-parallel.c oacc-host.c oacc-init.c oacc-mem.c \
 	oacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \
-	affinity-fmt.c teams.c $(am__append_3)
+	affinity-fmt.c teams.c oacc-profiling.c oacc-target.c \
+	$(am__append_4)
 
 # Nvidia PTX OpenACC plugin.
 @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_version_info = -version-info $(libtool_VERSION)
@@ -574,8 +594,20 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c \
 @PLUGIN_HSA_TRUE@	$(lt_host_flags) $(PLUGIN_HSA_LDFLAGS)
 @PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_LIBADD = libgomp.la $(PLUGIN_HSA_LIBS)
 @PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_LIBTOOLFLAGS = --tag=disable-static
+
+# AMD GCN plugin
+@PLUGIN_GCN_TRUE@libgomp_plugin_gcn_version_info = -version-info $(libtool_VERSION)
+@PLUGIN_GCN_TRUE@libgomp_plugin_gcn_la_SOURCES = plugin/plugin-gcn.c
+@PLUGIN_GCN_TRUE@libgomp_plugin_gcn_la_CPPFLAGS = $(AM_CPPFLAGS) $(PLUGIN_GCN_CPPFLAGS) \
+@PLUGIN_GCN_TRUE@	-D_GNU_SOURCE
+
+@PLUGIN_GCN_TRUE@libgomp_plugin_gcn_la_LDFLAGS =  \
+@PLUGIN_GCN_TRUE@	$(libgomp_plugin_gcn_version_info) \
+@PLUGIN_GCN_TRUE@	$(lt_host_flags) $(PLUGIN_GCN_LDFLAGS)
+@PLUGIN_GCN_TRUE@libgomp_plugin_gcn_la_LIBADD = libgomp.la $(PLUGIN_GCN_LIBS)
+@PLUGIN_GCN_TRUE@libgomp_plugin_gcn_la_LIBTOOLFLAGS = --tag=disable-static
 nodist_noinst_HEADERS = libgomp_f.h
-nodist_libsubinclude_HEADERS = omp.h openacc.h
+nodist_libsubinclude_HEADERS = omp.h openacc.h acc_prof.h
 @USE_FORTRAN_TRUE@nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod \
 @USE_FORTRAN_TRUE@	openacc_lib.h openacc.f90 openacc.mod openacc_kinds.mod
 
@@ -710,6 +742,9 @@ clean-toolexeclibLTLIBRARIES:
 	  rm -f $${locs}; \
 	}
 
+libgomp-plugin-gcn.la: $(libgomp_plugin_gcn_la_OBJECTS) $(libgomp_plugin_gcn_la_DEPENDENCIES) $(EXTRA_libgomp_plugin_gcn_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libgomp_plugin_gcn_la_LINK) $(am_libgomp_plugin_gcn_la_rpath) $(libgomp_plugin_gcn_la_OBJECTS) $(libgomp_plugin_gcn_la_LIBADD) $(LIBS)
+
 libgomp-plugin-hsa.la: $(libgomp_plugin_hsa_la_OBJECTS) $(libgomp_plugin_hsa_la_DEPENDENCIES) $(EXTRA_libgomp_plugin_hsa_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(libgomp_plugin_hsa_la_LINK) $(am_libgomp_plugin_hsa_la_rpath) $(libgomp_plugin_hsa_la_OBJECTS) $(libgomp_plugin_hsa_la_LIBADD) $(LIBS)
 
@@ -740,6 +775,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter_ull.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp-plugin.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp_plugin_gcn_la-plugin-gcn.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp_plugin_hsa_la-plugin-hsa.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp_plugin_nvptx_la-plugin-nvptx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock.Plo@am__quote@
@@ -753,6 +789,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-mem.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-parallel.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-plugin.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-profiling.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-target.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ordered.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parallel.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/priority_queue.Plo@am__quote@
@@ -790,6 +828,13 @@ distclean-compile:
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
 
+libgomp_plugin_gcn_la-plugin-gcn.lo: plugin/plugin-gcn.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgomp_plugin_gcn_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libgomp_plugin_gcn_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libgomp_plugin_gcn_la-plugin-gcn.lo -MD -MP -MF $(DEPDIR)/libgomp_plugin_gcn_la-plugin-gcn.Tpo -c -o libgomp_plugin_gcn_la-plugin-gcn.lo `test -f 'plugin/plugin-gcn.c' || echo '$(srcdir)/'`plugin/plugin-gcn.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libgomp_plugin_gcn_la-plugin-gcn.Tpo $(DEPDIR)/libgomp_plugin_gcn_la-plugin-gcn.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='plugin/plugin-gcn.c' object='libgomp_plugin_gcn_la-plugin-gcn.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgomp_plugin_gcn_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libgomp_plugin_gcn_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libgomp_plugin_gcn_la-plugin-gcn.lo `test -f 'plugin/plugin-gcn.c' || echo '$(srcdir)/'`plugin/plugin-gcn.c
+
 libgomp_plugin_hsa_la-plugin-hsa.lo: plugin/plugin-hsa.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgomp_plugin_hsa_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libgomp_plugin_hsa_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libgomp_plugin_hsa_la-plugin-hsa.lo -MD -MP -MF $(DEPDIR)/libgomp_plugin_hsa_la-plugin-hsa.Tpo -c -o libgomp_plugin_hsa_la-plugin-hsa.lo `test -f 'plugin/plugin-hsa.c' || echo '$(srcdir)/'`plugin/plugin-hsa.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libgomp_plugin_hsa_la-plugin-hsa.Tpo $(DEPDIR)/libgomp_plugin_hsa_la-plugin-hsa.Plo
diff --git a/libgomp/acc_prof.h b/libgomp/acc_prof.h
new file mode 100644
index 00000000000..c7a2197d11a
--- /dev/null
+++ b/libgomp/acc_prof.h
@@ -0,0 +1,252 @@
+/* OpenACC Profiling Interface
+
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   Contributed by Mentor, a Siemens Business.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ACC_PROF_H
+#define _ACC_PROF_H 1
+
+
+/* The OpenACC specification doesn't say so explicitly, but as its Profiling
+   Interface explicitly makes use of, for example, <openacc.h>'s
+   'acc_device_t', we supposedly are to '#include' that file here.  */
+
+#include <openacc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Events.  */
+
+typedef enum acc_event_t
+{
+  acc_ev_none = 0,
+  acc_ev_device_init_start,
+  acc_ev_device_init_end,
+  acc_ev_device_shutdown_start,
+  acc_ev_device_shutdown_end,
+  acc_ev_runtime_shutdown,
+  acc_ev_create,
+  acc_ev_delete,
+  acc_ev_alloc,
+  acc_ev_free,
+  acc_ev_enter_data_start,
+  acc_ev_enter_data_end,
+  acc_ev_exit_data_start,
+  acc_ev_exit_data_end,
+  acc_ev_update_start,
+  acc_ev_update_end,
+  acc_ev_compute_construct_start,
+  acc_ev_compute_construct_end,
+  acc_ev_enqueue_launch_start,
+  acc_ev_enqueue_launch_end,
+  acc_ev_enqueue_upload_start,
+  acc_ev_enqueue_upload_end,
+  acc_ev_enqueue_download_start,
+  acc_ev_enqueue_download_end,
+  acc_ev_wait_start,
+  acc_ev_wait_end,
+  acc_ev_last
+} acc_event_t;
+
+
+/* Callbacks Signature.  */
+
+/* "The datatype 'ssize_t' means a signed 32-bit integer for a 32-bit binary
+   and a 64-bit integer for a 64-bit binary".  */
+typedef signed long int _acc_prof_ssize_t;
+/* "The datatype 'size_t' means an unsigned 32-bit integer for a 32-bit binary
+   and a 64-bit integer for a 64-bit binary".  */
+typedef unsigned long int _acc_prof_size_t;
+/* "The datatype 'int' means a 32-bit integer for both 32-bit and 64-bit
+   binaries".  */
+typedef int _acc_prof_int_t;
+
+/* Internal helpers: a struct's 'valid_bytes' may be less than its 'sizeof'.  */
+#define _ACC_PROF_VALID_BYTES_STRUCT(_struct, _lastfield, _valid_bytes_lastfield) \
+  offsetof (_struct, _lastfield) + (_valid_bytes_lastfield)
+#if 0 /* Untested.  */
+#define _ACC_PROF_VALID_BYTES_TYPE_N(_type, _n, _valid_bytes_type) \
+  ((_n - 1) * sizeof (_type) + (_valid_bytes_type))
+#endif
+#define _ACC_PROF_VALID_BYTES_BASICTYPE(_basictype) \
+  (sizeof (_basictype))
+
+typedef struct acc_prof_info
+{
+  acc_event_t event_type;
+  _acc_prof_int_t valid_bytes;
+  _acc_prof_int_t version;
+  acc_device_t device_type;
+  _acc_prof_int_t device_number;
+  _acc_prof_int_t thread_id;
+  _acc_prof_ssize_t async;
+  _acc_prof_ssize_t async_queue;
+  const char *src_file;
+  const char *func_name;
+  _acc_prof_int_t line_no, end_line_no;
+  _acc_prof_int_t func_line_no, func_end_line_no;
+#define _ACC_PROF_INFO_VALID_BYTES \
+  _ACC_PROF_VALID_BYTES_STRUCT (acc_prof_info, func_end_line_no, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (_acc_prof_int_t))
+} acc_prof_info;
+
+/* We implement the OpenACC 2.6 Profiling Interface.  */
+
+#define _ACC_PROF_INFO_VERSION 201711
+
+typedef enum acc_construct_t
+{
+  acc_construct_parallel = 0,
+  acc_construct_kernels,
+  acc_construct_loop,
+  acc_construct_data,
+  acc_construct_enter_data,
+  acc_construct_exit_data,
+  acc_construct_host_data,
+  acc_construct_atomic,
+  acc_construct_declare,
+  acc_construct_init,
+  acc_construct_shutdown,
+  acc_construct_set,
+  acc_construct_update,
+  acc_construct_routine,
+  acc_construct_wait,
+  acc_construct_runtime_api,
+  acc_construct_serial
+} acc_construct_t;
+
+typedef struct acc_data_event_info
+{
+  acc_event_t event_type;
+  _acc_prof_int_t valid_bytes;
+  acc_construct_t parent_construct;
+  _acc_prof_int_t implicit;
+  void *tool_info;
+  const char *var_name;
+  _acc_prof_size_t bytes;
+  const void *host_ptr;
+  const void *device_ptr;
+#define _ACC_DATA_EVENT_INFO_VALID_BYTES \
+  _ACC_PROF_VALID_BYTES_STRUCT (acc_data_event_info, device_ptr, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (void *))
+} acc_data_event_info;
+
+typedef struct acc_launch_event_info
+{
+  acc_event_t event_type;
+  _acc_prof_int_t valid_bytes;
+  acc_construct_t parent_construct;
+  _acc_prof_int_t implicit;
+  void *tool_info;
+  const char *kernel_name;
+  _acc_prof_size_t num_gangs, num_workers, vector_length;
+#define _ACC_LAUNCH_EVENT_INFO_VALID_BYTES \
+  _ACC_PROF_VALID_BYTES_STRUCT (acc_launch_event_info, vector_length, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (_acc_prof_size_t))
+} acc_launch_event_info;
+
+typedef struct acc_other_event_info
+{
+  acc_event_t event_type;
+  _acc_prof_int_t valid_bytes;
+  acc_construct_t parent_construct;
+  _acc_prof_int_t implicit;
+  void *tool_info;
+#define _ACC_OTHER_EVENT_INFO_VALID_BYTES \
+  _ACC_PROF_VALID_BYTES_STRUCT (acc_other_event_info, tool_info, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (void *))
+} acc_other_event_info;
+
+typedef union acc_event_info
+{
+  acc_event_t event_type;
+  acc_data_event_info data_event;
+  acc_launch_event_info launch_event;
+  acc_other_event_info other_event;
+} acc_event_info;
+
+typedef enum acc_device_api
+{
+  acc_device_api_none = 0,
+  acc_device_api_cuda,
+  acc_device_api_opencl,
+  acc_device_api_coi,
+  acc_device_api_other
+} acc_device_api;
+
+typedef struct acc_api_info
+{
+  acc_device_api device_api;
+  _acc_prof_int_t valid_bytes;
+  acc_device_t device_type;
+  _acc_prof_int_t vendor;
+  const void *device_handle;
+  const void *context_handle;
+  const void *async_handle;
+#define _ACC_API_INFO_VALID_BYTES \
+  _ACC_PROF_VALID_BYTES_STRUCT (acc_api_info, async_handle, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (void *))
+} acc_api_info;
+
+/* Don't tag 'acc_prof_callback' as '__GOACC_NOTHROW': these functions are
+   provided by user code, and must be expected to do anything.  */
+typedef void (*acc_prof_callback) (acc_prof_info *, acc_event_info *,
+				   acc_api_info *);
+
+
+/* Loading the Library.  */
+
+typedef enum acc_register_t
+{
+  acc_reg = 0,
+  acc_toggle = 1,
+  acc_toggle_per_thread = 2
+} acc_register_t;
+
+typedef void (*acc_prof_reg) (acc_event_t, acc_prof_callback, acc_register_t);
+extern void acc_prof_register (acc_event_t, acc_prof_callback,
+			       acc_register_t) __GOACC_NOTHROW;
+extern void acc_prof_unregister (acc_event_t, acc_prof_callback,
+				 acc_register_t) __GOACC_NOTHROW;
+typedef void (*acc_query_fn) ();
+typedef acc_query_fn (*acc_prof_lookup_func) (const char *);
+extern acc_query_fn acc_prof_lookup (const char *) __GOACC_NOTHROW;
+/* Don't tag 'acc_register_library' as '__GOACC_NOTHROW': this function can be
+   overridden by user code, and must be expected to do anything.  */
+extern void acc_register_library (acc_prof_reg, acc_prof_reg,
+				  acc_prof_lookup_func);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _ACC_PROF_H */
diff --git a/libgomp/acinclude.m4 b/libgomp/acinclude.m4
index 51f4f30256c..dbf54d06db9 100644
--- a/libgomp/acinclude.m4
+++ b/libgomp/acinclude.m4
@@ -154,7 +154,7 @@ AC_DEFUN([LIBGOMP_CHECK_LINKER_FEATURES], [
   fi
   changequote(,)
   ldver=`$LD --version 2>/dev/null |
-         sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \([0-9.][0-9.]*\).*/\1/; q'`
+         sed -e 's/[. ][0-9]\{8\}$//;s/.* \([^ ]\{1,\}\)$/\1/; q'`
   changequote([,])
   libgomp_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`
diff --git a/libgomp/aclocal.m4 b/libgomp/aclocal.m4
index 252d5fca06c..12125996425 100644
--- a/libgomp/aclocal.m4
+++ b/libgomp/aclocal.m4
@@ -1168,6 +1168,7 @@ AC_SUBST([am__untar])
 ]) # _AM_PROG_TAR
 
 m4_include([../config/acx.m4])
+m4_include([../config/ax_count_cpus.m4])
 m4_include([../config/depstand.m4])
 m4_include([../config/enable.m4])
 m4_include([../config/futex.m4])
@@ -1175,7 +1176,6 @@ m4_include([../config/lead-dot.m4])
 m4_include([../config/lthostflags.m4])
 m4_include([../config/multi.m4])
 m4_include([../config/override.m4])
-m4_include([../config/stdint.m4])
 m4_include([../config/tls.m4])
 m4_include([../ltoptions.m4])
 m4_include([../ltsugar.m4])
diff --git a/libgomp/config.h.in b/libgomp/config.h.in
index 73f1b12805e..2d50fcd5c1a 100644
--- a/libgomp/config.h.in
+++ b/libgomp/config.h.in
@@ -170,6 +170,9 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
+/* Define to 1 if the GCN plugin is built, 0 if not. */
+#undef PLUGIN_GCN
+
 /* Define to 1 if the HSA plugin is built, 0 if not. */
 #undef PLUGIN_HSA
 
@@ -183,21 +186,6 @@
 /* Define if all infrastructure, needed for plugins, is supported. */
 #undef PLUGIN_SUPPORT
 
-/* The size of `char', as computed by sizeof. */
-#undef SIZEOF_CHAR
-
-/* The size of `int', as computed by sizeof. */
-#undef SIZEOF_INT
-
-/* The size of `long', as computed by sizeof. */
-#undef SIZEOF_LONG
-
-/* The size of `short', as computed by sizeof. */
-#undef SIZEOF_SHORT
-
-/* The size of `void *', as computed by sizeof. */
-#undef SIZEOF_VOID_P
-
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
diff --git a/libgomp/config/nvptx/libgomp-plugin.c b/libgomp/config/accel/libgomp-plugin.c
similarity index 100%
rename from libgomp/config/nvptx/libgomp-plugin.c
rename to libgomp/config/accel/libgomp-plugin.c
diff --git a/libgomp/config/nvptx/lock.c b/libgomp/config/accel/lock.c
similarity index 100%
rename from libgomp/config/nvptx/lock.c
rename to libgomp/config/accel/lock.c
diff --git a/libgomp/config/nvptx/mutex.c b/libgomp/config/accel/mutex.c
similarity index 100%
rename from libgomp/config/nvptx/mutex.c
rename to libgomp/config/accel/mutex.c
diff --git a/libgomp/config/nvptx/mutex.h b/libgomp/config/accel/mutex.h
similarity index 100%
rename from libgomp/config/nvptx/mutex.h
rename to libgomp/config/accel/mutex.h
diff --git a/libgomp/config/nvptx/oacc-async.c b/libgomp/config/accel/oacc-async.c
similarity index 100%
rename from libgomp/config/nvptx/oacc-async.c
rename to libgomp/config/accel/oacc-async.c
diff --git a/libgomp/config/nvptx/oacc-cuda.c b/libgomp/config/accel/oacc-cuda.c
similarity index 100%
rename from libgomp/config/nvptx/oacc-cuda.c
rename to libgomp/config/accel/oacc-cuda.c
diff --git a/libgomp/config/nvptx/oacc-host.c b/libgomp/config/accel/oacc-host.c
similarity index 100%
rename from libgomp/config/nvptx/oacc-host.c
rename to libgomp/config/accel/oacc-host.c
diff --git a/libgomp/config/nvptx/oacc-init.c b/libgomp/config/accel/oacc-init.c
similarity index 100%
rename from libgomp/config/nvptx/oacc-init.c
rename to libgomp/config/accel/oacc-init.c
diff --git a/libgomp/config/nvptx/oacc-mem.c b/libgomp/config/accel/oacc-mem.c
similarity index 100%
rename from libgomp/config/nvptx/oacc-mem.c
rename to libgomp/config/accel/oacc-mem.c
diff --git a/libgomp/config/nvptx/oacc-plugin.c b/libgomp/config/accel/oacc-plugin.c
similarity index 100%
rename from libgomp/config/nvptx/oacc-plugin.c
rename to libgomp/config/accel/oacc-plugin.c
diff --git a/libgomp/config/nvptx/omp-lock.h b/libgomp/config/accel/omp-lock.h
similarity index 100%
rename from libgomp/config/nvptx/omp-lock.h
rename to libgomp/config/accel/omp-lock.h
diff --git a/libgomp/config/nvptx/openacc.f90 b/libgomp/config/accel/openacc.f90
similarity index 98%
rename from libgomp/config/nvptx/openacc.f90
rename to libgomp/config/accel/openacc.f90
index a7f690e1572..6a8c5e9cb3d 100644
--- a/libgomp/config/nvptx/openacc.f90
+++ b/libgomp/config/accel/openacc.f90
@@ -51,6 +51,7 @@ module openacc_kinds
   ! integer (acc_device_kind), parameter :: acc_device_host_nonshm = 3 removed.
   integer (acc_device_kind), parameter :: acc_device_not_host = 4
   integer (acc_device_kind), parameter :: acc_device_nvidia = 5
+  integer (acc_device_kind), parameter :: acc_device_gcn = 8
 
 end module
 
diff --git a/libgomp/config/nvptx/pool.h b/libgomp/config/accel/pool.h
similarity index 100%
rename from libgomp/config/nvptx/pool.h
rename to libgomp/config/accel/pool.h
diff --git a/libgomp/config/nvptx/proc.c b/libgomp/config/accel/proc.c
similarity index 98%
rename from libgomp/config/nvptx/proc.c
rename to libgomp/config/accel/proc.c
index 8ca0b0a1ee1..be4cb30632a 100644
--- a/libgomp/config/nvptx/proc.c
+++ b/libgomp/config/accel/proc.c
@@ -39,3 +39,5 @@ omp_get_num_procs (void)
 {
   return gomp_icv (false)->nthreads_var;
 }
+
+ialias (omp_get_num_procs)
diff --git a/libgomp/config/nvptx/ptrlock.c b/libgomp/config/accel/ptrlock.c
similarity index 100%
rename from libgomp/config/nvptx/ptrlock.c
rename to libgomp/config/accel/ptrlock.c
diff --git a/libgomp/config/nvptx/ptrlock.h b/libgomp/config/accel/ptrlock.h
similarity index 100%
rename from libgomp/config/nvptx/ptrlock.h
rename to libgomp/config/accel/ptrlock.h
diff --git a/libgomp/config/nvptx/sem.c b/libgomp/config/accel/sem.c
similarity index 100%
rename from libgomp/config/nvptx/sem.c
rename to libgomp/config/accel/sem.c
diff --git a/libgomp/config/nvptx/sem.h b/libgomp/config/accel/sem.h
similarity index 100%
rename from libgomp/config/nvptx/sem.h
rename to libgomp/config/accel/sem.h
diff --git a/libgomp/config/nvptx/thread-stacksize.h b/libgomp/config/accel/thread-stacksize.h
similarity index 100%
rename from libgomp/config/nvptx/thread-stacksize.h
rename to libgomp/config/accel/thread-stacksize.h
diff --git a/libgomp/config/gcn/affinity-fmt.c b/libgomp/config/gcn/affinity-fmt.c
new file mode 100644
index 00000000000..3585f414460
--- /dev/null
+++ b/libgomp/config/gcn/affinity-fmt.c
@@ -0,0 +1,51 @@
+/* Copyright (C) 2018-2019 Free Software Foundation, Inc.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "libgomp.h"
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>  /* For PRIx64.  */
+#endif
+#ifdef HAVE_UNAME
+#include <sys/utsname.h>
+#endif
+
+/* The HAVE_GETPID and HAVE_GETHOSTNAME configure tests are passing for nvptx,
+   while the nvptx newlib implementation does not support those functions.
+   Override the configure test results here.  */
+#undef HAVE_GETPID
+#undef HAVE_GETHOSTNAME
+
+/* The GCN newlib implementation does not support fwrite, but it does support
+   write.  Map fwrite to write.  */
+#undef fwrite
+#define fwrite(ptr, size, nmemb, stream) write (1, (ptr), (nmemb) * (size))
+
+#include "../../affinity-fmt.c"
+
diff --git a/libgomp/config/gcn/bar.c b/libgomp/config/gcn/bar.c
new file mode 100644
index 00000000000..fb709be26ce
--- /dev/null
+++ b/libgomp/config/gcn/bar.c
@@ -0,0 +1,232 @@
+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Embedded.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This is an AMD GCN specific implementation of a barrier synchronization
+   mechanism for libgomp.  This type is private to the library.  This
+   implementation uses atomic instructions and s_barrier instruction.  It
+   uses MEMMODEL_RELAXED here because barriers are within workgroups and
+   therefore don't need to flush caches.  */
+
+#include <limits.h>
+#include "libgomp.h"
+
+
+void
+gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)
+{
+  if (__builtin_expect (state & BAR_WAS_LAST, 0))
+    {
+      /* Next time we'll be awaiting TOTAL threads again.  */
+      bar->awaited = bar->total;
+      __atomic_store_n (&bar->generation, bar->generation + BAR_INCR,
+			MEMMODEL_RELAXED);
+    }
+  asm ("s_barrier" ::: "memory");
+}
+
+void
+gomp_barrier_wait (gomp_barrier_t *bar)
+{
+  gomp_barrier_wait_end (bar, gomp_barrier_wait_start (bar));
+}
+
+/* Like gomp_barrier_wait, except that if the encountering thread
+   is not the last one to hit the barrier, it returns immediately.
+   The intended usage is that a thread which intends to gomp_barrier_destroy
+   this barrier calls gomp_barrier_wait, while all other threads
+   call gomp_barrier_wait_last.  When gomp_barrier_wait returns,
+   the barrier can be safely destroyed.  */
+
+void
+gomp_barrier_wait_last (gomp_barrier_t *bar)
+{
+  /* Deferring to gomp_barrier_wait does not use the optimization opportunity
+     allowed by the interface contract for all-but-last participants.  The
+     original implementation in config/linux/bar.c handles this better.  */
+  gomp_barrier_wait (bar);
+}
+
+void
+gomp_team_barrier_wake (gomp_barrier_t *bar, int count)
+{
+  asm ("s_barrier" ::: "memory");
+}
+
+void
+gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)
+{
+  unsigned int generation, gen;
+
+  if (__builtin_expect (state & BAR_WAS_LAST, 0))
+    {
+      /* Next time we'll be awaiting TOTAL threads again.  */
+      struct gomp_thread *thr = gomp_thread ();
+      struct gomp_team *team = thr->ts.team;
+
+      bar->awaited = bar->total;
+      team->work_share_cancelled = 0;
+      if (__builtin_expect (team->task_count, 0))
+	{
+	  gomp_barrier_handle_tasks (state);
+	  state &= ~BAR_WAS_LAST;
+	}
+      else
+	{
+	  state &= ~BAR_CANCELLED;
+	  state += BAR_INCR - BAR_WAS_LAST;
+	  __atomic_store_n (&bar->generation, state, MEMMODEL_RELAXED);
+	  asm ("s_barrier" ::: "memory");
+	  return;
+	}
+    }
+
+  generation = state;
+  state &= ~BAR_CANCELLED;
+  int retry = 100;
+  do
+    {
+      if (retry-- == 0)
+	{
+	  /* It really shouldn't happen that barriers get out of sync, but
+	     if they do then this will loop until they realign, so we need
+	     to avoid an infinite loop where the thread just isn't there.  */
+	  const char msg[] = ("Barrier sync failed (another thread died?);"
+			      " aborting.");
+	  write (2, msg, sizeof (msg)-1);
+	  abort();
+	}
+
+      asm ("s_barrier" ::: "memory");
+      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);
+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))
+	{
+	  gomp_barrier_handle_tasks (state);
+	  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);
+	}
+      generation |= gen & BAR_WAITING_FOR_TASK;
+    }
+  while (gen != state + BAR_INCR);
+}
+
+void
+gomp_team_barrier_wait (gomp_barrier_t *bar)
+{
+  gomp_team_barrier_wait_end (bar, gomp_barrier_wait_start (bar));
+}
+
+void
+gomp_team_barrier_wait_final (gomp_barrier_t *bar)
+{
+  gomp_barrier_state_t state = gomp_barrier_wait_final_start (bar);
+  if (__builtin_expect (state & BAR_WAS_LAST, 0))
+    bar->awaited_final = bar->total;
+  gomp_team_barrier_wait_end (bar, state);
+}
+
+bool
+gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,
+				   gomp_barrier_state_t state)
+{
+  unsigned int generation, gen;
+
+  if (__builtin_expect (state & BAR_WAS_LAST, 0))
+    {
+      /* Next time we'll be awaiting TOTAL threads again.  */
+      /* BAR_CANCELLED should never be set in state here, because
+	 cancellation means that at least one of the threads has been
+	 cancelled, thus on a cancellable barrier we should never see
+	 all threads to arrive.  */
+      struct gomp_thread *thr = gomp_thread ();
+      struct gomp_team *team = thr->ts.team;
+
+      bar->awaited = bar->total;
+      team->work_share_cancelled = 0;
+      if (__builtin_expect (team->task_count, 0))
+	{
+	  gomp_barrier_handle_tasks (state);
+	  state &= ~BAR_WAS_LAST;
+	}
+      else
+	{
+	  state += BAR_INCR - BAR_WAS_LAST;
+	  __atomic_store_n (&bar->generation, state, MEMMODEL_RELAXED);
+	  asm ("s_barrier" ::: "memory");
+	  return false;
+	}
+    }
+
+  if (__builtin_expect (state & BAR_CANCELLED, 0))
+    return true;
+
+  generation = state;
+  int retry = 100;
+  do
+    {
+      if (retry-- == 0)
+	{
+	  /* It really shouldn't happen that barriers get out of sync, but
+	     if they do then this will loop until they realign, so we need
+	     to avoid an infinite loop where the thread just isn't there.  */
+	  const char msg[] = ("Barrier sync failed (another thread died?);"
+			      " aborting.");
+	  write (2, msg, sizeof (msg)-1);
+	  abort();
+	}
+
+      asm ("s_barrier" ::: "memory");
+      gen = __atomic_load_n (&bar->generation, MEMMODEL_RELAXED);
+      if (__builtin_expect (gen & BAR_CANCELLED, 0))
+	return true;
+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))
+	{
+	  gomp_barrier_handle_tasks (state);
+	  gen = __atomic_load_n (&bar->generation, MEMMODEL_RELAXED);
+	}
+      generation |= gen & BAR_WAITING_FOR_TASK;
+    }
+  while (gen != state + BAR_INCR);
+
+  return false;
+}
+
+bool
+gomp_team_barrier_wait_cancel (gomp_barrier_t *bar)
+{
+  return gomp_team_barrier_wait_cancel_end (bar, gomp_barrier_wait_start (bar));
+}
+
+void
+gomp_team_barrier_cancel (struct gomp_team *team)
+{
+  gomp_mutex_lock (&team->task_lock);
+  if (team->barrier.generation & BAR_CANCELLED)
+    {
+      gomp_mutex_unlock (&team->task_lock);
+      return;
+    }
+  team->barrier.generation |= BAR_CANCELLED;
+  gomp_mutex_unlock (&team->task_lock);
+  gomp_team_barrier_wake (&team->barrier, INT_MAX);
+}
diff --git a/libgomp/config/gcn/bar.h b/libgomp/config/gcn/bar.h
new file mode 100644
index 00000000000..ec8851ba078
--- /dev/null
+++ b/libgomp/config/gcn/bar.h
@@ -0,0 +1,168 @@
+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Embedded.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This is an AMD GCN specific implementation of a barrier synchronization
+   mechanism for libgomp.  This type is private to the library.  This
+   implementation uses atomic instructions and s_barrier instruction.  It
+   uses MEMMODEL_RELAXED here because barriers are within workgroups and
+   therefore don't need to flush caches.  */
+
+#ifndef GOMP_BARRIER_H
+#define GOMP_BARRIER_H 1
+
+#include "mutex.h"
+
+typedef struct
+{
+  unsigned total;
+  unsigned generation;
+  unsigned awaited;
+  unsigned awaited_final;
+} gomp_barrier_t;
+
+typedef unsigned int gomp_barrier_state_t;
+
+/* The generation field contains a counter in the high bits, with a few
+   low bits dedicated to flags.  Note that TASK_PENDING and WAS_LAST can
+   share space because WAS_LAST is never stored back to generation.  */
+#define BAR_TASK_PENDING	1
+#define BAR_WAS_LAST		1
+#define BAR_WAITING_FOR_TASK	2
+#define BAR_CANCELLED		4
+#define BAR_INCR		8
+
+static inline void gomp_barrier_init (gomp_barrier_t *bar, unsigned count)
+{
+  bar->total = count;
+  bar->awaited = count;
+  bar->awaited_final = count;
+  bar->generation = 0;
+}
+
+static inline void gomp_barrier_reinit (gomp_barrier_t *bar, unsigned count)
+{
+  __atomic_add_fetch (&bar->awaited, count - bar->total, MEMMODEL_RELAXED);
+  bar->total = count;
+}
+
+static inline void gomp_barrier_destroy (gomp_barrier_t *bar)
+{
+}
+
+extern void gomp_barrier_wait (gomp_barrier_t *);
+extern void gomp_barrier_wait_last (gomp_barrier_t *);
+extern void gomp_barrier_wait_end (gomp_barrier_t *, gomp_barrier_state_t);
+extern void gomp_team_barrier_wait (gomp_barrier_t *);
+extern void gomp_team_barrier_wait_final (gomp_barrier_t *);
+extern void gomp_team_barrier_wait_end (gomp_barrier_t *,
+					gomp_barrier_state_t);
+extern bool gomp_team_barrier_wait_cancel (gomp_barrier_t *);
+extern bool gomp_team_barrier_wait_cancel_end (gomp_barrier_t *,
+					       gomp_barrier_state_t);
+extern void gomp_team_barrier_wake (gomp_barrier_t *, int);
+struct gomp_team;
+extern void gomp_team_barrier_cancel (struct gomp_team *);
+
+static inline gomp_barrier_state_t
+gomp_barrier_wait_start (gomp_barrier_t *bar)
+{
+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_RELAXED);
+  ret &= -BAR_INCR | BAR_CANCELLED;
+  /* A memory barrier is needed before exiting from the various forms
+     of gomp_barrier_wait, to satisfy OpenMP API version 3.1 section
+     2.8.6 flush Construct, which says there is an implicit flush during
+     a barrier region.  This is a convenient place to add the barrier,
+     so we use MEMMODEL_ACQ_REL here rather than MEMMODEL_ACQUIRE.  */
+  if (__atomic_add_fetch (&bar->awaited, -1, MEMMODEL_RELAXED) == 0)
+    ret |= BAR_WAS_LAST;
+  return ret;
+}
+
+static inline gomp_barrier_state_t
+gomp_barrier_wait_cancel_start (gomp_barrier_t *bar)
+{
+  return gomp_barrier_wait_start (bar);
+}
+
+/* This is like gomp_barrier_wait_start, except it decrements
+   bar->awaited_final rather than bar->awaited and should be used
+   for the gomp_team_end barrier only.  */
+static inline gomp_barrier_state_t
+gomp_barrier_wait_final_start (gomp_barrier_t *bar)
+{
+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_RELAXED);
+  ret &= -BAR_INCR | BAR_CANCELLED;
+  /* See above gomp_barrier_wait_start comment.  */
+  if (__atomic_add_fetch (&bar->awaited_final, -1, MEMMODEL_RELAXED) == 0)
+    ret |= BAR_WAS_LAST;
+  return ret;
+}
+
+static inline bool
+gomp_barrier_last_thread (gomp_barrier_state_t state)
+{
+  return state & BAR_WAS_LAST;
+}
+
+/* All the inlines below must be called with team->task_lock
+   held.  */
+
+static inline void
+gomp_team_barrier_set_task_pending (gomp_barrier_t *bar)
+{
+  bar->generation |= BAR_TASK_PENDING;
+}
+
+static inline void
+gomp_team_barrier_clear_task_pending (gomp_barrier_t *bar)
+{
+  bar->generation &= ~BAR_TASK_PENDING;
+}
+
+static inline void
+gomp_team_barrier_set_waiting_for_tasks (gomp_barrier_t *bar)
+{
+  bar->generation |= BAR_WAITING_FOR_TASK;
+}
+
+static inline bool
+gomp_team_barrier_waiting_for_tasks (gomp_barrier_t *bar)
+{
+  return (bar->generation & BAR_WAITING_FOR_TASK) != 0;
+}
+
+static inline bool
+gomp_team_barrier_cancelled (gomp_barrier_t *bar)
+{
+  return __builtin_expect ((bar->generation & BAR_CANCELLED) != 0, 0);
+}
+
+static inline void
+gomp_team_barrier_done (gomp_barrier_t *bar, gomp_barrier_state_t state)
+{
+  bar->generation = (state & -BAR_INCR) + BAR_INCR;
+}
+
+#endif /* GOMP_BARRIER_H */
diff --git a/libgomp/config/gcn/doacross.h b/libgomp/config/gcn/doacross.h
new file mode 100644
index 00000000000..2bff18ae1a8
--- /dev/null
+++ b/libgomp/config/gcn/doacross.h
@@ -0,0 +1,58 @@
+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Embedded.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This is the AMD GCN implementation of doacross spinning.  */
+
+#ifndef GOMP_DOACROSS_H
+#define GOMP_DOACROSS_H 1
+
+#include "libgomp.h"
+
+static inline int
+cpu_relax (void)
+{
+  /* This can be implemented as just a memory barrier, but a sleep seems
+     like it should allow the wavefront to yield (maybe?)
+     Use the shortest possible sleep time of 1*64 cycles.  */
+  asm volatile ("s_sleep\t1" ::: "memory");
+  return 0;
+}
+
+static inline void doacross_spin (unsigned long *addr, unsigned long expected,
+				  unsigned long cur)
+{
+  /* Prevent compiler from optimizing based on bounds of containing object.  */
+  asm ("" : "+r" (addr));
+  do
+    {
+       /* An alternative implementation might use s_setprio to lower the
+	  priority temporarily, and then restore it after.  */
+      int i = cpu_relax ();
+      cur = addr[i];
+    }
+  while (cur <= expected);
+}
+
+#endif /* GOMP_DOACROSS_H */
diff --git a/libgomp/config/gcn/icv-device.c b/libgomp/config/gcn/icv-device.c
new file mode 100644
index 00000000000..cbb9dfa1133
--- /dev/null
+++ b/libgomp/config/gcn/icv-device.c
@@ -0,0 +1,72 @@
+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Embedded.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This file defines OpenMP API entry points that accelerator targets are
+   expected to replace.  */
+
+#include "libgomp.h"
+
+void
+omp_set_default_device (int device_num __attribute__((unused)))
+{
+}
+
+int
+omp_get_default_device (void)
+{
+  return 0;
+}
+
+int
+omp_get_num_devices (void)
+{
+  return 0;
+}
+
+int
+omp_get_num_teams (void)
+{
+  return gomp_num_teams_var + 1;
+}
+
+int __attribute__ ((__optimize__ ("O2")))
+omp_get_team_num (void)
+{
+  return __builtin_gcn_dim_pos (0);
+}
+
+int
+omp_is_initial_device (void)
+{
+  /* AMD GCN is an accelerator-only target.  */
+  return 0;
+}
+
+ialias (omp_set_default_device)
+ialias (omp_get_default_device)
+ialias (omp_get_num_devices)
+ialias (omp_get_num_teams)
+ialias (omp_get_team_num)
+ialias (omp_is_initial_device)
diff --git a/libgomp/config/gcn/oacc-target.c b/libgomp/config/gcn/oacc-target.c
new file mode 100644
index 00000000000..bdcc9153d96
--- /dev/null
+++ b/libgomp/config/gcn/oacc-target.c
@@ -0,0 +1,31 @@
+/* Oversized reductions lock variable
+   Copyright (C) 2017-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Graphics.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* We use a global lock variable for reductions on objects larger than
+   64 bits.  Until and unless proven that lock contention for
+   different reductions is a problem, a single lock will suffice.  */
+
+unsigned volatile __reduction_lock = 0;
diff --git a/libgomp/config/gcn/simple-bar.h b/libgomp/config/gcn/simple-bar.h
new file mode 100644
index 00000000000..802e0f5c301
--- /dev/null
+++ b/libgomp/config/gcn/simple-bar.h
@@ -0,0 +1,61 @@
+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Embedded.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This is a simplified barrier that is suitable for thread pool
+   synchronizaton.  Only a subset of full barrier API (bar.h) is exposed.
+   Here in the AMD GCN-specific implementation, we expect that thread pool
+   corresponds to the wavefronts within a work group.  */
+
+#ifndef GOMP_SIMPLE_BARRIER_H
+#define GOMP_SIMPLE_BARRIER_H 1
+
+/* AMD GCN has no use for this type.  */
+typedef int gomp_simple_barrier_t;
+
+/* GCN barriers block all wavefronts, so the count is not interesting.  */
+static inline void
+gomp_simple_barrier_init (gomp_simple_barrier_t *bar, unsigned count)
+{
+}
+
+static inline void
+gomp_simple_barrier_destroy (gomp_simple_barrier_t *bar)
+{
+}
+
+static inline void
+gomp_simple_barrier_wait (gomp_simple_barrier_t *bar)
+{
+  asm volatile ("s_barrier" ::: "memory");
+}
+
+static inline void
+gomp_simple_barrier_wait_last (gomp_simple_barrier_t *bar)
+{
+  /* GCN has no way to signal a barrier without waiting.  */
+  asm volatile ("s_barrier" ::: "memory");
+}
+
+#endif /* GOMP_SIMPLE_BARRIER_H */
diff --git a/libgomp/config/gcn/target.c b/libgomp/config/gcn/target.c
new file mode 100644
index 00000000000..db00551e695
--- /dev/null
+++ b/libgomp/config/gcn/target.c
@@ -0,0 +1,67 @@
+/* Copyright (C) 2017-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Embedded.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "libgomp.h"
+#include <limits.h>
+
+void
+GOMP_teams (unsigned int num_teams, unsigned int thread_limit)
+{
+  if (thread_limit)
+    {
+      struct gomp_task_icv *icv = gomp_icv (true);
+      icv->thread_limit_var
+	= thread_limit > INT_MAX ? UINT_MAX : thread_limit;
+    }
+  unsigned int num_workgroups, workgroup_id;
+  num_workgroups = __builtin_gcn_dim_size (0);
+  workgroup_id = __builtin_gcn_dim_pos (0);
+  if (!num_teams || num_teams >= num_workgroups)
+    num_teams = num_workgroups;
+  else if (workgroup_id >= num_teams)
+    {
+      gomp_free_thread (gcn_thrs ());
+      exit (0);
+    }
+  gomp_num_teams_var = num_teams - 1;
+}
+
+int
+omp_pause_resource (omp_pause_resource_t kind, int device_num)
+{
+  (void) kind;
+  (void) device_num;
+  return -1;
+}
+
+int
+omp_pause_resource_all (omp_pause_resource_t kind)
+{
+  (void) kind;
+  return -1;
+}
+
+ialias (omp_pause_resource)
+ialias (omp_pause_resource_all)
diff --git a/libgomp/config/gcn/task.c b/libgomp/config/gcn/task.c
new file mode 100644
index 00000000000..91554571b99
--- /dev/null
+++ b/libgomp/config/gcn/task.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2017-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Embedded.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This file handles the maintenance of tasks in response to task
+   creation and termination.  */
+
+#include "libgomp.h"
+
+/* AMD GCN is an accelerator-only target, so this should never be called.  */
+
+bool
+gomp_target_task_fn (void *data)
+{
+  __builtin_unreachable ();
+}
+
+#include "../../task.c"
diff --git a/libgomp/config/gcn/team.c b/libgomp/config/gcn/team.c
new file mode 100644
index 00000000000..e538a10fd8a
--- /dev/null
+++ b/libgomp/config/gcn/team.c
@@ -0,0 +1,214 @@
+/* Copyright (C) 2017-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Embedded.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This file handles maintenance of threads on AMD GCN.  */
+
+#include "libgomp.h"
+#include <stdlib.h>
+#include <string.h>
+
+static void gomp_thread_start (struct gomp_thread_pool *);
+
+/* This externally visible function handles target region entry.  It
+   sets up a per-team thread pool and transfers control by returning to
+   the kernel in the master thread or gomp_thread_start in other threads.
+
+   The name of this function is part of the interface with the compiler: for
+   each OpenMP kernel the compiler configures the stack, then calls here.
+
+   Likewise, gomp_gcn_exit_kernel is called during the kernel epilogue.  */
+
+void
+gomp_gcn_enter_kernel (void)
+{
+  int threadid = __builtin_gcn_dim_pos (1);
+
+  if (threadid == 0)
+    {
+      int numthreads = __builtin_gcn_dim_size (1);
+      int teamid = __builtin_gcn_dim_pos(0);
+
+      /* Set up the global state.
+	 Every team will do this, but that should be harmless.  */
+      gomp_global_icv.nthreads_var = 16;
+      gomp_global_icv.thread_limit_var = numthreads;
+      /* Starting additional threads is not supported.  */
+      gomp_global_icv.dyn_var = true;
+
+      /* Initialize the team arena for optimized memory allocation.
+         The arena has been allocated on the host side, and the address
+         passed in via the kernargs.  Each team takes a small slice of it.  */
+      register void **kernargs asm("s8");
+      void *team_arena = (kernargs[4] + TEAM_ARENA_SIZE*teamid);
+      void * __lds *arena_start = (void * __lds *)TEAM_ARENA_START;
+      void * __lds *arena_free = (void * __lds *)TEAM_ARENA_FREE;
+      void * __lds *arena_end = (void * __lds *)TEAM_ARENA_END;
+      *arena_start = team_arena;
+      *arena_free = team_arena;
+      *arena_end = team_arena + TEAM_ARENA_SIZE;
+
+      /* Allocate and initialize the team-local-storage data.  */
+      struct gomp_thread *thrs = team_malloc_cleared (sizeof (*thrs)
+						      * numthreads);
+      set_gcn_thrs (thrs);
+
+      /* Allocate and initialize a pool of threads in the team.
+         The threads are already running, of course, we just need to manage
+         the communication between them.  */
+      struct gomp_thread_pool *pool = team_malloc (sizeof (*pool));
+      pool->threads = team_malloc (sizeof (void *) * numthreads);
+      for (int tid = 0; tid < numthreads; tid++)
+	pool->threads[tid] = &thrs[tid];
+      pool->threads_size = numthreads;
+      pool->threads_used = numthreads;
+      pool->threads_busy = 1;
+      pool->last_team = NULL;
+      gomp_simple_barrier_init (&pool->threads_dock, numthreads);
+      thrs->thread_pool = pool;
+
+      asm ("s_barrier" ::: "memory");
+      return;  /* Return to kernel.  */
+    }
+  else
+    {
+      asm ("s_barrier" ::: "memory");
+      gomp_thread_start (gcn_thrs ()[0].thread_pool);
+      /* gomp_thread_start does not return.  */
+    }
+}
+
+void
+gomp_gcn_exit_kernel (void)
+{
+  gomp_free_thread (gcn_thrs ());
+  team_free (gcn_thrs ());
+}
+
+/* This function contains the idle loop in which a thread waits
+   to be called up to become part of a team.  */
+
+static void
+gomp_thread_start (struct gomp_thread_pool *pool)
+{
+  struct gomp_thread *thr = gomp_thread ();
+
+  gomp_sem_init (&thr->release, 0);
+  thr->thread_pool = pool;
+
+  /* The loop exits only when "fn" is assigned "gomp_free_pool_helper",
+     which contains "s_endpgm", or an infinite no-op loop is
+     suspected (this happens when the thread master crashes).  */
+  int nul_limit = 99;
+  do
+    {
+      gomp_simple_barrier_wait (&pool->threads_dock);
+      if (!thr->fn)
+	{
+	  if (nul_limit-- > 0)
+	    continue;
+	  else
+	    {
+	      const char msg[] = ("team master not responding;"
+				  " slave thread aborting");
+	      write (2, msg, sizeof (msg)-1);
+	      abort();
+	    }
+	}
+      thr->fn (thr->data);
+      thr->fn = NULL;
+
+      struct gomp_task *task = thr->task;
+      gomp_team_barrier_wait_final (&thr->ts.team->barrier);
+      gomp_finish_task (task);
+    }
+  while (1);
+}
+
+/* Launch a team.  */
+
+void
+gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,
+		 unsigned flags, struct gomp_team *team,
+		 struct gomp_taskgroup *taskgroup)
+{
+  struct gomp_thread *thr, *nthr;
+  struct gomp_task *task;
+  struct gomp_task_icv *icv;
+  struct gomp_thread_pool *pool;
+  unsigned long nthreads_var;
+
+  thr = gomp_thread ();
+  pool = thr->thread_pool;
+  task = thr->task;
+  icv = task ? &task->icv : &gomp_global_icv;
+
+  /* Always save the previous state, even if this isn't a nested team.
+     In particular, we should save any work share state from an outer
+     orphaned work share construct.  */
+  team->prev_ts = thr->ts;
+
+  thr->ts.team = team;
+  thr->ts.team_id = 0;
+  ++thr->ts.level;
+  if (nthreads > 1)
+    ++thr->ts.active_level;
+  thr->ts.work_share = &team->work_shares[0];
+  thr->ts.last_work_share = NULL;
+  thr->ts.single_count = 0;
+  thr->ts.static_trip = 0;
+  thr->task = &team->implicit_task[0];
+  nthreads_var = icv->nthreads_var;
+  gomp_init_task (thr->task, task, icv);
+  team->implicit_task[0].icv.nthreads_var = nthreads_var;
+  team->implicit_task[0].taskgroup = taskgroup;
+
+  if (nthreads == 1)
+    return;
+
+  /* Release existing idle threads.  */
+  for (unsigned i = 1; i < nthreads; ++i)
+    {
+      nthr = pool->threads[i];
+      nthr->ts.team = team;
+      nthr->ts.work_share = &team->work_shares[0];
+      nthr->ts.last_work_share = NULL;
+      nthr->ts.team_id = i;
+      nthr->ts.level = team->prev_ts.level + 1;
+      nthr->ts.active_level = thr->ts.active_level;
+      nthr->ts.single_count = 0;
+      nthr->ts.static_trip = 0;
+      nthr->task = &team->implicit_task[i];
+      gomp_init_task (nthr->task, task, icv);
+      team->implicit_task[i].icv.nthreads_var = nthreads_var;
+      team->implicit_task[i].taskgroup = taskgroup;
+      nthr->fn = fn;
+      nthr->data = data;
+      team->ordered_release[i] = &nthr->release;
+    }
+
+  gomp_simple_barrier_wait (&pool->threads_dock);
+}
+
+#include "../../team.c"
diff --git a/libgomp/config/gcn/time.c b/libgomp/config/gcn/time.c
new file mode 100644
index 00000000000..f189e55889c
--- /dev/null
+++ b/libgomp/config/gcn/time.c
@@ -0,0 +1,52 @@
+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.
+   Contributed by Mentor Embedded.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This file implements timer routines for AMD GCN.  */
+
+#include "libgomp.h"
+
+/* According to AMD:
+    dGPU RTC is 27MHz
+    AGPU RTC is 100MHz
+   FIXME: DTRT on an APU.  */
+#define RTC_TICKS (1.0 / 27000000.0) /* 27MHz */
+
+double
+omp_get_wtime (void)
+{
+  uint64_t clock;
+  asm ("s_memrealtime %0\n\t"
+       "s_waitcnt 0" : "=r" (clock));
+  return clock * RTC_TICKS;
+}
+
+double
+omp_get_wtick (void)
+{
+  return RTC_TICKS;
+}
+
+ialias (omp_get_wtime)
+ialias (omp_get_wtick)
diff --git a/libgomp/config/nvptx/task.c b/libgomp/config/nvptx/task.c
index 643e301bd12..f7745a7314d 100644
--- a/libgomp/config/nvptx/task.c
+++ b/libgomp/config/nvptx/task.c
@@ -23,7 +23,7 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
-/* This file handles the maintainence of tasks in response to task
+/* This file handles the maintenance of tasks in response to task
    creation and termination.  */
 
 #ifdef __nvptx_softstack__
diff --git a/libgomp/config/nvptx/team.c b/libgomp/config/nvptx/team.c
index 8ad438df707..d19c963e871 100644
--- a/libgomp/config/nvptx/team.c
+++ b/libgomp/config/nvptx/team.c
@@ -23,7 +23,7 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
-/* This file handles maintainance of threads on NVPTX.  */
+/* This file handles maintenance of threads on NVPTX.  */
 
 #if defined __nvptx_softstack__ && defined __nvptx_unisimt__
 
diff --git a/libgomp/configure b/libgomp/configure
index b4bc4f43628..04a6fd96610 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -653,6 +653,7 @@ link_gomp
 XLDFLAGS
 XCFLAGS
 config_path
+CPU_COUNT
 LIBGOMP_BUILD_VERSIONED_SHLIB_SUN_FALSE
 LIBGOMP_BUILD_VERSIONED_SHLIB_SUN_TRUE
 LIBGOMP_BUILD_VERSIONED_SHLIB_GNU_FALSE
@@ -661,6 +662,8 @@ LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE
 LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE
 OPT_LDFLAGS
 SECTION_LDFLAGS
+PLUGIN_GCN_FALSE
+PLUGIN_GCN_TRUE
 PLUGIN_HSA_FALSE
 PLUGIN_HSA_TRUE
 PLUGIN_NVPTX_FALSE
@@ -669,6 +672,10 @@ offload_additional_lib_paths
 offload_additional_options
 offload_targets
 offload_plugins
+PLUGIN_GCN_LIBS
+PLUGIN_GCN_LDFLAGS
+PLUGIN_GCN_CPPFLAGS
+PLUGIN_GCN
 PLUGIN_HSA_LIBS
 PLUGIN_HSA_LDFLAGS
 PLUGIN_HSA_CPPFLAGS
@@ -6093,7 +6100,7 @@ irix5* | irix6* | nonstopux*)
   ;;
 
 # This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
+linux* | k*bsd*-gnu | kopensolaris*-gnu | uclinuxfdpiceabi)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
@@ -9173,7 +9180,7 @@ _LT_EOF
       archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
       ;;
 
-    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu | uclinuxfdpiceabi)
       tmp_diet=no
       if test "$host_os" = linux-dietlibc; then
 	case $cc_basename in
@@ -10704,7 +10711,12 @@ linux*oldld* | linux*aout* | linux*coff*)
   ;;
 
 # This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
+
+# uclinux* changes (here and below) have been submitted to the libtool
+# project, but have not yet been accepted: they are GCC-local changes
+# for the time being.  (See
+# https://lists.gnu.org/archive/html/libtool-patches/2018-05/msg00000.html)
+linux* | k*bsd*-gnu | kopensolaris*-gnu | uclinuxfdpiceabi)
   version_type=linux
   need_lib_prefix=no
   need_version=no
@@ -11393,7 +11405,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11396 "configure"
+#line 11408 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11499,7 +11511,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11502 "configure"
+#line 11514 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -13038,7 +13050,7 @@ _LT_EOF
       archive_expsym_cmds_FC='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
       ;;
 
-    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu | uclinuxfdpiceabi)
       tmp_diet=no
       if test "$host_os" = linux-dietlibc; then
 	case $cc_basename in
@@ -14349,7 +14361,12 @@ linux*oldld* | linux*aout* | linux*coff*)
   ;;
 
 # This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
+
+# uclinux* changes (here and below) have been submitted to the libtool
+# project, but have not yet been accepted: they are GCC-local changes
+# for the time being.  (See
+# https://lists.gnu.org/archive/html/libtool-patches/2018-05/msg00000.html)
+linux* | k*bsd*-gnu | kopensolaris*-gnu | uclinuxfdpiceabi)
   version_type=linux
   need_lib_prefix=no
   need_version=no
@@ -14905,414 +14922,12 @@ fi
 done
 
 
-
-
-inttype_headers=`echo inttypes.h sys/inttypes.h  | sed -e 's/,/ /g'`
-
-acx_cv_header_stdint=stddef.h
-acx_cv_header_stdint_kind="(already complete)"
-for i in stdint.h $inttype_headers; do
-  unset ac_cv_type_uintptr_t
-  unset ac_cv_type_uintmax_t
-  unset ac_cv_type_int_least32_t
-  unset ac_cv_type_int_fast32_t
-  unset ac_cv_type_uint64_t
-  $as_echo_n "looking for a compliant stdint.h in $i, " >&6
-  ac_fn_c_check_type "$LINENO" "uintmax_t" "ac_cv_type_uintmax_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_uintmax_t" = xyes; then :
-  acx_cv_header_stdint=$i
-else
-  continue
-fi
-
-  ac_fn_c_check_type "$LINENO" "uintptr_t" "ac_cv_type_uintptr_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_uintptr_t" = xyes; then :
-
-else
-  acx_cv_header_stdint_kind="(mostly complete)"
-fi
-
-  ac_fn_c_check_type "$LINENO" "int_least32_t" "ac_cv_type_int_least32_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_int_least32_t" = xyes; then :
-
-else
-  acx_cv_header_stdint_kind="(mostly complete)"
-fi
-
-  ac_fn_c_check_type "$LINENO" "int_fast32_t" "ac_cv_type_int_fast32_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_int_fast32_t" = xyes; then :
-
-else
-  acx_cv_header_stdint_kind="(mostly complete)"
-fi
-
-  ac_fn_c_check_type "$LINENO" "uint64_t" "ac_cv_type_uint64_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_uint64_t" = xyes; then :
-
-else
-  acx_cv_header_stdint_kind="(lacks uint64_t)"
-fi
-
-  break
-done
-if test "$acx_cv_header_stdint" = stddef.h; then
-  acx_cv_header_stdint_kind="(lacks uintmax_t)"
-  for i in stdint.h $inttype_headers; do
-    unset ac_cv_type_uintptr_t
-    unset ac_cv_type_uint32_t
-    unset ac_cv_type_uint64_t
-    $as_echo_n "looking for an incomplete stdint.h in $i, " >&6
-    ac_fn_c_check_type "$LINENO" "uint32_t" "ac_cv_type_uint32_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_uint32_t" = xyes; then :
-  acx_cv_header_stdint=$i
-else
-  continue
-fi
-
-    ac_fn_c_check_type "$LINENO" "uint64_t" "ac_cv_type_uint64_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_uint64_t" = xyes; then :
-
-fi
-
-    ac_fn_c_check_type "$LINENO" "uintptr_t" "ac_cv_type_uintptr_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_uintptr_t" = xyes; then :
-
-fi
-
-    break
-  done
-fi
-if test "$acx_cv_header_stdint" = stddef.h; then
-  acx_cv_header_stdint_kind="(u_intXX_t style)"
-  for i in sys/types.h $inttype_headers; do
-    unset ac_cv_type_u_int32_t
-    unset ac_cv_type_u_int64_t
-    $as_echo_n "looking for u_intXX_t types in $i, " >&6
-    ac_fn_c_check_type "$LINENO" "u_int32_t" "ac_cv_type_u_int32_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_u_int32_t" = xyes; then :
-  acx_cv_header_stdint=$i
-else
-  continue
-fi
-
-    ac_fn_c_check_type "$LINENO" "u_int64_t" "ac_cv_type_u_int64_t" "#include <sys/types.h>
-#include <$i>
-"
-if test "x$ac_cv_type_u_int64_t" = xyes; then :
-
-fi
-
-    break
-  done
-fi
-if test "$acx_cv_header_stdint" = stddef.h; then
-  acx_cv_header_stdint_kind="(using manual detection)"
-fi
-
-test -z "$ac_cv_type_uintptr_t" && ac_cv_type_uintptr_t=no
-test -z "$ac_cv_type_uint64_t" && ac_cv_type_uint64_t=no
-test -z "$ac_cv_type_u_int64_t" && ac_cv_type_u_int64_t=no
-test -z "$ac_cv_type_int_least32_t" && ac_cv_type_int_least32_t=no
-test -z "$ac_cv_type_int_fast32_t" && ac_cv_type_int_fast32_t=no
-
-# ----------------- Summarize what we found so far
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking what to include in gstdint.h" >&5
-$as_echo_n "checking what to include in gstdint.h... " >&6; }
-
-case `$as_basename -- gstdint.h ||
-$as_expr X/gstdint.h : '.*/\([^/][^/]*\)/*$' \| \
-	 Xgstdint.h : 'X\(//\)$' \| \
-	 Xgstdint.h : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/gstdint.h |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'` in
-  stdint.h) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: are you sure you want it there?" >&5
-$as_echo "$as_me: WARNING: are you sure you want it there?" >&2;} ;;
-  inttypes.h) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: are you sure you want it there?" >&5
-$as_echo "$as_me: WARNING: are you sure you want it there?" >&2;} ;;
-  *) ;;
-esac
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_header_stdint $acx_cv_header_stdint_kind" >&5
-$as_echo "$acx_cv_header_stdint $acx_cv_header_stdint_kind" >&6; }
-
-# ----------------- done included file, check C basic types --------
-
-# Lacking an uintptr_t?  Test size of void *
-case "$acx_cv_header_stdint:$ac_cv_type_uintptr_t" in
-  stddef.h:* | *:no) # The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of void *" >&5
-$as_echo_n "checking size of void *... " >&6; }
-if ${ac_cv_sizeof_void_p+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (void *))" "ac_cv_sizeof_void_p"        "$ac_includes_default"; then :
-
-else
-  if test "$ac_cv_type_void_p" = yes; then
-     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error 77 "cannot compute sizeof (void *)
-See \`config.log' for more details" "$LINENO" 5; }
-   else
-     ac_cv_sizeof_void_p=0
-   fi
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_void_p" >&5
-$as_echo "$ac_cv_sizeof_void_p" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_VOID_P $ac_cv_sizeof_void_p
-_ACEOF
-
- ;;
-esac
-
-# Lacking an uint64_t?  Test size of long
-case "$acx_cv_header_stdint:$ac_cv_type_uint64_t:$ac_cv_type_u_int64_t" in
-  stddef.h:*:* | *:no:no) # The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long" >&5
-$as_echo_n "checking size of long... " >&6; }
-if ${ac_cv_sizeof_long+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long))" "ac_cv_sizeof_long"        "$ac_includes_default"; then :
-
-else
-  if test "$ac_cv_type_long" = yes; then
-     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error 77 "cannot compute sizeof (long)
-See \`config.log' for more details" "$LINENO" 5; }
-   else
-     ac_cv_sizeof_long=0
-   fi
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long" >&5
-$as_echo "$ac_cv_sizeof_long" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_LONG $ac_cv_sizeof_long
-_ACEOF
-
- ;;
-esac
-
-if test $acx_cv_header_stdint = stddef.h; then
-  # Lacking a good header?  Test size of everything and deduce all types.
-  # The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of int" >&5
-$as_echo_n "checking size of int... " >&6; }
-if ${ac_cv_sizeof_int+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (int))" "ac_cv_sizeof_int"        "$ac_includes_default"; then :
-
-else
-  if test "$ac_cv_type_int" = yes; then
-     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error 77 "cannot compute sizeof (int)
-See \`config.log' for more details" "$LINENO" 5; }
-   else
-     ac_cv_sizeof_int=0
-   fi
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_int" >&5
-$as_echo "$ac_cv_sizeof_int" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_INT $ac_cv_sizeof_int
-_ACEOF
-
-
-  # The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of short" >&5
-$as_echo_n "checking size of short... " >&6; }
-if ${ac_cv_sizeof_short+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (short))" "ac_cv_sizeof_short"        "$ac_includes_default"; then :
-
-else
-  if test "$ac_cv_type_short" = yes; then
-     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error 77 "cannot compute sizeof (short)
-See \`config.log' for more details" "$LINENO" 5; }
-   else
-     ac_cv_sizeof_short=0
-   fi
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_short" >&5
-$as_echo "$ac_cv_sizeof_short" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_SHORT $ac_cv_sizeof_short
-_ACEOF
-
-
-  # The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of char" >&5
-$as_echo_n "checking size of char... " >&6; }
-if ${ac_cv_sizeof_char+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (char))" "ac_cv_sizeof_char"        "$ac_includes_default"; then :
-
-else
-  if test "$ac_cv_type_char" = yes; then
-     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error 77 "cannot compute sizeof (char)
-See \`config.log' for more details" "$LINENO" 5; }
-   else
-     ac_cv_sizeof_char=0
-   fi
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_char" >&5
-$as_echo "$ac_cv_sizeof_char" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_CHAR $ac_cv_sizeof_char
-_ACEOF
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for type equivalent to int8_t" >&5
-$as_echo_n "checking for type equivalent to int8_t... " >&6; }
-  case "$ac_cv_sizeof_char" in
-    1) acx_cv_type_int8_t=char ;;
-    *) as_fn_error $? "no 8-bit type, please report a bug" "$LINENO" 5
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_type_int8_t" >&5
-$as_echo "$acx_cv_type_int8_t" >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for type equivalent to int16_t" >&5
-$as_echo_n "checking for type equivalent to int16_t... " >&6; }
-  case "$ac_cv_sizeof_int:$ac_cv_sizeof_short" in
-    2:*) acx_cv_type_int16_t=int ;;
-    *:2) acx_cv_type_int16_t=short ;;
-    *) as_fn_error $? "no 16-bit type, please report a bug" "$LINENO" 5
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_type_int16_t" >&5
-$as_echo "$acx_cv_type_int16_t" >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for type equivalent to int32_t" >&5
-$as_echo_n "checking for type equivalent to int32_t... " >&6; }
-  case "$ac_cv_sizeof_int:$ac_cv_sizeof_long" in
-    4:*) acx_cv_type_int32_t=int ;;
-    *:4) acx_cv_type_int32_t=long ;;
-    *) as_fn_error $? "no 32-bit type, please report a bug" "$LINENO" 5
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_type_int32_t" >&5
-$as_echo "$acx_cv_type_int32_t" >&6; }
-fi
-
-# These tests are here to make the output prettier
-
-if test "$ac_cv_type_uint64_t" != yes && test "$ac_cv_type_u_int64_t" != yes; then
-  case "$ac_cv_sizeof_long" in
-    8) acx_cv_type_int64_t=long ;;
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for type equivalent to int64_t" >&5
-$as_echo_n "checking for type equivalent to int64_t... " >&6; }
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${acx_cv_type_int64_t-'using preprocessor symbols'}" >&5
-$as_echo "${acx_cv_type_int64_t-'using preprocessor symbols'}" >&6; }
-fi
-
-# Now we can use the above types
-
-if test "$ac_cv_type_uintptr_t" != yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for type equivalent to intptr_t" >&5
-$as_echo_n "checking for type equivalent to intptr_t... " >&6; }
-  case $ac_cv_sizeof_void_p in
-    2) acx_cv_type_intptr_t=int16_t ;;
-    4) acx_cv_type_intptr_t=int32_t ;;
-    8) acx_cv_type_intptr_t=int64_t ;;
-    *) as_fn_error $? "no equivalent for intptr_t, please report a bug" "$LINENO" 5
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_type_intptr_t" >&5
-$as_echo "$acx_cv_type_intptr_t" >&6; }
-fi
-
-# ----------------- done all checks, emit header -------------
-ac_config_commands="$ac_config_commands gstdint.h"
-
-
-
-
 XPCFLAGS=""
 case "$host" in
   *-*-rtems*)
     # RTEMS supports Pthreads, but the library is not available at GCC build time.
     ;;
-  nvptx*-*-*)
+  nvptx*-*-* | amdgcn*-*-*)
     # NVPTX does not support Pthreads, has its own code replacement.
     libgomp_use_pthreads=no
     # NVPTX is an accelerator-only target
@@ -15376,7 +14991,7 @@ fi
 
 # Plugins for offload execution, configure.ac fragment.  -*- mode: autoconf -*-
 #
-# Copyright (C) 2014-2018 Free Software Foundation, Inc.
+# Copyright (C) 2014-2019 Free Software Foundation, Inc.
 #
 # Contributed by Mentor Embedded.
 #
@@ -15620,6 +15235,15 @@ PLUGIN_HSA_LIBS=
 
 
 
+PLUGIN_GCN=0
+PLUGIN_GCN_CPPFLAGS=
+PLUGIN_GCN_LDFLAGS=
+PLUGIN_GCN_LIBS=
+
+
+
+
+
 # Parse '--enable-offload-targets', figure out the corresponding libgomp
 # plugins, and configure to find the corresponding offload compilers.
 # 'offload_plugins' and 'offload_targets' will be populated in the same order.
@@ -15731,6 +15355,29 @@ rm -f core conftest.err conftest.$ac_objext \
             ;;
         esac
         ;;
+
+      amdgcn*)
+	case "${target}" in
+	  x86_64-*-*)
+	    case " ${CC} ${CFLAGS} " in
+	      *" -m32 "*)
+		PLUGIN_GCN=0
+		;;
+	      *)
+		tgt_plugin=gcn
+		PLUGIN_GCN=$tgt
+		PLUGIN_GCN_CPPFLAGS=$HSA_RUNTIME_CPPFLAGS
+		PLUGIN_GCN_LDFLAGS="$HSA_RUNTIME_LDFLAGS"
+		PLUGIN_GCN_LIBS="-ldl"
+		PLUGIN_GCN=1
+		;;
+	      esac
+	    ;;
+	  *-*-*)
+	    PLUGIN_GCN=0
+	     ;;
+	esac
+	;;
       *)
 	as_fn_error $? "unknown offload target specified" "$LINENO" 5
 	;;
@@ -15795,6 +15442,19 @@ cat >>confdefs.h <<_ACEOF
 #define PLUGIN_HSA $PLUGIN_HSA
 _ACEOF
 
+ if test $PLUGIN_GCN = 1; then
+  PLUGIN_GCN_TRUE=
+  PLUGIN_GCN_FALSE='#'
+else
+  PLUGIN_GCN_TRUE='#'
+  PLUGIN_GCN_FALSE=
+fi
+
+
+cat >>confdefs.h <<_ACEOF
+#define PLUGIN_GCN $PLUGIN_GCN
+_ACEOF
+
 
 if test "$HSA_RUNTIME_LIB" != ""; then
   HSA_RUNTIME_LIB="$HSA_RUNTIME_LIB/"
@@ -15824,8 +15484,7 @@ for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -15875,7 +15534,7 @@ fi
 
 
 case "$target" in
-  *-linux*)
+  *-linux* | *-uclinux*)
     case "$enable_linux_futex" in
       default)
 	# If headers don't have gettid/futex syscalls definition, then
@@ -15888,6 +15547,7 @@ case "$target" in
 	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/syscall.h>
+	   #include <unistd.h>
 	   int lk;
 int
 main ()
@@ -15940,6 +15600,7 @@ rm -f core conftest.err conftest.$ac_objext \
 	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/syscall.h>
+	   #include <unistd.h>
 	   int lk;
 int
 main ()
@@ -16143,7 +15804,7 @@ _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
   chktls_save_LDFLAGS="$LDFLAGS"
 	  	  	  case $host in
-	    *-*-linux*)
+	    *-*-linux* | -*-uclinuxfdpic*)
 	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
 	      ;;
 	  esac
@@ -16587,7 +16248,7 @@ with_gnu_ld=$lt_cv_prog_gnu_ld
   fi
 
   ldver=`$LD --version 2>/dev/null |
-         sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \([0-9.][0-9.]*\).*/\1/; q'`
+         sed -e 's/[. ][0-9]\{8\}$//;s/.* \([^ ]\{1,\}\)$/\1/; q'`
 
   libgomp_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -16905,6 +16566,101 @@ $as_echo "#define LIBGOMP_GNU_SYMBOL_VERSIONING 1" >>confdefs.h
 
 fi
 
+# Determine cpu count to limit testsuite parallelism.
+                  { $as_echo "$as_me:${as_lineno-$LINENO}: checking the number of available CPUs" >&5
+$as_echo_n "checking the number of available CPUs... " >&6; }
+      CPU_COUNT="0"
+
+      # Try generic methods
+
+      # 'getconf' is POSIX utility, but '_NPROCESSORS_ONLN' and
+      # 'NPROCESSORS_ONLN' are platform-specific
+      command -v getconf >/dev/null 2>&1 && \
+        CPU_COUNT=`getconf _NPROCESSORS_ONLN 2>/dev/null || getconf NPROCESSORS_ONLN 2>/dev/null` || CPU_COUNT="0"
+      if test "$CPU_COUNT" -gt "0" 2>/dev/null || ! command -v nproc >/dev/null 2>&1; then :
+  : # empty
+else
+          # 'nproc' is part of GNU Coreutils and is widely available
+        CPU_COUNT=`OMP_NUM_THREADS='' nproc 2>/dev/null` || CPU_COUNT=`nproc 2>/dev/null` || CPU_COUNT="0"
+
+fi
+      if test "$CPU_COUNT" -gt "0" 2>/dev/null; then :
+  : # empty
+else
+          # Try platform-specific preferred methods
+        case $host_os in #(
+            *linux*) :
+    CPU_COUNT=`lscpu -p 2>/dev/null | $EGREP -e '^[0-9]+,' -c` || CPU_COUNT="0" ;; #(
+            *darwin*) :
+    CPU_COUNT=`sysctl -n hw.logicalcpu 2>/dev/null` || CPU_COUNT="0" ;; #(
+            freebsd*) :
+    command -v sysctl >/dev/null 2>&1 && CPU_COUNT=`sysctl -n kern.smp.cpus 2>/dev/null` || CPU_COUNT="0" ;; #(
+            netbsd*) :
+    command -v sysctl >/dev/null 2>&1 && CPU_COUNT=`sysctl -n hw.ncpuonline 2>/dev/null` || CPU_COUNT="0" ;; #(
+            solaris*) :
+    command -v psrinfo >/dev/null 2>&1 && CPU_COUNT=`psrinfo 2>/dev/null | $EGREP -e '^[0-9].*on-line' -c 2>/dev/null` || CPU_COUNT="0" ;; #(
+            mingw*) :
+    CPU_COUNT=`ls -qpU1 /proc/registry/HKEY_LOCAL_MACHINE/HARDWARE/DESCRIPTION/System/CentralProcessor/ 2>/dev/null | $EGREP -e '^[0-9]+/' -c` || CPU_COUNT="0" ;; #(
+            msys*) :
+    CPU_COUNT=`ls -qpU1 /proc/registry/HKEY_LOCAL_MACHINE/HARDWARE/DESCRIPTION/System/CentralProcessor/ 2>/dev/null | $EGREP -e '^[0-9]+/' -c` || CPU_COUNT="0" ;; #(
+            cygwin*) :
+    CPU_COUNT=`ls -qpU1 /proc/registry/HKEY_LOCAL_MACHINE/HARDWARE/DESCRIPTION/System/CentralProcessor/ 2>/dev/null | $EGREP -e '^[0-9]+/' -c` || CPU_COUNT="0"         ;; #(
+  *) :
+     ;;
+esac
+fi
+      if test "$CPU_COUNT" -gt "0" 2>/dev/null || ! command -v sysctl >/dev/null 2>&1; then :
+  : # empty
+else
+          # Try less preferred generic method
+        # 'hw.ncpu' exist on many platforms, but not on GNU/Linux
+        CPU_COUNT=`sysctl -n hw.ncpu 2>/dev/null` || CPU_COUNT="0"
+
+fi
+      if test "$CPU_COUNT" -gt "0" 2>/dev/null; then :
+  : # empty
+else
+        # Try platform-specific fallback methods
+      # They can be less accurate and slower then preferred methods
+        case $host_os in #(
+            *linux*) :
+    CPU_COUNT=`$EGREP -e '^processor' -c /proc/cpuinfo 2>/dev/null` || CPU_COUNT="0" ;; #(
+            *darwin*) :
+    CPU_COUNT=`system_profiler SPHardwareDataType 2>/dev/null | $EGREP -i -e 'number of cores:'|cut -d : -f 2 -s|tr -d ' '` || CPU_COUNT="0" ;; #(
+            freebsd*) :
+    CPU_COUNT=`dmesg 2>/dev/null| $EGREP -e '^cpu[0-9]+: '|sort -u|$EGREP -e '^' -c` || CPU_COUNT="0" ;; #(
+            netbsd*) :
+    CPU_COUNT=`command -v cpuctl >/dev/null 2>&1 && cpuctl list 2>/dev/null| $EGREP -e '^[0-9]+ .* online ' -c` || \
+                           CPU_COUNT=`dmesg 2>/dev/null| $EGREP -e '^cpu[0-9]+ at'|sort -u|$EGREP -e '^' -c` || CPU_COUNT="0" ;; #(
+            solaris*) :
+    command -v kstat >/dev/null 2>&1 && CPU_COUNT=`kstat -m cpu_info -s state -p 2>/dev/null | $EGREP -c -e 'on-line'` || \
+                           CPU_COUNT=`kstat -m cpu_info 2>/dev/null | $EGREP -c -e 'module: cpu_info'` || CPU_COUNT="0" ;; #(
+            mingw*) :
+    if CPU_COUNT=`reg query 'HKLM\\Hardware\\Description\\System\\CentralProcessor' 2>/dev/null | $EGREP -e '\\\\[0-9]+$' -c`; then :
+                          : # empty
+else
+  test "$NUMBER_OF_PROCESSORS" -gt "0" 2>/dev/null && CPU_COUNT="$NUMBER_OF_PROCESSORS"
+fi ;; #(
+            msys*) :
+    test "$NUMBER_OF_PROCESSORS" -gt "0" 2>/dev/null && CPU_COUNT="$NUMBER_OF_PROCESSORS" ;; #(
+            cygwin*) :
+    test "$NUMBER_OF_PROCESSORS" -gt "0" 2>/dev/null && CPU_COUNT="$NUMBER_OF_PROCESSORS"         ;; #(
+  *) :
+     ;;
+esac
+fi
+      if test "x$CPU_COUNT" != "x0" && test "$CPU_COUNT" -gt 0 2>/dev/null; then :
+            { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPU_COUNT" >&5
+$as_echo "$CPU_COUNT" >&6; }
+
+else
+                        CPU_COUNT="1"
+            { $as_echo "$as_me:${as_lineno-$LINENO}: result: unable to detect (assuming 1)" >&5
+$as_echo "unable to detect (assuming 1)" >&6; }
+
+fi
+
+
 # Get target configury.
 . ${srcdir}/configure.tgt
 CFLAGS="$save_CFLAGS $XCFLAGS"
@@ -17417,6 +17173,10 @@ if test -z "${PLUGIN_HSA_TRUE}" && test -z "${PLUGIN_HSA_FALSE}"; then
   as_fn_error $? "conditional \"PLUGIN_HSA\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${PLUGIN_GCN_TRUE}" && test -z "${PLUGIN_GCN_FALSE}"; then
+  as_fn_error $? "conditional \"PLUGIN_GCN\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE}" && test -z "${LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE}"; then
   as_fn_error $? "conditional \"LIBGOMP_BUILD_VERSIONED_SHLIB\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -18393,24 +18153,6 @@ fi
 
 
 
-GCC="$GCC"
-CC="$CC"
-acx_cv_header_stdint="$acx_cv_header_stdint"
-acx_cv_type_int8_t="$acx_cv_type_int8_t"
-acx_cv_type_int16_t="$acx_cv_type_int16_t"
-acx_cv_type_int32_t="$acx_cv_type_int32_t"
-acx_cv_type_int64_t="$acx_cv_type_int64_t"
-acx_cv_type_intptr_t="$acx_cv_type_intptr_t"
-ac_cv_type_uintmax_t="$ac_cv_type_uintmax_t"
-ac_cv_type_uintptr_t="$ac_cv_type_uintptr_t"
-ac_cv_type_uint64_t="$ac_cv_type_uint64_t"
-ac_cv_type_u_int64_t="$ac_cv_type_u_int64_t"
-ac_cv_type_u_int32_t="$ac_cv_type_u_int32_t"
-ac_cv_type_int_least32_t="$ac_cv_type_int_least32_t"
-ac_cv_type_int_fast32_t="$ac_cv_type_int_fast32_t"
-ac_cv_sizeof_void_p="$ac_cv_sizeof_void_p"
-
-
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
@@ -18423,7 +18165,6 @@ do
     "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
-    "gstdint.h") CONFIG_COMMANDS="$CONFIG_COMMANDS gstdint.h" ;;
     "omp.h") CONFIG_FILES="$CONFIG_FILES omp.h" ;;
     "omp_lib.h") CONFIG_FILES="$CONFIG_FILES omp_lib.h" ;;
     "omp_lib.f90") CONFIG_FILES="$CONFIG_FILES omp_lib.f90" ;;
@@ -19937,378 +19678,6 @@ compiler_lib_search_path=$lt_compiler_lib_search_path_FC
 # ### END LIBTOOL TAG CONFIG: FC
 _LT_EOF
 
- ;;
-    "gstdint.h":C)
-if test "$GCC" = yes; then
-  echo "/* generated for " `$CC --version | sed 1q` "*/" > tmp-stdint.h
-else
-  echo "/* generated for $CC */" > tmp-stdint.h
-fi
-
-sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-  #ifndef GCC_GENERATED_STDINT_H
-  #define GCC_GENERATED_STDINT_H 1
-
-  #include <sys/types.h>
-EOF
-
-if test "$acx_cv_header_stdint" != stdint.h; then
-  echo "#include <stddef.h>" >> tmp-stdint.h
-fi
-if test "$acx_cv_header_stdint" != stddef.h; then
-  echo "#include <$acx_cv_header_stdint>" >> tmp-stdint.h
-fi
-
-sed 's/^ *//' >> tmp-stdint.h <<EOF
-  /* glibc uses these symbols as guards to prevent redefinitions.  */
-  #ifdef __int8_t_defined
-  #define _INT8_T
-  #define _INT16_T
-  #define _INT32_T
-  #endif
-  #ifdef __uint32_t_defined
-  #define _UINT32_T
-  #endif
-
-EOF
-
-# ----------------- done header, emit basic int types -------------
-if test "$acx_cv_header_stdint" = stddef.h; then
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    #ifndef _UINT8_T
-    #define _UINT8_T
-    #ifndef __uint8_t_defined
-    #define __uint8_t_defined
-    #ifndef uint8_t
-    typedef unsigned $acx_cv_type_int8_t uint8_t;
-    #endif
-    #endif
-    #endif
-
-    #ifndef _UINT16_T
-    #define _UINT16_T
-    #ifndef __uint16_t_defined
-    #define __uint16_t_defined
-    #ifndef uint16_t
-    typedef unsigned $acx_cv_type_int16_t uint16_t;
-    #endif
-    #endif
-    #endif
-
-    #ifndef _UINT32_T
-    #define _UINT32_T
-    #ifndef __uint32_t_defined
-    #define __uint32_t_defined
-    #ifndef uint32_t
-    typedef unsigned $acx_cv_type_int32_t uint32_t;
-    #endif
-    #endif
-    #endif
-
-    #ifndef _INT8_T
-    #define _INT8_T
-    #ifndef __int8_t_defined
-    #define __int8_t_defined
-    #ifndef int8_t
-    typedef $acx_cv_type_int8_t int8_t;
-    #endif
-    #endif
-    #endif
-
-    #ifndef _INT16_T
-    #define _INT16_T
-    #ifndef __int16_t_defined
-    #define __int16_t_defined
-    #ifndef int16_t
-    typedef $acx_cv_type_int16_t int16_t;
-    #endif
-    #endif
-    #endif
-
-    #ifndef _INT32_T
-    #define _INT32_T
-    #ifndef __int32_t_defined
-    #define __int32_t_defined
-    #ifndef int32_t
-    typedef $acx_cv_type_int32_t int32_t;
-    #endif
-    #endif
-    #endif
-EOF
-elif test "$ac_cv_type_u_int32_t" = yes; then
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* int8_t int16_t int32_t defined by inet code, we do the u_intXX types */
-    #ifndef _INT8_T
-    #define _INT8_T
-    #endif
-    #ifndef _INT16_T
-    #define _INT16_T
-    #endif
-    #ifndef _INT32_T
-    #define _INT32_T
-    #endif
-
-    #ifndef _UINT8_T
-    #define _UINT8_T
-    #ifndef __uint8_t_defined
-    #define __uint8_t_defined
-    #ifndef uint8_t
-    typedef u_int8_t uint8_t;
-    #endif
-    #endif
-    #endif
-
-    #ifndef _UINT16_T
-    #define _UINT16_T
-    #ifndef __uint16_t_defined
-    #define __uint16_t_defined
-    #ifndef uint16_t
-    typedef u_int16_t uint16_t;
-    #endif
-    #endif
-    #endif
-
-    #ifndef _UINT32_T
-    #define _UINT32_T
-    #ifndef __uint32_t_defined
-    #define __uint32_t_defined
-    #ifndef uint32_t
-    typedef u_int32_t uint32_t;
-    #endif
-    #endif
-    #endif
-EOF
-else
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* Some systems have guard macros to prevent redefinitions, define them.  */
-    #ifndef _INT8_T
-    #define _INT8_T
-    #endif
-    #ifndef _INT16_T
-    #define _INT16_T
-    #endif
-    #ifndef _INT32_T
-    #define _INT32_T
-    #endif
-    #ifndef _UINT8_T
-    #define _UINT8_T
-    #endif
-    #ifndef _UINT16_T
-    #define _UINT16_T
-    #endif
-    #ifndef _UINT32_T
-    #define _UINT32_T
-    #endif
-EOF
-fi
-
-# ------------- done basic int types, emit int64_t types ------------
-if test "$ac_cv_type_uint64_t" = yes; then
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* system headers have good uint64_t and int64_t */
-    #ifndef _INT64_T
-    #define _INT64_T
-    #endif
-    #ifndef _UINT64_T
-    #define _UINT64_T
-    #endif
-EOF
-elif test "$ac_cv_type_u_int64_t" = yes; then
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* system headers have an u_int64_t (and int64_t) */
-    #ifndef _INT64_T
-    #define _INT64_T
-    #endif
-    #ifndef _UINT64_T
-    #define _UINT64_T
-    #ifndef __uint64_t_defined
-    #define __uint64_t_defined
-    #ifndef uint64_t
-    typedef u_int64_t uint64_t;
-    #endif
-    #endif
-    #endif
-EOF
-elif test -n "$acx_cv_type_int64_t"; then
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* architecture has a 64-bit type, $acx_cv_type_int64_t */
-    #ifndef _INT64_T
-    #define _INT64_T
-    #ifndef int64_t
-    typedef $acx_cv_type_int64_t int64_t;
-    #endif
-    #endif
-    #ifndef _UINT64_T
-    #define _UINT64_T
-    #ifndef __uint64_t_defined
-    #define __uint64_t_defined
-    #ifndef uint64_t
-    typedef unsigned $acx_cv_type_int64_t uint64_t;
-    #endif
-    #endif
-    #endif
-EOF
-else
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* some common heuristics for int64_t, using compiler-specific tests */
-    #if defined __STDC_VERSION__ && (__STDC_VERSION__-0) >= 199901L
-    #ifndef _INT64_T
-    #define _INT64_T
-    #ifndef __int64_t_defined
-    #ifndef int64_t
-    typedef long long int64_t;
-    #endif
-    #endif
-    #endif
-    #ifndef _UINT64_T
-    #define _UINT64_T
-    #ifndef uint64_t
-    typedef unsigned long long uint64_t;
-    #endif
-    #endif
-
-    #elif defined __GNUC__ && defined (__STDC__) && __STDC__-0
-    /* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and
-       does not implement __extension__.  But that compiler doesn't define
-       __GNUC_MINOR__.  */
-    # if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)
-    # define __extension__
-    # endif
-
-    # ifndef _INT64_T
-    # define _INT64_T
-    # ifndef int64_t
-    __extension__ typedef long long int64_t;
-    # endif
-    # endif
-    # ifndef _UINT64_T
-    # define _UINT64_T
-    # ifndef uint64_t
-    __extension__ typedef unsigned long long uint64_t;
-    # endif
-    # endif
-
-    #elif !defined __STRICT_ANSI__
-    # if defined _MSC_VER || defined __WATCOMC__ || defined __BORLANDC__
-
-    #  ifndef _INT64_T
-    #  define _INT64_T
-    #  ifndef int64_t
-    typedef __int64 int64_t;
-    #  endif
-    #  endif
-    #  ifndef _UINT64_T
-    #  define _UINT64_T
-    #  ifndef uint64_t
-    typedef unsigned __int64 uint64_t;
-    #  endif
-    #  endif
-    # endif /* compiler */
-
-    #endif /* ANSI version */
-EOF
-fi
-
-# ------------- done int64_t types, emit intptr types ------------
-if test "$ac_cv_type_uintptr_t" != yes; then
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* Define intptr_t based on sizeof(void*) = $ac_cv_sizeof_void_p */
-    #ifndef __uintptr_t_defined
-    #ifndef uintptr_t
-    typedef u$acx_cv_type_intptr_t uintptr_t;
-    #endif
-    #endif
-    #ifndef __intptr_t_defined
-    #ifndef intptr_t
-    typedef $acx_cv_type_intptr_t  intptr_t;
-    #endif
-    #endif
-EOF
-fi
-
-# ------------- done intptr types, emit int_least types ------------
-if test "$ac_cv_type_int_least32_t" != yes; then
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* Define int_least types */
-    typedef int8_t     int_least8_t;
-    typedef int16_t    int_least16_t;
-    typedef int32_t    int_least32_t;
-    #ifdef _INT64_T
-    typedef int64_t    int_least64_t;
-    #endif
-
-    typedef uint8_t    uint_least8_t;
-    typedef uint16_t   uint_least16_t;
-    typedef uint32_t   uint_least32_t;
-    #ifdef _UINT64_T
-    typedef uint64_t   uint_least64_t;
-    #endif
-EOF
-fi
-
-# ------------- done intptr types, emit int_fast types ------------
-if test "$ac_cv_type_int_fast32_t" != yes; then
-      sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* Define int_fast types.  short is often slow */
-    typedef int8_t       int_fast8_t;
-    typedef int          int_fast16_t;
-    typedef int32_t      int_fast32_t;
-    #ifdef _INT64_T
-    typedef int64_t      int_fast64_t;
-    #endif
-
-    typedef uint8_t      uint_fast8_t;
-    typedef unsigned int uint_fast16_t;
-    typedef uint32_t     uint_fast32_t;
-    #ifdef _UINT64_T
-    typedef uint64_t     uint_fast64_t;
-    #endif
-EOF
-fi
-
-if test "$ac_cv_type_uintmax_t" != yes; then
-  sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-    /* Define intmax based on what we found */
-    #ifndef intmax_t
-    #ifdef _INT64_T
-    typedef int64_t       intmax_t;
-    #else
-    typedef long          intmax_t;
-    #endif
-    #endif
-    #ifndef uintmax_t
-    #ifdef _UINT64_T
-    typedef uint64_t      uintmax_t;
-    #else
-    typedef unsigned long uintmax_t;
-    #endif
-    #endif
-EOF
-fi
-
-sed 's/^ *//' >> tmp-stdint.h <<EOF
-
-  #endif /* GCC_GENERATED_STDINT_H */
-EOF
-
-if test -r gstdint.h && cmp -s tmp-stdint.h gstdint.h; then
-  rm -f tmp-stdint.h
-else
-  mv -f tmp-stdint.h gstdint.h
-fi
-
  ;;
 
   esac
diff --git a/libgomp/configure.ac b/libgomp/configure.ac
index f75c6226566..725f3bfd285 100644
--- a/libgomp/configure.ac
+++ b/libgomp/configure.ac
@@ -171,14 +171,12 @@ AC_HEADER_TIME
 ACX_HEADER_STRING
 AC_CHECK_HEADERS(pthread.h unistd.h semaphore.h sys/loadavg.h sys/sysctl.h sys/time.h)
 
-GCC_HEADER_STDINT(gstdint.h)
-
 XPCFLAGS=""
 case "$host" in
   *-*-rtems*)
     # RTEMS supports Pthreads, but the library is not available at GCC build time.
     ;;
-  nvptx*-*-*)
+  nvptx*-*-* | amdgcn*-*-*)
     # NVPTX does not support Pthreads, has its own code replacement.
     libgomp_use_pthreads=no
     # NVPTX is an accelerator-only target
@@ -318,6 +316,10 @@ if test $enable_symvers = gnu; then
 	    [Define to 1 if GNU symbol versioning is used for libgomp.])
 fi
 
+# Determine cpu count to limit testsuite parallelism.
+AX_COUNT_CPUS
+AC_SUBST(CPU_COUNT)
+
 # Get target configury.
 . ${srcdir}/configure.tgt
 CFLAGS="$save_CFLAGS $XCFLAGS"
diff --git a/libgomp/configure.tgt b/libgomp/configure.tgt
index b88bf72fe3d..4790a31e394 100644
--- a/libgomp/configure.tgt
+++ b/libgomp/configure.tgt
@@ -17,6 +17,9 @@ if test $gcc_cv_have_tls = yes ; then
     *-*-k*bsd*-gnu*)
 	;;
 
+    *-*-musl*)
+	;;
+
     *-*-linux* | *-*-gnu*)
 	XCFLAGS="${XCFLAGS} -ftls-model=initial-exec -DUSING_INITIAL_EXEC_TLS"
 	;;
@@ -154,7 +157,7 @@ case "${target}" in
 	;;
 
   nvptx*-*-*)
-	config_path="nvptx"
+	config_path="nvptx accel"
 	;;
 
   *-*-rtems*)
@@ -164,6 +167,10 @@ case "${target}" in
 	fi
 	;;
 
+  amdgcn*-*-*)
+	config_path="gcn accel"
+	;;
+
   *)
 	;;
 
diff --git a/libgomp/env.c b/libgomp/env.c
index 7937fbb056a..9a7af1265a4 100644
--- a/libgomp/env.c
+++ b/libgomp/env.c
@@ -1337,7 +1337,7 @@ initialize_env (void)
     ignore = true;
   /* Make sure OMP_PLACES and GOMP_CPU_AFFINITY env vars are always
      parsed if present in the environment.  If OMP_PROC_BIND was set
-     explictly to false, don't populate places list though.  If places
+     explicitly to false, don't populate places list though.  If places
      list was successfully set from OMP_PLACES, only parse but don't process
      GOMP_CPU_AFFINITY.  If OMP_PROC_BIND was not set in the environment,
      default to OMP_PROC_BIND=true if OMP_PLACES or GOMP_CPU_AFFINITY
@@ -1425,5 +1425,7 @@ initialize_env (void)
   parse_gomp_openacc_dim ();
 
   goacc_runtime_initialize ();
+
+  goacc_profiling_initialize ();
 }
 #endif /* LIBGOMP_OFFLOADED_ONLY */
diff --git a/libgomp/libgomp-plugin.h b/libgomp/libgomp-plugin.h
index 8960d809265..037558c43f5 100644
--- a/libgomp/libgomp-plugin.h
+++ b/libgomp/libgomp-plugin.h
@@ -50,9 +50,24 @@ enum offload_target_type
   /* OFFLOAD_TARGET_TYPE_HOST_NONSHM = 3 removed.  */
   OFFLOAD_TARGET_TYPE_NVIDIA_PTX = 5,
   OFFLOAD_TARGET_TYPE_INTEL_MIC = 6,
-  OFFLOAD_TARGET_TYPE_HSA = 7
+  OFFLOAD_TARGET_TYPE_HSA = 7,
+  OFFLOAD_TARGET_TYPE_GCN = 8
 };
 
+/* Opaque type to represent plugin-dependent implementation of an
+   OpenACC asynchronous queue.  */
+struct goacc_asyncqueue;
+
+/* Used to keep a list of active asynchronous queues.  */
+struct goacc_asyncqueue_list
+{
+  struct goacc_asyncqueue *aq;
+  struct goacc_asyncqueue_list *next;
+};
+
+typedef struct goacc_asyncqueue *goacc_aq;
+typedef struct goacc_asyncqueue_list *goacc_aq_list;
+
 /* Auxiliary struct, used for transferring pairs of addresses from plugin
    to libgomp.  */
 struct addr_pair
@@ -93,22 +108,31 @@ extern bool GOMP_OFFLOAD_dev2dev (int, void *, const void *, size_t);
 extern bool GOMP_OFFLOAD_can_run (void *);
 extern void GOMP_OFFLOAD_run (int, void *, void *, void **);
 extern void GOMP_OFFLOAD_async_run (int, void *, void *, void **, void *);
+
 extern void GOMP_OFFLOAD_openacc_exec (void (*) (void *), size_t, void **,
-				       void **, int, unsigned *, void *);
-extern void GOMP_OFFLOAD_openacc_register_async_cleanup (void *, int);
-extern int GOMP_OFFLOAD_openacc_async_test (int);
-extern int GOMP_OFFLOAD_openacc_async_test_all (void);
-extern void GOMP_OFFLOAD_openacc_async_wait (int);
-extern void GOMP_OFFLOAD_openacc_async_wait_async (int, int);
-extern void GOMP_OFFLOAD_openacc_async_wait_all (void);
-extern void GOMP_OFFLOAD_openacc_async_wait_all_async (int);
-extern void GOMP_OFFLOAD_openacc_async_set_async (int);
+				       void **, unsigned *, void *);
 extern void *GOMP_OFFLOAD_openacc_create_thread_data (int);
 extern void GOMP_OFFLOAD_openacc_destroy_thread_data (void *);
+extern struct goacc_asyncqueue *GOMP_OFFLOAD_openacc_async_construct (int);
+extern bool GOMP_OFFLOAD_openacc_async_destruct (struct goacc_asyncqueue *);
+extern int GOMP_OFFLOAD_openacc_async_test (struct goacc_asyncqueue *);
+extern bool GOMP_OFFLOAD_openacc_async_synchronize (struct goacc_asyncqueue *);
+extern bool GOMP_OFFLOAD_openacc_async_serialize (struct goacc_asyncqueue *,
+						  struct goacc_asyncqueue *);
+extern void GOMP_OFFLOAD_openacc_async_queue_callback (struct goacc_asyncqueue *,
+						       void (*)(void *), void *);
+extern void GOMP_OFFLOAD_openacc_async_exec (void (*) (void *), size_t, void **,
+					     void **, unsigned *, void *,
+					     struct goacc_asyncqueue *);
+extern bool GOMP_OFFLOAD_openacc_async_dev2host (int, void *, const void *, size_t,
+						 struct goacc_asyncqueue *);
+extern bool GOMP_OFFLOAD_openacc_async_host2dev (int, void *, const void *, size_t,
+						 struct goacc_asyncqueue *);
 extern void *GOMP_OFFLOAD_openacc_cuda_get_current_device (void);
 extern void *GOMP_OFFLOAD_openacc_cuda_get_current_context (void);
-extern void *GOMP_OFFLOAD_openacc_cuda_get_stream (int);
-extern int GOMP_OFFLOAD_openacc_cuda_set_stream (int, void *);
+extern void *GOMP_OFFLOAD_openacc_cuda_get_stream (struct goacc_asyncqueue *);
+extern int GOMP_OFFLOAD_openacc_cuda_set_stream (struct goacc_asyncqueue *,
+						 void *);
 
 #ifdef __cplusplus
 }
diff --git a/libgomp/libgomp.h b/libgomp/libgomp.h
index afea659445d..36dcca28353 100644
--- a/libgomp/libgomp.h
+++ b/libgomp/libgomp.h
@@ -42,7 +42,7 @@
 #endif
 
 #include "config.h"
-#include "gstdint.h"
+#include <stdint.h>
 #include "libgomp-plugin.h"
 #include "gomp-constants.h"
 
@@ -106,6 +106,69 @@ extern void gomp_aligned_free (void *);
    GCC's builtin alloca().  */
 #define gomp_alloca(x)  __builtin_alloca(x)
 
+/* Optimized allocators for team-specific data that will die with the team.  */
+
+#ifdef __AMDGCN__
+/* The arena is initialized in config/gcn/team.c.  */
+#define TEAM_ARENA_SIZE  64*1024  /* Must match the value in plugin-gcn.c.  */
+#define TEAM_ARENA_START 16  /* LDS offset of free pointer.  */
+#define TEAM_ARENA_FREE  24  /* LDS offset of free pointer.  */
+#define TEAM_ARENA_END   32  /* LDS offset of end pointer.  */
+
+static inline void * __attribute__((malloc))
+team_malloc (size_t size)
+{
+  /* 4-byte align the size.  */
+  size = (size + 3) & ~3;
+
+  /* Allocate directly from the arena.
+     The compiler does not support DS atomics, yet. */
+  void *result;
+  asm ("ds_add_rtn_u64 %0, %1, %2\n\ts_waitcnt 0"
+       : "=v"(result) : "v"(TEAM_ARENA_FREE), "v"(size), "e"(1L) : "memory");
+
+  /* Handle OOM.  */
+  if (result + size > *(void * __lds *)TEAM_ARENA_END)
+    {
+      /* While this is experimental, let's make sure we know when OOM
+	 happens.  */
+      const char msg[] = "GCN team arena exhausted\n";
+      write (2, msg, sizeof(msg)-1);
+
+      /* Fall back to using the heap (slowly).  */
+      result = gomp_malloc (size);
+    }
+  return result;
+}
+
+static inline void * __attribute__((malloc))
+team_malloc_cleared (size_t size)
+{
+  char *result = team_malloc (size);
+
+  /* Clear the allocated memory.  */
+  __builtin_memset (result, 0, size);
+
+  return result;
+}
+
+static inline void
+team_free (void *ptr)
+{
+  /* The whole arena is freed when the kernel exits.
+     However, if we fell back to using heap then we should free it.
+     It would be better if this function could be a no-op, but at least
+     LDS loads are cheap.  */
+  if (ptr < *(void * __lds *)TEAM_ARENA_START
+      || ptr >= *(void * __lds *)TEAM_ARENA_END)
+    free (ptr);
+}
+#else
+#define team_malloc(...) gomp_malloc (__VA_ARGS__)
+#define team_malloc_cleared(...) gomp_malloc_cleared (__VA_ARGS__)
+#define team_free(...) free (__VA_ARGS__)
+#endif
+
 /* error.c */
 
 extern void gomp_vdebug (int, const char *, va_list);
@@ -692,6 +755,24 @@ static inline struct gomp_thread *gomp_thread (void)
   asm ("mov.u32 %0, %%tid.y;" : "=r" (tid));
   return nvptx_thrs + tid;
 }
+#elif defined __AMDGCN__
+static inline struct gomp_thread *gcn_thrs (void)
+{
+  /* The value is at the bottom of LDS.  */
+  struct gomp_thread * __lds *thrs = (struct gomp_thread * __lds *)4;
+  return *thrs;
+}
+static inline void set_gcn_thrs (struct gomp_thread *val)
+{
+  /* The value is at the bottom of LDS.  */
+  struct gomp_thread * __lds *thrs = (struct gomp_thread * __lds *)4;
+  *thrs = val;
+}
+static inline struct gomp_thread *gomp_thread (void)
+{
+  int tid = __builtin_gcn_dim_pos(1);
+  return gcn_thrs () + tid;
+}
 #elif defined HAVE_TLS || defined USE_EMUTLS
 extern __thread struct gomp_thread gomp_tls_data;
 static inline struct gomp_thread *gomp_thread (void)
@@ -903,6 +984,11 @@ struct target_mem_desc {
    artificial pointer to "omp declare target link" object.  */
 #define REFCOUNT_LINK (~(uintptr_t) 1)
 
+/* Special offset values.  */
+#define OFFSET_INLINED (~(uintptr_t) 0)
+#define OFFSET_POINTER (~(uintptr_t) 1)
+#define OFFSET_STRUCT (~(uintptr_t) 2)
+
 struct splay_tree_key_s {
   /* Address of the host object.  */
   uintptr_t host_start;
@@ -939,34 +1025,34 @@ splay_compare (splay_tree_key x, splay_tree_key y)
 
 typedef struct acc_dispatch_t
 {
-  /* This is a linked list of data mapped using the
-     acc_map_data/acc_unmap_data or "acc enter data"/"acc exit data" pragmas.
-     Unlike mapped_data in the goacc_thread struct, unmapping can
-     happen out-of-order with respect to mapping.  */
-  /* This is guarded by the lock in the "outer" struct gomp_device_descr.  */
-  struct target_mem_desc *data_environ;
-
   /* Execute.  */
   __typeof (GOMP_OFFLOAD_openacc_exec) *exec_func;
 
-  /* Async cleanup callback registration.  */
-  __typeof (GOMP_OFFLOAD_openacc_register_async_cleanup)
-    *register_async_cleanup_func;
-
-  /* Asynchronous routines.  */
-  __typeof (GOMP_OFFLOAD_openacc_async_test) *async_test_func;
-  __typeof (GOMP_OFFLOAD_openacc_async_test_all) *async_test_all_func;
-  __typeof (GOMP_OFFLOAD_openacc_async_wait) *async_wait_func;
-  __typeof (GOMP_OFFLOAD_openacc_async_wait_async) *async_wait_async_func;
-  __typeof (GOMP_OFFLOAD_openacc_async_wait_all) *async_wait_all_func;
-  __typeof (GOMP_OFFLOAD_openacc_async_wait_all_async)
-    *async_wait_all_async_func;
-  __typeof (GOMP_OFFLOAD_openacc_async_set_async) *async_set_async_func;
-
   /* Create/destroy TLS data.  */
   __typeof (GOMP_OFFLOAD_openacc_create_thread_data) *create_thread_data_func;
   __typeof (GOMP_OFFLOAD_openacc_destroy_thread_data)
     *destroy_thread_data_func;
+  
+  struct {
+    /* Once created and put into the "active" list, asyncqueues are then never
+       destructed and removed from the "active" list, other than if the TODO
+       device is shut down.  */
+    gomp_mutex_t lock;
+    int nasyncqueue;
+    struct goacc_asyncqueue **asyncqueue;
+    struct goacc_asyncqueue_list *active;
+
+    __typeof (GOMP_OFFLOAD_openacc_async_construct) *construct_func;
+    __typeof (GOMP_OFFLOAD_openacc_async_destruct) *destruct_func;
+    __typeof (GOMP_OFFLOAD_openacc_async_test) *test_func;
+    __typeof (GOMP_OFFLOAD_openacc_async_synchronize) *synchronize_func;
+    __typeof (GOMP_OFFLOAD_openacc_async_serialize) *serialize_func;
+    __typeof (GOMP_OFFLOAD_openacc_async_queue_callback) *queue_callback_func;
+
+    __typeof (GOMP_OFFLOAD_openacc_async_exec) *exec_func;
+    __typeof (GOMP_OFFLOAD_openacc_async_dev2host) *dev2host_func;
+    __typeof (GOMP_OFFLOAD_openacc_async_host2dev) *host2dev_func;
+  } async;
 
   /* NVIDIA target specific routines.  */
   struct {
@@ -1039,8 +1125,7 @@ struct gomp_device_descr
   enum gomp_device_state state;
 
   /* OpenACC-specific data and functions.  */
-  /* This is mutable because of its mutable data_environ and target_data
-     members.  */
+  /* This is mutable because of its mutable target_data member.  */
   acc_dispatch_t openacc;
 };
 
@@ -1053,20 +1138,36 @@ enum gomp_map_vars_kind
   GOMP_MAP_VARS_ENTER_DATA
 };
 
-extern void gomp_acc_insert_pointer (size_t, void **, size_t *, void *);
-extern void gomp_acc_remove_pointer (void *, size_t, bool, int, int, int);
 extern void gomp_acc_declare_allocate (bool, size_t, void **, size_t *,
 				       unsigned short *);
+struct gomp_coalesce_buf;
+extern void gomp_copy_host2dev (struct gomp_device_descr *,
+				struct goacc_asyncqueue *, void *, const void *,
+				size_t, struct gomp_coalesce_buf *);
+extern void gomp_copy_dev2host (struct gomp_device_descr *,
+				struct goacc_asyncqueue *, void *, const void *,
+				size_t);
 
 extern struct target_mem_desc *gomp_map_vars (struct gomp_device_descr *,
 					      size_t, void **, void **,
 					      size_t *, void *, bool,
 					      enum gomp_map_vars_kind);
+extern struct target_mem_desc *gomp_map_vars_async (struct gomp_device_descr *,
+						    struct goacc_asyncqueue *,
+						    size_t, void **, void **,
+						    size_t *, void *, bool,
+						    enum gomp_map_vars_kind);
+extern void gomp_unmap_tgt (struct target_mem_desc *);
 extern void gomp_unmap_vars (struct target_mem_desc *, bool);
+extern void gomp_unmap_vars_async (struct target_mem_desc *, bool,
+				   struct goacc_asyncqueue *);
 extern void gomp_init_device (struct gomp_device_descr *);
+extern bool gomp_fini_device (struct gomp_device_descr *);
 extern void gomp_free_memmap (struct splay_tree_s *);
 extern void gomp_unload_device (struct gomp_device_descr *);
 extern bool gomp_remove_var (struct gomp_device_descr *, splay_tree_key);
+extern void gomp_remove_var_async (struct gomp_device_descr *, splay_tree_key,
+				   struct goacc_asyncqueue *);
 
 /* work.c */
 
diff --git a/libgomp/libgomp.map b/libgomp/libgomp.map
index d8e2fd1818b..c79430f8d8d 100644
--- a/libgomp/libgomp.map
+++ b/libgomp/libgomp.map
@@ -476,6 +476,14 @@ OACC_2.5 {
 	acc_update_self_async_array_h_;
 } OACC_2.0.1;
 
+OACC_2.5.1 {
+  global:
+	acc_prof_lookup;
+	acc_prof_register;
+	acc_prof_unregister;
+	acc_register_library;
+} OACC_2.5;
+
 GOACC_2.0 {
   global:
 	GOACC_data_end;
@@ -515,3 +523,9 @@ GOMP_PLUGIN_1.2 {
   global:
 	GOMP_PLUGIN_acc_default_dim;
 } GOMP_PLUGIN_1.1;
+
+GOMP_PLUGIN_1.3 {
+  global:
+	GOMP_PLUGIN_goacc_profiling_dispatch;
+	GOMP_PLUGIN_goacc_thread;
+} GOMP_PLUGIN_1.2;
diff --git a/libgomp/libgomp.texi b/libgomp/libgomp.texi
index e2e384ae8b6..ac9d38e01d7 100644
--- a/libgomp/libgomp.texi
+++ b/libgomp/libgomp.texi
@@ -111,6 +111,7 @@ changed to GNU Offloading and Multi Processing Runtime Library.
                                asynchronous operations.
 * OpenACC Library Interoperability:: OpenACC library interoperability with the
                                NVIDIA CUBLAS library.
+* OpenACC Profiling Interface::
 * The libgomp ABI::            Notes on the external ABI presented by libgomp.
 * Reporting Bugs::             How to report bugs in the GNU Offloading and
                                Multi Processing Runtime Library.
@@ -1886,7 +1887,7 @@ acceleration device.
                                 host address.
 * acc_hostptr::                 Get host pointer associated with specific
                                 device address.
-* acc_is_present::              Indiciate whether host variable / array is
+* acc_is_present::              Indicate whether host variable / array is
                                 present on device.
 * acc_memcpy_to_device::        Copy host memory to device memory.
 * acc_memcpy_from_device::      Copy device memory to host memory.
@@ -1897,6 +1898,13 @@ API routines for target platforms.
 * acc_get_current_cuda_context::Get CUDA context handle.
 * acc_get_cuda_stream::         Get CUDA stream handle.
 * acc_set_cuda_stream::         Set CUDA stream handle.
+
+API routines for the OpenACC Profiling Interface.
+
+* acc_prof_register::           Register callbacks.
+* acc_prof_unregister::         Unregister callbacks.
+* acc_prof_lookup::             Obtain inquiry functions.
+* acc_register_library::        Library registration.
 @end menu
 
 
@@ -2034,10 +2042,10 @@ region.
 @section @code{acc_async_test} -- Test for completion of a specific asynchronous operation.
 @table @asis
 @item @emph{Description}
-This function tests for completion of the asynchrounous operation specified
+This function tests for completion of the asynchronous operation specified
 in @var{arg}. In C/C++, a non-zero value will be returned to indicate
 the specified asynchronous operation has completed. While Fortran will return
-a @code{true}. If the asynchrounous operation has not completed, C/C++ returns
+a @code{true}. If the asynchronous operation has not completed, C/C++ returns
 a zero and Fortran returns a @code{false}.
 
 @item @emph{C/C++}:
@@ -2063,7 +2071,7 @@ a zero and Fortran returns a @code{false}.
 @section @code{acc_async_test_all} -- Tests for completion of all asynchronous operations.
 @table @asis
 @item @emph{Description}
-This function tests for completion of all asynchrounous operations.
+This function tests for completion of all asynchronous operations.
 In C/C++, a non-zero value will be returned to indicate all asynchronous
 operations have completed. While Fortran will return a @code{true}. If
 any asynchronous operation has not completed, C/C++ returns a zero and
@@ -2247,7 +2255,7 @@ This function shuts down the runtime for the device type specified in
 @item @emph{Description}:
 This function returns whether the program is executing on a particular
 device specified in @var{devicetype}. In C/C++ a non-zero value is
-returned to indicate the device is execiting on the specified device type.
+returned to indicate the device is executing on the specified device type.
 In Fortran, @code{true} will be returned. If the program is not executing
 on the specified device type C/C++ will return a zero, while Fortran will
 return @code{false}.
@@ -2823,6 +2831,90 @@ A.2.1.4.
 
 
 
+@node acc_prof_register
+@section @code{acc_prof_register} -- Register callbacks.
+@table @asis
+@item @emph{Description}:
+This function registers callbacks.
+
+@item @emph{C/C++}:
+@multitable @columnfractions .20 .80
+@item @emph{Prototype}: @tab @code{void acc_prof_register (acc_event_t, acc_prof_callback, acc_register_t);}
+@end multitable
+
+@item @emph{See also}:
+@ref{OpenACC Profiling Interface}
+
+@item @emph{Reference}:
+@uref{https://www.openacc.org, OpenACC specification v2.6}, section
+5.3.
+@end table
+
+
+
+@node acc_prof_unregister
+@section @code{acc_prof_unregister} -- Unregister callbacks.
+@table @asis
+@item @emph{Description}:
+This function unregisters callbacks.
+
+@item @emph{C/C++}:
+@multitable @columnfractions .20 .80
+@item @emph{Prototype}: @tab @code{void acc_prof_unregister (acc_event_t, acc_prof_callback, acc_register_t);}
+@end multitable
+
+@item @emph{See also}:
+@ref{OpenACC Profiling Interface}
+
+@item @emph{Reference}:
+@uref{https://www.openacc.org, OpenACC specification v2.6}, section
+5.3.
+@end table
+
+
+
+@node acc_prof_lookup
+@section @code{acc_prof_lookup} -- Obtain inquiry functions.
+@table @asis
+@item @emph{Description}:
+Function to obtain inquiry functions.
+
+@item @emph{C/C++}:
+@multitable @columnfractions .20 .80
+@item @emph{Prototype}: @tab @code{acc_query_fn acc_prof_lookup (const char *);}
+@end multitable
+
+@item @emph{See also}:
+@ref{OpenACC Profiling Interface}
+
+@item @emph{Reference}:
+@uref{https://www.openacc.org, OpenACC specification v2.6}, section
+5.3.
+@end table
+
+
+
+@node acc_register_library
+@section @code{acc_register_library} -- Library registration.
+@table @asis
+@item @emph{Description}:
+Function for library registration.
+
+@item @emph{C/C++}:
+@multitable @columnfractions .20 .80
+@item @emph{Prototype}: @tab @code{void acc_register_library (acc_prof_reg, acc_prof_reg, acc_prof_lookup_func);}
+@end multitable
+
+@item @emph{See also}:
+@ref{OpenACC Profiling Interface}, @ref{ACC_PROFLIB}
+
+@item @emph{Reference}:
+@uref{https://www.openacc.org, OpenACC specification v2.6}, section
+5.3.
+@end table
+
+
+
 @c ---------------------------------------------------------------------
 @c OpenACC Environment Variables
 @c ---------------------------------------------------------------------
@@ -2832,11 +2924,14 @@ A.2.1.4.
 
 The variables @env{ACC_DEVICE_TYPE} and @env{ACC_DEVICE_NUM}
 are defined by section 4 of the OpenACC specification in version 2.0.
+The variable @env{ACC_PROFLIB}
+is defined by section 4 of the OpenACC specification in version 2.6.
 The variable @env{GCC_ACC_NOTIFY} is used for diagnostic purposes.
 
 @menu
 * ACC_DEVICE_TYPE::
 * ACC_DEVICE_NUM::
+* ACC_PROFLIB::
 * GCC_ACC_NOTIFY::
 @end menu
 
@@ -2862,6 +2957,19 @@ The variable @env{GCC_ACC_NOTIFY} is used for diagnostic purposes.
 
 
 
+@node ACC_PROFLIB
+@section @code{ACC_PROFLIB}
+@table @asis
+@item @emph{See also}:
+@ref{acc_register_library}, @ref{OpenACC Profiling Interface}
+
+@item @emph{Reference}:
+@uref{https://www.openacc.org, OpenACC specification v2.6}, section
+4.3.
+@end table
+
+
+
 @node GCC_ACC_NOTIFY
 @section @code{GCC_ACC_NOTIFY}
 @table @asis
@@ -3077,6 +3185,310 @@ Application Programming Interfaceâ€, Version 2.0.}
 
 
 
+@c ---------------------------------------------------------------------
+@c OpenACC Profiling Interface
+@c ---------------------------------------------------------------------
+
+@node OpenACC Profiling Interface
+@chapter OpenACC Profiling Interface
+
+@section Implementation Status and Implementation-Defined Behavior
+
+We're implementing the OpenACC Profiling Interface as defined by the
+OpenACC 2.6 specification.  We're clarifying some aspects here as
+@emph{implementation-defined behavior}, while they're still under
+discussion within the OpenACC Technical Committee.
+
+This implementation is tuned to keep the performance impact as low as
+possible for the (very common) case that the Profiling Interface is
+not enabled.  This is relevant, as the Profiling Interface affects all
+the @emph{hot} code paths (in the target code, not in the offloaded
+code).  Users of the OpenACC Profiling Interface can be expected to
+understand that performance will be impacted to some degree once the
+Profiling Interface has gotten enabled: for example, because of the
+@emph{runtime} (libgomp) calling into a third-party @emph{library} for
+every event that has been registered.
+
+We're not yet accounting for the fact that @cite{OpenACC events may
+occur during event processing}.
+
+We're not yet implementing initialization via a
+@code{acc_register_library} function that is either statically linked
+in, or dynamically via @env{LD_PRELOAD}.
+Initialization via @code{acc_register_library} functions dynamically
+loaded via the @env{ACC_PROFLIB} environment variable does work, as
+does directly calling @code{acc_prof_register},
+@code{acc_prof_unregister}, @code{acc_prof_lookup}.
+
+As currently there are no inquiry functions defined, calls to
+@code{acc_prof_lookup} will always return @code{NULL}.
+
+There aren't separate @emph{start}, @emph{stop} events defined for the
+event types @code{acc_ev_create}, @code{acc_ev_delete},
+@code{acc_ev_alloc}, @code{acc_ev_free}.  It's not clear if these
+should be triggered before or after the actual device-specific call is
+made.  We trigger them after.
+
+Remarks about data provided to callbacks:
+
+@table @asis
+
+@item @code{acc_prof_info.event_type}
+It's not clear if for @emph{nested} event callbacks (for example,
+@code{acc_ev_enqueue_launch_start} as part of a parent compute
+construct), this should be set for the nested event
+(@code{acc_ev_enqueue_launch_start}), or if the value of the parent
+construct should remain (@code{acc_ev_compute_construct_start}).  In
+this implementation, the value will generally correspond to the
+innermost nested event type.
+
+@item @code{acc_prof_info.device_type}
+@itemize
+
+@item
+For @code{acc_ev_compute_construct_start}, and in presence of an
+@code{if} clause with @emph{false} argument, this will still refer to
+the offloading device type.
+It's not clear if that's the expected behavior.
+
+@item
+Complementary to the item before, for
+@code{acc_ev_compute_construct_end}, this is set to
+@code{acc_device_host} in presence of an @code{if} clause with
+@emph{false} argument.
+It's not clear if that's the expected behavior.
+
+@end itemize
+
+@item @code{acc_prof_info.thread_id}
+Always @code{-1}; not yet implemented.
+
+@item @code{acc_prof_info.async}
+@itemize
+
+@item
+Not yet implemented correctly for
+@code{acc_ev_compute_construct_start}.
+
+@item
+In a compute construct, for host-fallback
+execution/@code{acc_device_host} it will always be
+@code{acc_async_sync}.
+It's not clear if that's the expected behavior.
+
+@item
+For @code{acc_ev_device_init_start} and @code{acc_ev_device_init_end},
+it will always be @code{acc_async_sync}.
+It's not clear if that's the expected behavior.
+
+@end itemize
+
+@item @code{acc_prof_info.async_queue}
+There is no @cite{limited number of asynchronous queues} in libgomp.
+This will always have the same value as @code{acc_prof_info.async}.
+
+@item @code{acc_prof_info.src_file}
+Always @code{NULL}; not yet implemented.
+
+@item @code{acc_prof_info.func_name}
+Always @code{NULL}; not yet implemented.
+
+@item @code{acc_prof_info.line_no}
+Always @code{-1}; not yet implemented.
+
+@item @code{acc_prof_info.end_line_no}
+Always @code{-1}; not yet implemented.
+
+@item @code{acc_prof_info.func_line_no}
+Always @code{-1}; not yet implemented.
+
+@item @code{acc_prof_info.func_end_line_no}
+Always @code{-1}; not yet implemented.
+
+@item @code{acc_event_info.event_type}, @code{acc_event_info.*.event_type}
+Relating to @code{acc_prof_info.event_type} discussed above, in this
+implementation, this will always be the same value as
+@code{acc_prof_info.event_type}.
+
+@item @code{acc_event_info.*.parent_construct}
+@itemize
+
+@item
+Will be @code{acc_construct_parallel} for all OpenACC compute
+constructs as well as many OpenACC Runtime API calls; should be the
+one matching the actual construct, or
+@code{acc_construct_runtime_api}, respectively.
+
+@item
+Will be @code{acc_construct_enter_data} or
+@code{acc_construct_exit_data} when processing variable mappings
+specified in OpenACC @emph{declare} directives; should be
+@code{acc_construct_declare}.
+
+@item
+For implicit @code{acc_ev_device_init_start},
+@code{acc_ev_device_init_end}, and explicit as well as implicit
+@code{acc_ev_alloc}, @code{acc_ev_free},
+@code{acc_ev_enqueue_upload_start}, @code{acc_ev_enqueue_upload_end},
+@code{acc_ev_enqueue_download_start}, and
+@code{acc_ev_enqueue_download_end}, will be
+@code{acc_construct_parallel}; should reflect the real parent
+construct.
+
+@end itemize
+
+@item @code{acc_event_info.*.implicit}
+For @code{acc_ev_alloc}, @code{acc_ev_free},
+@code{acc_ev_enqueue_upload_start}, @code{acc_ev_enqueue_upload_end},
+@code{acc_ev_enqueue_download_start}, and
+@code{acc_ev_enqueue_download_end}, this currently will be @code{1}
+also for explicit usage.
+
+@item @code{acc_event_info.data_event.var_name}
+Always @code{NULL}; not yet implemented.
+
+@item @code{acc_event_info.data_event.host_ptr}
+For @code{acc_ev_alloc}, and @code{acc_ev_free}, this is always
+@code{NULL}.
+
+@item @code{typedef union acc_api_info}
+@dots{} as printed in @cite{5.2.3. Third Argument: API-Specific
+Information}.  This should obviously be @code{typedef @emph{struct}
+acc_api_info}.
+
+@item @code{acc_api_info.device_api}
+Possibly not yet implemented correctly for
+@code{acc_ev_compute_construct_start},
+@code{acc_ev_device_init_start}, @code{acc_ev_device_init_end}:
+will always be @code{acc_device_api_none} for these event types.
+For @code{acc_ev_enter_data_start}, it will be
+@code{acc_device_api_none} in some cases.
+
+@item @code{acc_api_info.device_type}
+Always the same as @code{acc_prof_info.device_type}.
+
+@item @code{acc_api_info.vendor}
+Always @code{-1}; not yet implemented.
+
+@item @code{acc_api_info.device_handle}
+Always @code{NULL}; not yet implemented.
+
+@item @code{acc_api_info.context_handle}
+Always @code{NULL}; not yet implemented.
+
+@item @code{acc_api_info.async_handle}
+Always @code{NULL}; not yet implemented.
+
+@end table
+
+Remarks about certain event types:
+
+@table @asis
+
+@item @code{acc_ev_device_init_start}, @code{acc_ev_device_init_end}
+@itemize
+
+@item
+@c See 'DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT' in
+@c 'libgomp.oacc-c-c++-common/acc_prof-kernels-1.c',
+@c 'libgomp.oacc-c-c++-common/acc_prof-parallel-1.c'.
+Whan a compute construct triggers implicit
+@code{acc_ev_device_init_start} and @code{acc_ev_device_init_end}
+events, they currently aren't @emph{nested within} the corresponding
+@code{acc_ev_compute_construct_start} and
+@code{acc_ev_compute_construct_end}, but they're currently observed
+@emph{before} @code{acc_ev_compute_construct_start}.
+It's not clear what to do: the standard asks us provide a lot of
+details to the @code{acc_ev_compute_construct_start} callback, without
+(implicitly) initializing a device before?
+
+@item
+Callbacks for these event types will not be invoked for calls to the
+@code{acc_set_device_type} and @code{acc_set_device_num} functions.
+It's not clear if they should be.
+
+@end itemize
+
+@item @code{acc_ev_enter_data_start}, @code{acc_ev_enter_data_end}, @code{acc_ev_exit_data_start}, @code{acc_ev_exit_data_end}
+@itemize
+
+@item
+Callbacks for these event types will also be invoked for OpenACC
+@emph{host_data} constructs.
+It's not clear if they should be.
+
+@item
+Callbacks for these event types will also be invoked when processing
+variable mappings specified in OpenACC @emph{declare} directives.
+It's not clear if they should be.
+
+@end itemize
+
+@end table
+
+Callbacks for the following event types will be invoked, but dispatch
+and information provided therein has not yet been thoroughly reviewed:
+
+@itemize
+@item @code{acc_ev_alloc}
+@item @code{acc_ev_free}
+@item @code{acc_ev_update_start}, @code{acc_ev_update_end}
+@item @code{acc_ev_enqueue_upload_start}, @code{acc_ev_enqueue_upload_end}
+@item @code{acc_ev_enqueue_download_start}, @code{acc_ev_enqueue_download_end}
+@end itemize
+
+During device initialization, and finalization, respectively,
+callbacks for the following event types will not yet be invoked:
+
+@itemize
+@item @code{acc_ev_alloc}
+@item @code{acc_ev_free}
+@end itemize
+
+Callbacks for the following event types have not yet been implemented,
+so currently won't be invoked:
+
+@itemize
+@item @code{acc_ev_device_shutdown_start}, @code{acc_ev_device_shutdown_end}
+@item @code{acc_ev_runtime_shutdown}
+@item @code{acc_ev_create}, @code{acc_ev_delete}
+@item @code{acc_ev_wait_start}, @code{acc_ev_wait_end}
+@end itemize
+
+For the following runtime library functions, not all expected
+callbacks will be invoked (mostly concerning implicit device
+initialization):
+
+@itemize
+@item @code{acc_get_num_devices}
+@item @code{acc_set_device_type}
+@item @code{acc_get_device_type}
+@item @code{acc_set_device_num}
+@item @code{acc_get_device_num}
+@item @code{acc_init}
+@item @code{acc_shutdown}
+@end itemize
+
+Aside from implicit device initialization, for the following runtime
+library functions, no callbacks will be invoked for shared-memory
+offloading devices (it's not clear if they should be):
+
+@itemize
+@item @code{acc_malloc}
+@item @code{acc_free}
+@item @code{acc_copyin}, @code{acc_present_or_copyin}, @code{acc_copyin_async}
+@item @code{acc_create}, @code{acc_present_or_create}, @code{acc_create_async}
+@item @code{acc_copyout}, @code{acc_copyout_async}, @code{acc_copyout_finalize}, @code{acc_copyout_finalize_async}
+@item @code{acc_delete}, @code{acc_delete_async}, @code{acc_delete_finalize}, @code{acc_delete_finalize_async}
+@item @code{acc_update_device}, @code{acc_update_device_async}
+@item @code{acc_update_self}, @code{acc_update_self_async}
+@item @code{acc_map_data}, @code{acc_unmap_data}
+@item @code{acc_memcpy_to_device}, @code{acc_memcpy_to_device_async}
+@item @code{acc_memcpy_from_device}, @code{acc_memcpy_from_device_async}
+@end itemize
+
+
+
 @c ---------------------------------------------------------------------
 @c The libgomp ABI
 @c ---------------------------------------------------------------------
diff --git a/libgomp/libgomp_g.h b/libgomp/libgomp_g.h
index 32a9d8aade9..c6e1c94caf8 100644
--- a/libgomp/libgomp_g.h
+++ b/libgomp/libgomp_g.h
@@ -31,7 +31,7 @@
 
 #include <stdbool.h>
 #include <stddef.h>
-#include "gstdint.h"
+#include <stdint.h>
 
 /* barrier.c */
 
@@ -357,6 +357,15 @@ extern void GOMP_teams (unsigned int, unsigned int);
 extern void GOMP_teams_reg (void (*) (void *), void *, unsigned, unsigned,
 			    unsigned);
 
+/* oacc-async.c */
+
+extern void GOACC_wait (int, int, ...);
+
+/* oacc-mem.c */
+
+extern void GOACC_enter_exit_data (int, size_t, void **, size_t *,
+				   unsigned short *, int, int, ...);
+
 /* oacc-parallel.c */
 
 extern void GOACC_parallel_keyed (int, void (*) (void *), size_t,
@@ -366,11 +375,8 @@ extern void GOACC_parallel (int, void (*) (void *), size_t, void **, size_t *,
 extern void GOACC_data_start (int, size_t, void **, size_t *,
 			      unsigned short *);
 extern void GOACC_data_end (void);
-extern void GOACC_enter_exit_data (int, size_t, void **,
-				   size_t *, unsigned short *, int, int, ...);
 extern void GOACC_update (int, size_t, void **, size_t *,
 			  unsigned short *, int, int, ...);
-extern void GOACC_wait (int, int, ...);
 extern int GOACC_get_num_threads (void);
 extern int GOACC_get_thread_num (void);
 extern void GOACC_declare (int, size_t, void **, size_t *, unsigned short *);
diff --git a/libgomp/oacc-async.c b/libgomp/oacc-async.c
index 915284db20b..6dfc3bdeb8e 100644
--- a/libgomp/oacc-async.c
+++ b/libgomp/oacc-async.c
@@ -27,47 +27,199 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <assert.h>
+#include <string.h>
 #include "openacc.h"
 #include "libgomp.h"
 #include "oacc-int.h"
 
-int
-acc_async_test (int async)
+static struct goacc_thread *
+get_goacc_thread (void)
 {
-  if (!async_valid_p (async))
-    gomp_fatal ("invalid async argument: %d", async);
-
   struct goacc_thread *thr = goacc_thread ();
 
   if (!thr || !thr->dev)
     gomp_fatal ("no device active");
 
-  return thr->dev->openacc.async_test_func (async);
+  return thr;
+}
+
+static int
+validate_async_val (int async)
+{
+  if (!async_valid_p (async))
+    gomp_fatal ("invalid async-argument: %d", async);
+
+  if (async == acc_async_sync)
+    return -1;
+
+  if (async == acc_async_noval)
+    return 0;
+
+  if (async >= 0)
+    /* TODO: we reserve 0 for acc_async_noval before we can clarify the
+       semantics of "default_async".  */
+    return 1 + async;
+  else
+    __builtin_unreachable ();
+}
+
+/* Return the asyncqueue to be used for OpenACC async-argument ASYNC.  This
+   might return NULL if no asyncqueue is to be used.  Otherwise, if CREATE,
+   create the asyncqueue if it doesn't exist yet.
+
+   Unless CREATE, this will not generate any OpenACC Profiling Interface
+   events.  */
+
+attribute_hidden struct goacc_asyncqueue *
+lookup_goacc_asyncqueue (struct goacc_thread *thr, bool create, int async)
+{
+  async = validate_async_val (async);
+  if (async < 0)
+    return NULL;
+
+  struct goacc_asyncqueue *ret_aq = NULL;
+  struct gomp_device_descr *dev = thr->dev;
+
+  gomp_mutex_lock (&dev->openacc.async.lock);
+
+  if (!create
+      && (async >= dev->openacc.async.nasyncqueue
+	  || !dev->openacc.async.asyncqueue[async]))
+    goto end;
+
+  if (async >= dev->openacc.async.nasyncqueue)
+    {
+      int diff = async + 1 - dev->openacc.async.nasyncqueue;
+      dev->openacc.async.asyncqueue
+	= gomp_realloc (dev->openacc.async.asyncqueue,
+			sizeof (goacc_aq) * (async + 1));
+      memset (dev->openacc.async.asyncqueue + dev->openacc.async.nasyncqueue,
+	      0, sizeof (goacc_aq) * diff);
+      dev->openacc.async.nasyncqueue = async + 1;
+    }
+
+  if (!dev->openacc.async.asyncqueue[async])
+    {
+      dev->openacc.async.asyncqueue[async]
+	= dev->openacc.async.construct_func (dev->target_id);
+
+      if (!dev->openacc.async.asyncqueue[async])
+	{
+	  gomp_mutex_unlock (&dev->openacc.async.lock);
+	  gomp_fatal ("async %d creation failed", async);
+	}
+      
+      /* Link new async queue into active list.  */
+      goacc_aq_list n = gomp_malloc (sizeof (struct goacc_asyncqueue_list));
+      n->aq = dev->openacc.async.asyncqueue[async];
+      n->next = dev->openacc.async.active;
+      dev->openacc.async.active = n;
+    }
+
+  ret_aq = dev->openacc.async.asyncqueue[async];
+
+ end:
+  gomp_mutex_unlock (&dev->openacc.async.lock);
+  return ret_aq;
+}
+
+/* Return the asyncqueue to be used for OpenACC async-argument ASYNC.  This
+   might return NULL if no asyncqueue is to be used.  Otherwise, create the
+   asyncqueue if it doesn't exist yet.  */
+
+attribute_hidden struct goacc_asyncqueue *
+get_goacc_asyncqueue (int async)
+{
+  struct goacc_thread *thr = get_goacc_thread ();
+  return lookup_goacc_asyncqueue (thr, true, async);
 }
 
 int
-acc_async_test_all (void)
+acc_async_test (int async)
 {
   struct goacc_thread *thr = goacc_thread ();
 
   if (!thr || !thr->dev)
     gomp_fatal ("no device active");
 
-  return thr->dev->openacc.async_test_all_func ();
+  goacc_aq aq = lookup_goacc_asyncqueue (thr, false, async);
+  if (!aq)
+    return 1;
+
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    {
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+    }
+
+  int res = thr->dev->openacc.async.test_func (aq);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
+
+  return res;
+}
+
+int
+acc_async_test_all (void)
+{
+  struct goacc_thread *thr = get_goacc_thread ();
+
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+
+  int ret = 1;
+  gomp_mutex_lock (&thr->dev->openacc.async.lock);
+  for (goacc_aq_list l = thr->dev->openacc.async.active; l; l = l->next)
+    if (!thr->dev->openacc.async.test_func (l->aq))
+      {
+	ret = 0;
+	break;
+      }
+  gomp_mutex_unlock (&thr->dev->openacc.async.lock);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
+
+  return ret;
 }
 
 void
 acc_wait (int async)
 {
-  if (!async_valid_p (async))
-    gomp_fatal ("invalid async argument: %d", async);
+  struct goacc_thread *thr = get_goacc_thread ();
 
-  struct goacc_thread *thr = goacc_thread ();
+  goacc_aq aq = lookup_goacc_asyncqueue (thr, false, async);
+  if (!aq)
+    return;
 
-  if (!thr || !thr->dev)
-    gomp_fatal ("no device active");
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    {
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+    }
+
+  if (!thr->dev->openacc.async.synchronize_func (aq))
+    gomp_fatal ("wait on %d failed", async);
 
-  thr->dev->openacc.async_wait_func (async);
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
 /* acc_async_wait is an OpenACC 1.0 compatibility name for acc_wait.  */
@@ -84,12 +236,47 @@ acc_async_wait (int async)
 void
 acc_wait_async (int async1, int async2)
 {
-  struct goacc_thread *thr = goacc_thread ();
+  struct goacc_thread *thr = get_goacc_thread ();
 
-  if (!thr || !thr->dev)
-    gomp_fatal ("no device active");
+  goacc_aq aq1 = lookup_goacc_asyncqueue (thr, false, async1);
+  /* TODO: Is this also correct for acc_async_sync, assuming that in this case,
+     we'll always be synchronous anyways?  */
+  if (!aq1)
+    return;
 
-  thr->dev->openacc.async_wait_async_func (async1, async2);
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    {
+      prof_info.async = async2;
+      prof_info.async_queue = prof_info.async;
+    }
+
+  goacc_aq aq2 = lookup_goacc_asyncqueue (thr, true, async2);
+  /* An async queue is always synchronized with itself.  */
+  if (aq1 == aq2)
+    goto out_prof;
+
+  if (aq2)
+    {
+      if (!thr->dev->openacc.async.serialize_func (aq1, aq2))
+	gomp_fatal ("ordering of async ids %d and %d failed", async1, async2);
+    }
+  else
+    {
+      /* TODO: Local thread synchronization.
+	 Necessary for the "async2 == acc_async_sync" case, or can just skip?  */
+      if (!thr->dev->openacc.async.synchronize_func (aq1))
+	gomp_fatal ("wait on %d failed", async1);
+    }
+
+ out_prof:
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
 void
@@ -97,10 +284,24 @@ acc_wait_all (void)
 {
   struct goacc_thread *thr = goacc_thread ();
 
-  if (!thr || !thr->dev)
-    gomp_fatal ("no device active");
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
 
-  thr->dev->openacc.async_wait_all_func ();
+  bool ret = true;
+  gomp_mutex_lock (&thr->dev->openacc.async.lock);
+  for (goacc_aq_list l = thr->dev->openacc.async.active; l; l = l->next)
+    ret &= thr->dev->openacc.async.synchronize_func (l->aq);
+  gomp_mutex_unlock (&thr->dev->openacc.async.lock);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
+
+  if (!ret)
+    gomp_fatal ("wait all failed");
 }
 
 /* acc_async_wait_all is an OpenACC 1.0 compatibility name for acc_wait_all.  */
@@ -117,13 +318,159 @@ acc_async_wait_all (void)
 void
 acc_wait_all_async (int async)
 {
-  if (!async_valid_p (async))
-    gomp_fatal ("invalid async argument: %d", async);
+  struct goacc_thread *thr = get_goacc_thread ();
+
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    {
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+    }
+
+  goacc_aq waiting_queue = lookup_goacc_asyncqueue (thr, true, async);
+
+  bool ret = true;
+  gomp_mutex_lock (&thr->dev->openacc.async.lock);
+  for (goacc_aq_list l = thr->dev->openacc.async.active; l; l = l->next)
+    {
+      if (waiting_queue)
+	ret &= thr->dev->openacc.async.serialize_func (l->aq, waiting_queue);
+      else
+	/* TODO: Local thread synchronization.
+	   Necessary for the "async2 == acc_async_sync" case, or can just skip?  */
+	ret &= thr->dev->openacc.async.synchronize_func (l->aq);
+    }
+  gomp_mutex_unlock (&thr->dev->openacc.async.lock);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
+
+  if (!ret)
+    gomp_fatal ("wait all async(%d) failed", async);
+}
+
+void
+GOACC_wait (int async, int num_waits, ...)
+{
+  goacc_lazy_initialize ();
 
   struct goacc_thread *thr = goacc_thread ();
 
-  if (!thr || !thr->dev)
-    gomp_fatal ("no device active");
+  /* No nesting.  */
+  assert (thr->prof_info == NULL);
+  assert (thr->api_info == NULL);
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    {
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+    }
+
+  if (num_waits)
+    {
+      va_list ap;
+
+      va_start (ap, num_waits);
+      goacc_wait (async, num_waits, &ap);
+      va_end (ap);
+    }
+  else if (async == acc_async_sync)
+    acc_wait_all ();
+  else
+    acc_wait_all_async (async);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
+}
+
+attribute_hidden void
+goacc_wait (int async, int num_waits, va_list *ap)
+{
+  while (num_waits--)
+    {
+      int qid = va_arg (*ap, int);
+
+      /* Waiting on ACC_ASYNC_NOVAL maps to 'wait all'.  */
+      if (qid == acc_async_noval)
+	{
+	  if (async == acc_async_sync)
+	    acc_wait_all ();
+	  else
+	    acc_wait_all_async (async);
+	  break;
+	}
+
+      if (acc_async_test (qid))
+	continue;
 
-  thr->dev->openacc.async_wait_all_async_func (async);
+      if (async == acc_async_sync)
+	acc_wait (qid);
+      else if (qid == async)
+	/* If we're waiting on the same asynchronous queue as we're
+	   launching on, the queue itself will order work as
+	   required, so there's no need to wait explicitly.  */
+	;
+      else
+	acc_wait_async (qid, async);
+    }
+}
+
+attribute_hidden void
+goacc_async_free (struct gomp_device_descr *devicep,
+		  struct goacc_asyncqueue *aq, void *ptr)
+{
+  if (!aq)
+    free (ptr);
+  else
+    devicep->openacc.async.queue_callback_func (aq, free, ptr);
+}
+
+/* This function initializes the asyncqueues for the device specified by
+   DEVICEP.  TODO DEVICEP must be locked on entry, and remains locked on
+   return.  */
+
+attribute_hidden void
+goacc_init_asyncqueues (struct gomp_device_descr *devicep)
+{
+  devicep->openacc.async.nasyncqueue = 0;
+  devicep->openacc.async.asyncqueue = NULL;
+  devicep->openacc.async.active = NULL;
+  gomp_mutex_init (&devicep->openacc.async.lock);
+}
+
+/* This function finalizes the asyncqueues for the device specified by DEVICEP.
+   TODO DEVICEP must be locked on entry, and remains locked on return.  */
+
+attribute_hidden bool
+goacc_fini_asyncqueues (struct gomp_device_descr *devicep)
+{
+  bool ret = true;
+  gomp_mutex_lock (&devicep->openacc.async.lock);
+  if (devicep->openacc.async.nasyncqueue > 0)
+    {
+      goacc_aq_list next;
+      for (goacc_aq_list l = devicep->openacc.async.active; l; l = next)
+	{
+	  ret &= devicep->openacc.async.destruct_func (l->aq);
+	  next = l->next;
+	  free (l);
+	}
+      free (devicep->openacc.async.asyncqueue);
+      devicep->openacc.async.nasyncqueue = 0;
+      devicep->openacc.async.asyncqueue = NULL;
+      devicep->openacc.async.active = NULL;
+    }
+  gomp_mutex_unlock (&devicep->openacc.async.lock);
+  gomp_mutex_destroy (&devicep->openacc.async.lock);
+  return ret;
 }
diff --git a/libgomp/oacc-cuda.c b/libgomp/oacc-cuda.c
index 16eb6c3effb..7a42085c877 100644
--- a/libgomp/oacc-cuda.c
+++ b/libgomp/oacc-cuda.c
@@ -27,19 +27,32 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include "openacc.h"
-#include "config.h"
 #include "libgomp.h"
 #include "oacc-int.h"
+#include <assert.h>
 
 void *
 acc_get_current_cuda_device (void)
 {
   struct goacc_thread *thr = goacc_thread ();
 
+  void *ret = NULL;
   if (thr && thr->dev && thr->dev->openacc.cuda.get_current_device_func)
-    return thr->dev->openacc.cuda.get_current_device_func ();
+    {
+      acc_prof_info prof_info;
+      acc_api_info api_info;
+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
 
-  return NULL;
+      ret = thr->dev->openacc.cuda.get_current_device_func ();
+
+      if (profiling_p)
+	{
+	  thr->prof_info = NULL;
+	  thr->api_info = NULL;
+	}
+    }
+
+  return ret;
 }
 
 void *
@@ -47,10 +60,23 @@ acc_get_current_cuda_context (void)
 {
   struct goacc_thread *thr = goacc_thread ();
 
+  void *ret = NULL;
   if (thr && thr->dev && thr->dev->openacc.cuda.get_current_context_func)
-    return thr->dev->openacc.cuda.get_current_context_func ();
- 
-  return NULL;
+    {
+      acc_prof_info prof_info;
+      acc_api_info api_info;
+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+
+      ret = thr->dev->openacc.cuda.get_current_context_func ();
+
+      if (profiling_p)
+	{
+	  thr->prof_info = NULL;
+	  thr->api_info = NULL;
+	}
+    }
+
+  return ret;
 }
 
 void *
@@ -61,10 +87,32 @@ acc_get_cuda_stream (int async)
   if (!async_valid_p (async))
     return NULL;
 
+  void *ret = NULL;
   if (thr && thr->dev && thr->dev->openacc.cuda.get_stream_func)
-    return thr->dev->openacc.cuda.get_stream_func (async);
- 
-  return NULL;
+    {
+      goacc_aq aq = lookup_goacc_asyncqueue (thr, false, async);
+      if (!aq)
+	return ret;
+
+      acc_prof_info prof_info;
+      acc_api_info api_info;
+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+      if (profiling_p)
+	{
+	  prof_info.async = async;
+	  prof_info.async_queue = prof_info.async;
+	}
+
+      ret = thr->dev->openacc.cuda.get_stream_func (aq);
+
+      if (profiling_p)
+	{
+	  thr->prof_info = NULL;
+	  thr->api_info = NULL;
+	}
+    }
+
+  return ret;
 }
 
 int
@@ -79,8 +127,40 @@ acc_set_cuda_stream (int async, void *stream)
 
   thr = goacc_thread ();
 
+  int ret = -1;
   if (thr && thr->dev && thr->dev->openacc.cuda.set_stream_func)
-    return thr->dev->openacc.cuda.set_stream_func (async, stream);
-
-  return -1;
+    {
+      acc_prof_info prof_info;
+      acc_api_info api_info;
+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+      if (profiling_p)
+	{
+	  prof_info.async = async;
+	  prof_info.async_queue = prof_info.async;
+	}
+
+      goacc_aq aq = get_goacc_asyncqueue (async);
+      /* Due to not using an asyncqueue for "acc_async_sync", this cannot be
+	 used to change the CUDA stream associated with "acc_async_sync".  */
+      if (!aq)
+	{
+	  assert (async == acc_async_sync);
+	  gomp_debug (0, "Refusing request to set CUDA stream associated"
+		      " with \"acc_async_sync\"\n");
+	  ret = 0;
+	  goto out_prof;
+	}
+      gomp_mutex_lock (&thr->dev->openacc.async.lock);
+      ret = thr->dev->openacc.cuda.set_stream_func (aq, stream);
+      gomp_mutex_unlock (&thr->dev->openacc.async.lock);
+
+    out_prof:
+      if (profiling_p)
+	{
+	  thr->prof_info = NULL;
+	  thr->api_info = NULL;
+	}
+    }
+
+  return ret;
 }
diff --git a/libgomp/oacc-host.c b/libgomp/oacc-host.c
index 222bfb7d1a6..845140f04f5 100644
--- a/libgomp/oacc-host.c
+++ b/libgomp/oacc-host.c
@@ -32,7 +32,6 @@
 
 #include <stdbool.h>
 #include <stddef.h>
-#include <stdint.h>
 
 static struct gomp_device_descr host_dispatch;
 
@@ -140,55 +139,89 @@ host_openacc_exec (void (*fn) (void *),
 		   size_t mapnum __attribute__ ((unused)),
 		   void **hostaddrs,
 		   void **devaddrs __attribute__ ((unused)),
-		   int async __attribute__ ((unused)),
-		   unsigned *dims __attribute ((unused)),
+		   unsigned *dims __attribute__ ((unused)),
 		   void *targ_mem_desc __attribute__ ((unused)))
 {
   fn (hostaddrs);
 }
 
 static void
-host_openacc_register_async_cleanup (void *targ_mem_desc __attribute__ ((unused)),
-				     int async __attribute__ ((unused)))
+host_openacc_async_exec (void (*fn) (void *),
+			 size_t mapnum __attribute__ ((unused)),
+			 void **hostaddrs,
+			 void **devaddrs __attribute__ ((unused)),
+			 unsigned *dims __attribute__ ((unused)),
+			 void *targ_mem_desc __attribute__ ((unused)),
+			 struct goacc_asyncqueue *aq __attribute__ ((unused)))
 {
+  fn (hostaddrs);
 }
 
 static int
-host_openacc_async_test (int async __attribute__ ((unused)))
+host_openacc_async_test (struct goacc_asyncqueue *aq __attribute__ ((unused)))
 {
   return 1;
 }
 
-static int
-host_openacc_async_test_all (void)
+static bool
+host_openacc_async_synchronize (struct goacc_asyncqueue *aq
+				__attribute__ ((unused)))
 {
-  return 1;
+  return true;
 }
 
-static void
-host_openacc_async_wait (int async __attribute__ ((unused)))
+static bool
+host_openacc_async_serialize (struct goacc_asyncqueue *aq1
+			      __attribute__ ((unused)),
+			      struct goacc_asyncqueue *aq2
+			      __attribute__ ((unused)))
 {
+  return true;
 }
 
-static void
-host_openacc_async_wait_async (int async1 __attribute__ ((unused)),
-			       int async2 __attribute__ ((unused)))
+static bool
+host_openacc_async_host2dev (int ord __attribute__ ((unused)),
+			     void *dst __attribute__ ((unused)),
+			     const void *src __attribute__ ((unused)),
+			     size_t n __attribute__ ((unused)),
+			     struct goacc_asyncqueue *aq
+			     __attribute__ ((unused)))
 {
+  return true;
 }
 
-static void
-host_openacc_async_wait_all (void)
+static bool
+host_openacc_async_dev2host (int ord __attribute__ ((unused)),
+			     void *dst __attribute__ ((unused)),
+			     const void *src __attribute__ ((unused)),
+			     size_t n __attribute__ ((unused)),
+			     struct goacc_asyncqueue *aq
+			     __attribute__ ((unused)))
 {
+  return true;
 }
 
 static void
-host_openacc_async_wait_all_async (int async __attribute__ ((unused)))
+host_openacc_async_queue_callback (struct goacc_asyncqueue *aq
+				   __attribute__ ((unused)),
+				   void (*callback_fn)(void *)
+				   __attribute__ ((unused)),
+				   void *userptr __attribute__ ((unused)))
 {
 }
 
-static void
-host_openacc_async_set_async (int async __attribute__ ((unused)))
+static struct goacc_asyncqueue *
+host_openacc_async_construct (int device __attribute__((unused)))
+{
+  /* Non-NULL 0xffff... value as opaque dummy.  */
+  return (struct goacc_asyncqueue *) -1;
+}
+
+static bool
+host_openacc_async_destruct (struct goacc_asyncqueue *aq
+			     __attribute__ ((unused)))
 {
+  return true;
 }
 
 static void *
@@ -227,27 +260,27 @@ static struct gomp_device_descr host_dispatch =
     .run_func = host_run,
 
     .mem_map = { NULL },
-    /* .lock initilized in goacc_host_init.  */
+    /* .lock initialized in goacc_host_init.  */
     .state = GOMP_DEVICE_UNINITIALIZED,
 
     .openacc = {
-      .data_environ = NULL,
-
       .exec_func = host_openacc_exec,
 
-      .register_async_cleanup_func = host_openacc_register_async_cleanup,
-
-      .async_test_func = host_openacc_async_test,
-      .async_test_all_func = host_openacc_async_test_all,
-      .async_wait_func = host_openacc_async_wait,
-      .async_wait_async_func = host_openacc_async_wait_async,
-      .async_wait_all_func = host_openacc_async_wait_all,
-      .async_wait_all_async_func = host_openacc_async_wait_all_async,
-      .async_set_async_func = host_openacc_async_set_async,
-
       .create_thread_data_func = host_openacc_create_thread_data,
       .destroy_thread_data_func = host_openacc_destroy_thread_data,
 
+      .async = {
+	.construct_func = host_openacc_async_construct,
+	.destruct_func = host_openacc_async_destruct,
+	.test_func = host_openacc_async_test,
+	.synchronize_func = host_openacc_async_synchronize,
+	.serialize_func = host_openacc_async_serialize,
+	.queue_callback_func = host_openacc_async_queue_callback,
+	.exec_func = host_openacc_async_exec,
+	.dev2host_func = host_openacc_async_dev2host,
+	.host2dev_func = host_openacc_async_host2dev,
+      },
+
       .cuda = {
 	.get_current_device_func = NULL,
 	.get_current_context_func = NULL,
diff --git a/libgomp/oacc-init.c b/libgomp/oacc-init.c
index f30cf2f81d8..a444c604d59 100644
--- a/libgomp/oacc-init.c
+++ b/libgomp/oacc-init.c
@@ -82,6 +82,18 @@ goacc_register (struct gomp_device_descr *disp)
   gomp_mutex_unlock (&acc_device_lock);
 }
 
+static bool
+known_device_type_p (acc_device_t d)
+{
+  return d >= 0 && d < _ACC_device_hwm;
+}
+
+static void
+unknown_device_type_error (acc_device_t invalid_type)
+{
+  gomp_fatal ("unknown device type %u", invalid_type);
+}
+
 /* OpenACC names some things a little differently.  */
 
 static const char *
@@ -103,8 +115,9 @@ name_of_acc_device_t (enum acc_device_t type)
     case acc_device_host: return "host";
     case acc_device_not_host: return "not_host";
     case acc_device_nvidia: return "nvidia";
-    default: gomp_fatal ("unknown device type %u", (unsigned) type);
+    default: unknown_device_type_error (type);
     }
+  __builtin_unreachable ();
 }
 
 /* ACC_DEVICE_LOCK must be held before calling this function.  If FAIL_IS_ERROR
@@ -123,7 +136,7 @@ resolve_device (acc_device_t d, bool fail_is_error)
 	if (goacc_device_type)
 	  {
 	    /* Lookup the named device.  */
-	    while (++d != _ACC_device_hwm)
+	    while (known_device_type_p (++d))
 	      if (dispatchers[d]
 		  && !strcasecmp (goacc_device_type,
 				  get_openacc_name (dispatchers[d]->name))
@@ -147,7 +160,7 @@ resolve_device (acc_device_t d, bool fail_is_error)
 
     case acc_device_not_host:
       /* Find the first available device after acc_device_not_host.  */
-      while (++d != _ACC_device_hwm)
+      while (known_device_type_p (++d))
 	if (dispatchers[d] && dispatchers[d]->get_num_devices_func () > 0)
 	  goto found;
       if (d_arg == acc_device_default)
@@ -168,7 +181,7 @@ resolve_device (acc_device_t d, bool fail_is_error)
       break;
 
     default:
-      if (d > _ACC_device_hwm)
+      if (!known_device_type_p (d))
 	{
 	  if (fail_is_error)
 	    goto unsupported_device;
@@ -210,8 +223,67 @@ acc_dev_num_out_of_range (acc_device_t d, int ord, int ndevs)
    held before calling this function.  */
 
 static struct gomp_device_descr *
-acc_init_1 (acc_device_t d)
+acc_init_1 (acc_device_t d, acc_construct_t parent_construct, int implicit)
 {
+  bool check_not_nested_p;
+  if (implicit)
+    {
+      /* In the implicit case, there should (TODO: must?) already be something
+	 have been set up for an outer construct.  */
+      check_not_nested_p = false;
+    }
+  else
+    {
+      check_not_nested_p = true;
+      /* TODO: should we set 'thr->prof_info' etc. in this case ('acc_init')?
+	 The problem is, that we don't have 'thr' yet?  (So,
+	 'check_not_nested_p = true' also is pointless actually.)  */
+    }
+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (check_not_nested_p);
+
+  acc_prof_info prof_info;
+  if (profiling_p)
+    {
+      prof_info.event_type = acc_ev_device_init_start;
+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;
+      prof_info.version = _ACC_PROF_INFO_VERSION;
+      prof_info.device_type = d;
+      prof_info.device_number = goacc_device_num;
+      prof_info.thread_id = -1;
+      prof_info.async = acc_async_sync;
+      prof_info.async_queue = prof_info.async;
+      prof_info.src_file = NULL;
+      prof_info.func_name = NULL;
+      prof_info.line_no = -1;
+      prof_info.end_line_no = -1;
+      prof_info.func_line_no = -1;
+      prof_info.func_end_line_no = -1;
+    }
+  acc_event_info device_init_event_info;
+  if (profiling_p)
+    {
+      device_init_event_info.other_event.event_type = prof_info.event_type;
+      device_init_event_info.other_event.valid_bytes
+	= _ACC_OTHER_EVENT_INFO_VALID_BYTES;
+      device_init_event_info.other_event.parent_construct = parent_construct;
+      device_init_event_info.other_event.implicit = implicit;
+      device_init_event_info.other_event.tool_info = NULL;
+    }
+  acc_api_info api_info;
+  if (profiling_p)
+    {
+      api_info.device_api = acc_device_api_none;
+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;
+      api_info.device_type = prof_info.device_type;
+      api_info.vendor = -1;
+      api_info.device_handle = NULL;
+      api_info.context_handle = NULL;
+      api_info.async_handle = NULL;
+    }
+
+  if (profiling_p)
+    goacc_profiling_dispatch (&prof_info, &device_init_event_info, &api_info);
+
   struct gomp_device_descr *base_dev, *acc_dev;
   int ndevs;
 
@@ -234,6 +306,14 @@ acc_init_1 (acc_device_t d)
   gomp_init_device (acc_dev);
   gomp_mutex_unlock (&acc_dev->lock);
 
+  if (profiling_p)
+    {
+      prof_info.event_type = acc_ev_device_init_end;
+      device_init_event_info.other_event.event_type = prof_info.event_type;
+      goacc_profiling_dispatch (&prof_info, &device_init_event_info,
+				&api_info);
+    }
+
   return base_dev;
 }
 
@@ -309,7 +389,7 @@ acc_shutdown_1 (acc_device_t d)
       if (acc_dev->state == GOMP_DEVICE_INITIALIZED)
         {
 	  devices_active = true;
-	  ret &= acc_dev->fini_device_func (acc_dev->target_id);
+	  ret &= gomp_fini_device (acc_dev);
 	  acc_dev->state = GOMP_DEVICE_UNINITIALIZED;
 	}
       gomp_mutex_unlock (&acc_dev->lock);
@@ -423,11 +503,13 @@ goacc_attach_host_thread_to_device (int ord)
   thr->dev = acc_dev = &base_dev[ord];
   thr->saved_bound_dev = NULL;
   thr->mapped_data = NULL;
-  
+  thr->prof_info = NULL;
+  thr->api_info = NULL;
+  /* Initially, all callbacks for all events are enabled.  */
+  thr->prof_callbacks_enabled = true;
+
   thr->target_tls
     = acc_dev->openacc.create_thread_data_func (ord);
-  
-  acc_dev->openacc.async_set_async_func (acc_async_sync);
 }
 
 /* OpenACC 2.0a (3.2.12, 3.2.13) doesn't specify whether the serialization of
@@ -436,12 +518,13 @@ goacc_attach_host_thread_to_device (int ord)
 void
 acc_init (acc_device_t d)
 {
+  if (!known_device_type_p (d))
+    unknown_device_type_error (d);
+
   gomp_init_targets_once ();
 
   gomp_mutex_lock (&acc_device_lock);
-
-  cached_base_dev = acc_init_1 (d);
-
+  cached_base_dev = acc_init_1 (d, acc_construct_runtime_api, 0);
   gomp_mutex_unlock (&acc_device_lock);
   
   goacc_attach_host_thread_to_device (-1);
@@ -452,6 +535,9 @@ ialias (acc_init)
 void
 acc_shutdown (acc_device_t d)
 {
+  if (!known_device_type_p (d))
+    unknown_device_type_error (d);
+
   gomp_init_targets_once ();
 
   gomp_mutex_lock (&acc_device_lock);
@@ -466,6 +552,9 @@ ialias (acc_shutdown)
 int
 acc_get_num_devices (acc_device_t d)
 {
+  if (!known_device_type_p (d))
+    unknown_device_type_error (d);
+
   int n = 0;
   struct gomp_device_descr *acc_dev;
 
@@ -497,9 +586,18 @@ ialias (acc_get_num_devices)
 void
 acc_set_device_type (acc_device_t d)
 {
+  if (!known_device_type_p (d))
+    unknown_device_type_error (d);
+
   struct gomp_device_descr *base_dev, *acc_dev;
   struct goacc_thread *thr = goacc_thread ();
 
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    prof_info.device_type = d;
+
   gomp_init_targets_once ();
 
   gomp_mutex_lock (&acc_device_lock);
@@ -524,6 +622,12 @@ acc_set_device_type (acc_device_t d)
     }
 
   goacc_attach_host_thread_to_device (-1);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
 ialias (acc_set_device_type)
@@ -539,12 +643,22 @@ acc_get_device_type (void)
     res = acc_device_type (thr->base_dev->type);
   else
     {
+      acc_prof_info prof_info;
+      acc_api_info api_info;
+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+
       gomp_init_targets_once ();
 
       gomp_mutex_lock (&acc_device_lock);
       dev = resolve_device (acc_device_default, true);
       gomp_mutex_unlock (&acc_device_lock);
       res = acc_device_type (dev->type);
+
+      if (profiling_p)
+	{
+	  thr->prof_info = NULL;
+	  thr->api_info = NULL;
+	}
     }
 
   assert (res != acc_device_default
@@ -558,11 +672,17 @@ ialias (acc_get_device_type)
 int
 acc_get_device_num (acc_device_t d)
 {
+  if (!known_device_type_p (d))
+    unknown_device_type_error (d);
+
   const struct gomp_device_descr *dev;
   struct goacc_thread *thr = goacc_thread ();
 
-  if (d >= _ACC_device_hwm)
-    gomp_fatal ("unknown device type %u", (unsigned) d);
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    prof_info.device_type = d;
 
   gomp_init_targets_once ();
 
@@ -570,6 +690,12 @@ acc_get_device_num (acc_device_t d)
   dev = resolve_device (d, true);
   gomp_mutex_unlock (&acc_device_lock);
 
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
+
   if (thr && thr->base_dev == dev && thr->dev)
     return thr->dev->target_id;
 
@@ -581,6 +707,9 @@ ialias (acc_get_device_num)
 void
 acc_set_device_num (int ord, acc_device_t d)
 {
+  if (!known_device_type_p (d))
+    unknown_device_type_error (d);
+
   struct gomp_device_descr *base_dev, *acc_dev;
   int num_devices;
 
@@ -627,7 +756,10 @@ ialias (acc_set_device_num)
    version.
 
    Compile this with optimization, so that the compiler expands
-   this, rather than generating infinitely recursive code.  */
+   this, rather than generating infinitely recursive code.
+
+   The function just forwards its argument to __builtin_acc_on_device.  It does
+   not verify that the argument is a valid acc_device_t enumeration value.  */
 
 int __attribute__ ((__optimize__ ("O2")))
 acc_on_device (acc_device_t dev)
@@ -691,8 +823,13 @@ goacc_lazy_initialize (void)
   if (thr && thr->dev)
     return;
 
+  gomp_init_targets_once ();
+
+  gomp_mutex_lock (&acc_device_lock);
   if (!cached_base_dev)
-    acc_init (acc_device_default);
-  else
-    goacc_attach_host_thread_to_device (-1);
+    cached_base_dev = acc_init_1 (acc_device_default,
+				  acc_construct_parallel, 1);
+  gomp_mutex_unlock (&acc_device_lock);
+
+  goacc_attach_host_thread_to_device (-1);
 }
diff --git a/libgomp/oacc-int.h b/libgomp/oacc-int.h
index 940052b7936..81cb15c605f 100644
--- a/libgomp/oacc-int.h
+++ b/libgomp/oacc-int.h
@@ -40,6 +40,7 @@
 
 #include "openacc.h"
 #include "config.h"
+#include "acc_prof.h"
 #include <stddef.h>
 #include <stdbool.h>
 #include <stdarg.h>
@@ -68,6 +69,12 @@ struct goacc_thread
      strictly push/pop semantics according to lexical scope.  */
   struct target_mem_desc *mapped_data;
 
+  /* Data of the OpenACC Profiling Interface.  */
+  acc_prof_info *prof_info;
+  acc_api_info *api_info;
+  /* Per-thread toggle of OpenACC Profiling Interface callbacks.  */
+  bool prof_callbacks_enabled;
+
   /* These structures form a list: this is the next thread in that list.  */
   struct goacc_thread *next;
 
@@ -75,7 +82,14 @@ struct goacc_thread
   void *target_tls;
 };
 
-#if defined HAVE_TLS || defined USE_EMUTLS
+#ifdef __AMDGCN__
+static inline struct goacc_thread *
+goacc_thread (void)
+{
+  /* Unused in the offload libgomp for OpenACC: return a dummy value.  */
+  return 0;
+}
+#elif defined HAVE_TLS || defined USE_EMUTLS
 extern __thread struct goacc_thread *goacc_tls_data;
 static inline struct goacc_thread *
 goacc_thread (void)
@@ -99,6 +113,14 @@ void goacc_restore_bind (void);
 void goacc_lazy_initialize (void);
 void goacc_host_init (void);
 
+void goacc_wait (int, int, va_list *);
+void goacc_init_asyncqueues (struct gomp_device_descr *);
+bool goacc_fini_asyncqueues (struct gomp_device_descr *);
+void goacc_async_free (struct gomp_device_descr *, struct goacc_asyncqueue *,
+		       void *);
+struct goacc_asyncqueue *get_goacc_asyncqueue (int);
+struct goacc_asyncqueue *lookup_goacc_asyncqueue (struct goacc_thread *, bool,
+						  int);
 static inline bool
 async_valid_stream_id_p (int async)
 {
@@ -121,6 +143,28 @@ async_synchronous_p (int async)
   return async == acc_async_sync;
 }
 
+
+extern bool goacc_prof_enabled;
+/* Tune for the (very common) case that profiling is not enabled.  */
+#define GOACC_PROF_ENABLED \
+  (__builtin_expect (__atomic_load_n (&goacc_prof_enabled, \
+				      MEMMODEL_ACQUIRE) == true, false))
+
+void goacc_profiling_initialize (void);
+bool _goacc_profiling_dispatch_p (bool);
+/* Tune for the (very common) case that profiling is not enabled.  */
+#define GOACC_PROFILING_DISPATCH_P(...) \
+  (GOACC_PROF_ENABLED \
+   && _goacc_profiling_dispatch_p (__VA_ARGS__))
+bool _goacc_profiling_setup_p (struct goacc_thread *,
+			       acc_prof_info *, acc_api_info *);
+/* Tune for the (very common) case that profiling is not enabled.  */
+#define GOACC_PROFILING_SETUP_P(...) \
+  (GOACC_PROFILING_DISPATCH_P (false) \
+   && _goacc_profiling_setup_p (__VA_ARGS__))
+void goacc_profiling_dispatch (acc_prof_info *, acc_event_info *,
+			       acc_api_info *);
+
 #ifdef HAVE_ATTRIBUTE_VISIBILITY
 # pragma GCC visibility pop
 #endif
diff --git a/libgomp/oacc-mem.c b/libgomp/oacc-mem.c
index 26e1a7545df..196b7e2a520 100644
--- a/libgomp/oacc-mem.c
+++ b/libgomp/oacc-mem.c
@@ -27,11 +27,9 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include "openacc.h"
-#include "config.h"
 #include "libgomp.h"
 #include "gomp-constants.h"
 #include "oacc-int.h"
-#include <stdint.h>
 #include <string.h>
 #include <assert.h>
 
@@ -52,44 +50,42 @@ lookup_host (struct gomp_device_descr *dev, void *h, size_t s)
   return key;
 }
 
-/* Return block containing [D->S), or NULL if not contained.
-   The list isn't ordered by device address, so we have to iterate
-   over the whole array.  This is not expected to be a common
-   operation.  The device lock associated with TGT must be locked on entry, and
-   remains locked on exit.  */
+/* Helper for lookup_dev.  Iterate over splay tree.  */
 
 static splay_tree_key
-lookup_dev (struct target_mem_desc *tgt, void *d, size_t s)
+lookup_dev_1 (splay_tree_node node, uintptr_t d, size_t s)
 {
-  int i;
-  struct target_mem_desc *t;
+  splay_tree_key key = &node->key;
+  if (d >= key->tgt->tgt_start && d + s <= key->tgt->tgt_end)
+    return key;
 
-  if (!tgt)
-    return NULL;
+  key = NULL;
+  if (node->left)
+    key = lookup_dev_1 (node->left, d, s);
+  if (!key && node->right)
+    key = lookup_dev_1 (node->right, d, s);
 
-  for (t = tgt; t != NULL; t = t->prev)
-    {
-      if (t->tgt_start <= (uintptr_t) d && t->tgt_end >= (uintptr_t) d + s)
-        break;
-    }
+  return key;
+}
 
-  if (!t)
-    return NULL;
+/* Return block containing [D->S), or NULL if not contained.
 
-  for (i = 0; i < t->list_count; i++)
-    {
-      void * offset;
+   This iterates over the splay tree.  This is not expected to be a common
+   operation.
 
-      splay_tree_key k = &t->array[i].key;
-      offset = d - t->tgt_start + k->tgt_offset;
+   The device lock associated with MEM_MAP must be locked on entry, and remains
+   locked on exit.  */
 
-      if (k->host_start + offset <= (void *) k->host_end)
-        return k;
-    }
+static splay_tree_key
+lookup_dev (splay_tree mem_map, void *d, size_t s)
+{
+  if (!mem_map || !mem_map->root)
+    return NULL;
 
-  return NULL;
+  return lookup_dev_1 (mem_map->root, (uintptr_t) d, s);
 }
 
+
 /* OpenACC is silent on how memory exhaustion is indicated.  We return
    NULL.  */
 
@@ -108,12 +104,21 @@ acc_malloc (size_t s)
   if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
     return malloc (s);
 
-  return thr->dev->alloc_func (thr->dev->target_id, s);
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+
+  void *res = thr->dev->alloc_func (thr->dev->target_id, s);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
+
+  return res;
 }
 
-/* OpenACC 2.0a (3.2.16) doesn't specify what to do in the event
-   the device address is mapped. We choose to check if it mapped,
-   and if it is, to unmap it. */
 void
 acc_free (void *d)
 {
@@ -131,26 +136,38 @@ acc_free (void *d)
   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
     return free (d);
 
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+
   gomp_mutex_lock (&acc_dev->lock);
 
   /* We don't have to call lazy open here, as the ptr value must have
      been returned by acc_malloc.  It's not permitted to pass NULL in
      (unless you got that null from acc_malloc).  */
-  if ((k = lookup_dev (acc_dev->openacc.data_environ, d, 1)))
+  if ((k = lookup_dev (&acc_dev->mem_map, d, 1)))
     {
-      void *offset;
-
-      offset = d - k->tgt->tgt_start + k->tgt_offset;
-
+      void *offset = d - k->tgt->tgt_start + k->tgt_offset;
+      void *h = k->host_start + offset;
+      size_t h_size = k->host_end - k->host_start;
       gomp_mutex_unlock (&acc_dev->lock);
-
-      acc_unmap_data ((void *)(k->host_start + offset));
+      /* PR92503 "[OpenACC] Behavior of 'acc_free' if the memory space is still
+	 used in a mapping".  */
+      gomp_fatal ("refusing to free device memory space at %p that is still"
+		  " mapped at [%p,+%d]",
+		  d, h, (int) h_size);
     }
   else
     gomp_mutex_unlock (&acc_dev->lock);
 
   if (!acc_dev->free_func (acc_dev->target_id, d))
     gomp_fatal ("error in freeing device memory in %s", __FUNCTION__);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
 static void
@@ -172,18 +189,26 @@ memcpy_tofrom_device (bool from, void *d, void *h, size_t s, int async,
       return;
     }
 
-  if (async > acc_async_sync)
-    thr->dev->openacc.async_set_async_func (async);
-
-  bool ret = (from
-	      ? thr->dev->dev2host_func (thr->dev->target_id, h, d, s)
-	      : thr->dev->host2dev_func (thr->dev->target_id, d, h, s));
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    {
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+    }
 
-  if (async > acc_async_sync)
-    thr->dev->openacc.async_set_async_func (acc_async_sync);
+  goacc_aq aq = get_goacc_asyncqueue (async);
+  if (from)
+    gomp_copy_dev2host (thr->dev, aq, h, d, s);
+  else
+    gomp_copy_host2dev (thr->dev, aq, d, h, s, /* TODO: cbuf? */ NULL);
 
-  if (!ret)
-    gomp_fatal ("error in %s", libfnname);
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
 void
@@ -228,6 +253,9 @@ acc_deviceptr (void *h)
   if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
     return h;
 
+  /* In the following, no OpenACC Profiling Interface events can possibly be
+     generated.  */
+
   gomp_mutex_lock (&dev->lock);
 
   n = lookup_host (dev, h, 1);
@@ -265,9 +293,12 @@ acc_hostptr (void *d)
   if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
     return d;
 
+  /* In the following, no OpenACC Profiling Interface events can possibly be
+     generated.  */
+
   gomp_mutex_lock (&acc_dev->lock);
 
-  n = lookup_dev (acc_dev->openacc.data_environ, d, 1);
+  n = lookup_dev (&acc_dev->mem_map, d, 1);
 
   if (!n)
     {
@@ -302,6 +333,9 @@ acc_is_present (void *h, size_t s)
   if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
     return h != NULL;
 
+  /* In the following, no OpenACC Profiling Interface events can possibly be
+     generated.  */
+
   gomp_mutex_lock (&acc_dev->lock);
 
   n = lookup_host (acc_dev, h, s);
@@ -346,6 +380,10 @@ acc_map_data (void *h, void *d, size_t s)
 	gomp_fatal ("[%p,+%d]->[%p,+%d] is a bad map",
                     (void *)h, (int)s, (void *)d, (int)s);
 
+      acc_prof_info prof_info;
+      acc_api_info api_info;
+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+
       gomp_mutex_lock (&acc_dev->lock);
 
       if (lookup_host (acc_dev, h, s))
@@ -355,7 +393,7 @@ acc_map_data (void *h, void *d, size_t s)
 		      (int)s);
 	}
 
-      if (lookup_dev (thr->dev->openacc.data_environ, d, s))
+      if (lookup_dev (&thr->dev->mem_map, d, s))
         {
 	  gomp_mutex_unlock (&acc_dev->lock);
 	  gomp_fatal ("device address [%p, +%d] is already mapped", (void *)d,
@@ -366,13 +404,18 @@ acc_map_data (void *h, void *d, size_t s)
 
       tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, &devaddrs, &sizes,
 			   &kinds, true, GOMP_MAP_VARS_OPENACC);
-      tgt->list[0].key->refcount = REFCOUNT_INFINITY;
-    }
+      splay_tree_key n = tgt->list[0].key;
+      assert (n->refcount == 1);
+      assert (n->dynamic_refcount == 0);
+      /* Special reference counting behavior.  */
+      n->refcount = REFCOUNT_INFINITY;
 
-  gomp_mutex_lock (&acc_dev->lock);
-  tgt->prev = acc_dev->openacc.data_environ;
-  acc_dev->openacc.data_environ = tgt;
-  gomp_mutex_unlock (&acc_dev->lock);
+      if (profiling_p)
+	{
+	  thr->prof_info = NULL;
+	  thr->api_info = NULL;
+	}
+    }
 }
 
 void
@@ -387,6 +430,10 @@ acc_unmap_data (void *h)
   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
     return;
 
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+
   size_t host_size;
 
   gomp_mutex_lock (&acc_dev->lock);
@@ -408,6 +455,18 @@ acc_unmap_data (void *h)
       gomp_fatal ("[%p,%d] surrounds %p",
 		  (void *) n->host_start, (int) host_size, (void *) h);
     }
+  /* TODO This currently doesn't catch 'REFCOUNT_INFINITY' usage different from
+     'acc_map_data'.  Maybe 'dynamic_refcount' can be used for disambiguating
+     the different 'REFCOUNT_INFINITY' cases, or simply separate
+     'REFCOUNT_INFINITY' values per different usage ('REFCOUNT_ACC_MAP_DATA'
+     etc.)?  */
+  else if (n->refcount != REFCOUNT_INFINITY)
+    {
+      gomp_mutex_unlock (&acc_dev->lock);
+      gomp_fatal ("refusing to unmap block [%p,+%d] that has not been mapped"
+		  " by 'acc_map_data'",
+		  (void *) h, (int) host_size);
+    }
 
   /* Mark for removal.  */
   n->refcount = 1;
@@ -416,30 +475,22 @@ acc_unmap_data (void *h)
 
   if (t->refcount == 2)
     {
-      struct target_mem_desc *tp;
-
       /* This is the last reference, so pull the descriptor off the
          chain. This avoids gomp_unmap_vars via gomp_unmap_tgt from
          freeing the device memory. */
       t->tgt_end = 0;
       t->to_free = 0;
-
-      for (tp = NULL, t = acc_dev->openacc.data_environ; t != NULL;
-	   tp = t, t = t->prev)
-	if (n->tgt == t)
-	  {
-	    if (tp)
-	      tp->prev = t->prev;
-	    else
-	      acc_dev->openacc.data_environ = t->prev;
-
-	    break;
-	  }
     }
 
   gomp_mutex_unlock (&acc_dev->lock);
 
   gomp_unmap_vars (t, true);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
 #define FLAG_PRESENT (1 << 0)
@@ -463,13 +514,22 @@ present_create_copy (unsigned f, void *h, size_t s, int async)
   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
     return h;
 
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    {
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+    }
+
   gomp_mutex_lock (&acc_dev->lock);
 
   n = lookup_host (acc_dev, h, s);
   if (n)
     {
       /* Present. */
-      d = (void *) (n->tgt->tgt_start + n->tgt_offset);
+      d = (void *) (n->tgt->tgt_start + n->tgt_offset + h - n->host_start);
 
       if (!(f & FLAG_PRESENT))
         {
@@ -483,11 +543,11 @@ present_create_copy (unsigned f, void *h, size_t s, int async)
 	  gomp_fatal ("[%p,+%d] not mapped", (void *)h, (int)s);
 	}
 
+      assert (n->refcount != REFCOUNT_LINK);
       if (n->refcount != REFCOUNT_INFINITY)
-	{
-	  n->refcount++;
-	  n->dynamic_refcount++;
-	}
+	n->refcount++;
+      n->dynamic_refcount++;
+
       gomp_mutex_unlock (&acc_dev->lock);
     }
   else if (!(f & FLAG_CREATE))
@@ -509,24 +569,22 @@ present_create_copy (unsigned f, void *h, size_t s, int async)
 
       gomp_mutex_unlock (&acc_dev->lock);
 
-      if (async > acc_async_sync)
-	acc_dev->openacc.async_set_async_func (async);
-
-      tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, NULL, &s, &kinds, true,
-			   GOMP_MAP_VARS_OPENACC);
-      /* Initialize dynamic refcount.  */
-      tgt->list[0].key->dynamic_refcount = 1;
+      goacc_aq aq = get_goacc_asyncqueue (async);
 
-      if (async > acc_async_sync)
-	acc_dev->openacc.async_set_async_func (acc_async_sync);
-
-      gomp_mutex_lock (&acc_dev->lock);
+      tgt = gomp_map_vars_async (acc_dev, aq, mapnum, &hostaddrs, NULL, &s,
+				 &kinds, true, GOMP_MAP_VARS_OPENACC);
+      n = tgt->list[0].key;
+      assert (n->refcount == 1);
+      assert (n->dynamic_refcount == 0);
+      n->dynamic_refcount++;
 
       d = tgt->to_free;
-      tgt->prev = acc_dev->openacc.data_environ;
-      acc_dev->openacc.data_environ = tgt;
+    }
 
-      gomp_mutex_unlock (&acc_dev->lock);
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
     }
 
   return d;
@@ -601,15 +659,22 @@ acc_pcopyin (void *h, size_t s)
 static void
 delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)
 {
-  size_t host_size;
   splay_tree_key n;
-  void *d;
   struct goacc_thread *thr = goacc_thread ();
   struct gomp_device_descr *acc_dev = thr->dev;
 
   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
     return;
 
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    {
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+    }
+
   gomp_mutex_lock (&acc_dev->lock);
 
   n = lookup_host (acc_dev, h, s);
@@ -623,24 +688,17 @@ delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)
       gomp_fatal ("[%p,%d] is not mapped", (void *)h, (int)s);
     }
 
-  d = (void *) (n->tgt->tgt_start + n->tgt_offset
-		+ (uintptr_t) h - n->host_start);
-
-  host_size = n->host_end - n->host_start;
-
-  if (n->host_start != (uintptr_t) h || host_size != s)
+  if ((uintptr_t) h < n->host_start || (uintptr_t) h + s > n->host_end)
     {
+      size_t host_size = n->host_end - n->host_start;
       gomp_mutex_unlock (&acc_dev->lock);
-      gomp_fatal ("[%p,%d] surrounds2 [%p,+%d]",
-		  (void *) n->host_start, (int) host_size, (void *) h, (int) s);
+      gomp_fatal ("[%p,+%d] outside mapped block [%p,+%d]",
+		  (void *) h, (int) s, (void *) n->host_start, (int) host_size);
     }
 
-  if (n->refcount == REFCOUNT_INFINITY)
-    {
-      n->refcount = 0;
-      n->dynamic_refcount = 0;
-    }
-  if (n->refcount < n->dynamic_refcount)
+  assert (n->refcount != REFCOUNT_LINK);
+  if (n->refcount != REFCOUNT_INFINITY
+      && n->refcount < n->dynamic_refcount)
     {
       gomp_mutex_unlock (&acc_dev->lock);
       gomp_fatal ("Dynamic reference counting assert fail\n");
@@ -648,45 +706,37 @@ delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)
 
   if (f & FLAG_FINALIZE)
     {
-      n->refcount -= n->dynamic_refcount;
+      if (n->refcount != REFCOUNT_INFINITY)
+	n->refcount -= n->dynamic_refcount;
       n->dynamic_refcount = 0;
     }
   else if (n->dynamic_refcount)
     {
+      if (n->refcount != REFCOUNT_INFINITY)
+	n->refcount--;
       n->dynamic_refcount--;
-      n->refcount--;
     }
 
   if (n->refcount == 0)
     {
-      if (n->tgt->refcount == 2)
-	{
-	  struct target_mem_desc *tp, *t;
-	  for (tp = NULL, t = acc_dev->openacc.data_environ; t != NULL;
-	       tp = t, t = t->prev)
-	    if (n->tgt == t)
-	      {
-		if (tp)
-		  tp->prev = t->prev;
-		else
-		  acc_dev->openacc.data_environ = t->prev;
-		break;
-	      }
-	}
+      goacc_aq aq = get_goacc_asyncqueue (async);
 
       if (f & FLAG_COPYOUT)
 	{
-	  if (async > acc_async_sync)
-	    acc_dev->openacc.async_set_async_func (async);
-	  acc_dev->dev2host_func (acc_dev->target_id, h, d, s);
-	  if (async > acc_async_sync)
-	    acc_dev->openacc.async_set_async_func (acc_async_sync);
+	  void *d = (void *) (n->tgt->tgt_start + n->tgt_offset
+			      + (uintptr_t) h - n->host_start);
+	  gomp_copy_dev2host (acc_dev, aq, h, d, s);
 	}
-
-      gomp_remove_var (acc_dev, n);
+      gomp_remove_var_async (acc_dev, n, aq);
     }
 
   gomp_mutex_unlock (&acc_dev->lock);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
 void
@@ -752,6 +802,21 @@ update_dev_host (int is_dev, void *h, size_t s, int async)
   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
     return;
 
+  /* Fortran optional arguments that are non-present result in a
+     NULL host address here.  This can safely be ignored as it is
+     not possible to 'update' a non-present optional argument.  */
+  if (h == NULL)
+    return;
+
+  acc_prof_info prof_info;
+  acc_api_info api_info;
+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);
+  if (profiling_p)
+    {
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+    }
+
   gomp_mutex_lock (&acc_dev->lock);
 
   n = lookup_host (acc_dev, h, s);
@@ -765,18 +830,20 @@ update_dev_host (int is_dev, void *h, size_t s, int async)
   d = (void *) (n->tgt->tgt_start + n->tgt_offset
 		+ (uintptr_t) h - n->host_start);
 
-  if (async > acc_async_sync)
-    acc_dev->openacc.async_set_async_func (async);
+  goacc_aq aq = get_goacc_asyncqueue (async);
 
   if (is_dev)
-    acc_dev->host2dev_func (acc_dev->target_id, d, h, s);
+    gomp_copy_host2dev (acc_dev, aq, d, h, s, /* TODO: cbuf? */ NULL);
   else
-    acc_dev->dev2host_func (acc_dev->target_id, h, d, s);
-
-  if (async > acc_async_sync)
-    acc_dev->openacc.async_set_async_func (acc_async_sync);
+    gomp_copy_dev2host (acc_dev, aq, h, d, s);
 
   gomp_mutex_unlock (&acc_dev->lock);
+
+  if (profiling_p)
+    {
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
 void
@@ -803,19 +870,33 @@ acc_update_self_async (void *h, size_t s, int async)
   update_dev_host (0, h, s, async);
 }
 
-void
-gomp_acc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,
-			 void *kinds)
+
+/* OpenACC 'enter data', 'exit data': 'GOACC_enter_exit_data' and its helper
+   functions.  */
+
+/* Special handling for 'GOMP_MAP_POINTER', 'GOMP_MAP_TO_PSET'.
+
+   Only the first mapping is considered in reference counting; the following
+   ones implicitly follow suit.  */
+
+static void
+goacc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,
+		      void *kinds, int async)
 {
   struct target_mem_desc *tgt;
   struct goacc_thread *thr = goacc_thread ();
   struct gomp_device_descr *acc_dev = thr->dev;
 
+  if (*hostaddrs == NULL)
+    return;
+
   if (acc_is_present (*hostaddrs, *sizes))
     {
       splay_tree_key n;
       gomp_mutex_lock (&acc_dev->lock);
       n = lookup_host (acc_dev, *hostaddrs, *sizes);
+      assert (n->refcount != REFCOUNT_INFINITY
+	      && n->refcount != REFCOUNT_LINK);
       gomp_mutex_unlock (&acc_dev->lock);
 
       tgt = n->tgt;
@@ -835,22 +916,19 @@ gomp_acc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,
     }
 
   gomp_debug (0, "  %s: prepare mappings\n", __FUNCTION__);
-  tgt = gomp_map_vars (acc_dev, mapnum, hostaddrs,
-		       NULL, sizes, kinds, true, GOMP_MAP_VARS_OPENACC);
+  goacc_aq aq = get_goacc_asyncqueue (async);
+  tgt = gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs,
+			     NULL, sizes, kinds, true, GOMP_MAP_VARS_OPENACC);
+  splay_tree_key n = tgt->list[0].key;
+  assert (n->refcount == 1);
+  assert (n->dynamic_refcount == 0);
+  n->dynamic_refcount++;
   gomp_debug (0, "  %s: mappings prepared\n", __FUNCTION__);
-
-  /* Initialize dynamic refcount.  */
-  tgt->list[0].key->dynamic_refcount = 1;
-
-  gomp_mutex_lock (&acc_dev->lock);
-  tgt->prev = acc_dev->openacc.data_environ;
-  acc_dev->openacc.data_environ = tgt;
-  gomp_mutex_unlock (&acc_dev->lock);
 }
 
-void
-gomp_acc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,
-			 int finalize, int mapnum)
+static void
+goacc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,
+		      int finalize, int mapnum)
 {
   struct goacc_thread *thr = goacc_thread ();
   struct gomp_device_descr *acc_dev = thr->dev;
@@ -875,6 +953,8 @@ gomp_acc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,
 
   t = n->tgt;
 
+  assert (n->refcount != REFCOUNT_INFINITY
+	  && n->refcount != REFCOUNT_LINK);
   if (n->refcount < n->dynamic_refcount)
     {
       gomp_mutex_unlock (&acc_dev->lock);
@@ -888,34 +968,14 @@ gomp_acc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,
     }
   else if (n->dynamic_refcount)
     {
-      n->dynamic_refcount--;
       n->refcount--;
+      n->dynamic_refcount--;
     }
 
   gomp_mutex_unlock (&acc_dev->lock);
 
   if (n->refcount == 0)
     {
-      if (t->refcount == minrefs)
-	{
-	  /* This is the last reference, so pull the descriptor off the
-	     chain. This prevents gomp_unmap_vars via gomp_unmap_tgt from
-	     freeing the device memory. */
-	  struct target_mem_desc *tp;
-	  for (tp = NULL, t = acc_dev->openacc.data_environ; t != NULL;
-	       tp = t, t = t->prev)
-	    {
-	      if (n->tgt == t)
-		{
-		  if (tp)
-		    tp->prev = t->prev;
-		  else
-		    acc_dev->openacc.data_environ = t->prev;
-		  break;
-		}
-	    }
-	}
-
       /* Set refcount to 1 to allow gomp_unmap_vars to unmap it.  */
       n->refcount = 1;
       t->refcount = minrefs;
@@ -930,10 +990,266 @@ gomp_acc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,
       if (async < acc_async_noval)
 	gomp_unmap_vars (t, true);
       else
-	t->device_descr->openacc.register_async_cleanup_func (t, async);
+	{
+	  goacc_aq aq = get_goacc_asyncqueue (async);
+	  gomp_unmap_vars_async (t, true, aq);
+	}
     }
 
   gomp_mutex_unlock (&acc_dev->lock);
 
   gomp_debug (0, "  %s: mappings restored\n", __FUNCTION__);
 }
+
+/* Return the number of mappings associated with 'GOMP_MAP_TO_PSET' or
+   'GOMP_MAP_POINTER'.  */
+
+static int
+find_pointer (int pos, size_t mapnum, unsigned short *kinds)
+{
+  if (pos + 1 >= mapnum)
+    return 0;
+
+  unsigned char kind = kinds[pos+1] & 0xff;
+
+  if (kind == GOMP_MAP_TO_PSET)
+    return 3;
+  else if (kind == GOMP_MAP_POINTER)
+    return 2;
+
+  return 0;
+}
+
+void
+GOACC_enter_exit_data (int flags_m, size_t mapnum, void **hostaddrs,
+		       size_t *sizes, unsigned short *kinds, int async,
+		       int num_waits, ...)
+{
+  int flags = GOACC_FLAGS_UNMARSHAL (flags_m);
+
+  struct goacc_thread *thr;
+  struct gomp_device_descr *acc_dev;
+  bool data_enter = false;
+  size_t i;
+
+  goacc_lazy_initialize ();
+
+  thr = goacc_thread ();
+  acc_dev = thr->dev;
+
+  /* Determine whether "finalize" semantics apply to all mappings of this
+     OpenACC directive.  */
+  bool finalize = false;
+  if (mapnum > 0)
+    {
+      unsigned char kind = kinds[0] & 0xff;
+      if (kind == GOMP_MAP_DELETE
+	  || kind == GOMP_MAP_FORCE_FROM)
+	finalize = true;
+    }
+
+  /* Determine if this is an "acc enter data".  */
+  for (i = 0; i < mapnum; ++i)
+    {
+      unsigned char kind = kinds[i] & 0xff;
+
+      if (kind == GOMP_MAP_POINTER || kind == GOMP_MAP_TO_PSET)
+	continue;
+
+      if (kind == GOMP_MAP_FORCE_ALLOC
+	  || kind == GOMP_MAP_FORCE_PRESENT
+	  || kind == GOMP_MAP_FORCE_TO
+	  || kind == GOMP_MAP_TO
+	  || kind == GOMP_MAP_ALLOC)
+	{
+	  data_enter = true;
+	  break;
+	}
+
+      if (kind == GOMP_MAP_RELEASE
+	  || kind == GOMP_MAP_DELETE
+	  || kind == GOMP_MAP_FROM
+	  || kind == GOMP_MAP_FORCE_FROM)
+	break;
+
+      gomp_fatal (">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x",
+		      kind);
+    }
+
+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);
+
+  acc_prof_info prof_info;
+  if (profiling_p)
+    {
+      thr->prof_info = &prof_info;
+
+      prof_info.event_type
+	= data_enter ? acc_ev_enter_data_start : acc_ev_exit_data_start;
+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;
+      prof_info.version = _ACC_PROF_INFO_VERSION;
+      prof_info.device_type = acc_device_type (acc_dev->type);
+      prof_info.device_number = acc_dev->target_id;
+      prof_info.thread_id = -1;
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+      prof_info.src_file = NULL;
+      prof_info.func_name = NULL;
+      prof_info.line_no = -1;
+      prof_info.end_line_no = -1;
+      prof_info.func_line_no = -1;
+      prof_info.func_end_line_no = -1;
+    }
+  acc_event_info enter_exit_data_event_info;
+  if (profiling_p)
+    {
+      enter_exit_data_event_info.other_event.event_type
+	= prof_info.event_type;
+      enter_exit_data_event_info.other_event.valid_bytes
+	= _ACC_OTHER_EVENT_INFO_VALID_BYTES;
+      enter_exit_data_event_info.other_event.parent_construct
+	= data_enter ? acc_construct_enter_data : acc_construct_exit_data;
+      enter_exit_data_event_info.other_event.implicit = 0;
+      enter_exit_data_event_info.other_event.tool_info = NULL;
+    }
+  acc_api_info api_info;
+  if (profiling_p)
+    {
+      thr->api_info = &api_info;
+
+      api_info.device_api = acc_device_api_none;
+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;
+      api_info.device_type = prof_info.device_type;
+      api_info.vendor = -1;
+      api_info.device_handle = NULL;
+      api_info.context_handle = NULL;
+      api_info.async_handle = NULL;
+    }
+
+  if (profiling_p)
+    goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,
+			      &api_info);
+
+  if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
+      || (flags & GOACC_FLAG_HOST_FALLBACK))
+    {
+      prof_info.device_type = acc_device_host;
+      api_info.device_type = prof_info.device_type;
+
+      goto out_prof;
+    }
+
+  if (num_waits)
+    {
+      va_list ap;
+
+      va_start (ap, num_waits);
+      goacc_wait (async, num_waits, &ap);
+      va_end (ap);
+    }
+
+  /* In c, non-pointers and arrays are represented by a single data clause.
+     Dynamically allocated arrays and subarrays are represented by a data
+     clause followed by an internal GOMP_MAP_POINTER.
+
+     In fortran, scalars and not allocated arrays are represented by a
+     single data clause. Allocated arrays and subarrays have three mappings:
+     1) the original data clause, 2) a PSET 3) a pointer to the array data.
+  */
+
+  if (data_enter)
+    {
+      for (i = 0; i < mapnum; i++)
+	{
+	  unsigned char kind = kinds[i] & 0xff;
+
+	  /* Scan for pointers and PSETs.  */
+	  int pointer = find_pointer (i, mapnum, kinds);
+
+	  if (!pointer)
+	    {
+	      switch (kind)
+		{
+		case GOMP_MAP_ALLOC:
+		case GOMP_MAP_FORCE_ALLOC:
+		  acc_create_async (hostaddrs[i], sizes[i], async);
+		  break;
+		case GOMP_MAP_TO:
+		case GOMP_MAP_FORCE_TO:
+		  acc_copyin_async (hostaddrs[i], sizes[i], async);
+		  break;
+		default:
+		  gomp_fatal (">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x",
+			      kind);
+		  break;
+		}
+	    }
+	  else
+	    {
+	      goacc_insert_pointer (pointer, &hostaddrs[i], &sizes[i], &kinds[i],
+				    async);
+	      /* Increment 'i' by two because OpenACC requires fortran
+		 arrays to be contiguous, so each PSET is associated with
+		 one of MAP_FORCE_ALLOC/MAP_FORCE_PRESET/MAP_FORCE_TO, and
+		 one MAP_POINTER.  */
+	      i += pointer - 1;
+	    }
+	}
+    }
+  else
+    for (i = 0; i < mapnum; ++i)
+      {
+	unsigned char kind = kinds[i] & 0xff;
+
+	int pointer = find_pointer (i, mapnum, kinds);
+
+	if (!pointer)
+	  {
+	    switch (kind)
+	      {
+	      case GOMP_MAP_RELEASE:
+	      case GOMP_MAP_DELETE:
+		if (acc_is_present (hostaddrs[i], sizes[i]))
+		  {
+		    if (finalize)
+		      acc_delete_finalize_async (hostaddrs[i], sizes[i], async);
+		    else
+		      acc_delete_async (hostaddrs[i], sizes[i], async);
+		  }
+		break;
+	      case GOMP_MAP_FROM:
+	      case GOMP_MAP_FORCE_FROM:
+		if (finalize)
+		  acc_copyout_finalize_async (hostaddrs[i], sizes[i], async);
+		else
+		  acc_copyout_async (hostaddrs[i], sizes[i], async);
+		break;
+	      default:
+		gomp_fatal (">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x",
+			    kind);
+		break;
+	      }
+	  }
+	else
+	  {
+	    bool copyfrom = (kind == GOMP_MAP_FORCE_FROM
+			     || kind == GOMP_MAP_FROM);
+	    goacc_remove_pointer (hostaddrs[i], sizes[i], copyfrom, async,
+				  finalize, pointer);
+	    /* See the above comment.  */
+	    i += pointer - 1;
+	  }
+      }
+
+ out_prof:
+  if (profiling_p)
+    {
+      prof_info.event_type
+	= data_enter ? acc_ev_enter_data_end : acc_ev_exit_data_end;
+      enter_exit_data_event_info.other_event.event_type = prof_info.event_type;
+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,
+				&api_info);
+
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
+}
diff --git a/libgomp/oacc-parallel.c b/libgomp/oacc-parallel.c
index b77c5e8b9c5..5c13a7e4348 100644
--- a/libgomp/oacc-parallel.c
+++ b/libgomp/oacc-parallel.c
@@ -28,7 +28,6 @@
 
 #include "openacc.h"
 #include "libgomp.h"
-#include "libgomp_g.h"
 #include "gomp-constants.h"
 #include "oacc-int.h"
 #ifdef HAVE_INTTYPES_H
@@ -48,25 +47,6 @@ _Static_assert (GOACC_FLAGS_UNMARSHAL (GOMP_DEVICE_HOST_FALLBACK)
 		"legacy GOMP_DEVICE_HOST_FALLBACK broken");
 
 
-/* Returns the number of mappings associated with the pointer or pset. PSET
-   have three mappings, whereas pointer have two.  */
-
-static int
-find_pointer (int pos, size_t mapnum, unsigned short *kinds)
-{
-  if (pos + 1 >= mapnum)
-    return 0;
-
-  unsigned char kind = kinds[pos+1] & 0xff;
-
-  if (kind == GOMP_MAP_TO_PSET)
-    return 3;
-  else if (kind == GOMP_MAP_POINTER)
-    return 2;
-
-  return 0;
-}
-
 /* Handle the mapping pair that are presented when a
    deviceptr clause is used with Fortran.  */
 
@@ -112,8 +92,6 @@ handle_ftn_pointers (size_t mapnum, void **hostaddrs, size_t *sizes,
     }
 }
 
-static void goacc_wait (int async, int num_waits, va_list *ap);
-
 
 /* Launch a possibly offloaded function with FLAGS.  FN is the host fn
    address.  MAPNUM, HOSTADDRS, SIZES & KINDS  describe the memory
@@ -152,21 +130,75 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),
   thr = goacc_thread ();
   acc_dev = thr->dev;
 
+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);
+
+  acc_prof_info prof_info;
+  if (profiling_p)
+    {
+      thr->prof_info = &prof_info;
+
+      prof_info.event_type = acc_ev_compute_construct_start;
+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;
+      prof_info.version = _ACC_PROF_INFO_VERSION;
+      prof_info.device_type = acc_device_type (acc_dev->type);
+      prof_info.device_number = acc_dev->target_id;
+      prof_info.thread_id = -1;
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+      prof_info.src_file = NULL;
+      prof_info.func_name = NULL;
+      prof_info.line_no = -1;
+      prof_info.end_line_no = -1;
+      prof_info.func_line_no = -1;
+      prof_info.func_end_line_no = -1;
+    }
+  acc_event_info compute_construct_event_info;
+  if (profiling_p)
+    {
+      compute_construct_event_info.other_event.event_type
+	= prof_info.event_type;
+      compute_construct_event_info.other_event.valid_bytes
+	= _ACC_OTHER_EVENT_INFO_VALID_BYTES;
+      compute_construct_event_info.other_event.parent_construct
+	= acc_construct_parallel;
+      compute_construct_event_info.other_event.implicit = 0;
+      compute_construct_event_info.other_event.tool_info = NULL;
+    }
+  acc_api_info api_info;
+  if (profiling_p)
+    {
+      thr->api_info = &api_info;
+
+      api_info.device_api = acc_device_api_none;
+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;
+      api_info.device_type = prof_info.device_type;
+      api_info.vendor = -1;
+      api_info.device_handle = NULL;
+      api_info.context_handle = NULL;
+      api_info.async_handle = NULL;
+    }
+
+  if (profiling_p)
+    goacc_profiling_dispatch (&prof_info, &compute_construct_event_info,
+			      &api_info);
+
   handle_ftn_pointers (mapnum, hostaddrs, sizes, kinds);
 
   /* Host fallback if "if" clause is false or if the current device is set to
      the host.  */
   if (flags & GOACC_FLAG_HOST_FALLBACK)
     {
+      prof_info.device_type = acc_device_host;
+      api_info.device_type = prof_info.device_type;
       goacc_save_and_set_bind (acc_device_host);
       fn (hostaddrs);
       goacc_restore_bind ();
-      return;
+      goto out_prof;
     }
   else if (acc_device_type (acc_dev->type) == acc_device_host)
     {
       fn (hostaddrs);
-      return;
+      goto out_prof;
     }
 
   /* Default: let the runtime choose.  */
@@ -200,6 +232,13 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),
 
 	    if (async == GOMP_LAUNCH_OP_MAX)
 	      async = va_arg (ap, unsigned);
+
+	    if (profiling_p)
+	      {
+		prof_info.async = async;
+		prof_info.async_queue = prof_info.async;
+	      }
+
 	    break;
 	  }
 
@@ -217,8 +256,6 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),
     }
   va_end (ap);
   
-  acc_dev->openacc.async_set_async_func (async);
-
   if (!(acc_dev->capabilities & GOMP_OFFLOAD_CAP_NATIVE_EXEC))
     {
       k.host_start = (uintptr_t) fn;
@@ -235,47 +272,88 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),
   else
     tgt_fn = (void (*)) fn;
 
-  tgt = gomp_map_vars (acc_dev, mapnum, hostaddrs, NULL, sizes, kinds, true,
-		       GOMP_MAP_VARS_OPENACC);
+  acc_event_info enter_exit_data_event_info;
+  if (profiling_p)
+    {
+      prof_info.event_type = acc_ev_enter_data_start;
+      enter_exit_data_event_info.other_event.event_type
+	= prof_info.event_type;
+      enter_exit_data_event_info.other_event.valid_bytes
+	= _ACC_OTHER_EVENT_INFO_VALID_BYTES;
+      enter_exit_data_event_info.other_event.parent_construct
+	= compute_construct_event_info.other_event.parent_construct;
+      enter_exit_data_event_info.other_event.implicit = 1;
+      enter_exit_data_event_info.other_event.tool_info = NULL;
+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,
+				&api_info);
+    }
+
+  goacc_aq aq = get_goacc_asyncqueue (async);
 
+  tgt = gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs, NULL, sizes, kinds,
+			     true, GOMP_MAP_VARS_OPENACC);
+  if (profiling_p)
+    {
+      prof_info.event_type = acc_ev_enter_data_end;
+      enter_exit_data_event_info.other_event.event_type
+	= prof_info.event_type;
+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,
+				&api_info);
+    }
+  
   devaddrs = gomp_alloca (sizeof (void *) * mapnum);
   for (i = 0; i < mapnum; i++)
-    devaddrs[i] = (void *) (tgt->list[i].key->tgt->tgt_start
-			    + tgt->list[i].key->tgt_offset
-			    + tgt->list[i].offset);
+    if (tgt->list[i].key != NULL)
+      devaddrs[i] = (void *) (tgt->list[i].key->tgt->tgt_start
+			      + tgt->list[i].key->tgt_offset
+			      + tgt->list[i].offset);
+    else
+      devaddrs[i] = NULL;
+  if (aq == NULL)
+    acc_dev->openacc.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs, dims,
+				tgt);
+  else
+    acc_dev->openacc.async.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs,
+				      dims, tgt, aq);
 
-  acc_dev->openacc.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs,
-			      async, dims, tgt);
+  if (profiling_p)
+    {
+      prof_info.event_type = acc_ev_exit_data_start;
+      enter_exit_data_event_info.other_event.event_type = prof_info.event_type;
+      enter_exit_data_event_info.other_event.tool_info = NULL;
+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,
+				&api_info);
+    }
 
   /* If running synchronously, unmap immediately.  */
-  bool copyfrom = true;
-  if (async_synchronous_p (async))
+  if (aq == NULL)
     gomp_unmap_vars (tgt, true);
   else
+    gomp_unmap_vars_async (tgt, true, aq);
+
+  if (profiling_p)
     {
-      bool async_unmap = false;
-      for (size_t i = 0; i < tgt->list_count; i++)
-	{
-	  splay_tree_key k = tgt->list[i].key;
-	  if (k && k->refcount == 1)
-	    {
-	      async_unmap = true;
-	      break;
-	    }
-	}
-      if (async_unmap)
-	tgt->device_descr->openacc.register_async_cleanup_func (tgt, async);
-      else
-	{
-	  copyfrom = false;
-	  gomp_unmap_vars (tgt, copyfrom);
-	}
+      prof_info.event_type = acc_ev_exit_data_end;
+      enter_exit_data_event_info.other_event.event_type = prof_info.event_type;
+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,
+				&api_info);
     }
 
-  acc_dev->openacc.async_set_async_func (acc_async_sync);
+ out_prof:
+  if (profiling_p)
+    {
+      prof_info.event_type = acc_ev_compute_construct_end;
+      compute_construct_event_info.other_event.event_type
+	= prof_info.event_type;
+      goacc_profiling_dispatch (&prof_info, &compute_construct_event_info,
+				&api_info);
+
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
-/* Legacy entry point, only provide host execution.  */
+/* Legacy entry point (GCC 5).  Only provide host fallback execution.  */
 
 void
 GOACC_parallel (int flags_m, void (*fn) (void *),
@@ -310,16 +388,83 @@ GOACC_data_start (int flags_m, size_t mapnum,
   struct goacc_thread *thr = goacc_thread ();
   struct gomp_device_descr *acc_dev = thr->dev;
 
+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);
+
+  acc_prof_info prof_info;
+  if (profiling_p)
+    {
+      thr->prof_info = &prof_info;
+
+      prof_info.event_type = acc_ev_enter_data_start;
+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;
+      prof_info.version = _ACC_PROF_INFO_VERSION;
+      prof_info.device_type = acc_device_type (acc_dev->type);
+      prof_info.device_number = acc_dev->target_id;
+      prof_info.thread_id = -1;
+      prof_info.async = acc_async_sync; /* Always synchronous.  */
+      prof_info.async_queue = prof_info.async;
+      prof_info.src_file = NULL;
+      prof_info.func_name = NULL;
+      prof_info.line_no = -1;
+      prof_info.end_line_no = -1;
+      prof_info.func_line_no = -1;
+      prof_info.func_end_line_no = -1;
+    }
+  acc_event_info enter_data_event_info;
+  if (profiling_p)
+    {
+      enter_data_event_info.other_event.event_type
+	= prof_info.event_type;
+      enter_data_event_info.other_event.valid_bytes
+	= _ACC_OTHER_EVENT_INFO_VALID_BYTES;
+      enter_data_event_info.other_event.parent_construct = acc_construct_data;
+      for (int i = 0; i < mapnum; ++i)
+	if ((kinds[i] & 0xff) == GOMP_MAP_USE_DEVICE_PTR)
+	  {
+	    /* If there is one such data mapping kind, then this is actually an
+	       OpenACC 'host_data' construct.  (GCC maps the OpenACC
+	       'host_data' construct to the OpenACC 'data' construct.)  Apart
+	       from artificial test cases (such as an OpenACC 'host_data'
+	       construct's (implicit) device initialization when there hasn't
+	       been any device data be set up before...), there can't really
+	       any meaningful events be generated from OpenACC 'host_data'
+	       constructs, though.  */
+	    enter_data_event_info.other_event.parent_construct
+	      = acc_construct_host_data;
+	    break;
+	  }
+      enter_data_event_info.other_event.implicit = 0;
+      enter_data_event_info.other_event.tool_info = NULL;
+    }
+  acc_api_info api_info;
+  if (profiling_p)
+    {
+      thr->api_info = &api_info;
+
+      api_info.device_api = acc_device_api_none;
+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;
+      api_info.device_type = prof_info.device_type;
+      api_info.vendor = -1;
+      api_info.device_handle = NULL;
+      api_info.context_handle = NULL;
+      api_info.async_handle = NULL;
+    }
+
+  if (profiling_p)
+    goacc_profiling_dispatch (&prof_info, &enter_data_event_info, &api_info);
+
   /* Host fallback or 'do nothing'.  */
   if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
       || (flags & GOACC_FLAG_HOST_FALLBACK))
     {
+      prof_info.device_type = acc_device_host;
+      api_info.device_type = prof_info.device_type;
       tgt = gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, true,
 			   GOMP_MAP_VARS_OPENACC);
       tgt->prev = thr->mapped_data;
       thr->mapped_data = tgt;
 
-      return;
+      goto out_prof;
     }
 
   gomp_debug (0, "  %s: prepare mappings\n", __FUNCTION__);
@@ -328,215 +473,89 @@ GOACC_data_start (int flags_m, size_t mapnum,
   gomp_debug (0, "  %s: mappings prepared\n", __FUNCTION__);
   tgt->prev = thr->mapped_data;
   thr->mapped_data = tgt;
+
+ out_prof:
+  if (profiling_p)
+    {
+      prof_info.event_type = acc_ev_enter_data_end;
+      enter_data_event_info.other_event.event_type = prof_info.event_type;
+      goacc_profiling_dispatch (&prof_info, &enter_data_event_info, &api_info);
+
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
+    }
 }
 
 void
 GOACC_data_end (void)
 {
   struct goacc_thread *thr = goacc_thread ();
+  struct gomp_device_descr *acc_dev = thr->dev;
   struct target_mem_desc *tgt = thr->mapped_data;
 
-  gomp_debug (0, "  %s: restore mappings\n", __FUNCTION__);
-  thr->mapped_data = tgt->prev;
-  gomp_unmap_vars (tgt, true);
-  gomp_debug (0, "  %s: mappings restored\n", __FUNCTION__);
-}
-
-void
-GOACC_enter_exit_data (int flags_m, size_t mapnum,
-		       void **hostaddrs, size_t *sizes, unsigned short *kinds,
-		       int async, int num_waits, ...)
-{
-  int flags = GOACC_FLAGS_UNMARSHAL (flags_m);
-
-  struct goacc_thread *thr;
-  struct gomp_device_descr *acc_dev;
-  bool data_enter = false;
-  size_t i;
-
-  goacc_lazy_initialize ();
-
-  thr = goacc_thread ();
-  acc_dev = thr->dev;
-
-  if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
-      || (flags & GOACC_FLAG_HOST_FALLBACK))
-    return;
-
-  if (num_waits)
-    {
-      va_list ap;
+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);
 
-      va_start (ap, num_waits);
-      goacc_wait (async, num_waits, &ap);
-      va_end (ap);
-    }
-
-  /* Determine whether "finalize" semantics apply to all mappings of this
-     OpenACC directive.  */
-  bool finalize = false;
-  if (mapnum > 0)
+  acc_prof_info prof_info;
+  if (profiling_p)
     {
-      unsigned char kind = kinds[0] & 0xff;
-      if (kind == GOMP_MAP_DELETE
-	  || kind == GOMP_MAP_FORCE_FROM)
-	finalize = true;
+      thr->prof_info = &prof_info;
+
+      prof_info.event_type = acc_ev_exit_data_start;
+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;
+      prof_info.version = _ACC_PROF_INFO_VERSION;
+      prof_info.device_type = acc_device_type (acc_dev->type);
+      prof_info.device_number = acc_dev->target_id;
+      prof_info.thread_id = -1;
+      prof_info.async = acc_async_sync; /* Always synchronous.  */
+      prof_info.async_queue = prof_info.async;
+      prof_info.src_file = NULL;
+      prof_info.func_name = NULL;
+      prof_info.line_no = -1;
+      prof_info.end_line_no = -1;
+      prof_info.func_line_no = -1;
+      prof_info.func_end_line_no = -1;
     }
-
-  acc_dev->openacc.async_set_async_func (async);
-
-  /* Determine if this is an "acc enter data".  */
-  for (i = 0; i < mapnum; ++i)
+  acc_event_info exit_data_event_info;
+  if (profiling_p)
     {
-      unsigned char kind = kinds[i] & 0xff;
-
-      if (kind == GOMP_MAP_POINTER || kind == GOMP_MAP_TO_PSET)
-	continue;
-
-      if (kind == GOMP_MAP_FORCE_ALLOC
-	  || kind == GOMP_MAP_FORCE_PRESENT
-	  || kind == GOMP_MAP_FORCE_TO
-	  || kind == GOMP_MAP_TO
-	  || kind == GOMP_MAP_ALLOC)
-	{
-	  data_enter = true;
-	  break;
-	}
-
-      if (kind == GOMP_MAP_RELEASE
-	  || kind == GOMP_MAP_DELETE
-	  || kind == GOMP_MAP_FROM
-	  || kind == GOMP_MAP_FORCE_FROM)
-	break;
-
-      gomp_fatal (">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x",
-		      kind);
+      exit_data_event_info.other_event.event_type
+	= prof_info.event_type;
+      exit_data_event_info.other_event.valid_bytes
+	= _ACC_OTHER_EVENT_INFO_VALID_BYTES;
+      exit_data_event_info.other_event.parent_construct = acc_construct_data;
+      exit_data_event_info.other_event.implicit = 0;
+      exit_data_event_info.other_event.tool_info = NULL;
     }
-
-  /* In c, non-pointers and arrays are represented by a single data clause.
-     Dynamically allocated arrays and subarrays are represented by a data
-     clause followed by an internal GOMP_MAP_POINTER.
-
-     In fortran, scalars and not allocated arrays are represented by a
-     single data clause. Allocated arrays and subarrays have three mappings:
-     1) the original data clause, 2) a PSET 3) a pointer to the array data.
-  */
-
-  if (data_enter)
+  acc_api_info api_info;
+  if (profiling_p)
     {
-      for (i = 0; i < mapnum; i++)
-	{
-	  unsigned char kind = kinds[i] & 0xff;
-
-	  /* Scan for pointers and PSETs.  */
-	  int pointer = find_pointer (i, mapnum, kinds);
-
-	  if (!pointer)
-	    {
-	      switch (kind)
-		{
-		case GOMP_MAP_ALLOC:
-		case GOMP_MAP_FORCE_ALLOC:
-		  acc_create (hostaddrs[i], sizes[i]);
-		  break;
-		case GOMP_MAP_TO:
-		case GOMP_MAP_FORCE_TO:
-		  acc_copyin (hostaddrs[i], sizes[i]);
-		  break;
-		default:
-		  gomp_fatal (">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x",
-			      kind);
-		  break;
-		}
-	    }
-	  else
-	    {
-	      gomp_acc_insert_pointer (pointer, &hostaddrs[i],
-				       &sizes[i], &kinds[i]);
-	      /* Increment 'i' by two because OpenACC requires fortran
-		 arrays to be contiguous, so each PSET is associated with
-		 one of MAP_FORCE_ALLOC/MAP_FORCE_PRESET/MAP_FORCE_TO, and
-		 one MAP_POINTER.  */
-	      i += pointer - 1;
-	    }
-	}
+      thr->api_info = &api_info;
+
+      api_info.device_api = acc_device_api_none;
+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;
+      api_info.device_type = prof_info.device_type;
+      api_info.vendor = -1;
+      api_info.device_handle = NULL;
+      api_info.context_handle = NULL;
+      api_info.async_handle = NULL;
     }
-  else
-    for (i = 0; i < mapnum; ++i)
-      {
-	unsigned char kind = kinds[i] & 0xff;
-
-	int pointer = find_pointer (i, mapnum, kinds);
 
-	if (!pointer)
-	  {
-	    switch (kind)
-	      {
-	      case GOMP_MAP_RELEASE:
-	      case GOMP_MAP_DELETE:
-		if (acc_is_present (hostaddrs[i], sizes[i]))
-		  {
-		    if (finalize)
-		      acc_delete_finalize (hostaddrs[i], sizes[i]);
-		    else
-		      acc_delete (hostaddrs[i], sizes[i]);
-		  }
-		break;
-	      case GOMP_MAP_FROM:
-	      case GOMP_MAP_FORCE_FROM:
-		if (finalize)
-		  acc_copyout_finalize (hostaddrs[i], sizes[i]);
-		else
-		  acc_copyout (hostaddrs[i], sizes[i]);
-		break;
-	      default:
-		gomp_fatal (">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x",
-			    kind);
-		break;
-	      }
-	  }
-	else
-	  {
-	    bool copyfrom = (kind == GOMP_MAP_FORCE_FROM
-			     || kind == GOMP_MAP_FROM);
-	    gomp_acc_remove_pointer (hostaddrs[i], sizes[i], copyfrom, async,
-				     finalize, pointer);
-	    /* See the above comment.  */
-	    i += pointer - 1;
-	  }
-      }
+  if (profiling_p)
+    goacc_profiling_dispatch (&prof_info, &exit_data_event_info, &api_info);
 
-  acc_dev->openacc.async_set_async_func (acc_async_sync);
-}
+  gomp_debug (0, "  %s: restore mappings\n", __FUNCTION__);
+  thr->mapped_data = tgt->prev;
+  gomp_unmap_vars (tgt, true);
+  gomp_debug (0, "  %s: mappings restored\n", __FUNCTION__);
 
-static void
-goacc_wait (int async, int num_waits, va_list *ap)
-{
-  while (num_waits--)
+  if (profiling_p)
     {
-      int qid = va_arg (*ap, int);
+      prof_info.event_type = acc_ev_exit_data_end;
+      exit_data_event_info.other_event.event_type = prof_info.event_type;
+      goacc_profiling_dispatch (&prof_info, &exit_data_event_info, &api_info);
 
-      /* Waiting on ACC_ASYNC_NOVAL maps to 'wait all'.  */
-      if (qid == acc_async_noval)
-	{
-	  if (async == acc_async_sync)
-	    acc_wait_all ();
-	  else
-	    acc_wait_all_async (async);
-	  break;
-	}
-
-      if (acc_async_test (qid))
-	continue;
-
-      if (async == acc_async_sync)
-	acc_wait (qid);
-      else if (qid == async)
-	;/* If we're waiting on the same asynchronous queue as we're
-	    launching on, the queue itself will order work as
-	    required, so there's no need to wait explicitly.  */
-      else
-	acc_wait_async (qid, async);
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
     }
 }
 
@@ -554,9 +573,64 @@ GOACC_update (int flags_m, size_t mapnum,
   struct goacc_thread *thr = goacc_thread ();
   struct gomp_device_descr *acc_dev = thr->dev;
 
+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);
+
+  acc_prof_info prof_info;
+  if (profiling_p)
+    {
+      thr->prof_info = &prof_info;
+
+      prof_info.event_type = acc_ev_update_start;
+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;
+      prof_info.version = _ACC_PROF_INFO_VERSION;
+      prof_info.device_type = acc_device_type (acc_dev->type);
+      prof_info.device_number = acc_dev->target_id;
+      prof_info.thread_id = -1;
+      prof_info.async = async;
+      prof_info.async_queue = prof_info.async;
+      prof_info.src_file = NULL;
+      prof_info.func_name = NULL;
+      prof_info.line_no = -1;
+      prof_info.end_line_no = -1;
+      prof_info.func_line_no = -1;
+      prof_info.func_end_line_no = -1;
+    }
+  acc_event_info update_event_info;
+  if (profiling_p)
+    {
+      update_event_info.other_event.event_type
+	= prof_info.event_type;
+      update_event_info.other_event.valid_bytes
+	= _ACC_OTHER_EVENT_INFO_VALID_BYTES;
+      update_event_info.other_event.parent_construct = acc_construct_update;
+      update_event_info.other_event.implicit = 0;
+      update_event_info.other_event.tool_info = NULL;
+    }
+  acc_api_info api_info;
+  if (profiling_p)
+    {
+      thr->api_info = &api_info;
+
+      api_info.device_api = acc_device_api_none;
+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;
+      api_info.device_type = prof_info.device_type;
+      api_info.vendor = -1;
+      api_info.device_handle = NULL;
+      api_info.context_handle = NULL;
+      api_info.async_handle = NULL;
+    }
+
+  if (profiling_p)
+    goacc_profiling_dispatch (&prof_info, &update_event_info, &api_info);
+
   if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)
       || (flags & GOACC_FLAG_HOST_FALLBACK))
-    return;
+    {
+      prof_info.device_type = acc_device_host;
+      api_info.device_type = prof_info.device_type;
+
+      goto out_prof;
+    }
 
   if (num_waits)
     {
@@ -567,8 +641,6 @@ GOACC_update (int flags_m, size_t mapnum,
       va_end (ap);
     }
 
-  acc_dev->openacc.async_set_async_func (async);
-
   bool update_device = false;
   for (i = 0; i < mapnum; ++i)
     {
@@ -591,6 +663,8 @@ GOACC_update (int flags_m, size_t mapnum,
 		 the value of the allocated device memory in the
 		 previous pointer.  */
 	      *(uintptr_t *) hostaddrs[i] = (uintptr_t)dptr;
+	      /* TODO: verify that we really cannot use acc_update_device_async
+		 here.  */
 	      acc_update_device (hostaddrs[i], sizeof (uintptr_t));
 
 	      /* Restore the host pointer.  */
@@ -608,7 +682,7 @@ GOACC_update (int flags_m, size_t mapnum,
 	  /* Fallthru  */
 	case GOMP_MAP_FORCE_TO:
 	  update_device = true;
-	  acc_update_device (hostaddrs[i], sizes[i]);
+	  acc_update_device_async (hostaddrs[i], sizes[i], async);
 	  break;
 
 	case GOMP_MAP_FROM:
@@ -620,7 +694,7 @@ GOACC_update (int flags_m, size_t mapnum,
 	  /* Fallthru  */
 	case GOMP_MAP_FORCE_FROM:
 	  update_device = false;
-	  acc_update_self (hostaddrs[i], sizes[i]);
+	  acc_update_self_async (hostaddrs[i], sizes[i], async);
 	  break;
 
 	default:
@@ -629,32 +703,29 @@ GOACC_update (int flags_m, size_t mapnum,
 	}
     }
 
-  acc_dev->openacc.async_set_async_func (acc_async_sync);
-}
-
-void
-GOACC_wait (int async, int num_waits, ...)
-{
-  if (num_waits)
+ out_prof:
+  if (profiling_p)
     {
-      va_list ap;
+      prof_info.event_type = acc_ev_update_end;
+      update_event_info.other_event.event_type = prof_info.event_type;
+      goacc_profiling_dispatch (&prof_info, &update_event_info, &api_info);
 
-      va_start (ap, num_waits);
-      goacc_wait (async, num_waits, &ap);
-      va_end (ap);
+      thr->prof_info = NULL;
+      thr->api_info = NULL;
     }
-  else if (async == acc_async_sync)
-    acc_wait_all ();
-  else
-    acc_wait_all_async (async);
 }
 
+
+/* Legacy entry point (GCC 5).  */
+
 int
 GOACC_get_num_threads (void)
 {
   return 1;
 }
 
+/* Legacy entry point (GCC 5).  */
+
 int
 GOACC_get_thread_num (void)
 {
diff --git a/libgomp/oacc-plugin.c b/libgomp/oacc-plugin.c
index 958cda97177..b4f71a11c18 100644
--- a/libgomp/oacc-plugin.c
+++ b/libgomp/oacc-plugin.c
@@ -29,16 +29,22 @@
 #include "libgomp.h"
 #include "oacc-plugin.h"
 #include "oacc-int.h"
+#include "acc_prof.h"
 
+/* This plugin function is now obsolete.  */
 void
-GOMP_PLUGIN_async_unmap_vars (void *ptr, int async)
+GOMP_PLUGIN_async_unmap_vars (void *ptr __attribute__((unused)),
+			      int async __attribute__((unused)))
 {
-  struct target_mem_desc *tgt = ptr;
-  struct gomp_device_descr *devicep = tgt->device_descr;
+  gomp_fatal ("invalid plugin function");
+}
+
+/* Return the TLS data for the current thread.  */
 
-  devicep->openacc.async_set_async_func (async);
-  gomp_unmap_vars (tgt, true);
-  devicep->openacc.async_set_async_func (acc_async_sync);
+struct goacc_thread *
+GOMP_PLUGIN_goacc_thread (void)
+{
+  return goacc_thread ();
 }
 
 /* Return the target-specific part of the TLS data for the current thread.  */
@@ -60,3 +66,11 @@ GOMP_PLUGIN_acc_default_dim (unsigned int i)
     }
   return goacc_default_dims[i];
 }
+
+void
+GOMP_PLUGIN_goacc_profiling_dispatch (acc_prof_info *prof_info,
+				      acc_event_info *event_info,
+				      acc_api_info *api_info)
+{
+  goacc_profiling_dispatch (prof_info, event_info, api_info);
+}
diff --git a/libgomp/oacc-plugin.h b/libgomp/oacc-plugin.h
index 112d4a593f9..887c6f60125 100644
--- a/libgomp/oacc-plugin.h
+++ b/libgomp/oacc-plugin.h
@@ -27,8 +27,15 @@
 #ifndef OACC_PLUGIN_H
 #define OACC_PLUGIN_H 1
 
+#include "oacc-int.h"
+#include "acc_prof.h"
+
 extern void GOMP_PLUGIN_async_unmap_vars (void *, int);
+extern struct goacc_thread *GOMP_PLUGIN_goacc_thread (void);
 extern void *GOMP_PLUGIN_acc_thread (void);
 extern int GOMP_PLUGIN_acc_default_dim (unsigned int);
+extern void GOMP_PLUGIN_goacc_profiling_dispatch (acc_prof_info *,
+						  acc_event_info *,
+						  acc_api_info *);
 
 #endif
diff --git a/libgomp/oacc-profiling.c b/libgomp/oacc-profiling.c
new file mode 100644
index 00000000000..eff28865089
--- /dev/null
+++ b/libgomp/oacc-profiling.c
@@ -0,0 +1,662 @@
+/* OpenACC Profiling Interface
+
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   Contributed by Mentor, a Siemens Business.
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define _GNU_SOURCE
+#include "libgomp.h"
+#include "oacc-int.h"
+#include "secure_getenv.h"
+#include "acc_prof.h"
+#include <assert.h>
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+#ifdef PLUGIN_SUPPORT
+# include <dlfcn.h>
+#endif
+
+#define STATIC_ASSERT(expr) _Static_assert (expr, "!(" #expr ")")
+
+/* Statically assert that the layout of the common fields in the
+   'acc_event_info' variants matches.  */
+/* 'event_type' */
+STATIC_ASSERT (offsetof (acc_event_info, event_type)
+	       == offsetof (acc_event_info, data_event.event_type));
+STATIC_ASSERT (offsetof (acc_event_info, data_event.event_type)
+	       == offsetof (acc_event_info, launch_event.event_type));
+STATIC_ASSERT (offsetof (acc_event_info, data_event.event_type)
+	       == offsetof (acc_event_info, other_event.event_type));
+/* 'valid_bytes' */
+STATIC_ASSERT (offsetof (acc_event_info, data_event.valid_bytes)
+	       == offsetof (acc_event_info, launch_event.valid_bytes));
+STATIC_ASSERT (offsetof (acc_event_info, data_event.valid_bytes)
+	       == offsetof (acc_event_info, other_event.valid_bytes));
+/* 'parent_construct' */
+STATIC_ASSERT (offsetof (acc_event_info, data_event.parent_construct)
+	       == offsetof (acc_event_info, launch_event.parent_construct));
+STATIC_ASSERT (offsetof (acc_event_info, data_event.parent_construct)
+	       == offsetof (acc_event_info, other_event.parent_construct));
+/* 'implicit' */
+STATIC_ASSERT (offsetof (acc_event_info, data_event.implicit)
+	       == offsetof (acc_event_info, launch_event.implicit));
+STATIC_ASSERT (offsetof (acc_event_info, data_event.implicit)
+	       == offsetof (acc_event_info, other_event.implicit));
+/* 'tool_info' */
+STATIC_ASSERT (offsetof (acc_event_info, data_event.tool_info)
+	       == offsetof (acc_event_info, launch_event.tool_info));
+STATIC_ASSERT (offsetof (acc_event_info, data_event.tool_info)
+	       == offsetof (acc_event_info, other_event.tool_info));
+
+struct goacc_prof_callback_entry
+{
+  acc_prof_callback cb;
+  int ref;
+  bool enabled;
+  struct goacc_prof_callback_entry *next;
+};
+
+/* Use a separate flag to minimize run-time performance impact for the (very
+   common) case that profiling is not enabled.
+
+   Once enabled, we're not going to disable this anymore, anywhere.  We
+   probably could, by adding appropriate logic to 'acc_prof_register',
+   'acc_prof_unregister'.  */
+bool goacc_prof_enabled = false;
+
+/* Global state for registered callbacks.
+   'goacc_prof_callbacks_enabled[acc_ev_none]' acts as a global toggle.  */
+static bool goacc_prof_callbacks_enabled[acc_ev_last];
+static struct goacc_prof_callback_entry *goacc_prof_callback_entries[acc_ev_last];
+/* Lock used to protect access to 'goacc_prof_callbacks_enabled', and
+   'goacc_prof_callback_entries'.  */
+static gomp_mutex_t goacc_prof_lock;
+
+void
+goacc_profiling_initialize (void)
+{
+  gomp_mutex_init (&goacc_prof_lock);
+
+  /* Initially, all callbacks for all events are enabled.  */
+  for (int i = 0; i < acc_ev_last; ++i)
+    goacc_prof_callbacks_enabled[i] = true;
+
+
+#ifdef PLUGIN_SUPPORT
+  char *acc_proflibs = secure_getenv ("ACC_PROFLIB");
+  while (acc_proflibs != NULL && acc_proflibs[0] != '\0')
+    {
+      char *acc_proflibs_sep = strchr (acc_proflibs, ';');
+      char *acc_proflib;
+      if (acc_proflibs_sep == acc_proflibs)
+	{
+	  /* Stray ';' separator: make sure we don't 'dlopen' the main
+	     program.  */
+	  acc_proflib = NULL;
+	}
+      else
+	{
+	  if (acc_proflibs_sep != NULL)
+	    {
+	      /* Single out the first library.  */
+	      acc_proflib = gomp_malloc (acc_proflibs_sep - acc_proflibs + 1);
+	      memcpy (acc_proflib, acc_proflibs,
+		      acc_proflibs_sep - acc_proflibs);
+	      acc_proflib[acc_proflibs_sep - acc_proflibs] = '\0';
+	    }
+	  else
+	    {
+	      /* No ';' separator, so only one library.  */
+	      acc_proflib = acc_proflibs;
+	    }
+
+	  gomp_debug (0, "%s: dlopen (\"%s\")\n", __FUNCTION__, acc_proflib);
+	  void *dl_handle = dlopen (acc_proflib, RTLD_LAZY);
+	  if (dl_handle != NULL)
+	    {
+	      typeof (&acc_register_library) a_r_l
+		= dlsym (dl_handle, "acc_register_library");
+	      if (a_r_l == NULL)
+		goto dl_fail;
+	      gomp_debug (0, "  %s: calling %s:acc_register_library\n",
+			  __FUNCTION__, acc_proflib);
+	      a_r_l (acc_prof_register, acc_prof_unregister,
+		     acc_prof_lookup);
+	    }
+	  else
+	    {
+	    dl_fail:
+	      gomp_error ("while loading ACC_PROFLIB \"%s\": %s",
+			  acc_proflib, dlerror ());
+	      if (dl_handle != NULL)
+		{
+		  int err = dlclose (dl_handle);
+		  dl_handle = NULL;
+		  if (err != 0)
+		    goto dl_fail;
+		}
+	    }
+	}
+
+      if (acc_proflib != acc_proflibs)
+	{
+	  free (acc_proflib);
+
+	  acc_proflibs = acc_proflibs_sep + 1;
+	}
+      else
+	acc_proflibs = NULL;
+    }
+#endif /* PLUGIN_SUPPORT */
+}
+
+void
+acc_prof_register (acc_event_t ev, acc_prof_callback cb, acc_register_t reg)
+{
+  gomp_debug (0, "%s: ev=%d, cb=%p, reg=%d\n",
+	      __FUNCTION__, (int) ev, (void *) cb, (int) reg);
+
+
+  /* For any events to be dispatched, the user first has to register a
+     callback, which makes this here a good place for enabling the whole
+     machinery.  */
+  if (!GOACC_PROF_ENABLED)
+    __atomic_store_n (&goacc_prof_enabled, true, MEMMODEL_RELEASE);
+
+
+  enum
+  {
+    EVENT_KIND_BOGUS,
+    EVENT_KIND_NORMAL,
+    /* As end events invoke callbacks in the reverse order, we register these
+       in the reverse order here.  */
+    EVENT_KIND_END,
+  } event_kind = EVENT_KIND_BOGUS;
+  switch (ev)
+    {
+    case acc_ev_none:
+    case acc_ev_device_init_start:
+    case acc_ev_device_shutdown_start:
+    case acc_ev_runtime_shutdown:
+    case acc_ev_create:
+    case acc_ev_delete:
+    case acc_ev_alloc:
+    case acc_ev_free:
+    case acc_ev_enter_data_start:
+    case acc_ev_exit_data_start:
+    case acc_ev_update_start:
+    case acc_ev_compute_construct_start:
+    case acc_ev_enqueue_launch_start:
+    case acc_ev_enqueue_upload_start:
+    case acc_ev_enqueue_download_start:
+    case acc_ev_wait_start:
+      event_kind = EVENT_KIND_NORMAL;
+      break;
+    case acc_ev_device_init_end:
+    case acc_ev_device_shutdown_end:
+    case acc_ev_enter_data_end:
+    case acc_ev_exit_data_end:
+    case acc_ev_update_end:
+    case acc_ev_compute_construct_end:
+    case acc_ev_enqueue_launch_end:
+    case acc_ev_enqueue_upload_end:
+    case acc_ev_enqueue_download_end:
+    case acc_ev_wait_end:
+      event_kind = EVENT_KIND_END;
+      break;
+    case acc_ev_last:
+      break;
+    }
+  if (event_kind == EVENT_KIND_BOGUS)
+    {
+      /* Silently ignore.  */
+      gomp_debug (0, "  ignoring request for bogus 'acc_event_t'\n");
+      return;
+    }
+
+  bool bogus = true;
+  switch (reg)
+    {
+    case acc_reg:
+    case acc_toggle:
+    case acc_toggle_per_thread:
+      bogus = false;
+      break;
+    }
+  if (bogus)
+    {
+      /* Silently ignore.  */
+      gomp_debug (0, "  ignoring request with bogus 'acc_register_t'\n");
+      return;
+    }
+
+  /* Special cases.  */
+  if (reg == acc_toggle)
+    {
+      if (cb == NULL)
+	{
+	  gomp_debug (0, "  globally enabling callbacks\n");
+	  gomp_mutex_lock (&goacc_prof_lock);
+	  /* For 'acc_ev_none', this acts as a global toggle.  */
+	  goacc_prof_callbacks_enabled[ev] = true;
+	  gomp_mutex_unlock (&goacc_prof_lock);
+	  return;
+	}
+      else if (ev == acc_ev_none && cb != NULL)
+	{
+	  gomp_debug (0, "  ignoring request\n");
+	  return;
+	}
+    }
+  else if (reg == acc_toggle_per_thread)
+    {
+      if (ev == acc_ev_none && cb == NULL)
+	{
+	  gomp_debug (0, "  thread: enabling callbacks\n");
+	  goacc_lazy_initialize ();
+	  struct goacc_thread *thr = goacc_thread ();
+	  thr->prof_callbacks_enabled = true;
+	  return;
+	}
+      /* Silently ignore.  */
+      gomp_debug (0, "  ignoring bogus request\n");
+      return;
+    }
+
+  gomp_mutex_lock (&goacc_prof_lock);
+
+  struct goacc_prof_callback_entry *it, *it_p;
+  it = goacc_prof_callback_entries[ev];
+  it_p = NULL;
+  while (it)
+    {
+      if (it->cb == cb)
+	break;
+      it_p = it;
+      it = it->next;
+    }
+
+  switch (reg)
+    {
+    case acc_reg:
+      /* If we already have this callback registered, just increment its
+	 reference count.  */
+      if (it != NULL)
+	{
+	  it->ref++;
+	  gomp_debug (0, "  already registered;"
+		      " incrementing reference count to: %d\n", it->ref);
+	}
+      else
+	{
+	  struct goacc_prof_callback_entry *e
+	    = gomp_malloc (sizeof (struct goacc_prof_callback_entry));
+	  e->cb = cb;
+	  e->ref = 1;
+	  e->enabled = true;
+	  bool prepend = (event_kind == EVENT_KIND_END);
+	  /* If we don't have any callback registered yet, also use the
+	     'prepend' code path.  */
+	  if (it_p == NULL)
+	    prepend = true;
+	  if (prepend)
+	    {
+	      gomp_debug (0, "  prepending\n");
+	      e->next = goacc_prof_callback_entries[ev];
+	      goacc_prof_callback_entries[ev] = e;
+	    }
+	  else
+	    {
+	      gomp_debug (0, "  appending\n");
+	      e->next = NULL;
+	      it_p->next = e;
+	    }
+	}
+      break;
+
+    case acc_toggle:
+      if (it == NULL)
+	{
+	  gomp_debug (0, "  ignoring request: is not registered\n");
+	  break;
+	}
+      else
+	{
+	  gomp_debug (0, "  enabling\n");
+	  it->enabled = true;
+	}
+      break;
+
+    case acc_toggle_per_thread:
+      __builtin_unreachable ();
+    }
+
+  gomp_mutex_unlock (&goacc_prof_lock);
+}
+
+void
+acc_prof_unregister (acc_event_t ev, acc_prof_callback cb, acc_register_t reg)
+{
+  gomp_debug (0, "%s: ev=%d, cb=%p, reg=%d\n",
+	      __FUNCTION__, (int) ev, (void *) cb, (int) reg);
+
+  /* If profiling is not enabled, there cannot be anything to unregister.  */
+  if (!GOACC_PROF_ENABLED)
+    return;
+
+  if (ev < acc_ev_none
+      || ev >= acc_ev_last)
+    {
+      /* Silently ignore.  */
+      gomp_debug (0, "  ignoring request for bogus 'acc_event_t'\n");
+      return;
+    }
+
+  bool bogus = true;
+  switch (reg)
+    {
+    case acc_reg:
+    case acc_toggle:
+    case acc_toggle_per_thread:
+      bogus = false;
+      break;
+    }
+  if (bogus)
+    {
+      /* Silently ignore.  */
+      gomp_debug (0, "  ignoring request with bogus 'acc_register_t'\n");
+      return;
+    }
+
+  /* Special cases.  */
+  if (reg == acc_toggle)
+    {
+      if (cb == NULL)
+	{
+	  gomp_debug (0, "  globally disabling callbacks\n");
+	  gomp_mutex_lock (&goacc_prof_lock);
+	  /* For 'acc_ev_none', this acts as a global toggle.  */
+	  goacc_prof_callbacks_enabled[ev] = false;
+	  gomp_mutex_unlock (&goacc_prof_lock);
+	  return;
+	}
+      else if (ev == acc_ev_none && cb != NULL)
+	{
+	  gomp_debug (0, "  ignoring request\n");
+	  return;
+	}
+    }
+  else if (reg == acc_toggle_per_thread)
+    {
+      if (ev == acc_ev_none && cb == NULL)
+	{
+	  gomp_debug (0, "  thread: disabling callbacks\n");
+	  goacc_lazy_initialize ();
+	  struct goacc_thread *thr = goacc_thread ();
+	  thr->prof_callbacks_enabled = false;
+	  return;
+	}
+      /* Silently ignore.  */
+      gomp_debug (0, "  ignoring bogus request\n");
+      return;
+    }
+
+  gomp_mutex_lock (&goacc_prof_lock);
+
+  struct goacc_prof_callback_entry *it, *it_p;
+  it = goacc_prof_callback_entries[ev];
+  it_p = NULL;
+  while (it)
+    {
+      if (it->cb == cb)
+	break;
+      it_p = it;
+      it = it->next;
+    }
+
+  switch (reg)
+    {
+    case acc_reg:
+      if (it == NULL)
+	{
+	  /* Silently ignore.  */
+	  gomp_debug (0, "  ignoring bogus request: is not registered\n");
+	  break;
+	}
+      it->ref--;
+      gomp_debug (0, "  decrementing reference count to: %d\n", it->ref);
+      if (it->ref == 0)
+	{
+	  if (it_p == NULL)
+	    goacc_prof_callback_entries[ev] = it->next;
+	  else
+	    it_p->next = it->next;
+	  free (it);
+	}
+      break;
+
+    case acc_toggle:
+      if (it == NULL)
+	{
+	  gomp_debug (0, "  ignoring request: is not registered\n");
+	  break;
+	}
+      else
+	{
+	  gomp_debug (0, "  disabling\n");
+	  it->enabled = false;
+	}
+      break;
+
+    case acc_toggle_per_thread:
+      __builtin_unreachable ();
+    }
+
+  gomp_mutex_unlock (&goacc_prof_lock);
+}
+
+acc_query_fn
+acc_prof_lookup (const char *name)
+{
+  gomp_debug (0, "%s (%s)\n",
+	      __FUNCTION__, name ?: "NULL");
+
+  return NULL;
+}
+
+void
+acc_register_library (acc_prof_reg reg, acc_prof_reg unreg,
+		      acc_prof_lookup_func lookup)
+{
+  gomp_fatal ("TODO");
+}
+
+/* Prepare to dispatch events?  */
+
+bool
+_goacc_profiling_dispatch_p (bool check_not_nested_p)
+{
+  gomp_debug (0, "%s\n", __FUNCTION__);
+
+  bool ret;
+
+  struct goacc_thread *thr = goacc_thread ();
+  if (__builtin_expect (thr == NULL, false))
+    {
+      /* If we don't have any per-thread state yet, that means that per-thread
+	 callback dispatch has not been explicitly disabled (which only a call
+	 to 'acc_prof_unregister' with 'acc_toggle_per_thread' would do, and
+	 that would have allocated per-thread state via
+	 'goacc_lazy_initialize'); initially, all callbacks for all events are
+	 enabled.  */
+      gomp_debug (0, "  %s: don't have any per-thread state yet\n", __FUNCTION__);
+    }
+  else
+    {
+      if (check_not_nested_p)
+	{
+	  /* No nesting.  */
+	  assert (thr->prof_info == NULL);
+	  assert (thr->api_info == NULL);
+	}
+
+      if (__builtin_expect (!thr->prof_callbacks_enabled, true))
+	{
+	  gomp_debug (0, "  %s: disabled for this thread\n", __FUNCTION__);
+	  ret = false;
+	  goto out;
+	}
+    }
+
+  gomp_mutex_lock (&goacc_prof_lock);
+
+  /* 'goacc_prof_callbacks_enabled[acc_ev_none]' acts as a global toggle.  */
+  if (__builtin_expect (!goacc_prof_callbacks_enabled[acc_ev_none], true))
+    {
+      gomp_debug (0, "  %s: disabled globally\n", __FUNCTION__);
+      ret = false;
+      goto out_unlock;
+    }
+  else
+    ret = true;
+
+ out_unlock:
+  gomp_mutex_unlock (&goacc_prof_lock);
+
+ out:
+  return ret;
+}
+
+/* Set up to dispatch events?  */
+
+bool
+_goacc_profiling_setup_p (struct goacc_thread *thr,
+			  acc_prof_info *prof_info, acc_api_info *api_info)
+{
+  gomp_debug (0, "%s (%p)\n", __FUNCTION__, thr);
+
+  /* If we don't have any per-thread state yet, we can't register 'prof_info'
+     and 'api_info'.  */
+  if (__builtin_expect (thr == NULL, false))
+    {
+      gomp_debug (0, "Can't dispatch OpenACC Profiling Interface events for"
+		  " the current call, construct, or directive\n");
+      return false;
+    }
+
+  if (thr->prof_info != NULL)
+    {
+      /* Profiling has already been set up for an outer construct.  In this
+	 case, we continue to use the existing information, and thus return
+	 'false' here.
+
+	 This can happen, for example, for an 'enter data' directive, which
+	 sets up profiling, then calls into 'acc_copyin', which should not
+	 again set up profiling, should not overwrite the existing
+	 information.  */
+      return false;
+    }
+
+  thr->prof_info = prof_info;
+  thr->api_info = api_info;
+
+  /* Fill in some defaults.  */
+
+  prof_info->event_type = -1; /* Must be set later.  */
+  prof_info->valid_bytes = _ACC_PROF_INFO_VALID_BYTES;
+  prof_info->version = _ACC_PROF_INFO_VERSION;
+  if (thr->dev)
+    {
+      prof_info->device_type = acc_device_type (thr->dev->type);
+      prof_info->device_number = thr->dev->target_id;
+    }
+  else
+    {
+      prof_info->device_type = -1;
+      prof_info->device_number = -1;
+    }
+  prof_info->thread_id = -1;
+  prof_info->async = acc_async_sync;
+  prof_info->async_queue = prof_info->async;
+  prof_info->src_file = NULL;
+  prof_info->func_name = NULL;
+  prof_info->line_no = -1;
+  prof_info->end_line_no = -1;
+  prof_info->func_line_no = -1;
+  prof_info->func_end_line_no = -1;
+
+  api_info->device_api = acc_device_api_none;
+  api_info->valid_bytes = _ACC_API_INFO_VALID_BYTES;
+  api_info->device_type = prof_info->device_type;
+  api_info->vendor = -1;
+  api_info->device_handle = NULL;
+  api_info->context_handle = NULL;
+  api_info->async_handle = NULL;
+
+  return true;
+}
+
+/* Dispatch events.
+
+   This must only be called if 'GOACC_PROFILING_DISPATCH_P' or
+   'GOACC_PROFILING_SETUP_P' returned a true result.  */
+
+void
+goacc_profiling_dispatch (acc_prof_info *prof_info, acc_event_info *event_info,
+			  acc_api_info *apt_info)
+{
+  acc_event_t event_type = event_info->event_type;
+  gomp_debug (0, "%s: event_type=%d\n", __FUNCTION__, (int) event_type);
+  assert (event_type > acc_ev_none
+	  && event_type < acc_ev_last);
+
+  gomp_mutex_lock (&goacc_prof_lock);
+
+  if (!goacc_prof_callbacks_enabled[event_type])
+    {
+      gomp_debug (0, "  disabled for this event type\n");
+
+      goto out_unlock;
+    }
+
+  for (struct goacc_prof_callback_entry *e
+	 = goacc_prof_callback_entries[event_type];
+       e != NULL;
+       e = e->next)
+    {
+      if (!e->enabled)
+	{
+	  gomp_debug (0, "  disabled for callback %p\n", e->cb);
+	  continue;
+	}
+
+      gomp_debug (0, "  calling callback %p\n", e->cb);
+      e->cb (prof_info, event_info, apt_info);
+    }
+
+ out_unlock:
+  gomp_mutex_unlock (&goacc_prof_lock);
+}
diff --git a/libgomp/oacc-target.c b/libgomp/oacc-target.c
new file mode 100644
index 00000000000..f2e79899030
--- /dev/null
+++ b/libgomp/oacc-target.c
@@ -0,0 +1 @@
+/* Nothing needed here.  */
diff --git a/libgomp/omp_lib.h.in b/libgomp/omp_lib.h.in
index a0fc04cc724..2c33ce8ea76 100644
--- a/libgomp/omp_lib.h.in
+++ b/libgomp/omp_lib.h.in
@@ -102,8 +102,8 @@
       external omp_in_final
       logical(4) omp_in_final
 
-      external omp_get_cancelllation
-      logical(4) omp_get_cancelllation
+      external omp_get_cancellation
+      logical(4) omp_get_cancellation
 
       external omp_get_proc_bind
       integer(omp_proc_bind_kind) omp_get_proc_bind
diff --git a/libgomp/openacc.f90 b/libgomp/openacc.f90
index bc205453f82..b37f1872d50 100644
--- a/libgomp/openacc.f90
+++ b/libgomp/openacc.f90
@@ -31,13 +31,12 @@ module openacc_kinds
   use iso_fortran_env, only: int32
   implicit none
 
+  public
   private :: int32
-  public :: acc_device_kind
 
-  integer, parameter :: acc_device_kind = int32
+  ! When adding items, also update 'public' setting in 'module openmp' below.
 
-  public :: acc_device_none, acc_device_default, acc_device_host
-  public :: acc_device_not_host, acc_device_nvidia
+  integer, parameter :: acc_device_kind = int32
 
   ! Keep in sync with include/gomp-constants.h.
   integer (acc_device_kind), parameter :: acc_device_none = 0
@@ -46,17 +45,13 @@ module openacc_kinds
   ! integer (acc_device_kind), parameter :: acc_device_host_nonshm = 3 removed.
   integer (acc_device_kind), parameter :: acc_device_not_host = 4
   integer (acc_device_kind), parameter :: acc_device_nvidia = 5
-
-  public :: acc_handle_kind
+  integer (acc_device_kind), parameter :: acc_device_gcn = 8
 
   integer, parameter :: acc_handle_kind = int32
 
-  public :: acc_async_noval, acc_async_sync
-
   ! Keep in sync with include/gomp-constants.h.
   integer (acc_handle_kind), parameter :: acc_async_noval = -1
   integer (acc_handle_kind), parameter :: acc_async_sync = -2
-
 end module
 
 module openacc_internal
@@ -716,6 +711,13 @@ module openacc
   use openacc_internal
   implicit none
 
+  private
+  ! From openacc_kinds
+  public :: acc_device_kind, acc_handle_kind
+  public :: acc_device_none, acc_device_default, acc_device_host
+  public :: acc_device_not_host, acc_device_nvidia, acc_device_gcn
+  public :: acc_async_noval, acc_async_sync
+
   public :: openacc_version
 
   public :: acc_get_num_devices, acc_set_device_type, acc_get_device_type
@@ -729,6 +731,7 @@ module openacc
   public :: acc_update_device, acc_update_self, acc_is_present
   public :: acc_copyin_async, acc_create_async, acc_copyout_async
   public :: acc_delete_async, acc_update_device_async, acc_update_self_async
+  public :: acc_copyout_finalize, acc_delete_finalize
 
   integer, parameter :: openacc_version = 201306
 
diff --git a/libgomp/openacc.h b/libgomp/openacc.h
index 1bbe6c90e7f..42c861caabf 100644
--- a/libgomp/openacc.h
+++ b/libgomp/openacc.h
@@ -55,6 +55,7 @@ typedef enum acc_device_t {
   /* acc_device_host_nonshm = 3 removed.  */
   acc_device_not_host = 4,
   acc_device_nvidia = 5,
+  acc_device_gcn = 8,
   _ACC_device_hwm,
   /* Ensure enumeration is layout compatible with int.  */
   _ACC_highest = __INT_MAX__,
diff --git a/libgomp/ordered.c b/libgomp/ordered.c
index 6d07fd445d3..60e310e01a1 100644
--- a/libgomp/ordered.c
+++ b/libgomp/ordered.c
@@ -214,7 +214,7 @@ gomp_ordered_sync (void)
      Either way we get correct results.
      However, there is an implicit flush on entry to an ordered region,
      so we do need to have a barrier here.  If we were taking a lock
-     this could be MEMMODEL_RELEASE since the acquire would be coverd
+     this could be MEMMODEL_RELEASE since the acquire would be covered
      by the lock.  */
 
   __atomic_thread_fence (MEMMODEL_ACQ_REL);
@@ -246,7 +246,7 @@ GOMP_ordered_start (void)
 
    However, the current implementation has a flaw in that it does not allow
    the next thread into the ORDERED section immediately after the current
-   thread exits the ORDERED section in its last iteration.  The existance
+   thread exits the ORDERED section in its last iteration.  The existence
    of this function allows the implementation to change.  */
 
 void
diff --git a/libgomp/plugin/Makefrag.am b/libgomp/plugin/Makefrag.am
index 168ef59de41..45ed043e333 100644
--- a/libgomp/plugin/Makefrag.am
+++ b/libgomp/plugin/Makefrag.am
@@ -52,3 +52,17 @@ libgomp_plugin_hsa_la_LDFLAGS += $(PLUGIN_HSA_LDFLAGS)
 libgomp_plugin_hsa_la_LIBADD = libgomp.la $(PLUGIN_HSA_LIBS)
 libgomp_plugin_hsa_la_LIBTOOLFLAGS = --tag=disable-static
 endif
+
+if PLUGIN_GCN
+# AMD GCN plugin
+libgomp_plugin_gcn_version_info = -version-info $(libtool_VERSION)
+toolexeclib_LTLIBRARIES += libgomp-plugin-gcn.la
+libgomp_plugin_gcn_la_SOURCES = plugin/plugin-gcn.c
+libgomp_plugin_gcn_la_CPPFLAGS = $(AM_CPPFLAGS) $(PLUGIN_GCN_CPPFLAGS) \
+	-D_GNU_SOURCE
+libgomp_plugin_gcn_la_LDFLAGS = $(libgomp_plugin_gcn_version_info) \
+	$(lt_host_flags)
+libgomp_plugin_gcn_la_LDFLAGS += $(PLUGIN_GCN_LDFLAGS)
+libgomp_plugin_gcn_la_LIBADD = libgomp.la $(PLUGIN_GCN_LIBS)
+libgomp_plugin_gcn_la_LIBTOOLFLAGS = --tag=disable-static
+endif
diff --git a/libgomp/plugin/configfrag.ac b/libgomp/plugin/configfrag.ac
index 9718ac752e2..424ec6c96b2 100644
--- a/libgomp/plugin/configfrag.ac
+++ b/libgomp/plugin/configfrag.ac
@@ -137,6 +137,15 @@ AC_SUBST(PLUGIN_HSA_CPPFLAGS)
 AC_SUBST(PLUGIN_HSA_LDFLAGS)
 AC_SUBST(PLUGIN_HSA_LIBS)
 
+PLUGIN_GCN=0
+PLUGIN_GCN_CPPFLAGS=
+PLUGIN_GCN_LDFLAGS=
+PLUGIN_GCN_LIBS=
+AC_SUBST(PLUGIN_GCN)
+AC_SUBST(PLUGIN_GCN_CPPFLAGS)
+AC_SUBST(PLUGIN_GCN_LDFLAGS)
+AC_SUBST(PLUGIN_GCN_LIBS)
+
 # Parse '--enable-offload-targets', figure out the corresponding libgomp
 # plugins, and configure to find the corresponding offload compilers.
 # 'offload_plugins' and 'offload_targets' will be populated in the same order.
@@ -237,6 +246,29 @@ if test x"$enable_offload_targets" != x; then
             ;;
         esac
         ;;
+
+      amdgcn*)
+	case "${target}" in
+	  x86_64-*-*)
+	    case " ${CC} ${CFLAGS} " in
+	      *" -m32 "*)
+		PLUGIN_GCN=0
+		;;
+	      *)
+		tgt_plugin=gcn
+		PLUGIN_GCN=$tgt
+		PLUGIN_GCN_CPPFLAGS=$HSA_RUNTIME_CPPFLAGS
+		PLUGIN_GCN_LDFLAGS="$HSA_RUNTIME_LDFLAGS"
+		PLUGIN_GCN_LIBS="-ldl"
+		PLUGIN_GCN=1
+		;;
+	      esac
+	    ;;
+	  *-*-*)
+	    PLUGIN_GCN=0
+	     ;;
+	esac
+	;;
       *)
 	AC_MSG_ERROR([unknown offload target specified])
 	;;
@@ -275,6 +307,9 @@ AC_DEFINE_UNQUOTED([PLUGIN_NVPTX_DYNAMIC], [$PLUGIN_NVPTX_DYNAMIC],
 AM_CONDITIONAL([PLUGIN_HSA], [test $PLUGIN_HSA = 1])
 AC_DEFINE_UNQUOTED([PLUGIN_HSA], [$PLUGIN_HSA],
   [Define to 1 if the HSA plugin is built, 0 if not.])
+AM_CONDITIONAL([PLUGIN_GCN], [test $PLUGIN_GCN = 1])
+AC_DEFINE_UNQUOTED([PLUGIN_GCN], [$PLUGIN_GCN],
+  [Define to 1 if the GCN plugin is built, 0 if not.])
 
 if test "$HSA_RUNTIME_LIB" != ""; then
   HSA_RUNTIME_LIB="$HSA_RUNTIME_LIB/"
diff --git a/libgomp/plugin/cuda-lib.def b/libgomp/plugin/cuda-lib.def
index b2a4c2154eb..a16badcfa9d 100644
--- a/libgomp/plugin/cuda-lib.def
+++ b/libgomp/plugin/cuda-lib.def
@@ -42,6 +42,7 @@ CUDA_ONE_CALL (cuModuleLoad)
 CUDA_ONE_CALL (cuModuleLoadData)
 CUDA_ONE_CALL (cuModuleUnload)
 CUDA_ONE_CALL_MAYBE_NULL (cuOccupancyMaxPotentialBlockSize)
+CUDA_ONE_CALL (cuStreamAddCallback)
 CUDA_ONE_CALL (cuStreamCreate)
 CUDA_ONE_CALL (cuStreamDestroy)
 CUDA_ONE_CALL (cuStreamQuery)
diff --git a/libgomp/plugin/cuda/cuda.h b/libgomp/plugin/cuda/cuda.h
index 7c0afafc730..e65f9725349 100644
--- a/libgomp/plugin/cuda/cuda.h
+++ b/libgomp/plugin/cuda/cuda.h
@@ -54,7 +54,11 @@ typedef enum {
   CUDA_ERROR_INVALID_CONTEXT = 201,
   CUDA_ERROR_NOT_FOUND = 500,
   CUDA_ERROR_NOT_READY = 600,
-  CUDA_ERROR_LAUNCH_FAILED = 719
+  CUDA_ERROR_LAUNCH_FAILED = 719,
+  CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = 720,
+  CUDA_ERROR_NOT_PERMITTED = 800,
+  CUDA_ERROR_NOT_SUPPORTED = 801,
+  CUDA_ERROR_UNKNOWN = 999
 } CUresult;
 
 typedef enum {
@@ -173,6 +177,8 @@ CUresult cuModuleLoadData (CUmodule *, const void *);
 CUresult cuModuleUnload (CUmodule);
 CUresult cuOccupancyMaxPotentialBlockSize(int *, int *, CUfunction,
 					  CUoccupancyB2DSize, size_t, int);
+typedef void (*CUstreamCallback)(CUstream, CUresult, void *);
+CUresult cuStreamAddCallback(CUstream, CUstreamCallback, void *, unsigned int);
 CUresult cuStreamCreate (CUstream *, unsigned);
 #define cuStreamDestroy cuStreamDestroy_v2
 CUresult cuStreamDestroy (CUstream);
diff --git a/libgomp/plugin/plugin-gcn.c b/libgomp/plugin/plugin-gcn.c
new file mode 100644
index 00000000000..04fe472a70d
--- /dev/null
+++ b/libgomp/plugin/plugin-gcn.c
@@ -0,0 +1,4012 @@
+/* Plugin for AMD GCN execution.
+
+   Copyright (C) 2013-2019 Free Software Foundation, Inc.
+
+   Contributed by Mentor Embedded
+
+   This file is part of the GNU Offloading and Multi Processing Library
+   (libgomp).
+
+   Libgomp is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* {{{ Includes and defines  */
+
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <limits.h>
+#include <hsa.h>
+#include <dlfcn.h>
+#include <signal.h>
+#include "libgomp-plugin.h"
+#include "gomp-constants.h"
+#include <elf.h>
+#include "oacc-plugin.h"
+#include "oacc-int.h"
+#include <assert.h>
+
+/* Additional definitions not in HSA 1.1.
+   FIXME: this needs to be updated in hsa.h for upstream, but the only source
+          right now is the ROCr source which may cause license issues.  */
+#define HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT 0xA002
+
+/* These probably won't be in elf.h for a while.  */
+#define R_AMDGPU_NONE		0
+#define R_AMDGPU_ABS32_LO	1	/* (S + A) & 0xFFFFFFFF  */
+#define R_AMDGPU_ABS32_HI	2	/* (S + A) >> 32  */
+#define R_AMDGPU_ABS64		3	/* S + A  */
+#define R_AMDGPU_REL32		4	/* S + A - P  */
+#define R_AMDGPU_REL64		5	/* S + A - P  */
+#define R_AMDGPU_ABS32		6	/* S + A  */
+#define R_AMDGPU_GOTPCREL	7	/* G + GOT + A - P  */
+#define R_AMDGPU_GOTPCREL32_LO	8	/* (G + GOT + A - P) & 0xFFFFFFFF  */
+#define R_AMDGPU_GOTPCREL32_HI	9	/* (G + GOT + A - P) >> 32  */
+#define R_AMDGPU_REL32_LO	10	/* (S + A - P) & 0xFFFFFFFF  */
+#define R_AMDGPU_REL32_HI	11	/* (S + A - P) >> 32  */
+#define reserved		12
+#define R_AMDGPU_RELATIVE64	13	/* B + A  */
+
+/* GCN specific definitions for asynchronous queues.  */
+
+#define ASYNC_QUEUE_SIZE 64
+#define DRAIN_QUEUE_SYNCHRONOUS_P false
+#define DEBUG_QUEUES 0
+#define DEBUG_THREAD_SLEEP 0
+#define DEBUG_THREAD_SIGNAL 0
+
+/* Defaults.  */
+#define DEFAULT_GCN_HEAP_SIZE (100*1024*1024)  /* 100MB.  */
+
+/* Secure getenv() which returns NULL if running as SUID/SGID.  */
+#ifndef HAVE_SECURE_GETENV
+#ifdef HAVE___SECURE_GETENV
+#define secure_getenv __secure_getenv
+#elif defined (HAVE_UNISTD_H) && defined(HAVE_GETUID) && defined(HAVE_GETEUID) \
+  && defined(HAVE_GETGID) && defined(HAVE_GETEGID)
+
+#include <unistd.h>
+
+/* Implementation of secure_getenv() for targets where it is not provided but
+   we have at least means to test real and effective IDs. */
+
+static char *
+secure_getenv (const char *name)
+{
+  if ((getuid () == geteuid ()) && (getgid () == getegid ()))
+    return getenv (name);
+  else
+    return NULL;
+}
+
+#else
+#define secure_getenv getenv
+#endif
+#endif
+
+/* }}}  */
+/* {{{ Types  */
+
+/* GCN-specific implementation of the GOMP_PLUGIN_acc_thread data.  */
+
+struct gcn_thread
+{
+  /* The thread number from the async clause, or GOMP_ASYNC_SYNC.  */
+  int async;
+};
+
+/* As an HSA runtime is dlopened, following structure defines function
+   pointers utilized by the HSA plug-in.  */
+
+struct hsa_runtime_fn_info
+{
+  /* HSA runtime.  */
+  hsa_status_t (*hsa_status_string_fn) (hsa_status_t status,
+					const char **status_string);
+  hsa_status_t (*hsa_system_get_info_fn) (hsa_system_info_t attribute,
+					  void *value);
+  hsa_status_t (*hsa_agent_get_info_fn) (hsa_agent_t agent,
+					 hsa_agent_info_t attribute,
+					 void *value);
+  hsa_status_t (*hsa_isa_get_info_fn)(hsa_isa_t isa,
+				      hsa_isa_info_t attribute,
+				      uint32_t index,
+				      void *value);
+  hsa_status_t (*hsa_init_fn) (void);
+  hsa_status_t (*hsa_iterate_agents_fn)
+    (hsa_status_t (*callback)(hsa_agent_t agent, void *data), void *data);
+  hsa_status_t (*hsa_region_get_info_fn) (hsa_region_t region,
+					  hsa_region_info_t attribute,
+					  void *value);
+  hsa_status_t (*hsa_queue_create_fn)
+    (hsa_agent_t agent, uint32_t size, hsa_queue_type_t type,
+     void (*callback)(hsa_status_t status, hsa_queue_t *source, void *data),
+     void *data, uint32_t private_segment_size,
+     uint32_t group_segment_size, hsa_queue_t **queue);
+  hsa_status_t (*hsa_agent_iterate_regions_fn)
+    (hsa_agent_t agent,
+     hsa_status_t (*callback)(hsa_region_t region, void *data), void *data);
+  hsa_status_t (*hsa_executable_destroy_fn) (hsa_executable_t executable);
+  hsa_status_t (*hsa_executable_create_fn)
+    (hsa_profile_t profile, hsa_executable_state_t executable_state,
+     const char *options, hsa_executable_t *executable);
+  hsa_status_t (*hsa_executable_global_variable_define_fn)
+    (hsa_executable_t executable, const char *variable_name, void *address);
+  hsa_status_t (*hsa_executable_load_code_object_fn)
+    (hsa_executable_t executable, hsa_agent_t agent,
+     hsa_code_object_t code_object, const char *options);
+  hsa_status_t (*hsa_executable_freeze_fn)(hsa_executable_t executable,
+					   const char *options);
+  hsa_status_t (*hsa_signal_create_fn) (hsa_signal_value_t initial_value,
+					uint32_t num_consumers,
+					const hsa_agent_t *consumers,
+					hsa_signal_t *signal);
+  hsa_status_t (*hsa_memory_allocate_fn) (hsa_region_t region, size_t size,
+					  void **ptr);
+  hsa_status_t (*hsa_memory_assign_agent_fn) (void *ptr, hsa_agent_t agent,
+					      hsa_access_permission_t access);
+  hsa_status_t (*hsa_memory_copy_fn)(void *dst, const void *src, size_t size);
+  hsa_status_t (*hsa_memory_free_fn) (void *ptr);
+  hsa_status_t (*hsa_signal_destroy_fn) (hsa_signal_t signal);
+  hsa_status_t (*hsa_executable_get_symbol_fn)
+    (hsa_executable_t executable, const char *module_name,
+     const char *symbol_name, hsa_agent_t agent, int32_t call_convention,
+     hsa_executable_symbol_t *symbol);
+  hsa_status_t (*hsa_executable_symbol_get_info_fn)
+    (hsa_executable_symbol_t executable_symbol,
+     hsa_executable_symbol_info_t attribute, void *value);
+  hsa_status_t (*hsa_executable_iterate_symbols_fn)
+    (hsa_executable_t executable,
+     hsa_status_t (*callback)(hsa_executable_t executable,
+			      hsa_executable_symbol_t symbol, void *data),
+     void *data);
+  uint64_t (*hsa_queue_add_write_index_release_fn) (const hsa_queue_t *queue,
+						    uint64_t value);
+  uint64_t (*hsa_queue_load_read_index_acquire_fn) (const hsa_queue_t *queue);
+  void (*hsa_signal_store_relaxed_fn) (hsa_signal_t signal,
+				       hsa_signal_value_t value);
+  void (*hsa_signal_store_release_fn) (hsa_signal_t signal,
+				       hsa_signal_value_t value);
+  hsa_signal_value_t (*hsa_signal_wait_acquire_fn)
+    (hsa_signal_t signal, hsa_signal_condition_t condition,
+     hsa_signal_value_t compare_value, uint64_t timeout_hint,
+     hsa_wait_state_t wait_state_hint);
+  hsa_signal_value_t (*hsa_signal_load_acquire_fn) (hsa_signal_t signal);
+  hsa_status_t (*hsa_queue_destroy_fn) (hsa_queue_t *queue);
+
+  hsa_status_t (*hsa_code_object_deserialize_fn)
+    (void *serialized_code_object, size_t serialized_code_object_size,
+     const char *options, hsa_code_object_t *code_object);
+};
+
+/* Structure describing the run-time and grid properties of an HSA kernel
+   lauch.  This needs to match the format passed to GOMP_OFFLOAD_run.  */
+
+struct GOMP_kernel_launch_attributes
+{
+  /* Number of dimensions the workload has.  Maximum number is 3.  */
+  uint32_t ndim;
+  /* Size of the grid in the three respective dimensions.  */
+  uint32_t gdims[3];
+  /* Size of work-groups in the respective dimensions.  */
+  uint32_t wdims[3];
+};
+
+/* Collection of information needed for a dispatch of a kernel from a
+   kernel.  */
+
+struct kernel_dispatch
+{
+  struct agent_info *agent;
+  /* Pointer to a command queue associated with a kernel dispatch agent.  */
+  void *queue;
+  /* Pointer to a memory space used for kernel arguments passing.  */
+  void *kernarg_address;
+  /* Kernel object.  */
+  uint64_t object;
+  /* Synchronization signal used for dispatch synchronization.  */
+  uint64_t signal;
+  /* Private segment size.  */
+  uint32_t private_segment_size;
+  /* Group segment size.  */
+  uint32_t group_segment_size;
+};
+
+/* Structure of the kernargs segment, supporting console output.
+ 
+   This needs to match the definitions in Newlib, and the expectations
+   in libgomp target code.  */
+
+struct kernargs {
+  /* Leave space for the real kernel arguments.
+     OpenACC and OpenMP only use one pointer.  */
+  int64_t dummy1;
+  int64_t dummy2;
+
+  /* A pointer to struct output, below, for console output data.  */
+  int64_t out_ptr;
+
+  /* A pointer to struct heap, below.  */
+  int64_t heap_ptr;
+
+  /* A pointer to an ephemeral memory arena.
+    Only needed for OpenMP.  */
+  int64_t arena_ptr;
+
+  /* Output data.  */
+  struct output {
+    int return_value;
+    unsigned int next_output;
+    struct printf_data {
+      int written;
+      char msg[128];
+      int type;
+      union {
+	int64_t ivalue;
+	double dvalue;
+	char text[128];
+      };
+    } queue[1024];
+    unsigned int consumed;
+  } output_data;
+};
+
+/* A queue entry for a future asynchronous launch.  */
+
+struct kernel_launch
+{
+  struct kernel_info *kernel;
+  void *vars;
+  struct GOMP_kernel_launch_attributes kla;
+};
+
+/* A queue entry for a future callback.  */
+
+struct callback
+{
+  void (*fn)(void *);
+  void *data;
+};
+
+/* A data struct for the copy_data callback.  */
+
+struct copy_data
+{
+  void *dst;
+  const void *src;
+  size_t len;
+  bool free_src;
+  struct goacc_asyncqueue *aq;
+};
+
+/* A queue entry for a placeholder.  These correspond to a wait event.  */
+
+struct placeholder
+{
+  int executed;
+  pthread_cond_t cond;
+  pthread_mutex_t mutex;
+};
+
+/* A queue entry for a wait directive.  */
+
+struct asyncwait_info
+{
+  struct placeholder *placeholderp;
+};
+
+/* Encode the type of an entry in an async queue.  */
+
+enum entry_type
+{
+  KERNEL_LAUNCH,
+  CALLBACK,
+  ASYNC_WAIT,
+  ASYNC_PLACEHOLDER
+};
+
+/* An entry in an async queue.  */
+
+struct queue_entry
+{
+  enum entry_type type;
+  union {
+    struct kernel_launch launch;
+    struct callback callback;
+    struct asyncwait_info asyncwait;
+    struct placeholder placeholder;
+  } u;
+};
+
+/* An async queue header.
+
+   OpenMP may create one of these.
+   OpenACC may create many.  */
+
+struct goacc_asyncqueue
+{
+  struct agent_info *agent;
+  hsa_queue_t *hsa_queue;
+
+  pthread_t thread_drain_queue;
+  pthread_mutex_t mutex;
+  pthread_cond_t queue_cond_in;
+  pthread_cond_t queue_cond_out;
+  struct queue_entry queue[ASYNC_QUEUE_SIZE];
+  int queue_first;
+  int queue_n;
+  int drain_queue_stop;
+
+  int id;
+  struct goacc_asyncqueue *prev;
+  struct goacc_asyncqueue *next;
+};
+
+/* Mkoffload uses this structure to describe a kernel.
+
+   OpenMP kernel dimensions are passed at runtime.
+   OpenACC kernel dimensions are passed at compile time, here.  */
+
+struct hsa_kernel_description
+{
+  const char *name;
+  int oacc_dims[3];  /* Only present for GCN kernels.  */
+};
+
+/* Mkoffload uses this structure to describe an offload variable.  */
+
+struct global_var_info
+{
+  const char *name;
+  void *address;
+};
+
+/* Mkoffload uses this structure to describe all the kernels in a
+   loadable module.  These are passed the libgomp via static constructors.  */
+
+struct gcn_image_desc
+{
+  struct gcn_image {
+    size_t size;
+    void *image;
+  } *gcn_image;
+  const unsigned kernel_count;
+  struct hsa_kernel_description *kernel_infos;
+  const unsigned global_variable_count;
+  struct global_var_info *global_variables;
+};
+
+/* Description of an HSA GPU agent (device) and the program associated with
+   it.  */
+
+struct agent_info
+{
+  /* The HSA ID of the agent.  Assigned when hsa_context is initialized.  */
+  hsa_agent_t id;
+  /* The user-visible device number.  */
+  int device_id;
+  /* Whether the agent has been initialized.  The fields below are usable only
+     if it has been.  */
+  bool initialized;
+  /* Precomputed check for problem architectures.  */
+  bool gfx900_p;
+
+  /* Command queues of the agent.  */
+  hsa_queue_t *sync_queue;
+  struct goacc_asyncqueue *async_queues, *omp_async_queue;
+  pthread_mutex_t async_queues_mutex;
+
+  /* The HSA memory region from which to allocate kernel arguments.  */
+  hsa_region_t kernarg_region;
+
+  /* The HSA memory region from which to allocate device data.  */
+  hsa_region_t data_region;
+
+  /* Allocated team arenas.  */
+  struct team_arena_list *team_arena_list;
+  pthread_mutex_t team_arena_write_lock;
+
+  /* Read-write lock that protects kernels which are running or about to be run
+     from interference with loading and unloading of images.  Needs to be
+     locked for reading while a kernel is being run, and for writing if the
+     list of modules is manipulated (and thus the HSA program invalidated).  */
+  pthread_rwlock_t module_rwlock;
+
+  /* The module associated with this kernel.  */
+  struct module_info *module;
+
+  /* Mutex enforcing that only one thread will finalize the HSA program.  A
+     thread should have locked agent->module_rwlock for reading before
+     acquiring it.  */
+  pthread_mutex_t prog_mutex;
+  /* Flag whether the HSA program that consists of all the modules has been
+     finalized.  */
+  bool prog_finalized;
+  /* HSA executable - the finalized program that is used to locate kernels.  */
+  hsa_executable_t executable;
+};
+
+/* Information required to identify, finalize and run any given kernel.  */
+
+enum offload_kind {KIND_UNKNOWN, KIND_OPENMP, KIND_OPENACC};
+
+struct kernel_info
+{
+  /* Name of the kernel, required to locate it within the GCN object-code
+     module.  */
+  const char *name;
+  /* The specific agent the kernel has been or will be finalized for and run
+     on.  */
+  struct agent_info *agent;
+  /* The specific module where the kernel takes place.  */
+  struct module_info *module;
+  /* Mutex enforcing that at most once thread ever initializes a kernel for
+     use.  A thread should have locked agent->module_rwlock for reading before
+     acquiring it.  */
+  pthread_mutex_t init_mutex;
+  /* Flag indicating whether the kernel has been initialized and all fields
+     below it contain valid data.  */
+  bool initialized;
+  /* Flag indicating that the kernel has a problem that blocks an execution.  */
+  bool initialization_failed;
+  /* The object to be put into the dispatch queue.  */
+  uint64_t object;
+  /* Required size of kernel arguments.  */
+  uint32_t kernarg_segment_size;
+  /* Required size of group segment.  */
+  uint32_t group_segment_size;
+  /* Required size of private segment.  */
+  uint32_t private_segment_size;
+  /* Set up for OpenMP or OpenACC?  */
+  enum offload_kind kind;
+};
+
+/* Information about a particular GCN module, its image and kernels.  */
+
+struct module_info
+{
+  /* The description with which the program has registered the image.  */
+  struct gcn_image_desc *image_desc;
+  /* GCN heap allocation.  */
+  struct heap *heap;
+  /* Physical boundaries of the loaded module.  */
+  Elf64_Addr phys_address_start;
+  Elf64_Addr phys_address_end;
+
+  bool constructors_run_p;
+  struct kernel_info *init_array_func, *fini_array_func;
+
+  /* Number of kernels in this module.  */
+  int kernel_count;
+  /* An array of kernel_info structures describing each kernel in this
+     module.  */
+  struct kernel_info kernels[];
+};
+
+/* A linked list of memory arenas allocated on the device.
+   These are only used by OpenMP, as a means to optimize per-team malloc.  */
+
+struct team_arena_list
+{
+  struct team_arena_list *next;
+
+  /* The number of teams determines the size of the allocation.  */
+  int num_teams;
+  /* The device address of the arena itself.  */
+  void *arena;
+  /* A flag to prevent two asynchronous kernels trying to use the same arena.
+     The mutex is locked until the kernel exits.  */
+  pthread_mutex_t in_use;
+};
+
+/* Information about the whole HSA environment and all of its agents.  */
+
+struct hsa_context_info
+{
+  /* Whether the structure has been initialized.  */
+  bool initialized;
+  /* Number of usable GPU HSA agents in the system.  */
+  int agent_count;
+  /* Array of agent_info structures describing the individual HSA agents.  */
+  struct agent_info *agents;
+};
+
+/* Format of the on-device heap.
+
+   This must match the definition in Newlib and gcn-run.  */
+
+struct heap {
+  int64_t size;
+  char data[0];
+};
+
+/* }}}  */
+/* {{{ Global variables  */
+
+/* Information about the whole HSA environment and all of its agents.  */
+
+static struct hsa_context_info hsa_context;
+
+/* HSA runtime functions that are initialized in init_hsa_context.  */
+
+static struct hsa_runtime_fn_info hsa_fns;
+
+/* Heap space, allocated target-side, provided for use of newlib malloc.
+   Each module should have it's own heap allocated.
+   Beware that heap usage increases with OpenMP teams.  See also arenas.  */
+
+static size_t gcn_kernel_heap_size = DEFAULT_GCN_HEAP_SIZE;
+
+/* Flag to decide whether print to stderr information about what is going on.
+   Set in init_debug depending on environment variables.  */
+
+static bool debug;
+
+/* Flag to decide if the runtime should suppress a possible fallback to host
+   execution.  */
+
+static bool suppress_host_fallback;
+
+/* Flag to locate HSA runtime shared library that is dlopened
+   by this plug-in.  */
+
+static const char *hsa_runtime_lib;
+
+/* Flag to decide if the runtime should support also CPU devices (can be
+   a simulator).  */
+
+static bool support_cpu_devices;
+
+/* Runtime dimension overrides.  Zero indicates default.  */
+
+static int override_x_dim = 0;
+static int override_z_dim = 0;
+
+/* }}}  */
+/* {{{ Debug & Diagnostic  */
+
+/* Print a message to stderr if GCN_DEBUG value is set to true.  */
+
+#define DEBUG_PRINT(...) \
+  do \
+  { \
+    if (debug) \
+      { \
+	fprintf (stderr, __VA_ARGS__); \
+      } \
+  } \
+  while (false);
+
+/* Flush stderr if GCN_DEBUG value is set to true.  */
+
+#define DEBUG_FLUSH()				\
+  do {						\
+    if (debug)					\
+      fflush (stderr);				\
+  } while (false)
+
+/* Print a logging message with PREFIX to stderr if GCN_DEBUG value
+   is set to true.  */
+
+#define DEBUG_LOG(prefix, ...)			\
+  do						\
+    {						\
+      DEBUG_PRINT (prefix);			\
+      DEBUG_PRINT (__VA_ARGS__);			\
+      DEBUG_FLUSH ();				\
+    } while (false)
+
+/* Print a debugging message to stderr.  */
+
+#define GCN_DEBUG(...) DEBUG_LOG ("GCN debug: ", __VA_ARGS__)
+
+/* Print a warning message to stderr.  */
+
+#define GCN_WARNING(...) DEBUG_LOG ("GCN warning: ", __VA_ARGS__)
+
+/* Print HSA warning STR with an HSA STATUS code.  */
+
+static void
+hsa_warn (const char *str, hsa_status_t status)
+{
+  if (!debug)
+    return;
+
+  const char *hsa_error_msg = "[unknown]";
+  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);
+
+  fprintf (stderr, "GCN warning: %s\nRuntime message: %s\n", str,
+	   hsa_error_msg);
+}
+
+/* Report a fatal error STR together with the HSA error corresponding to STATUS
+   and terminate execution of the current process.  */
+
+static void
+hsa_fatal (const char *str, hsa_status_t status)
+{
+  const char *hsa_error_msg = "[unknown]";
+  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);
+  GOMP_PLUGIN_fatal ("GCN fatal error: %s\nRuntime message: %s\n", str,
+		     hsa_error_msg);
+}
+
+/* Like hsa_fatal, except only report error message, and return FALSE
+   for propagating error processing to outside of plugin.  */
+
+static bool
+hsa_error (const char *str, hsa_status_t status)
+{
+  const char *hsa_error_msg = "[unknown]";
+  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);
+  GOMP_PLUGIN_error ("GCN fatal error: %s\nRuntime message: %s\n", str,
+		     hsa_error_msg);
+  return false;
+}
+
+/* Dump information about the available hardware.  */
+
+static void
+dump_hsa_system_info (void)
+{
+  hsa_status_t status;
+
+  hsa_endianness_t endianness;
+  status = hsa_fns.hsa_system_get_info_fn (HSA_SYSTEM_INFO_ENDIANNESS,
+					   &endianness);
+  if (status == HSA_STATUS_SUCCESS)
+    switch (endianness)
+      {
+      case HSA_ENDIANNESS_LITTLE:
+	GCN_DEBUG ("HSA_SYSTEM_INFO_ENDIANNESS: LITTLE\n");
+	break;
+      case HSA_ENDIANNESS_BIG:
+	GCN_DEBUG ("HSA_SYSTEM_INFO_ENDIANNESS: BIG\n");
+	break;
+      default:
+	GCN_WARNING ("HSA_SYSTEM_INFO_ENDIANNESS: UNKNOWN\n");
+      }
+  else
+    GCN_WARNING ("HSA_SYSTEM_INFO_ENDIANNESS: FAILED\n");
+
+  uint8_t extensions[128];
+  status = hsa_fns.hsa_system_get_info_fn (HSA_SYSTEM_INFO_EXTENSIONS,
+					   &extensions);
+  if (status == HSA_STATUS_SUCCESS)
+    {
+      if (extensions[0] & (1 << HSA_EXTENSION_IMAGES))
+	GCN_DEBUG ("HSA_SYSTEM_INFO_EXTENSIONS: IMAGES\n");
+    }
+  else
+    GCN_WARNING ("HSA_SYSTEM_INFO_EXTENSIONS: FAILED\n");
+}
+
+/* Dump information about the available hardware.  */
+
+static void
+dump_machine_model (hsa_machine_model_t machine_model, const char *s)
+{
+  switch (machine_model)
+    {
+    case HSA_MACHINE_MODEL_SMALL:
+      GCN_DEBUG ("%s: SMALL\n", s);
+      break;
+    case HSA_MACHINE_MODEL_LARGE:
+      GCN_DEBUG ("%s: LARGE\n", s);
+      break;
+    default:
+      GCN_WARNING ("%s: UNKNOWN\n", s);
+      break;
+    }
+}
+
+/* Dump information about the available hardware.  */
+
+static void
+dump_profile (hsa_profile_t profile, const char *s)
+{
+  switch (profile)
+    {
+    case HSA_PROFILE_FULL:
+      GCN_DEBUG ("%s: FULL\n", s);
+      break;
+    case HSA_PROFILE_BASE:
+      GCN_DEBUG ("%s: BASE\n", s);
+      break;
+    default:
+      GCN_WARNING ("%s: UNKNOWN\n", s);
+      break;
+    }
+}
+
+/* Dump information about a device memory region.  */
+
+static hsa_status_t
+dump_hsa_region (hsa_region_t region, void *data __attribute__((unused)))
+{
+  hsa_status_t status;
+
+  hsa_region_segment_t segment;
+  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_SEGMENT,
+					   &segment);
+  if (status == HSA_STATUS_SUCCESS)
+    {
+      if (segment == HSA_REGION_SEGMENT_GLOBAL)
+	GCN_DEBUG ("HSA_REGION_INFO_SEGMENT: GLOBAL\n");
+      else if (segment == HSA_REGION_SEGMENT_READONLY)
+	GCN_DEBUG ("HSA_REGION_INFO_SEGMENT: READONLY\n");
+      else if (segment == HSA_REGION_SEGMENT_PRIVATE)
+	GCN_DEBUG ("HSA_REGION_INFO_SEGMENT: PRIVATE\n");
+      else if (segment == HSA_REGION_SEGMENT_GROUP)
+	GCN_DEBUG ("HSA_REGION_INFO_SEGMENT: GROUP\n");
+      else
+	GCN_WARNING ("HSA_REGION_INFO_SEGMENT: UNKNOWN\n");
+    }
+  else
+    GCN_WARNING ("HSA_REGION_INFO_SEGMENT: FAILED\n");
+
+  if (segment == HSA_REGION_SEGMENT_GLOBAL)
+    {
+      uint32_t flags;
+      status
+	= hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_GLOBAL_FLAGS,
+					  &flags);
+      if (status == HSA_STATUS_SUCCESS)
+	{
+	  if (flags & HSA_REGION_GLOBAL_FLAG_KERNARG)
+	    GCN_DEBUG ("HSA_REGION_INFO_GLOBAL_FLAGS: KERNARG\n");
+	  if (flags & HSA_REGION_GLOBAL_FLAG_FINE_GRAINED)
+	    GCN_DEBUG ("HSA_REGION_INFO_GLOBAL_FLAGS: FINE_GRAINED\n");
+	  if (flags & HSA_REGION_GLOBAL_FLAG_COARSE_GRAINED)
+	    GCN_DEBUG ("HSA_REGION_INFO_GLOBAL_FLAGS: COARSE_GRAINED\n");
+	}
+      else
+	GCN_WARNING ("HSA_REGION_INFO_GLOBAL_FLAGS: FAILED\n");
+    }
+
+  size_t size;
+  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_SIZE, &size);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_REGION_INFO_SIZE: %zu\n", size);
+  else
+    GCN_WARNING ("HSA_REGION_INFO_SIZE: FAILED\n");
+
+  status
+    = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_ALLOC_MAX_SIZE,
+				      &size);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_REGION_INFO_ALLOC_MAX_SIZE: %zu\n", size);
+  else
+    GCN_WARNING ("HSA_REGION_INFO_ALLOC_MAX_SIZE: FAILED\n");
+
+  bool alloc_allowed;
+  status
+    = hsa_fns.hsa_region_get_info_fn (region,
+				      HSA_REGION_INFO_RUNTIME_ALLOC_ALLOWED,
+				      &alloc_allowed);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_REGION_INFO_RUNTIME_ALLOC_ALLOWED: %u\n", alloc_allowed);
+  else
+    GCN_WARNING ("HSA_REGION_INFO_RUNTIME_ALLOC_ALLOWED: FAILED\n");
+
+  if (status != HSA_STATUS_SUCCESS || !alloc_allowed)
+    return HSA_STATUS_SUCCESS;
+
+  status
+    = hsa_fns.hsa_region_get_info_fn (region,
+				      HSA_REGION_INFO_RUNTIME_ALLOC_GRANULE,
+				      &size);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_REGION_INFO_RUNTIME_ALLOC_GRANULE: %zu\n", size);
+  else
+    GCN_WARNING ("HSA_REGION_INFO_RUNTIME_ALLOC_GRANULE: FAILED\n");
+
+  size_t align;
+  status
+    = hsa_fns.hsa_region_get_info_fn (region,
+				      HSA_REGION_INFO_RUNTIME_ALLOC_ALIGNMENT,
+				      &align);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_REGION_INFO_RUNTIME_ALLOC_ALIGNMENT: %zu\n", align);
+  else
+    GCN_WARNING ("HSA_REGION_INFO_RUNTIME_ALLOC_ALIGNMENT: FAILED\n");
+
+  return HSA_STATUS_SUCCESS;
+}
+
+/* Dump information about all the device memory regions.  */
+
+static void
+dump_hsa_regions (hsa_agent_t agent)
+{
+  hsa_status_t status;
+  status = hsa_fns.hsa_agent_iterate_regions_fn (agent,
+						 dump_hsa_region,
+						 NULL);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_error ("Dumping hsa regions failed", status);
+}
+
+/* Dump information about the available devices.  */
+
+static hsa_status_t
+dump_hsa_agent_info (hsa_agent_t agent, void *data __attribute__((unused)))
+{
+  hsa_status_t status;
+
+  char buf[64];
+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_NAME,
+					  &buf);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_AGENT_INFO_NAME: %s\n", buf);
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_NAME: FAILED\n");
+
+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_VENDOR_NAME,
+					  &buf);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_AGENT_INFO_VENDOR_NAME: %s\n", buf);
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_VENDOR_NAME: FAILED\n");
+
+  hsa_machine_model_t machine_model;
+  status
+    = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_MACHINE_MODEL,
+				     &machine_model);
+  if (status == HSA_STATUS_SUCCESS)
+    dump_machine_model (machine_model, "HSA_AGENT_INFO_MACHINE_MODEL");
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_MACHINE_MODEL: FAILED\n");
+
+  hsa_profile_t profile;
+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_PROFILE,
+					  &profile);
+  if (status == HSA_STATUS_SUCCESS)
+    dump_profile (profile, "HSA_AGENT_INFO_PROFILE");
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_PROFILE: FAILED\n");
+
+  hsa_device_type_t device_type;
+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_DEVICE,
+					  &device_type);
+  if (status == HSA_STATUS_SUCCESS)
+    {
+      switch (device_type)
+	{
+	case HSA_DEVICE_TYPE_CPU:
+	  GCN_DEBUG ("HSA_AGENT_INFO_DEVICE: CPU\n");
+	  break;
+	case HSA_DEVICE_TYPE_GPU:
+	  GCN_DEBUG ("HSA_AGENT_INFO_DEVICE: GPU\n");
+	  break;
+	case HSA_DEVICE_TYPE_DSP:
+	  GCN_DEBUG ("HSA_AGENT_INFO_DEVICE: DSP\n");
+	  break;
+	default:
+	  GCN_WARNING ("HSA_AGENT_INFO_DEVICE: UNKNOWN\n");
+	  break;
+	}
+    }
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_DEVICE: FAILED\n");
+
+  uint32_t cu_count;
+  status = hsa_fns.hsa_agent_get_info_fn
+    (agent, HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT, &cu_count);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT: %u\n", cu_count);
+  else
+    GCN_WARNING ("HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT: FAILED\n");
+
+  uint32_t size;
+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_WAVEFRONT_SIZE,
+					  &size);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_AGENT_INFO_WAVEFRONT_SIZE: %u\n", size);
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_WAVEFRONT_SIZE: FAILED\n");
+
+  uint32_t max_dim;
+  status = hsa_fns.hsa_agent_get_info_fn (agent,
+					  HSA_AGENT_INFO_WORKGROUP_MAX_DIM,
+					  &max_dim);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_AGENT_INFO_WORKGROUP_MAX_DIM: %u\n", max_dim);
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_WORKGROUP_MAX_DIM: FAILED\n");
+
+  uint32_t max_size;
+  status = hsa_fns.hsa_agent_get_info_fn (agent,
+					  HSA_AGENT_INFO_WORKGROUP_MAX_SIZE,
+					  &max_size);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_AGENT_INFO_WORKGROUP_MAX_SIZE: %u\n", max_size);
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_WORKGROUP_MAX_SIZE: FAILED\n");
+
+  uint32_t grid_max_dim;
+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_GRID_MAX_DIM,
+					  &grid_max_dim);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_AGENT_INFO_GRID_MAX_DIM: %u\n", grid_max_dim);
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_GRID_MAX_DIM: FAILED\n");
+
+  uint32_t grid_max_size;
+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_GRID_MAX_SIZE,
+					  &grid_max_size);
+  if (status == HSA_STATUS_SUCCESS)
+    GCN_DEBUG ("HSA_AGENT_INFO_GRID_MAX_SIZE: %u\n", grid_max_size);
+  else
+    GCN_WARNING ("HSA_AGENT_INFO_GRID_MAX_SIZE: FAILED\n");
+
+  dump_hsa_regions (agent);
+
+  return HSA_STATUS_SUCCESS;
+}
+
+/* Forward reference.  */
+
+static char *get_executable_symbol_name (hsa_executable_symbol_t symbol);
+
+/* Helper function for dump_executable_symbols.  */
+
+static hsa_status_t
+dump_executable_symbol (hsa_executable_t executable,
+			hsa_executable_symbol_t symbol,
+			void *data __attribute__((unused)))
+{
+  char *name = get_executable_symbol_name (symbol);
+
+  if (name)
+    {
+      GCN_DEBUG ("executable symbol: %s\n", name);
+      free (name);
+    }
+
+  return HSA_STATUS_SUCCESS;
+}
+
+/* Dump all global symbol in an executable.  */
+
+static void
+dump_executable_symbols (hsa_executable_t executable)
+{
+  hsa_status_t status;
+  status
+    = hsa_fns.hsa_executable_iterate_symbols_fn (executable,
+						 dump_executable_symbol,
+						 NULL);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Could not dump HSA executable symbols", status);
+}
+
+/* Dump kernel DISPATCH data structure and indent it by INDENT spaces.  */
+
+static void
+print_kernel_dispatch (struct kernel_dispatch *dispatch, unsigned indent)
+{
+  struct kernargs *kernargs = (struct kernargs *)dispatch->kernarg_address;
+
+  fprintf (stderr, "%*sthis: %p\n", indent, "", dispatch);
+  fprintf (stderr, "%*squeue: %p\n", indent, "", dispatch->queue);
+  fprintf (stderr, "%*skernarg_address: %p\n", indent, "", kernargs);
+  fprintf (stderr, "%*sheap address: %p\n", indent, "",
+	   (void*)kernargs->heap_ptr);
+  fprintf (stderr, "%*sarena address: %p\n", indent, "",
+	   (void*)kernargs->arena_ptr);
+  fprintf (stderr, "%*sobject: %lu\n", indent, "", dispatch->object);
+  fprintf (stderr, "%*sprivate_segment_size: %u\n", indent, "",
+	   dispatch->private_segment_size);
+  fprintf (stderr, "%*sgroup_segment_size: %u\n", indent, "",
+	   dispatch->group_segment_size);
+  fprintf (stderr, "\n");
+}
+
+/* }}}  */
+/* {{{ Utility functions  */
+
+/* Cast the thread local storage to gcn_thread.  */
+
+static inline struct gcn_thread *
+gcn_thread (void)
+{
+  return (struct gcn_thread *) GOMP_PLUGIN_acc_thread ();
+}
+
+/* Initialize debug and suppress_host_fallback according to the environment.  */
+
+static void
+init_environment_variables (void)
+{
+  if (secure_getenv ("GCN_DEBUG"))
+    debug = true;
+  else
+    debug = false;
+
+  if (secure_getenv ("GCN_SUPPRESS_HOST_FALLBACK"))
+    suppress_host_fallback = true;
+  else
+    suppress_host_fallback = false;
+
+  hsa_runtime_lib = secure_getenv ("HSA_RUNTIME_LIB");
+  if (hsa_runtime_lib == NULL)
+    hsa_runtime_lib = HSA_RUNTIME_LIB "libhsa-runtime64.so";
+
+  support_cpu_devices = secure_getenv ("GCN_SUPPORT_CPU_DEVICES");
+
+  const char *x = secure_getenv ("GCN_NUM_TEAMS");
+  if (!x)
+    x = secure_getenv ("GCN_NUM_GANGS");
+  if (x)
+    override_x_dim = atoi (x);
+
+  const char *z = secure_getenv ("GCN_NUM_THREADS");
+  if (!z)
+    z = secure_getenv ("GCN_NUM_WORKERS");
+  if (z)
+    override_z_dim = atoi (z);
+
+  const char *heap = secure_getenv ("GCN_HEAP_SIZE");
+  if (heap)
+    {
+      size_t tmp = atol (heap);
+      if (tmp)
+	gcn_kernel_heap_size = tmp;
+    }
+}
+
+/* Return malloc'd string with name of SYMBOL.  */
+
+static char *
+get_executable_symbol_name (hsa_executable_symbol_t symbol)
+{
+  hsa_status_t status;
+  char *res;
+  uint32_t len;
+  const hsa_executable_symbol_info_t info_name_length
+    = HSA_EXECUTABLE_SYMBOL_INFO_NAME_LENGTH;
+
+  status = hsa_fns.hsa_executable_symbol_get_info_fn (symbol, info_name_length,
+						      &len);
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_error ("Could not get length of symbol name", status);
+      return NULL;
+    }
+
+  res = GOMP_PLUGIN_malloc (len + 1);
+
+  const hsa_executable_symbol_info_t info_name
+    = HSA_EXECUTABLE_SYMBOL_INFO_NAME;
+
+  status = hsa_fns.hsa_executable_symbol_get_info_fn (symbol, info_name, res);
+
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_error ("Could not get symbol name", status);
+      free (res);
+      return NULL;
+    }
+
+  res[len] = '\0';
+
+  return res;
+}
+
+/* Helper function for find_executable_symbol.  */
+
+static hsa_status_t
+find_executable_symbol_1 (hsa_executable_t executable,
+			  hsa_executable_symbol_t symbol,
+			  void *data)
+{
+  hsa_executable_symbol_t *res = (hsa_executable_symbol_t *)data;
+  *res = symbol;
+  return HSA_STATUS_INFO_BREAK;
+}
+
+/* Find a global symbol in EXECUTABLE, save to *SYMBOL and return true.  If not
+   found, return false.  */
+
+static bool
+find_executable_symbol (hsa_executable_t executable,
+			hsa_executable_symbol_t *symbol)
+{
+  hsa_status_t status;
+
+  status
+    = hsa_fns.hsa_executable_iterate_symbols_fn (executable,
+						 find_executable_symbol_1,
+						 symbol);
+  if (status != HSA_STATUS_INFO_BREAK)
+    {
+      hsa_error ("Could not find executable symbol", status);
+      return false;
+    }
+
+  return true;
+}
+
+/* Get the number of GPU Compute Units.  */
+
+static int
+get_cu_count (struct agent_info *agent)
+{
+  uint32_t cu_count;
+  hsa_status_t status = hsa_fns.hsa_agent_get_info_fn
+    (agent->id, HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT, &cu_count);
+  if (status == HSA_STATUS_SUCCESS)
+    return cu_count;
+  else
+    return 64;  /* The usual number for older devices.  */
+}
+
+/* Calculate the maximum grid size for OMP threads / OACC workers.
+   This depends on the kernel's resource usage levels.  */
+
+static int
+limit_worker_threads (int threads)
+{
+  /* FIXME Do something more inteligent here.
+     GCN can always run 4 threads within a Compute Unit, but
+     more than that depends on register usage.  */
+  if (threads > 16)
+    threads = 16;
+  return threads;
+}
+
+/* Parse the target attributes INPUT provided by the compiler and return true
+   if we should run anything all.  If INPUT is NULL, fill DEF with default
+   values, then store INPUT or DEF into *RESULT.
+ 
+   This is used for OpenMP only.  */
+
+static bool
+parse_target_attributes (void **input,
+			 struct GOMP_kernel_launch_attributes *def,
+			 struct GOMP_kernel_launch_attributes **result,
+			 struct agent_info *agent)
+{
+  if (!input)
+    GOMP_PLUGIN_fatal ("No target arguments provided");
+
+  bool grid_attrs_found = false;
+  bool gcn_dims_found = false;
+  int gcn_teams = 0;
+  int gcn_threads = 0;
+  while (*input)
+    {
+      intptr_t id = (intptr_t) *input++, val;
+
+      if (id & GOMP_TARGET_ARG_SUBSEQUENT_PARAM)
+	val = (intptr_t) *input++;
+      else
+	val = id >> GOMP_TARGET_ARG_VALUE_SHIFT;
+
+      val = (val > INT_MAX) ? INT_MAX : val;
+
+      if ((id & GOMP_TARGET_ARG_DEVICE_MASK) == GOMP_DEVICE_GCN
+	  && ((id & GOMP_TARGET_ARG_ID_MASK)
+	      == GOMP_TARGET_ARG_HSA_KERNEL_ATTRIBUTES))
+	{
+	  grid_attrs_found = true;
+	  break;
+	}
+      else if ((id & GOMP_TARGET_ARG_DEVICE_ALL) == GOMP_TARGET_ARG_DEVICE_ALL)
+	{
+	  gcn_dims_found = true;
+	  switch (id & GOMP_TARGET_ARG_ID_MASK)
+	    {
+	    case GOMP_TARGET_ARG_NUM_TEAMS:
+	      gcn_teams = val;
+	      break;
+	    case GOMP_TARGET_ARG_THREAD_LIMIT:
+	      gcn_threads = limit_worker_threads (val);
+	      break;
+	    default:
+	      ;
+	    }
+	}
+    }
+
+  if (gcn_dims_found)
+    {
+      if (agent->gfx900_p && gcn_threads == 0 && override_z_dim == 0)
+	{
+	  gcn_threads = 4;
+	  GCN_WARNING ("VEGA BUG WORKAROUND: reducing default number of "
+		       "threads to 4 per team.\n");
+	  GCN_WARNING (" - If this is not a Vega 10 device, please use "
+		       "GCN_NUM_THREADS=16\n");
+	}
+
+      def->ndim = 3;
+      /* Fiji has 64 CUs, but Vega20 has 60.  */
+      def->gdims[0] = (gcn_teams > 0) ? gcn_teams : get_cu_count (agent);
+      /* Each thread is 64 work items wide.  */
+      def->gdims[1] = 64;
+      /* A work group can have 16 wavefronts.  */
+      def->gdims[2] = (gcn_threads > 0) ? gcn_threads : 16;
+      def->wdims[0] = 1; /* Single team per work-group.  */
+      def->wdims[1] = 64;
+      def->wdims[2] = 16;
+      *result = def;
+      return true;
+    }
+  else if (!grid_attrs_found)
+    {
+      def->ndim = 1;
+      def->gdims[0] = 1;
+      def->gdims[1] = 1;
+      def->gdims[2] = 1;
+      def->wdims[0] = 1;
+      def->wdims[1] = 1;
+      def->wdims[2] = 1;
+      *result = def;
+      GCN_WARNING ("GOMP_OFFLOAD_run called with no launch attributes\n");
+      return true;
+    }
+
+  struct GOMP_kernel_launch_attributes *kla;
+  kla = (struct GOMP_kernel_launch_attributes *) *input;
+  *result = kla;
+  if (kla->ndim == 0 || kla->ndim > 3)
+    GOMP_PLUGIN_fatal ("Invalid number of dimensions (%u)", kla->ndim);
+
+  GCN_DEBUG ("GOMP_OFFLOAD_run called with %u dimensions:\n", kla->ndim);
+  unsigned i;
+  for (i = 0; i < kla->ndim; i++)
+    {
+      GCN_DEBUG ("  Dimension %u: grid size %u and group size %u\n", i,
+		 kla->gdims[i], kla->wdims[i]);
+      if (kla->gdims[i] == 0)
+	return false;
+    }
+  return true;
+}
+
+/* Return the group size given the requested GROUP size, GRID size and number
+   of grid dimensions NDIM.  */
+
+static uint32_t
+get_group_size (uint32_t ndim, uint32_t grid, uint32_t group)
+{
+  if (group == 0)
+    {
+      /* TODO: Provide a default via environment or device characteristics.  */
+      if (ndim == 1)
+	group = 64;
+      else if (ndim == 2)
+	group = 8;
+      else
+	group = 4;
+    }
+
+  if (group > grid)
+    group = grid;
+  return group;
+}
+
+/* Atomically store pair of uint16_t values (HEADER and REST) to a PACKET.  */
+
+static void
+packet_store_release (uint32_t* packet, uint16_t header, uint16_t rest)
+{
+  __atomic_store_n (packet, header | (rest << 16), __ATOMIC_RELEASE);
+}
+
+/* A never-called callback for the HSA command queues.  These signal events
+   that we don't use, so we trigger an error.
+ 
+   This "queue" is not to be confused with the async queues, below.  */
+
+static void
+hsa_queue_callback (hsa_status_t status,
+		hsa_queue_t *queue __attribute__ ((unused)),
+		void *data __attribute__ ((unused)))
+{
+  hsa_fatal ("Asynchronous queue error", status);
+}
+
+/* }}}  */
+/* {{{ HSA initialization  */
+
+/* Populate hsa_fns with the function addresses from libhsa-runtime64.so.  */
+
+static bool
+init_hsa_runtime_functions (void)
+{
+#define DLSYM_FN(function) \
+  hsa_fns.function##_fn = dlsym (handle, #function); \
+  if (hsa_fns.function##_fn == NULL) \
+    return false;
+  void *handle = dlopen (hsa_runtime_lib, RTLD_LAZY);
+  if (handle == NULL)
+    return false;
+
+  DLSYM_FN (hsa_status_string)
+  DLSYM_FN (hsa_system_get_info)
+  DLSYM_FN (hsa_agent_get_info)
+  DLSYM_FN (hsa_init)
+  DLSYM_FN (hsa_iterate_agents)
+  DLSYM_FN (hsa_region_get_info)
+  DLSYM_FN (hsa_queue_create)
+  DLSYM_FN (hsa_agent_iterate_regions)
+  DLSYM_FN (hsa_executable_destroy)
+  DLSYM_FN (hsa_executable_create)
+  DLSYM_FN (hsa_executable_global_variable_define)
+  DLSYM_FN (hsa_executable_load_code_object)
+  DLSYM_FN (hsa_executable_freeze)
+  DLSYM_FN (hsa_signal_create)
+  DLSYM_FN (hsa_memory_allocate)
+  DLSYM_FN (hsa_memory_assign_agent)
+  DLSYM_FN (hsa_memory_copy)
+  DLSYM_FN (hsa_memory_free)
+  DLSYM_FN (hsa_signal_destroy)
+  DLSYM_FN (hsa_executable_get_symbol)
+  DLSYM_FN (hsa_executable_symbol_get_info)
+  DLSYM_FN (hsa_executable_iterate_symbols)
+  DLSYM_FN (hsa_queue_add_write_index_release)
+  DLSYM_FN (hsa_queue_load_read_index_acquire)
+  DLSYM_FN (hsa_signal_wait_acquire)
+  DLSYM_FN (hsa_signal_store_relaxed)
+  DLSYM_FN (hsa_signal_store_release)
+  DLSYM_FN (hsa_signal_load_acquire)
+  DLSYM_FN (hsa_queue_destroy)
+  DLSYM_FN (hsa_code_object_deserialize)
+  return true;
+#undef DLSYM_FN
+}
+
+/* Return true if the agent is a GPU and can accept of concurrent submissions
+   from different threads.  */
+
+static bool
+suitable_hsa_agent_p (hsa_agent_t agent)
+{
+  hsa_device_type_t device_type;
+  hsa_status_t status
+    = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_DEVICE,
+				     &device_type);
+  if (status != HSA_STATUS_SUCCESS)
+    return false;
+
+  switch (device_type)
+    {
+    case HSA_DEVICE_TYPE_GPU:
+      break;
+    case HSA_DEVICE_TYPE_CPU:
+      if (!support_cpu_devices)
+	return false;
+      break;
+    default:
+      return false;
+    }
+
+  uint32_t features = 0;
+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_FEATURE,
+					  &features);
+  if (status != HSA_STATUS_SUCCESS
+      || !(features & HSA_AGENT_FEATURE_KERNEL_DISPATCH))
+    return false;
+  hsa_queue_type_t queue_type;
+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_QUEUE_TYPE,
+					  &queue_type);
+  if (status != HSA_STATUS_SUCCESS
+      || (queue_type != HSA_QUEUE_TYPE_MULTI))
+    return false;
+
+  return true;
+}
+
+/* Callback of hsa_iterate_agents; if AGENT is a GPU device, increment
+   agent_count in hsa_context.  */
+
+static hsa_status_t
+count_gpu_agents (hsa_agent_t agent, void *data __attribute__ ((unused)))
+{
+  if (suitable_hsa_agent_p (agent))
+    hsa_context.agent_count++;
+  return HSA_STATUS_SUCCESS;
+}
+
+/* Callback of hsa_iterate_agents; if AGENT is a GPU device, assign the agent
+   id to the describing structure in the hsa context.  The index of the
+   structure is pointed to by DATA, increment it afterwards.  */
+
+static hsa_status_t
+assign_agent_ids (hsa_agent_t agent, void *data)
+{
+  if (suitable_hsa_agent_p (agent))
+    {
+      int *agent_index = (int *) data;
+      hsa_context.agents[*agent_index].id = agent;
+      ++*agent_index;
+    }
+  return HSA_STATUS_SUCCESS;
+}
+
+/* Initialize hsa_context if it has not already been done.
+   Return TRUE on success.  */
+
+static bool
+init_hsa_context (void)
+{
+  hsa_status_t status;
+  int agent_index = 0;
+
+  if (hsa_context.initialized)
+    return true;
+  init_environment_variables ();
+  if (!init_hsa_runtime_functions ())
+    {
+      GCN_WARNING ("Run-time could not be dynamically opened\n");
+      if (suppress_host_fallback)
+	GOMP_PLUGIN_fatal ("GCN host fallback has been suppressed");
+      return false;
+    }
+  status = hsa_fns.hsa_init_fn ();
+  if (status != HSA_STATUS_SUCCESS)
+    return hsa_error ("Run-time could not be initialized", status);
+  GCN_DEBUG ("HSA run-time initialized for GCN\n");
+
+  if (debug)
+    dump_hsa_system_info ();
+
+  status = hsa_fns.hsa_iterate_agents_fn (count_gpu_agents, NULL);
+  if (status != HSA_STATUS_SUCCESS)
+    return hsa_error ("GCN GPU devices could not be enumerated", status);
+  GCN_DEBUG ("There are %i GCN GPU devices.\n", hsa_context.agent_count);
+
+  hsa_context.agents
+    = GOMP_PLUGIN_malloc_cleared (hsa_context.agent_count
+				  * sizeof (struct agent_info));
+  status = hsa_fns.hsa_iterate_agents_fn (assign_agent_ids, &agent_index);
+  if (agent_index != hsa_context.agent_count)
+    {
+      GOMP_PLUGIN_error ("Failed to assign IDs to all GCN agents");
+      return false;
+    }
+
+  if (debug)
+    {
+      status = hsa_fns.hsa_iterate_agents_fn (dump_hsa_agent_info, NULL);
+      if (status != HSA_STATUS_SUCCESS)
+	GOMP_PLUGIN_error ("Failed to list all HSA runtime agents");
+    }
+
+  hsa_context.initialized = true;
+  return true;
+}
+
+/* Verify that hsa_context has already been initialized and return the
+   agent_info structure describing device number N.  Return NULL on error.  */
+
+static struct agent_info *
+get_agent_info (int n)
+{
+  if (!hsa_context.initialized)
+    {
+      GOMP_PLUGIN_error ("Attempt to use uninitialized GCN context.");
+      return NULL;
+    }
+  if (n >= hsa_context.agent_count)
+    {
+      GOMP_PLUGIN_error ("Request to operate on non-existent GCN device %i", n);
+      return NULL;
+    }
+  if (!hsa_context.agents[n].initialized)
+    {
+      GOMP_PLUGIN_error ("Attempt to use an uninitialized GCN agent.");
+      return NULL;
+    }
+  return &hsa_context.agents[n];
+}
+
+/* Callback of hsa_agent_iterate_regions, via get_*_memory_region functions.
+
+   Selects (breaks at) a suitable region of type KIND.  */
+
+static hsa_status_t
+get_memory_region (hsa_region_t region, hsa_region_t *retval,
+		   hsa_region_global_flag_t kind)
+{
+  hsa_status_t status;
+  hsa_region_segment_t segment;
+
+  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_SEGMENT,
+					   &segment);
+  if (status != HSA_STATUS_SUCCESS)
+    return status;
+  if (segment != HSA_REGION_SEGMENT_GLOBAL)
+    return HSA_STATUS_SUCCESS;
+
+  uint32_t flags;
+  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_GLOBAL_FLAGS,
+					   &flags);
+  if (status != HSA_STATUS_SUCCESS)
+    return status;
+  if (flags & kind)
+    {
+      *retval = region;
+      return HSA_STATUS_INFO_BREAK;
+    }
+  return HSA_STATUS_SUCCESS;
+}
+
+/* Callback of hsa_agent_iterate_regions.
+ 
+   Selects a kernargs memory region.  */
+
+static hsa_status_t
+get_kernarg_memory_region (hsa_region_t region, void *data)
+{
+  return get_memory_region (region, (hsa_region_t *)data,
+			    HSA_REGION_GLOBAL_FLAG_KERNARG);
+}
+
+/* Callback of hsa_agent_iterate_regions.
+
+   Selects a coarse-grained memory region suitable for the heap and
+   offload data.  */
+
+static hsa_status_t
+get_data_memory_region (hsa_region_t region, void *data)
+{
+  return get_memory_region (region, (hsa_region_t *)data,
+			    HSA_REGION_GLOBAL_FLAG_COARSE_GRAINED);
+}
+
+/* }}}  */
+/* {{{ Run  */
+
+/* Create or reuse a team arena.
+ 
+   Team arenas are used by OpenMP to avoid calling malloc multiple times
+   while setting up each team.  This is purely a performance optimization.
+
+   Allocating an arena also costs performance, albeit on the host side, so
+   this function will reuse an existing arena if a large enough one is idle.
+   The arena is released, but not deallocated, when the kernel exits.  */
+
+static void *
+get_team_arena (struct agent_info *agent, int num_teams)
+{
+  struct team_arena_list **next_ptr = &agent->team_arena_list;
+  struct team_arena_list *item;
+
+  for (item = *next_ptr; item; next_ptr = &item->next, item = item->next)
+    {
+      if (item->num_teams < num_teams)
+	continue;
+
+      if (pthread_mutex_trylock (&item->in_use))
+	continue;
+
+      return item->arena;
+    }
+
+  GCN_DEBUG ("Creating a new arena for %d teams\n", num_teams);
+
+  if (pthread_mutex_lock (&agent->team_arena_write_lock))
+    {
+      GOMP_PLUGIN_error ("Could not lock a GCN agent program mutex");
+      return false;
+    }
+  item = malloc (sizeof (*item));
+  item->num_teams = num_teams;
+  item->next = NULL;
+  *next_ptr = item;
+
+  if (pthread_mutex_init (&item->in_use, NULL))
+    {
+      GOMP_PLUGIN_error ("Failed to initialize a GCN team arena write mutex");
+      return false;
+    }
+  if (pthread_mutex_lock (&item->in_use))
+    {
+      GOMP_PLUGIN_error ("Could not lock a GCN agent program mutex");
+      return false;
+    }
+  if (pthread_mutex_unlock (&agent->team_arena_write_lock))
+    {
+      GOMP_PLUGIN_error ("Could not unlock a GCN agent program mutex");
+      return false;
+    }
+
+  const int TEAM_ARENA_SIZE = 64*1024;  /* Must match libgomp.h.  */
+  hsa_status_t status;
+  status = hsa_fns.hsa_memory_allocate_fn (agent->data_region,
+					   TEAM_ARENA_SIZE*num_teams,
+					   &item->arena);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Could not allocate memory for GCN kernel arena", status);
+  status = hsa_fns.hsa_memory_assign_agent_fn (item->arena, agent->id,
+					       HSA_ACCESS_PERMISSION_RW);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Could not assign arena memory to device", status);
+
+  return item->arena;
+}
+
+/* Mark a team arena available for reuse.  */
+
+static void
+release_team_arena (struct agent_info* agent, void *arena)
+{
+  struct team_arena_list *item;
+
+  for (item = agent->team_arena_list; item; item = item->next)
+    {
+      if (item->arena == arena)
+	{
+	  if (pthread_mutex_unlock (&item->in_use))
+	    GOMP_PLUGIN_error ("Could not unlock a GCN agent program mutex");
+	  return;
+	}
+    }
+  GOMP_PLUGIN_error ("Could not find a GCN arena to release.");
+}
+
+/* Clean up all the allocated team arenas.  */
+
+static bool
+destroy_team_arenas (struct agent_info *agent)
+{
+  struct team_arena_list *item, *next;
+
+  for (item = agent->team_arena_list; item; item = next)
+    {
+      next = item->next;
+      hsa_fns.hsa_memory_free_fn (item->arena);
+      if (pthread_mutex_destroy (&item->in_use))
+	{
+	  GOMP_PLUGIN_error ("Failed to destroy a GCN team arena mutex");
+	  return false;
+	}
+      free (item);
+    }
+  agent->team_arena_list = NULL;
+
+  return true;
+}
+
+/* Allocate memory on a specified device.  */
+
+static void *
+alloc_by_agent (struct agent_info *agent, size_t size)
+{
+  GCN_DEBUG ("Allocating %zu bytes on device %d\n", size, agent->device_id);
+
+  /* Zero-size allocations are invalid, so in order to return a valid pointer
+     we need to pass a valid size.  One source of zero-size allocations is
+     kernargs for kernels that have no inputs or outputs (the kernel may
+     only use console output, for example).  */
+  if (size == 0)
+    size = 4;
+
+  void *ptr;
+  hsa_status_t status = hsa_fns.hsa_memory_allocate_fn (agent->data_region,
+							size, &ptr);
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_error ("Could not allocate device memory", status);
+      return NULL;
+    }
+
+  status = hsa_fns.hsa_memory_assign_agent_fn (ptr, agent->id,
+					       HSA_ACCESS_PERMISSION_RW);
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_error ("Could not assign data memory to device", status);
+      return NULL;
+    }
+
+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();
+  bool profiling_dispatch_p
+    = __builtin_expect (thr != NULL && thr->prof_info != NULL, false);
+  if (profiling_dispatch_p)
+    {
+      acc_prof_info *prof_info = thr->prof_info;
+      acc_event_info data_event_info;
+      acc_api_info *api_info = thr->api_info;
+
+      prof_info->event_type = acc_ev_alloc;
+
+      data_event_info.data_event.event_type = prof_info->event_type;
+      data_event_info.data_event.valid_bytes
+	= _ACC_DATA_EVENT_INFO_VALID_BYTES;
+      data_event_info.data_event.parent_construct
+	= acc_construct_parallel;
+      data_event_info.data_event.implicit = 1;
+      data_event_info.data_event.tool_info = NULL;
+      data_event_info.data_event.var_name = NULL;
+      data_event_info.data_event.bytes = size;
+      data_event_info.data_event.host_ptr = NULL;
+      data_event_info.data_event.device_ptr = (void *) ptr;
+
+      api_info->device_api = acc_device_api_other;
+
+      GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,
+					    api_info);
+    }
+
+  return ptr;
+}
+
+/* Create kernel dispatch data structure for given KERNEL, along with
+   the necessary device signals and memory allocations.  */
+
+static struct kernel_dispatch *
+create_kernel_dispatch (struct kernel_info *kernel, int num_teams)
+{
+  struct agent_info *agent = kernel->agent;
+  struct kernel_dispatch *shadow
+    = GOMP_PLUGIN_malloc_cleared (sizeof (struct kernel_dispatch));
+
+  shadow->agent = kernel->agent;
+  shadow->object = kernel->object;
+
+  hsa_signal_t sync_signal;
+  hsa_status_t status = hsa_fns.hsa_signal_create_fn (1, 0, NULL, &sync_signal);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Error creating the GCN sync signal", status);
+
+  shadow->signal = sync_signal.handle;
+  shadow->private_segment_size = kernel->private_segment_size;
+  shadow->group_segment_size = kernel->group_segment_size;
+
+  /* We expect kernels to request a single pointer, explicitly, and the
+     rest of struct kernargs, implicitly.  If they request anything else
+     then something is wrong.  */
+  if (kernel->kernarg_segment_size > 8)
+    {
+      GOMP_PLUGIN_fatal ("Unexpectedly large kernargs segment requested");
+      return NULL;
+    }
+
+  status = hsa_fns.hsa_memory_allocate_fn (agent->kernarg_region,
+					   sizeof (struct kernargs),
+					   &shadow->kernarg_address);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Could not allocate memory for GCN kernel arguments", status);
+  struct kernargs *kernargs = shadow->kernarg_address;
+
+  /* Zero-initialize the output_data (minimum needed).  */
+  kernargs->out_ptr = (int64_t)&kernargs->output_data;
+  kernargs->output_data.next_output = 0;
+  for (unsigned i = 0;
+       i < (sizeof (kernargs->output_data.queue)
+	    / sizeof (kernargs->output_data.queue[0]));
+       i++)
+    kernargs->output_data.queue[i].written = 0;
+  kernargs->output_data.consumed = 0;
+
+  /* Pass in the heap location.  */
+  kernargs->heap_ptr = (int64_t)kernel->module->heap;
+
+  /* Create an arena.  */
+  if (kernel->kind == KIND_OPENMP)
+    kernargs->arena_ptr = (int64_t)get_team_arena (agent, num_teams);
+  else
+    kernargs->arena_ptr = 0;
+
+  /* Ensure we can recognize unset return values.  */
+  kernargs->output_data.return_value = 0xcafe0000;
+
+  return shadow;
+}
+
+/* Output any data written to console output from the kernel.  It is expected
+   that this function is polled during kernel execution.
+
+   We print all entries from the last item printed to the next entry without
+   a "written" flag.  If the "final" flag is set then it'll continue right to
+   the end.
+ 
+   The print buffer is circular, but the from and to locations don't wrap when
+   the buffer does, so the output limit is UINT_MAX.  The target blocks on
+   output when the buffer is full.  */
+
+static void
+console_output (struct kernel_info *kernel, struct kernargs *kernargs,
+		bool final)
+{
+  unsigned int limit = (sizeof (kernargs->output_data.queue)
+			/ sizeof (kernargs->output_data.queue[0]));
+
+  unsigned int from = __atomic_load_n (&kernargs->output_data.consumed,
+				       __ATOMIC_ACQUIRE);
+  unsigned int to = kernargs->output_data.next_output;
+
+  if (from > to)
+    {
+      /* Overflow.  */
+      if (final)
+	printf ("GCN print buffer overflowed.\n");
+      return;
+    }
+
+  unsigned int i;
+  for (i = from; i < to; i++)
+    {
+      struct printf_data *data = &kernargs->output_data.queue[i%limit];
+
+      if (!data->written && !final)
+	break;
+
+      switch (data->type)
+	{
+	case 0: printf ("%.128s%ld\n", data->msg, data->ivalue); break;
+	case 1: printf ("%.128s%f\n", data->msg, data->dvalue); break;
+	case 2: printf ("%.128s%.128s\n", data->msg, data->text); break;
+	case 3: printf ("%.128s%.128s", data->msg, data->text); break;
+	default: printf ("GCN print buffer error!\n"); break;
+	}
+      data->written = 0;
+      __atomic_store_n (&kernargs->output_data.consumed, i+1,
+			__ATOMIC_RELEASE);
+    }
+  fflush (stdout);
+}
+
+/* Release data structure created for a kernel dispatch in SHADOW argument,
+   and clean up the signal and memory allocations.  */
+
+static void
+release_kernel_dispatch (struct kernel_dispatch *shadow)
+{
+  GCN_DEBUG ("Released kernel dispatch: %p\n", shadow);
+
+  struct kernargs *kernargs = shadow->kernarg_address;
+  void *arena = (void *)kernargs->arena_ptr;
+  if (arena)
+    release_team_arena (shadow->agent, arena);
+
+  hsa_fns.hsa_memory_free_fn (shadow->kernarg_address);
+
+  hsa_signal_t s;
+  s.handle = shadow->signal;
+  hsa_fns.hsa_signal_destroy_fn (s);
+
+  free (shadow);
+}
+
+/* Extract the properties from a kernel binary.  */
+
+static void
+init_kernel_properties (struct kernel_info *kernel)
+{
+  hsa_status_t status;
+  struct agent_info *agent = kernel->agent;
+  hsa_executable_symbol_t kernel_symbol;
+  status = hsa_fns.hsa_executable_get_symbol_fn (agent->executable, NULL,
+						 kernel->name, agent->id,
+						 0, &kernel_symbol);
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_warn ("Could not find symbol for kernel in the code object", status);
+      fprintf (stderr, "not found name: '%s'\n", kernel->name);
+      dump_executable_symbols (agent->executable);
+      goto failure;
+    }
+  GCN_DEBUG ("Located kernel %s\n", kernel->name);
+  status = hsa_fns.hsa_executable_symbol_get_info_fn
+    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &kernel->object);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Could not extract a kernel object from its symbol", status);
+  status = hsa_fns.hsa_executable_symbol_get_info_fn
+    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_SIZE,
+     &kernel->kernarg_segment_size);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Could not get info about kernel argument size", status);
+  status = hsa_fns.hsa_executable_symbol_get_info_fn
+    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_GROUP_SEGMENT_SIZE,
+     &kernel->group_segment_size);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Could not get info about kernel group segment size", status);
+  status = hsa_fns.hsa_executable_symbol_get_info_fn
+    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE,
+     &kernel->private_segment_size);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Could not get info about kernel private segment size",
+	       status);
+
+  /* The kernel type is not known until something tries to launch it.  */
+  kernel->kind = KIND_UNKNOWN;
+
+  GCN_DEBUG ("Kernel structure for %s fully initialized with "
+	     "following segment sizes: \n", kernel->name);
+  GCN_DEBUG ("  group_segment_size: %u\n",
+	     (unsigned) kernel->group_segment_size);
+  GCN_DEBUG ("  private_segment_size: %u\n",
+	     (unsigned) kernel->private_segment_size);
+  GCN_DEBUG ("  kernarg_segment_size: %u\n",
+	     (unsigned) kernel->kernarg_segment_size);
+  return;
+
+failure:
+  kernel->initialization_failed = true;
+}
+
+/* Do all the work that is necessary before running KERNEL for the first time.
+   The function assumes the program has been created, finalized and frozen by
+   create_and_finalize_hsa_program.  */
+
+static void
+init_kernel (struct kernel_info *kernel)
+{
+  if (pthread_mutex_lock (&kernel->init_mutex))
+    GOMP_PLUGIN_fatal ("Could not lock a GCN kernel initialization mutex");
+  if (kernel->initialized)
+    {
+      if (pthread_mutex_unlock (&kernel->init_mutex))
+	GOMP_PLUGIN_fatal ("Could not unlock a GCN kernel initialization "
+			   "mutex");
+
+      return;
+    }
+
+  init_kernel_properties (kernel);
+
+  if (!kernel->initialization_failed)
+    {
+      GCN_DEBUG ("\n");
+
+      kernel->initialized = true;
+    }
+  if (pthread_mutex_unlock (&kernel->init_mutex))
+    GOMP_PLUGIN_fatal ("Could not unlock a GCN kernel initialization "
+		       "mutex");
+}
+
+/* Run KERNEL on its agent, pass VARS to it as arguments and take
+   launch attributes from KLA.
+   
+   MODULE_LOCKED indicates that the caller already holds the lock and
+   run_kernel need not lock it again.
+   If AQ is NULL then agent->sync_queue will be used.  */
+
+static void
+run_kernel (struct kernel_info *kernel, void *vars,
+	    struct GOMP_kernel_launch_attributes *kla,
+	    struct goacc_asyncqueue *aq, bool module_locked)
+{
+  GCN_DEBUG ("GCN launch on queue: %d:%d\n", kernel->agent->device_id,
+	     (aq ? aq->id : 0));
+  GCN_DEBUG ("GCN launch attribs: gdims:[");
+  int i;
+  for (i = 0; i < kla->ndim; ++i)
+    {
+      if (i)
+	DEBUG_PRINT (", ");
+      DEBUG_PRINT ("%u", kla->gdims[i]);
+    }
+  DEBUG_PRINT ("], normalized gdims:[");
+  for (i = 0; i < kla->ndim; ++i)
+    {
+      if (i)
+	DEBUG_PRINT (", ");
+      DEBUG_PRINT ("%u", kla->gdims[i] / kla->wdims[i]);
+    }
+  DEBUG_PRINT ("], wdims:[");
+  for (i = 0; i < kla->ndim; ++i)
+    {
+      if (i)
+	DEBUG_PRINT (", ");
+      DEBUG_PRINT ("%u", kla->wdims[i]);
+    }
+  DEBUG_PRINT ("]\n");
+  DEBUG_FLUSH ();
+
+  struct agent_info *agent = kernel->agent;
+  if (!module_locked && pthread_rwlock_rdlock (&agent->module_rwlock))
+    GOMP_PLUGIN_fatal ("Unable to read-lock a GCN agent rwlock");
+
+  if (!agent->initialized)
+    GOMP_PLUGIN_fatal ("Agent must be initialized");
+
+  if (!kernel->initialized)
+    GOMP_PLUGIN_fatal ("Called kernel must be initialized");
+
+  hsa_queue_t *command_q = (aq ? aq->hsa_queue : kernel->agent->sync_queue);
+
+  uint64_t index
+    = hsa_fns.hsa_queue_add_write_index_release_fn (command_q, 1);
+  GCN_DEBUG ("Got AQL index %llu\n", (long long int) index);
+
+  /* Wait until the queue is not full before writing the packet.   */
+  while (index - hsa_fns.hsa_queue_load_read_index_acquire_fn (command_q)
+	 >= command_q->size)
+    ;
+
+  /* Do not allow the dimensions to be overridden when running
+     constructors or destructors.  */
+  int override_x = kernel->kind == KIND_UNKNOWN ? 0 : override_x_dim;
+  int override_z = kernel->kind == KIND_UNKNOWN ? 0 : override_z_dim;
+
+  hsa_kernel_dispatch_packet_t *packet;
+  packet = ((hsa_kernel_dispatch_packet_t *) command_q->base_address)
+	   + index % command_q->size;
+
+  memset (((uint8_t *) packet) + 4, 0, sizeof (*packet) - 4);
+  packet->grid_size_x = override_x ? : kla->gdims[0];
+  packet->workgroup_size_x = get_group_size (kla->ndim,
+					     packet->grid_size_x,
+					     kla->wdims[0]);
+
+  if (kla->ndim >= 2)
+    {
+      packet->grid_size_y = kla->gdims[1];
+      packet->workgroup_size_y = get_group_size (kla->ndim, kla->gdims[1],
+						 kla->wdims[1]);
+    }
+  else
+    {
+      packet->grid_size_y = 1;
+      packet->workgroup_size_y = 1;
+    }
+
+  if (kla->ndim == 3)
+    {
+      packet->grid_size_z = limit_worker_threads (override_z
+						  ? : kla->gdims[2]);
+      packet->workgroup_size_z = get_group_size (kla->ndim,
+						 packet->grid_size_z,
+						 kla->wdims[2]);
+    }
+  else
+    {
+      packet->grid_size_z = 1;
+      packet->workgroup_size_z = 1;
+    }
+
+  GCN_DEBUG ("GCN launch actuals: grid:[%u, %u, %u],"
+	     " normalized grid:[%u, %u, %u], workgroup:[%u, %u, %u]\n",
+	     packet->grid_size_x, packet->grid_size_y, packet->grid_size_z,
+	     packet->grid_size_x / packet->workgroup_size_x,
+	     packet->grid_size_y / packet->workgroup_size_y,
+	     packet->grid_size_z / packet->workgroup_size_z,
+	     packet->workgroup_size_x, packet->workgroup_size_y,
+	     packet->workgroup_size_z);
+
+  struct kernel_dispatch *shadow
+    = create_kernel_dispatch (kernel, packet->grid_size_x);
+  shadow->queue = command_q;
+
+  if (debug)
+    {
+      fprintf (stderr, "\nKernel has following dependencies:\n");
+      print_kernel_dispatch (shadow, 2);
+    }
+
+  packet->private_segment_size = kernel->private_segment_size;
+  packet->group_segment_size = kernel->group_segment_size;
+  packet->kernel_object = kernel->object;
+  packet->kernarg_address = shadow->kernarg_address;
+  hsa_signal_t s;
+  s.handle = shadow->signal;
+  packet->completion_signal = s;
+  hsa_fns.hsa_signal_store_relaxed_fn (s, 1);
+  memcpy (shadow->kernarg_address, &vars, sizeof (vars));
+
+  GCN_DEBUG ("Copying kernel runtime pointer to kernarg_address\n");
+
+  uint16_t header;
+  header = HSA_PACKET_TYPE_KERNEL_DISPATCH << HSA_PACKET_HEADER_TYPE;
+  header |= HSA_FENCE_SCOPE_SYSTEM << HSA_PACKET_HEADER_ACQUIRE_FENCE_SCOPE;
+  header |= HSA_FENCE_SCOPE_SYSTEM << HSA_PACKET_HEADER_RELEASE_FENCE_SCOPE;
+
+  GCN_DEBUG ("Going to dispatch kernel %s on device %d\n", kernel->name,
+	     agent->device_id);
+
+  packet_store_release ((uint32_t *) packet, header,
+			(uint16_t) kla->ndim
+			<< HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS);
+
+  hsa_fns.hsa_signal_store_release_fn (command_q->doorbell_signal,
+				       index);
+
+  GCN_DEBUG ("Kernel dispatched, waiting for completion\n");
+
+  /* Root signal waits with 1ms timeout.  */
+  while (hsa_fns.hsa_signal_wait_acquire_fn (s, HSA_SIGNAL_CONDITION_LT, 1,
+					     1000 * 1000,
+					     HSA_WAIT_STATE_BLOCKED) != 0)
+    {
+      console_output (kernel, shadow->kernarg_address, false);
+    }
+  console_output (kernel, shadow->kernarg_address, true);
+
+  struct kernargs *kernargs = shadow->kernarg_address;
+  unsigned int return_value = (unsigned int)kernargs->output_data.return_value;
+
+  release_kernel_dispatch (shadow);
+
+  if (!module_locked && pthread_rwlock_unlock (&agent->module_rwlock))
+    GOMP_PLUGIN_fatal ("Unable to unlock a GCN agent rwlock");
+
+  unsigned int upper = (return_value & ~0xffff) >> 16;
+  if (upper == 0xcafe)
+    ; // exit not called, normal termination.
+  else if (upper == 0xffff)
+    ; // exit called.
+  else
+    {
+      GOMP_PLUGIN_error ("Possible kernel exit value corruption, 2 most"
+			 " significant bytes aren't 0xffff or 0xcafe: 0x%x\n",
+			 return_value);
+      abort ();
+    }
+
+  if (upper == 0xffff)
+    {
+      unsigned int signal = (return_value >> 8) & 0xff;
+
+      if (signal == SIGABRT)
+	{
+	  GCN_WARNING ("GCN Kernel aborted\n");
+	  abort ();
+	}
+      else if (signal != 0)
+	{
+	  GCN_WARNING ("GCN Kernel received unknown signal\n");
+	  abort ();
+	}
+
+      GCN_DEBUG ("GCN Kernel exited with value: %d\n", return_value & 0xff);
+      exit (return_value & 0xff);
+    }
+}
+
+/* }}}  */
+/* {{{ Load/Unload  */
+
+/* Initialize KERNEL from D and other parameters.  Return true on success. */
+
+static bool
+init_basic_kernel_info (struct kernel_info *kernel,
+			struct hsa_kernel_description *d,
+			struct agent_info *agent,
+			struct module_info *module)
+{
+  kernel->agent = agent;
+  kernel->module = module;
+  kernel->name = d->name;
+  if (pthread_mutex_init (&kernel->init_mutex, NULL))
+    {
+      GOMP_PLUGIN_error ("Failed to initialize a GCN kernel mutex");
+      return false;
+    }
+  return true;
+}
+
+/* Find the load_offset for MODULE, save to *LOAD_OFFSET, and return true.  If
+   not found, return false.  */
+
+static bool
+find_load_offset (Elf64_Addr *load_offset, struct agent_info *agent,
+		  struct module_info *module, Elf64_Ehdr *image,
+		  Elf64_Shdr *sections)
+{
+  bool res = false;
+
+  hsa_status_t status;
+
+  hsa_executable_symbol_t symbol;
+  if (!find_executable_symbol (agent->executable, &symbol))
+    return false;
+
+  status = hsa_fns.hsa_executable_symbol_get_info_fn
+    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS, load_offset);
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_error ("Could not extract symbol address", status);
+      return false;
+    }
+
+  char *symbol_name = get_executable_symbol_name (symbol);
+  if (symbol_name == NULL)
+    return false;
+
+  /* Find the kernel function in ELF, and calculate actual load offset.  */
+  for (int i = 0; i < image->e_shnum; i++)
+    if (sections[i].sh_type == SHT_SYMTAB)
+      {
+	Elf64_Shdr *strtab = &sections[sections[i].sh_link];
+	char *strings = (char *)image + strtab->sh_offset;
+
+	for (size_t offset = 0;
+	     offset < sections[i].sh_size;
+	     offset += sections[i].sh_entsize)
+	  {
+	    Elf64_Sym *sym = (Elf64_Sym*)((char*)image
+					  + sections[i].sh_offset
+					  + offset);
+	    if (strcmp (symbol_name, strings + sym->st_name) == 0)
+	      {
+		*load_offset -= sym->st_value;
+		res = true;
+		break;
+	      }
+	  }
+      }
+
+  free (symbol_name);
+  return res;
+}
+
+/* Create and finalize the program consisting of all loaded modules.  */
+
+static bool
+create_and_finalize_hsa_program (struct agent_info *agent)
+{
+  hsa_status_t status;
+  int reloc_count = 0;
+  bool res = true;
+  if (pthread_mutex_lock (&agent->prog_mutex))
+    {
+      GOMP_PLUGIN_error ("Could not lock a GCN agent program mutex");
+      return false;
+    }
+  if (agent->prog_finalized)
+    goto final;
+
+  status
+    = hsa_fns.hsa_executable_create_fn (HSA_PROFILE_FULL,
+					HSA_EXECUTABLE_STATE_UNFROZEN,
+					"", &agent->executable);
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_error ("Could not create GCN executable", status);
+      goto fail;
+    }
+
+  /* Load any GCN modules.  */
+  struct module_info *module = agent->module;
+  if (module)
+    {
+      Elf64_Ehdr *image = (Elf64_Ehdr *)module->image_desc->gcn_image->image;
+
+      /* Hide relocations from the HSA runtime loader.
+	 Keep a copy of the unmodified section headers to use later.  */
+      Elf64_Shdr *image_sections = (Elf64_Shdr *)((char *)image
+						  + image->e_shoff);
+      for (int i = image->e_shnum - 1; i >= 0; i--)
+	{
+	  if (image_sections[i].sh_type == SHT_RELA
+	      || image_sections[i].sh_type == SHT_REL)
+	    /* Change section type to something harmless.  */
+	    image_sections[i].sh_type |= 0x80;
+	}
+
+      hsa_code_object_t co = { 0 };
+      status = hsa_fns.hsa_code_object_deserialize_fn
+	(module->image_desc->gcn_image->image,
+	 module->image_desc->gcn_image->size,
+	 NULL, &co);
+      if (status != HSA_STATUS_SUCCESS)
+	{
+	  hsa_error ("Could not deserialize GCN code object", status);
+	  goto fail;
+	}
+
+      status = hsa_fns.hsa_executable_load_code_object_fn
+	(agent->executable, agent->id, co, "");
+      if (status != HSA_STATUS_SUCCESS)
+	{
+	  hsa_error ("Could not load GCN code object", status);
+	  goto fail;
+	}
+
+      if (!module->heap)
+	{
+	  status = hsa_fns.hsa_memory_allocate_fn (agent->data_region,
+						   gcn_kernel_heap_size,
+						   (void**)&module->heap);
+	  if (status != HSA_STATUS_SUCCESS)
+	    {
+	      hsa_error ("Could not allocate memory for GCN heap", status);
+	      goto fail;
+	    }
+
+	  status = hsa_fns.hsa_memory_assign_agent_fn
+			(module->heap, agent->id, HSA_ACCESS_PERMISSION_RW);
+	  if (status != HSA_STATUS_SUCCESS)
+	    {
+	      hsa_error ("Could not assign GCN heap memory to device", status);
+	      goto fail;
+	    }
+
+	  hsa_fns.hsa_memory_copy_fn (&module->heap->size,
+				      &gcn_kernel_heap_size,
+				      sizeof (gcn_kernel_heap_size));
+	}
+
+    }
+
+  if (debug)
+    dump_executable_symbols (agent->executable);
+
+  status = hsa_fns.hsa_executable_freeze_fn (agent->executable, "");
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_error ("Could not freeze the GCN executable", status);
+      goto fail;
+    }
+
+  if (agent->module)
+    {
+      struct module_info *module = agent->module;
+      Elf64_Ehdr *image = (Elf64_Ehdr *)module->image_desc->gcn_image->image;
+      Elf64_Shdr *sections = (Elf64_Shdr *)((char *)image + image->e_shoff);
+
+      Elf64_Addr load_offset;
+      if (!find_load_offset (&load_offset, agent, module, image, sections))
+	goto fail;
+
+      /* Record the physical load address range.
+	 We need this for data copies later.  */
+      Elf64_Phdr *segments = (Elf64_Phdr *)((char*)image + image->e_phoff);
+      Elf64_Addr low = ~0, high = 0;
+      for (int i = 0; i < image->e_phnum; i++)
+	if (segments[i].p_memsz > 0)
+	  {
+	    if (segments[i].p_paddr < low)
+	      low = segments[i].p_paddr;
+	    if (segments[i].p_paddr > high)
+	      high = segments[i].p_paddr + segments[i].p_memsz - 1;
+	  }
+      module->phys_address_start = low + load_offset;
+      module->phys_address_end = high + load_offset;
+
+      // Find dynamic symbol table
+      Elf64_Shdr *dynsym = NULL;
+      for (int i = 0; i < image->e_shnum; i++)
+	if (sections[i].sh_type == SHT_DYNSYM)
+	  {
+	    dynsym = &sections[i];
+	    break;
+	  }
+
+      /* Fix up relocations.  */
+      for (int i = 0; i < image->e_shnum; i++)
+	{
+	  if (sections[i].sh_type == (SHT_RELA | 0x80))
+	    for (size_t offset = 0;
+		 offset < sections[i].sh_size;
+		 offset += sections[i].sh_entsize)
+	      {
+		Elf64_Rela *reloc = (Elf64_Rela*)((char*)image
+						  + sections[i].sh_offset
+						  + offset);
+		Elf64_Sym *sym =
+		  (dynsym
+		   ? (Elf64_Sym*)((char*)image
+				  + dynsym->sh_offset
+				  + (dynsym->sh_entsize
+				     * ELF64_R_SYM (reloc->r_info)))
+		   : NULL);
+
+		int64_t S = (sym ? sym->st_value : 0);
+		int64_t P = reloc->r_offset + load_offset;
+		int64_t A = reloc->r_addend;
+		int64_t B = load_offset;
+		int64_t V, size;
+		switch (ELF64_R_TYPE (reloc->r_info))
+		  {
+		  case R_AMDGPU_ABS32_LO:
+		    V = (S + A) & 0xFFFFFFFF;
+		    size = 4;
+		    break;
+		  case R_AMDGPU_ABS32_HI:
+		    V = (S + A) >> 32;
+		    size = 4;
+		    break;
+		  case R_AMDGPU_ABS64:
+		    V = S + A;
+		    size = 8;
+		    break;
+		  case R_AMDGPU_REL32:
+		    V = S + A - P;
+		    size = 4;
+		    break;
+		  case R_AMDGPU_REL64:
+		    /* FIXME
+		       LLD seems to emit REL64 where the the assembler has
+		       ABS64.  This is clearly wrong because it's not what the
+		       compiler is expecting.  Let's assume, for now, that
+		       it's a bug.  In any case, GCN kernels are always self
+		       contained and therefore relative relocations will have
+		       been resolved already, so this should be a safe
+		       workaround.  */
+		    V = S + A/* - P*/;
+		    size = 8;
+		    break;
+		  case R_AMDGPU_ABS32:
+		    V = S + A;
+		    size = 4;
+		    break;
+		    /* TODO R_AMDGPU_GOTPCREL */
+		    /* TODO R_AMDGPU_GOTPCREL32_LO */
+		    /* TODO R_AMDGPU_GOTPCREL32_HI */
+		  case R_AMDGPU_REL32_LO:
+		    V = (S + A - P) & 0xFFFFFFFF;
+		    size = 4;
+		    break;
+		  case R_AMDGPU_REL32_HI:
+		    V = (S + A - P) >> 32;
+		    size = 4;
+		    break;
+		  case R_AMDGPU_RELATIVE64:
+		    V = B + A;
+		    size = 8;
+		    break;
+		  default:
+		    fprintf (stderr, "Error: unsupported relocation type.\n");
+		    exit (1);
+		  }
+		status = hsa_fns.hsa_memory_copy_fn ((void*)P, &V, size);
+		if (status != HSA_STATUS_SUCCESS)
+		  {
+		    hsa_error ("Failed to fix up relocation", status);
+		    goto fail;
+		  }
+		reloc_count++;
+	      }
+	}
+    }
+
+  GCN_DEBUG ("Loaded GCN kernels to device %d (%d relocations)\n",
+	     agent->device_id, reloc_count);
+
+final:
+  agent->prog_finalized = true;
+
+  if (pthread_mutex_unlock (&agent->prog_mutex))
+    {
+      GOMP_PLUGIN_error ("Could not unlock a GCN agent program mutex");
+      res = false;
+    }
+
+  return res;
+
+fail:
+  res = false;
+  goto final;
+}
+
+/* Free the HSA program in agent and everything associated with it and set
+   agent->prog_finalized and the initialized flags of all kernels to false.
+   Return TRUE on success.  */
+
+static bool
+destroy_hsa_program (struct agent_info *agent)
+{
+  if (!agent->prog_finalized)
+    return true;
+
+  hsa_status_t status;
+
+  GCN_DEBUG ("Destroying the current GCN program.\n");
+
+  status = hsa_fns.hsa_executable_destroy_fn (agent->executable);
+  if (status != HSA_STATUS_SUCCESS)
+    return hsa_error ("Could not destroy GCN executable", status);
+
+  if (agent->module)
+    {
+      int i;
+      for (i = 0; i < agent->module->kernel_count; i++)
+	agent->module->kernels[i].initialized = false;
+
+      if (agent->module->heap)
+	{
+	  hsa_fns.hsa_memory_free_fn (agent->module->heap);
+	  agent->module->heap = NULL;
+	}
+    }
+  agent->prog_finalized = false;
+  return true;
+}
+
+/* Deinitialize all information associated with MODULE and kernels within
+   it.  Return TRUE on success.  */
+
+static bool
+destroy_module (struct module_info *module, bool locked)
+{
+  /* Run destructors before destroying module.  */
+  struct GOMP_kernel_launch_attributes kla =
+    { 3,
+      /* Grid size.  */
+      { 1, 64, 1 },
+      /* Work-group size.  */
+      { 1, 64, 1 }
+    };
+
+  if (module->fini_array_func)
+    {
+      init_kernel (module->fini_array_func);
+      run_kernel (module->fini_array_func, NULL, &kla, NULL, locked);
+    }
+  module->constructors_run_p = false;
+
+  int i;
+  for (i = 0; i < module->kernel_count; i++)
+    if (pthread_mutex_destroy (&module->kernels[i].init_mutex))
+      {
+	GOMP_PLUGIN_error ("Failed to destroy a GCN kernel initialization "
+			   "mutex");
+	return false;
+      }
+
+  return true;
+}
+
+/* }}}  */
+/* {{{ Async  */
+
+/* Callback of dispatch queues to report errors.  */
+
+static void
+execute_queue_entry (struct goacc_asyncqueue *aq, int index)
+{
+  struct queue_entry *entry = &aq->queue[index];
+
+  switch (entry->type)
+    {
+    case KERNEL_LAUNCH:
+      if (DEBUG_QUEUES)
+	GCN_DEBUG ("Async thread %d:%d: Executing launch entry (%d)\n",
+		   aq->agent->device_id, aq->id, index);
+      run_kernel (entry->u.launch.kernel,
+		  entry->u.launch.vars,
+		  &entry->u.launch.kla, aq, false);
+      if (DEBUG_QUEUES)
+	GCN_DEBUG ("Async thread %d:%d: Executing launch entry (%d) done\n",
+		   aq->agent->device_id, aq->id, index);
+      break;
+
+    case CALLBACK:
+      if (DEBUG_QUEUES)
+	GCN_DEBUG ("Async thread %d:%d: Executing callback entry (%d)\n",
+		   aq->agent->device_id, aq->id, index);
+      entry->u.callback.fn (entry->u.callback.data);
+      if (DEBUG_QUEUES)
+	GCN_DEBUG ("Async thread %d:%d: Executing callback entry (%d) done\n",
+		   aq->agent->device_id, aq->id, index);
+      break;
+
+    case ASYNC_WAIT:
+      {
+	/* FIXME: is it safe to access a placeholder that may already have
+	   been executed?  */
+        struct placeholder *placeholderp = entry->u.asyncwait.placeholderp;
+
+	if (DEBUG_QUEUES)
+          GCN_DEBUG ("Async thread %d:%d: Executing async wait entry (%d)\n",
+		     aq->agent->device_id, aq->id, index);
+
+	pthread_mutex_lock (&placeholderp->mutex);
+
+	while (!placeholderp->executed)
+          pthread_cond_wait (&placeholderp->cond, &placeholderp->mutex);
+
+	pthread_mutex_unlock (&placeholderp->mutex);
+
+	if (pthread_cond_destroy (&placeholderp->cond))
+	  GOMP_PLUGIN_error ("Failed to destroy serialization cond");
+
+	if (pthread_mutex_destroy (&placeholderp->mutex))
+	  GOMP_PLUGIN_error ("Failed to destroy serialization mutex");
+
+	if (DEBUG_QUEUES)
+          GCN_DEBUG ("Async thread %d:%d: Executing async wait "
+		     "entry (%d) done\n", aq->agent->device_id, aq->id, index);
+      }
+      break;
+
+    case ASYNC_PLACEHOLDER:
+      pthread_mutex_lock (&entry->u.placeholder.mutex);
+      entry->u.placeholder.executed = 1;
+      pthread_cond_signal (&entry->u.placeholder.cond);
+      pthread_mutex_unlock (&entry->u.placeholder.mutex);
+      break;
+
+    default:
+      GOMP_PLUGIN_fatal ("Unknown queue element");
+    }
+}
+
+/* This function is run as a thread to service an async queue in the
+   background.  It runs continuously until the stop flag is set.  */
+
+static void *
+drain_queue (void *thread_arg)
+{
+  struct goacc_asyncqueue *aq = thread_arg;
+
+  if (DRAIN_QUEUE_SYNCHRONOUS_P)
+    {
+      aq->drain_queue_stop = 2;
+      return NULL;
+    }
+
+  pthread_mutex_lock (&aq->mutex);
+
+  while (true)
+    {
+      if (aq->drain_queue_stop)
+	break;
+
+      if (aq->queue_n > 0)
+	{
+	  pthread_mutex_unlock (&aq->mutex);
+	  execute_queue_entry (aq, aq->queue_first);
+
+	  pthread_mutex_lock (&aq->mutex);
+	  aq->queue_first = ((aq->queue_first + 1)
+			     % ASYNC_QUEUE_SIZE);
+	  aq->queue_n--;
+
+	  if (DEBUG_THREAD_SIGNAL)
+	    GCN_DEBUG ("Async thread %d:%d: broadcasting queue out update\n",
+		       aq->agent->device_id, aq->id);
+	  pthread_cond_broadcast (&aq->queue_cond_out);
+	  pthread_mutex_unlock (&aq->mutex);
+
+	  if (DEBUG_QUEUES)
+	    GCN_DEBUG ("Async thread %d:%d: continue\n", aq->agent->device_id,
+		       aq->id);
+	  pthread_mutex_lock (&aq->mutex);
+	}
+      else
+	{
+	  if (DEBUG_THREAD_SLEEP)
+	    GCN_DEBUG ("Async thread %d:%d: going to sleep\n",
+		       aq->agent->device_id, aq->id);
+	  pthread_cond_wait (&aq->queue_cond_in, &aq->mutex);
+	  if (DEBUG_THREAD_SLEEP)
+	    GCN_DEBUG ("Async thread %d:%d: woke up, rechecking\n",
+		       aq->agent->device_id, aq->id);
+	}
+    }
+
+  aq->drain_queue_stop = 2;
+  if (DEBUG_THREAD_SIGNAL)
+    GCN_DEBUG ("Async thread %d:%d: broadcasting last queue out update\n",
+	       aq->agent->device_id, aq->id);
+  pthread_cond_broadcast (&aq->queue_cond_out);
+  pthread_mutex_unlock (&aq->mutex);
+
+  GCN_DEBUG ("Async thread %d:%d: returning\n", aq->agent->device_id, aq->id);
+  return NULL;
+}
+
+/* This function is used only when DRAIN_QUEUE_SYNCHRONOUS_P is set, which
+   is not usually the case.  This is just a debug tool.  */
+
+static void
+drain_queue_synchronous (struct goacc_asyncqueue *aq)
+{
+  pthread_mutex_lock (&aq->mutex);
+
+  while (aq->queue_n > 0)
+    {
+      execute_queue_entry (aq, aq->queue_first);
+
+      aq->queue_first = ((aq->queue_first + 1)
+			 % ASYNC_QUEUE_SIZE);
+      aq->queue_n--;
+    }
+
+  pthread_mutex_unlock (&aq->mutex);
+}
+
+/* Block the current thread until an async queue is writable.  The aq->mutex
+   lock should be held on entry, and remains locked on exit.  */
+
+static void
+wait_for_queue_nonfull (struct goacc_asyncqueue *aq)
+{
+  if (aq->queue_n == ASYNC_QUEUE_SIZE)
+    {
+      /* Queue is full.  Wait for it to not be full.  */
+      while (aq->queue_n == ASYNC_QUEUE_SIZE)
+	pthread_cond_wait (&aq->queue_cond_out, &aq->mutex);
+    }
+}
+
+/* Request an asynchronous kernel launch on the specified queue.  This
+   may block if the queue is full, but returns without waiting for the
+   kernel to run.  */
+
+static void
+queue_push_launch (struct goacc_asyncqueue *aq, struct kernel_info *kernel,
+		   void *vars, struct GOMP_kernel_launch_attributes *kla)
+{
+  assert (aq->agent == kernel->agent);
+
+  pthread_mutex_lock (&aq->mutex);
+
+  wait_for_queue_nonfull (aq);
+
+  int queue_last = ((aq->queue_first + aq->queue_n)
+		    % ASYNC_QUEUE_SIZE);
+  if (DEBUG_QUEUES)
+    GCN_DEBUG ("queue_push_launch %d:%d: at %i\n", aq->agent->device_id,
+	       aq->id, queue_last);
+
+  aq->queue[queue_last].type = KERNEL_LAUNCH;
+  aq->queue[queue_last].u.launch.kernel = kernel;
+  aq->queue[queue_last].u.launch.vars = vars;
+  aq->queue[queue_last].u.launch.kla = *kla;
+
+  aq->queue_n++;
+
+  if (DEBUG_THREAD_SIGNAL)
+    GCN_DEBUG ("signalling async thread %d:%d: cond_in\n",
+	       aq->agent->device_id, aq->id);
+  pthread_cond_signal (&aq->queue_cond_in);
+
+  pthread_mutex_unlock (&aq->mutex);
+}
+
+/* Request an asynchronous callback on the specified queue.  The callback
+   function will be called, with the given opaque data, from the appropriate
+   async thread, when all previous items on that queue are complete.  */
+
+static void
+queue_push_callback (struct goacc_asyncqueue *aq, void (*fn)(void *),
+		     void *data)
+{
+  pthread_mutex_lock (&aq->mutex);
+
+  wait_for_queue_nonfull (aq);
+
+  int queue_last = ((aq->queue_first + aq->queue_n)
+		    % ASYNC_QUEUE_SIZE);
+  if (DEBUG_QUEUES)
+    GCN_DEBUG ("queue_push_callback %d:%d: at %i\n", aq->agent->device_id,
+	       aq->id, queue_last);
+
+  aq->queue[queue_last].type = CALLBACK;
+  aq->queue[queue_last].u.callback.fn = fn;
+  aq->queue[queue_last].u.callback.data = data;
+
+  aq->queue_n++;
+
+  if (DEBUG_THREAD_SIGNAL)
+    GCN_DEBUG ("signalling async thread %d:%d: cond_in\n",
+	       aq->agent->device_id, aq->id);
+  pthread_cond_signal (&aq->queue_cond_in);
+
+  pthread_mutex_unlock (&aq->mutex);
+}
+
+/* Request that a given async thread wait for another thread (unspecified) to
+   reach the given placeholder.  The wait will occur when all previous entries
+   on the queue are complete.  A placeholder is effectively a kind of signal
+   which simply sets a flag when encountered in a queue.  */
+
+static void
+queue_push_asyncwait (struct goacc_asyncqueue *aq,
+		      struct placeholder *placeholderp)
+{
+  pthread_mutex_lock (&aq->mutex);
+
+  wait_for_queue_nonfull (aq);
+
+  int queue_last = ((aq->queue_first + aq->queue_n) % ASYNC_QUEUE_SIZE);
+  if (DEBUG_QUEUES)
+    GCN_DEBUG ("queue_push_asyncwait %d:%d: at %i\n", aq->agent->device_id,
+	       aq->id, queue_last);
+
+  aq->queue[queue_last].type = ASYNC_WAIT;
+  aq->queue[queue_last].u.asyncwait.placeholderp = placeholderp;
+
+  aq->queue_n++;
+
+  if (DEBUG_THREAD_SIGNAL)
+    GCN_DEBUG ("signalling async thread %d:%d: cond_in\n",
+	       aq->agent->device_id, aq->id);
+  pthread_cond_signal (&aq->queue_cond_in);
+
+  pthread_mutex_unlock (&aq->mutex);
+}
+
+/* Add a placeholder into an async queue.  When the async thread reaches the
+   placeholder it will set the "executed" flag to true and continue.
+   Another thread may be waiting on this thread reaching the placeholder.  */
+
+static struct placeholder *
+queue_push_placeholder (struct goacc_asyncqueue *aq)
+{
+  struct placeholder *placeholderp;
+
+  pthread_mutex_lock (&aq->mutex);
+
+  wait_for_queue_nonfull (aq);
+
+  int queue_last = ((aq->queue_first + aq->queue_n) % ASYNC_QUEUE_SIZE);
+  if (DEBUG_QUEUES)
+    GCN_DEBUG ("queue_push_placeholder %d:%d: at %i\n", aq->agent->device_id,
+	       aq->id, queue_last);
+
+  aq->queue[queue_last].type = ASYNC_PLACEHOLDER;
+  placeholderp = &aq->queue[queue_last].u.placeholder;
+
+  if (pthread_mutex_init (&placeholderp->mutex, NULL))
+    {
+      pthread_mutex_unlock (&aq->mutex);
+      GOMP_PLUGIN_error ("Failed to initialize serialization mutex");
+    }
+
+  if (pthread_cond_init (&placeholderp->cond, NULL))
+    {
+      pthread_mutex_unlock (&aq->mutex);
+      GOMP_PLUGIN_error ("Failed to initialize serialization cond");
+    }
+
+  placeholderp->executed = 0;
+
+  aq->queue_n++;
+
+  if (DEBUG_THREAD_SIGNAL)
+    GCN_DEBUG ("signalling async thread %d:%d: cond_in\n",
+	       aq->agent->device_id, aq->id);
+  pthread_cond_signal (&aq->queue_cond_in);
+
+  pthread_mutex_unlock (&aq->mutex);
+
+  return placeholderp;
+}
+
+/* Signal an asynchronous thread to terminate, and wait for it to do so.  */
+
+static void
+finalize_async_thread (struct goacc_asyncqueue *aq)
+{
+  pthread_mutex_lock (&aq->mutex);
+  if (aq->drain_queue_stop == 2)
+    {
+      pthread_mutex_unlock (&aq->mutex);
+      return;
+    }
+
+  aq->drain_queue_stop = 1;
+
+  if (DEBUG_THREAD_SIGNAL)
+    GCN_DEBUG ("Signalling async thread %d:%d: cond_in\n",
+	       aq->agent->device_id, aq->id);
+  pthread_cond_signal (&aq->queue_cond_in);
+
+  while (aq->drain_queue_stop != 2)
+    {
+      if (DEBUG_THREAD_SLEEP)
+	GCN_DEBUG ("Waiting for async thread %d:%d to finish, putting thread"
+		   " to sleep\n", aq->agent->device_id, aq->id);
+      pthread_cond_wait (&aq->queue_cond_out, &aq->mutex);
+      if (DEBUG_THREAD_SLEEP)
+	GCN_DEBUG ("Waiting, woke up thread %d:%d.  Rechecking\n",
+		   aq->agent->device_id, aq->id);
+    }
+
+  GCN_DEBUG ("Done waiting for async thread %d:%d\n", aq->agent->device_id,
+	     aq->id);
+  pthread_mutex_unlock (&aq->mutex);
+
+  int err = pthread_join (aq->thread_drain_queue, NULL);
+  if (err != 0)
+    GOMP_PLUGIN_fatal ("Join async thread %d:%d: failed: %s",
+		       aq->agent->device_id, aq->id, strerror (err));
+  GCN_DEBUG ("Joined with async thread %d:%d\n", aq->agent->device_id, aq->id);
+}
+
+/* Set up an async queue for OpenMP.  There will be only one.  The
+   implementation simply uses an OpenACC async queue.
+   FIXME: is this thread-safe if two threads call this function?  */
+
+static void
+maybe_init_omp_async (struct agent_info *agent)
+{
+  if (!agent->omp_async_queue)
+    agent->omp_async_queue
+      = GOMP_OFFLOAD_openacc_async_construct (agent->device_id);
+}
+
+/* A wrapper that works around an issue in the HSA runtime with host-to-device
+   copies from read-only pages.  */
+
+static void
+hsa_memory_copy_wrapper (void *dst, const void *src, size_t len)
+{
+  hsa_status_t status = hsa_fns.hsa_memory_copy_fn (dst, src, len);
+
+  if (status == HSA_STATUS_SUCCESS)
+    return;
+
+  /* It appears that the copy fails if the source data is in a read-only page.
+     We can't detect that easily, so try copying the data to a temporary buffer
+     and doing the copy again if we got an error above.  */
+
+  GCN_WARNING ("Read-only data transfer bug workaround triggered for "
+	       "[%p:+%d]\n", (void *) src, (int) len);
+
+  void *src_copy = malloc (len);
+  memcpy (src_copy, src, len);
+  status = hsa_fns.hsa_memory_copy_fn (dst, (const void *) src_copy, len);
+  free (src_copy);
+  if (status != HSA_STATUS_SUCCESS)
+    GOMP_PLUGIN_error ("memory copy failed");
+}
+
+/* Copy data to or from a device.  This is intended for use as an async
+   callback event.  */
+
+static void
+copy_data (void *data_)
+{
+  struct copy_data *data = (struct copy_data *)data_;
+  GCN_DEBUG ("Async thread %d:%d: Copying %zu bytes from (%p) to (%p)\n",
+	     data->aq->agent->device_id, data->aq->id, data->len, data->src,
+	     data->dst);
+  hsa_memory_copy_wrapper (data->dst, data->src, data->len);
+  if (data->free_src)
+    free ((void *) data->src);
+  free (data);
+}
+
+/* Free device data.  This is intended for use as an async callback event.  */
+
+static void
+gomp_offload_free (void *ptr)
+{
+  GCN_DEBUG ("Async thread ?:?: Freeing %p\n", ptr);
+  GOMP_OFFLOAD_free (0, ptr);
+}
+
+/* Request an asynchronous data copy, to or from a device, on a given queue.
+   The event will be registered as a callback.  If FREE_SRC is true
+   then the source data will be freed following the copy.  */
+
+static void
+queue_push_copy (struct goacc_asyncqueue *aq, void *dst, const void *src,
+		 size_t len, bool free_src)
+{
+  if (DEBUG_QUEUES)
+    GCN_DEBUG ("queue_push_copy %d:%d: %zu bytes from (%p) to (%p)\n",
+	       aq->agent->device_id, aq->id, len, src, dst);
+  struct copy_data *data
+    = (struct copy_data *)GOMP_PLUGIN_malloc (sizeof (struct copy_data));
+  data->dst = dst;
+  data->src = src;
+  data->len = len;
+  data->free_src = free_src;
+  data->aq = aq;
+  queue_push_callback (aq, copy_data, data);
+}
+
+/* Return true if the given queue is currently empty.  */
+
+static int
+queue_empty (struct goacc_asyncqueue *aq)
+{
+  pthread_mutex_lock (&aq->mutex);
+  int res = aq->queue_n == 0 ? 1 : 0;
+  pthread_mutex_unlock (&aq->mutex);
+
+  return res;
+}
+
+/* Wait for a given queue to become empty.  This implements an OpenACC wait
+   directive.  */
+
+static void
+wait_queue (struct goacc_asyncqueue *aq)
+{
+  if (DRAIN_QUEUE_SYNCHRONOUS_P)
+    {
+      drain_queue_synchronous (aq);
+      return;
+    }
+
+  pthread_mutex_lock (&aq->mutex);
+
+  while (aq->queue_n > 0)
+    {
+      if (DEBUG_THREAD_SLEEP)
+	GCN_DEBUG ("waiting for thread %d:%d, putting thread to sleep\n",
+		   aq->agent->device_id, aq->id);
+      pthread_cond_wait (&aq->queue_cond_out, &aq->mutex);
+      if (DEBUG_THREAD_SLEEP)
+	GCN_DEBUG ("thread %d:%d woke up.  Rechecking\n", aq->agent->device_id,
+		   aq->id);
+    }
+
+  pthread_mutex_unlock (&aq->mutex);
+  GCN_DEBUG ("waiting for thread %d:%d, done\n", aq->agent->device_id, aq->id);
+}
+
+/* }}}  */
+/* {{{ OpenACC support  */
+
+/* Execute an OpenACC kernel, synchronously or asynchronously.  */
+
+static void
+gcn_exec (struct kernel_info *kernel, size_t mapnum, void **hostaddrs,
+	  void **devaddrs, unsigned *dims, void *targ_mem_desc, bool async,
+	  struct goacc_asyncqueue *aq)
+{
+  if (!GOMP_OFFLOAD_can_run (kernel))
+    GOMP_PLUGIN_fatal ("OpenACC host fallback unimplemented.");
+
+  /* If we get here then this must be an OpenACC kernel.  */
+  kernel->kind = KIND_OPENACC;
+
+  /* devaddrs must be double-indirect on the target.  */
+  void **ind_da = alloc_by_agent (kernel->agent, sizeof (void*) * mapnum);
+  for (size_t i = 0; i < mapnum; i++)
+    hsa_fns.hsa_memory_copy_fn (&ind_da[i],
+				devaddrs[i] ? &devaddrs[i] : &hostaddrs[i],
+				sizeof (void *));
+
+  struct hsa_kernel_description *hsa_kernel_desc = NULL;
+  for (unsigned i = 0; i < kernel->module->image_desc->kernel_count; i++)
+    {
+      struct hsa_kernel_description *d
+	= &kernel->module->image_desc->kernel_infos[i];
+      if (d->name == kernel->name)
+	{
+	  hsa_kernel_desc = d;
+	  break;
+	}
+    }
+
+  /* We may have statically-determined dimensions in
+     hsa_kernel_desc->oacc_dims[] or dimensions passed to this offload kernel
+     invocation at runtime in dims[].  We allow static dimensions to take
+     priority over dynamic dimensions when present (non-zero).  */
+  if (hsa_kernel_desc->oacc_dims[0] > 0)
+    dims[0] = hsa_kernel_desc->oacc_dims[0];
+  if (hsa_kernel_desc->oacc_dims[1] > 0)
+    dims[1] = hsa_kernel_desc->oacc_dims[1];
+  if (hsa_kernel_desc->oacc_dims[2] > 0)
+    dims[2] = hsa_kernel_desc->oacc_dims[2];
+
+  /* If any of the OpenACC dimensions remain 0 then we get to pick a number.
+     There isn't really a correct answer for this without a clue about the
+     problem size, so let's do a reasonable number of single-worker gangs.
+     64 gangs matches a typical Fiji device.  */
+
+  /* NOTE: Until support for middle-end worker partitioning is merged, use 1
+     for the default number of workers.  */
+  if (dims[0] == 0) dims[0] = get_cu_count (kernel->agent); /* Gangs.  */
+  if (dims[1] == 0) dims[1] = 1;  /* Workers.  */
+
+  /* The incoming dimensions are expressed in terms of gangs, workers, and
+     vectors.  The HSA dimensions are expressed in terms of "work-items",
+     which means multiples of vector lanes.
+
+     The "grid size" specifies the size of the problem space, and the
+     "work-group size" specifies how much of that we want a single compute
+     unit to chew on at once.
+
+     The three dimensions do not really correspond to hardware, but the
+     important thing is that the HSA runtime will launch as many
+     work-groups as it takes to process the entire grid, and each
+     work-group will contain as many wave-fronts as it takes to process
+     the work-items in that group.
+
+     Essentially, as long as we set the Y dimension to 64 (the number of
+     vector lanes in hardware), and the Z group size to the maximum (16),
+     then we will get the gangs (X) and workers (Z) launched as we expect.
+
+     The reason for the apparent reversal of vector and worker dimension
+     order is to do with the way the run-time distributes work-items across
+     v1 and v2.  */
+  struct GOMP_kernel_launch_attributes kla =
+    {3,
+     /* Grid size.  */
+     {dims[0], 64, dims[1]},
+     /* Work-group size.  */
+     {1,       64, 16}
+    };
+
+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();
+  acc_prof_info *prof_info = thr->prof_info;
+  acc_event_info enqueue_launch_event_info;
+  acc_api_info *api_info = thr->api_info;
+  bool profiling_dispatch_p = __builtin_expect (prof_info != NULL, false);
+  if (profiling_dispatch_p)
+    {
+      prof_info->event_type = acc_ev_enqueue_launch_start;
+
+      enqueue_launch_event_info.launch_event.event_type
+	= prof_info->event_type;
+      enqueue_launch_event_info.launch_event.valid_bytes
+	= _ACC_LAUNCH_EVENT_INFO_VALID_BYTES;
+      enqueue_launch_event_info.launch_event.parent_construct
+	= acc_construct_parallel;
+      enqueue_launch_event_info.launch_event.implicit = 1;
+      enqueue_launch_event_info.launch_event.tool_info = NULL;
+      enqueue_launch_event_info.launch_event.kernel_name
+	= (char *) kernel->name;
+      enqueue_launch_event_info.launch_event.num_gangs = kla.gdims[0];
+      enqueue_launch_event_info.launch_event.num_workers = kla.gdims[2];
+      enqueue_launch_event_info.launch_event.vector_length = kla.gdims[1];
+
+      api_info->device_api = acc_device_api_other;
+
+      GOMP_PLUGIN_goacc_profiling_dispatch (prof_info,
+	&enqueue_launch_event_info, api_info);
+    }
+
+  if (!async)
+    {
+      run_kernel (kernel, ind_da, &kla, NULL, false);
+      gomp_offload_free (ind_da);
+    }
+  else
+    {
+      queue_push_launch (aq, kernel, ind_da, &kla);
+      if (DEBUG_QUEUES)
+	GCN_DEBUG ("queue_push_callback %d:%d gomp_offload_free, %p\n",
+		   aq->agent->device_id, aq->id, ind_da);
+      queue_push_callback (aq, gomp_offload_free, ind_da);
+    }
+
+  if (profiling_dispatch_p)
+    {
+      prof_info->event_type = acc_ev_enqueue_launch_end;
+      enqueue_launch_event_info.launch_event.event_type = prof_info->event_type;
+      GOMP_PLUGIN_goacc_profiling_dispatch (prof_info,
+					    &enqueue_launch_event_info,
+					    api_info);
+    }
+}
+
+/* }}}  */
+/* {{{ Generic Plugin API  */
+
+/* Return the name of the accelerator, which is "gcn".  */
+
+const char *
+GOMP_OFFLOAD_get_name (void)
+{
+  return "gcn";
+}
+
+/* Return the specific capabilities the HSA accelerator have.  */
+
+unsigned int
+GOMP_OFFLOAD_get_caps (void)
+{
+  /* FIXME: Enable shared memory for APU, but not discrete GPU.  */
+  return /*GOMP_OFFLOAD_CAP_SHARED_MEM |*/ GOMP_OFFLOAD_CAP_OPENMP_400
+	    | GOMP_OFFLOAD_CAP_OPENACC_200;
+}
+
+/* Identify as GCN accelerator.  */
+
+int
+GOMP_OFFLOAD_get_type (void)
+{
+  return OFFLOAD_TARGET_TYPE_GCN;
+}
+
+/* Return the libgomp version number we're compatible with.  There is
+   no requirement for cross-version compatibility.  */
+
+unsigned
+GOMP_OFFLOAD_version (void)
+{
+  return GOMP_VERSION;
+}
+
+/* Return the number of GCN devices on the system.  */
+
+int
+GOMP_OFFLOAD_get_num_devices (void)
+{
+  if (!init_hsa_context ())
+    return 0;
+  return hsa_context.agent_count;
+}
+
+/* Initialize device (agent) number N so that it can be used for computation.
+   Return TRUE on success.  */
+
+bool
+GOMP_OFFLOAD_init_device (int n)
+{
+  if (!init_hsa_context ())
+    return false;
+  if (n >= hsa_context.agent_count)
+    {
+      GOMP_PLUGIN_error ("Request to initialize non-existent GCN device %i", n);
+      return false;
+    }
+  struct agent_info *agent = &hsa_context.agents[n];
+
+  if (agent->initialized)
+    return true;
+
+  agent->device_id = n;
+
+  if (pthread_rwlock_init (&agent->module_rwlock, NULL))
+    {
+      GOMP_PLUGIN_error ("Failed to initialize a GCN agent rwlock");
+      return false;
+    }
+  if (pthread_mutex_init (&agent->prog_mutex, NULL))
+    {
+      GOMP_PLUGIN_error ("Failed to initialize a GCN agent program mutex");
+      return false;
+    }
+  if (pthread_mutex_init (&agent->async_queues_mutex, NULL))
+    {
+      GOMP_PLUGIN_error ("Failed to initialize a GCN agent queue mutex");
+      return false;
+    }
+  if (pthread_mutex_init (&agent->team_arena_write_lock, NULL))
+    {
+      GOMP_PLUGIN_error ("Failed to initialize a GCN team arena write mutex");
+      return false;
+    }
+  agent->async_queues = NULL;
+  agent->omp_async_queue = NULL;
+  agent->team_arena_list = NULL;
+
+  uint32_t queue_size;
+  hsa_status_t status;
+  status = hsa_fns.hsa_agent_get_info_fn (agent->id,
+					  HSA_AGENT_INFO_QUEUE_MAX_SIZE,
+					  &queue_size);
+  if (status != HSA_STATUS_SUCCESS)
+    return hsa_error ("Error requesting maximum queue size of the GCN agent",
+		      status);
+
+  char buf[64];
+  status = hsa_fns.hsa_agent_get_info_fn (agent->id, HSA_AGENT_INFO_NAME,
+					  &buf);
+  if (status != HSA_STATUS_SUCCESS)
+    return hsa_error ("Error querying the name of the agent", status);
+  agent->gfx900_p = (strncmp (buf, "gfx900", 6) == 0);
+
+  status = hsa_fns.hsa_queue_create_fn (agent->id, queue_size,
+					HSA_QUEUE_TYPE_MULTI,
+					hsa_queue_callback, NULL, UINT32_MAX,
+					UINT32_MAX, &agent->sync_queue);
+  if (status != HSA_STATUS_SUCCESS)
+    return hsa_error ("Error creating command queue", status);
+
+  agent->kernarg_region.handle = (uint64_t) -1;
+  status = hsa_fns.hsa_agent_iterate_regions_fn (agent->id,
+						 get_kernarg_memory_region,
+						 &agent->kernarg_region);
+  if (agent->kernarg_region.handle == (uint64_t) -1)
+    {
+      GOMP_PLUGIN_error ("Could not find suitable memory region for kernel "
+			 "arguments");
+      return false;
+    }
+  GCN_DEBUG ("Selected kernel arguments memory region:\n");
+  dump_hsa_region (agent->kernarg_region, NULL);
+
+  agent->data_region.handle = (uint64_t) -1;
+  status = hsa_fns.hsa_agent_iterate_regions_fn (agent->id,
+						 get_data_memory_region,
+						 &agent->data_region);
+  if (agent->data_region.handle == (uint64_t) -1)
+    {
+      GOMP_PLUGIN_error ("Could not find suitable memory region for device "
+			 "data");
+      return false;
+    }
+  GCN_DEBUG ("Selected device data memory region:\n");
+  dump_hsa_region (agent->data_region, NULL);
+
+  GCN_DEBUG ("GCN agent %d initialized\n", n);
+
+  agent->initialized = true;
+  return true;
+}
+
+/* Load GCN object-code module described by struct gcn_image_desc in
+   TARGET_DATA and return references to kernel descriptors in TARGET_TABLE.
+   If there are any constructors then run them.  */
+
+int
+GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,
+			 struct addr_pair **target_table)
+{
+  if (GOMP_VERSION_DEV (version) != GOMP_VERSION_GCN)
+    {
+      GOMP_PLUGIN_error ("Offload data incompatible with GCN plugin"
+			 " (expected %u, received %u)",
+			 GOMP_VERSION_GCN, GOMP_VERSION_DEV (version));
+      return -1;
+    }
+
+  struct gcn_image_desc *image_desc = (struct gcn_image_desc *) target_data;
+  struct agent_info *agent;
+  struct addr_pair *pair;
+  struct module_info *module;
+  struct kernel_info *kernel;
+  int kernel_count = image_desc->kernel_count;
+  unsigned var_count = image_desc->global_variable_count;
+
+  agent = get_agent_info (ord);
+  if (!agent)
+    return -1;
+
+  if (pthread_rwlock_wrlock (&agent->module_rwlock))
+    {
+      GOMP_PLUGIN_error ("Unable to write-lock a GCN agent rwlock");
+      return -1;
+    }
+  if (agent->prog_finalized
+      && !destroy_hsa_program (agent))
+    return -1;
+
+  GCN_DEBUG ("Encountered %d kernels in an image\n", kernel_count);
+  GCN_DEBUG ("Encountered %u global variables in an image\n", var_count);
+  pair = GOMP_PLUGIN_malloc ((kernel_count + var_count - 2)
+			     * sizeof (struct addr_pair));
+  *target_table = pair;
+  module = (struct module_info *)
+    GOMP_PLUGIN_malloc_cleared (sizeof (struct module_info)
+				+ kernel_count * sizeof (struct kernel_info));
+  module->image_desc = image_desc;
+  module->kernel_count = kernel_count;
+  module->heap = NULL;
+  module->constructors_run_p = false;
+
+  kernel = &module->kernels[0];
+
+  /* Allocate memory for kernel dependencies.  */
+  for (unsigned i = 0; i < kernel_count; i++)
+    {
+      struct hsa_kernel_description *d = &image_desc->kernel_infos[i];
+      if (!init_basic_kernel_info (kernel, d, agent, module))
+	return -1;
+      if (strcmp (d->name, "_init_array") == 0)
+	module->init_array_func = kernel;
+      else if (strcmp (d->name, "_fini_array") == 0)
+        module->fini_array_func = kernel;
+      else
+	{
+	  pair->start = (uintptr_t) kernel;
+	  pair->end = (uintptr_t) (kernel + 1);
+	  pair++;
+	}
+      kernel++;
+    }
+
+  agent->module = module;
+  if (pthread_rwlock_unlock (&agent->module_rwlock))
+    {
+      GOMP_PLUGIN_error ("Unable to unlock a GCN agent rwlock");
+      return -1;
+    }
+
+  if (!create_and_finalize_hsa_program (agent))
+    return -1;
+
+  for (unsigned i = 0; i < var_count; i++)
+    {
+      struct global_var_info *v = &image_desc->global_variables[i];
+      GCN_DEBUG ("Looking for variable %s\n", v->name);
+
+      hsa_status_t status;
+      hsa_executable_symbol_t var_symbol;
+      status = hsa_fns.hsa_executable_get_symbol_fn (agent->executable, NULL,
+						     v->name, agent->id,
+						     0, &var_symbol);
+
+      if (status != HSA_STATUS_SUCCESS)
+	hsa_fatal ("Could not find symbol for variable in the code object",
+		   status);
+
+      uint64_t var_addr;
+      uint32_t var_size;
+      status = hsa_fns.hsa_executable_symbol_get_info_fn
+	(var_symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS, &var_addr);
+      if (status != HSA_STATUS_SUCCESS)
+	hsa_fatal ("Could not extract a variable from its symbol", status);
+      status = hsa_fns.hsa_executable_symbol_get_info_fn
+	(var_symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_SIZE, &var_size);
+      if (status != HSA_STATUS_SUCCESS)
+	hsa_fatal ("Could not extract a variable size from its symbol", status);
+
+      pair->start = var_addr;
+      pair->end = var_addr + var_size;
+      GCN_DEBUG ("Found variable %s at %p with size %u\n", v->name,
+		 (void *)var_addr, var_size);
+      pair++;
+    }
+
+  /* Ensure that constructors are run first.  */
+  struct GOMP_kernel_launch_attributes kla =
+    { 3,
+      /* Grid size.  */
+      { 1, 64, 1 },
+      /* Work-group size.  */
+      { 1, 64, 1 }
+    };
+
+  if (module->init_array_func)
+    {
+      init_kernel (module->init_array_func);
+      run_kernel (module->init_array_func, NULL, &kla, NULL, false);
+    }
+  module->constructors_run_p = true;
+
+  /* Don't report kernels that libgomp need not know about.  */
+  if (module->init_array_func)
+    kernel_count--;
+  if (module->fini_array_func)
+    kernel_count--;
+
+  return kernel_count + var_count;
+}
+
+/* Unload GCN object-code module described by struct gcn_image_desc in
+   TARGET_DATA from agent number N.  Return TRUE on success.  */
+
+bool
+GOMP_OFFLOAD_unload_image (int n, unsigned version, const void *target_data)
+{
+  if (GOMP_VERSION_DEV (version) != GOMP_VERSION_GCN)
+    {
+      GOMP_PLUGIN_error ("Offload data incompatible with GCN plugin"
+			 " (expected %u, received %u)",
+			 GOMP_VERSION_GCN, GOMP_VERSION_DEV (version));
+      return false;
+    }
+
+  struct agent_info *agent;
+  agent = get_agent_info (n);
+  if (!agent)
+    return false;
+
+  if (pthread_rwlock_wrlock (&agent->module_rwlock))
+    {
+      GOMP_PLUGIN_error ("Unable to write-lock a GCN agent rwlock");
+      return false;
+    }
+
+  if (!agent->module || agent->module->image_desc != target_data)
+    {
+      GOMP_PLUGIN_error ("Attempt to unload an image that has never been "
+			 "loaded before");
+      return false;
+    }
+
+  if (!destroy_module (agent->module, true))
+    return false;
+  free (agent->module);
+  agent->module = NULL;
+  if (!destroy_hsa_program (agent))
+    return false;
+  if (pthread_rwlock_unlock (&agent->module_rwlock))
+    {
+      GOMP_PLUGIN_error ("Unable to unlock a GCN agent rwlock");
+      return false;
+    }
+  return true;
+}
+
+/* Deinitialize all information and status associated with agent number N.  We
+   do not attempt any synchronization, assuming the user and libgomp will not
+   attempt deinitialization of a device that is in any way being used at the
+   same time.  Return TRUE on success.  */
+
+bool
+GOMP_OFFLOAD_fini_device (int n)
+{
+  struct agent_info *agent = get_agent_info (n);
+  if (!agent)
+    return false;
+
+  if (!agent->initialized)
+    return true;
+
+  if (agent->omp_async_queue)
+    {
+      GOMP_OFFLOAD_openacc_async_destruct (agent->omp_async_queue);
+      agent->omp_async_queue = NULL;
+    }
+
+  if (agent->module)
+    {
+      if (!destroy_module (agent->module, false))
+	return false;
+      free (agent->module);
+      agent->module = NULL;
+    }
+
+  if (!destroy_team_arenas (agent))
+    return false;
+
+  if (!destroy_hsa_program (agent))
+    return false;
+
+  hsa_status_t status = hsa_fns.hsa_queue_destroy_fn (agent->sync_queue);
+  if (status != HSA_STATUS_SUCCESS)
+    return hsa_error ("Error destroying command queue", status);
+
+  if (pthread_mutex_destroy (&agent->prog_mutex))
+    {
+      GOMP_PLUGIN_error ("Failed to destroy a GCN agent program mutex");
+      return false;
+    }
+  if (pthread_rwlock_destroy (&agent->module_rwlock))
+    {
+      GOMP_PLUGIN_error ("Failed to destroy a GCN agent rwlock");
+      return false;
+    }
+
+  if (pthread_mutex_destroy (&agent->async_queues_mutex))
+    {
+      GOMP_PLUGIN_error ("Failed to destroy a GCN agent queue mutex");
+      return false;
+    }
+  if (pthread_mutex_destroy (&agent->team_arena_write_lock))
+    {
+      GOMP_PLUGIN_error ("Failed to destroy a GCN team arena mutex");
+      return false;
+    }
+  agent->initialized = false;
+  return true;
+}
+
+/* Return true if the HSA runtime can run function FN_PTR.  */
+
+bool
+GOMP_OFFLOAD_can_run (void *fn_ptr)
+{
+  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;
+
+  init_kernel (kernel);
+  if (kernel->initialization_failed)
+    goto failure;
+
+  return true;
+
+failure:
+  if (suppress_host_fallback)
+    GOMP_PLUGIN_fatal ("GCN host fallback has been suppressed");
+  GCN_WARNING ("GCN target cannot be launched, doing a host fallback\n");
+  return false;
+}
+
+/* Allocate memory on device N.  */
+
+void *
+GOMP_OFFLOAD_alloc (int n, size_t size)
+{
+  struct agent_info *agent = get_agent_info (n);
+  return alloc_by_agent (agent, size);
+}
+
+/* Free memory from device N.  */
+
+bool
+GOMP_OFFLOAD_free (int device, void *ptr)
+{
+  GCN_DEBUG ("Freeing memory on device %d\n", device);
+
+  hsa_status_t status = hsa_fns.hsa_memory_free_fn (ptr);
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_error ("Could not free device memory", status);
+      return false;
+    }
+
+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();
+  bool profiling_dispatch_p
+    = __builtin_expect (thr != NULL && thr->prof_info != NULL, false);
+  if (profiling_dispatch_p)
+    {
+      acc_prof_info *prof_info = thr->prof_info;
+      acc_event_info data_event_info;
+      acc_api_info *api_info = thr->api_info;
+
+      prof_info->event_type = acc_ev_free;
+
+      data_event_info.data_event.event_type = prof_info->event_type;
+      data_event_info.data_event.valid_bytes
+	= _ACC_DATA_EVENT_INFO_VALID_BYTES;
+      data_event_info.data_event.parent_construct
+	= acc_construct_parallel;
+      data_event_info.data_event.implicit = 1;
+      data_event_info.data_event.tool_info = NULL;
+      data_event_info.data_event.var_name = NULL;
+      data_event_info.data_event.bytes = 0;
+      data_event_info.data_event.host_ptr = NULL;
+      data_event_info.data_event.device_ptr = (void *) ptr;
+
+      api_info->device_api = acc_device_api_other;
+
+      GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,
+					    api_info);
+    }
+
+  return true;
+}
+
+/* Copy data from DEVICE to host.  */
+
+bool
+GOMP_OFFLOAD_dev2host (int device, void *dst, const void *src, size_t n)
+{
+  GCN_DEBUG ("Copying %zu bytes from device %d (%p) to host (%p)\n", n, device,
+	     src, dst);
+  hsa_status_t status = hsa_fns.hsa_memory_copy_fn (dst, src, n);
+  if (status != HSA_STATUS_SUCCESS)
+    GOMP_PLUGIN_error ("memory copy failed");
+  return true;
+}
+
+/* Copy data from host to DEVICE.  */
+
+bool
+GOMP_OFFLOAD_host2dev (int device, void *dst, const void *src, size_t n)
+{
+  GCN_DEBUG ("Copying %zu bytes from host (%p) to device %d (%p)\n", n, src,
+	     device, dst);
+  hsa_memory_copy_wrapper (dst, src, n);
+  return true;
+}
+
+/* Copy data within DEVICE.  Do the copy asynchronously, if appropriate.  */
+
+bool
+GOMP_OFFLOAD_dev2dev (int device, void *dst, const void *src, size_t n)
+{
+  struct gcn_thread *thread_data = gcn_thread ();
+
+  if (thread_data && !async_synchronous_p (thread_data->async))
+    {
+      struct agent_info *agent = get_agent_info (device);
+      maybe_init_omp_async (agent);
+      queue_push_copy (agent->omp_async_queue, dst, src, n, false);
+      return true;
+    }
+
+  GCN_DEBUG ("Copying %zu bytes from device %d (%p) to device %d (%p)\n", n,
+	     device, src, device, dst);
+  hsa_status_t status = hsa_fns.hsa_memory_copy_fn (dst, src, n);
+  if (status != HSA_STATUS_SUCCESS)
+    GOMP_PLUGIN_error ("memory copy failed");
+  return true;
+}
+
+/* }}}  */
+/* {{{ OpenMP Plugin API  */
+
+/* Run a synchronous OpenMP kernel on DEVICE and pass it an array of pointers
+   in VARS as a parameter.  The kernel is identified by FN_PTR which must point
+   to a kernel_info structure, and must have previously been loaded to the
+   specified device.  */
+
+void
+GOMP_OFFLOAD_run (int device, void *fn_ptr, void *vars, void **args)
+{
+  struct agent_info *agent = get_agent_info (device);
+  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;
+  struct GOMP_kernel_launch_attributes def;
+  struct GOMP_kernel_launch_attributes *kla;
+  assert (agent == kernel->agent);
+
+  /* If we get here then the kernel must be OpenMP.  */
+  kernel->kind = KIND_OPENMP;
+
+  if (!parse_target_attributes (args, &def, &kla, agent))
+    {
+      GCN_WARNING ("Will not run GCN kernel because the grid size is zero\n");
+      return;
+    }
+  run_kernel (kernel, vars, kla, NULL, false);
+}
+
+/* Run an asynchronous OpenMP kernel on DEVICE.  This is similar to
+   GOMP_OFFLOAD_run except that the launch is queued and there is a call to
+   GOMP_PLUGIN_target_task_completion when it has finished.  */
+
+void
+GOMP_OFFLOAD_async_run (int device, void *tgt_fn, void *tgt_vars,
+			void **args, void *async_data)
+{
+  GCN_DEBUG ("GOMP_OFFLOAD_async_run invoked\n");
+  struct agent_info *agent = get_agent_info (device);
+  struct kernel_info *kernel = (struct kernel_info *) tgt_fn;
+  struct GOMP_kernel_launch_attributes def;
+  struct GOMP_kernel_launch_attributes *kla;
+  assert (agent == kernel->agent);
+
+  /* If we get here then the kernel must be OpenMP.  */
+  kernel->kind = KIND_OPENMP;
+
+  if (!parse_target_attributes (args, &def, &kla, agent))
+    {
+      GCN_WARNING ("Will not run GCN kernel because the grid size is zero\n");
+      return;
+    }
+
+  maybe_init_omp_async (agent);
+  queue_push_launch (agent->omp_async_queue, kernel, tgt_vars, kla);
+  queue_push_callback (agent->omp_async_queue,
+		       GOMP_PLUGIN_target_task_completion, async_data);
+}
+
+/* }}} */
+/* {{{ OpenACC Plugin API  */
+
+/* Run a synchronous OpenACC kernel.  The device number is inferred from the
+   already-loaded KERNEL.  */
+
+void
+GOMP_OFFLOAD_openacc_exec (void (*fn_ptr) (void *), size_t mapnum,
+			   void **hostaddrs, void **devaddrs, unsigned *dims,
+			   void *targ_mem_desc)
+{
+  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;
+
+  gcn_exec (kernel, mapnum, hostaddrs, devaddrs, dims, targ_mem_desc, false,
+	    NULL);
+}
+
+/* Run an asynchronous OpenACC kernel on the specified queue.  */
+
+void
+GOMP_OFFLOAD_openacc_async_exec (void (*fn_ptr) (void *), size_t mapnum,
+				 void **hostaddrs, void **devaddrs,
+				 unsigned *dims, void *targ_mem_desc,
+				 struct goacc_asyncqueue *aq)
+{
+  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;
+
+  gcn_exec (kernel, mapnum, hostaddrs, devaddrs, dims, targ_mem_desc, true,
+	    aq);
+}
+
+/* Create a new asynchronous thread and queue for running future kernels.  */
+
+struct goacc_asyncqueue *
+GOMP_OFFLOAD_openacc_async_construct (int device)
+{
+  struct agent_info *agent = get_agent_info (device);
+
+  pthread_mutex_lock (&agent->async_queues_mutex);
+
+  struct goacc_asyncqueue *aq = GOMP_PLUGIN_malloc (sizeof (*aq));
+  aq->agent = get_agent_info (device);
+  aq->prev = NULL;
+  aq->next = agent->async_queues;
+  if (aq->next)
+    {
+      aq->next->prev = aq;
+      aq->id = aq->next->id + 1;
+    }
+  else
+    aq->id = 1;
+  agent->async_queues = aq;
+
+  aq->queue_first = 0;
+  aq->queue_n = 0;
+  aq->drain_queue_stop = 0;
+
+  if (pthread_mutex_init (&aq->mutex, NULL))
+    {
+      GOMP_PLUGIN_error ("Failed to initialize a GCN agent queue mutex");
+      return false;
+    }
+  if (pthread_cond_init (&aq->queue_cond_in, NULL))
+    {
+      GOMP_PLUGIN_error ("Failed to initialize a GCN agent queue cond");
+      return false;
+    }
+  if (pthread_cond_init (&aq->queue_cond_out, NULL))
+    {
+      GOMP_PLUGIN_error ("Failed to initialize a GCN agent queue cond");
+      return false;
+    }
+
+  hsa_status_t status = hsa_fns.hsa_queue_create_fn (agent->id,
+						     ASYNC_QUEUE_SIZE,
+						     HSA_QUEUE_TYPE_MULTI,
+						     hsa_queue_callback, NULL,
+						     UINT32_MAX, UINT32_MAX,
+						     &aq->hsa_queue);
+  if (status != HSA_STATUS_SUCCESS)
+    hsa_fatal ("Error creating command queue", status);
+
+  int err = pthread_create (&aq->thread_drain_queue, NULL, &drain_queue, aq);
+  if (err != 0)
+    GOMP_PLUGIN_fatal ("GCN asynchronous thread creation failed: %s",
+		       strerror (err));
+  GCN_DEBUG ("Async thread %d:%d: created\n", aq->agent->device_id,
+	     aq->id);
+
+  pthread_mutex_unlock (&agent->async_queues_mutex);
+
+  return aq;
+}
+
+/* Destroy an existing asynchronous thread and queue.  Waits for any
+   currently-running task to complete, but cancels any queued tasks.  */
+
+bool
+GOMP_OFFLOAD_openacc_async_destruct (struct goacc_asyncqueue *aq)
+{
+  struct agent_info *agent = aq->agent;
+
+  finalize_async_thread (aq);
+
+  pthread_mutex_lock (&agent->async_queues_mutex);
+
+  int err;
+  if ((err = pthread_mutex_destroy (&aq->mutex)))
+    {
+      GOMP_PLUGIN_error ("Failed to destroy a GCN async queue mutex: %d", err);
+      goto fail;
+    }
+  if (pthread_cond_destroy (&aq->queue_cond_in))
+    {
+      GOMP_PLUGIN_error ("Failed to destroy a GCN async queue cond");
+      goto fail;
+    }
+  if (pthread_cond_destroy (&aq->queue_cond_out))
+    {
+      GOMP_PLUGIN_error ("Failed to destroy a GCN async queue cond");
+      goto fail;
+    }
+  hsa_status_t status = hsa_fns.hsa_queue_destroy_fn (aq->hsa_queue);
+  if (status != HSA_STATUS_SUCCESS)
+    {
+      hsa_error ("Error destroying command queue", status);
+      goto fail;
+    }
+
+  if (aq->prev)
+    aq->prev->next = aq->next;
+  if (aq->next)
+    aq->next->prev = aq->prev;
+  if (agent->async_queues == aq)
+    agent->async_queues = aq->next;
+
+  GCN_DEBUG ("Async thread %d:%d: destroyed\n", agent->device_id, aq->id);
+
+  free (aq);
+  pthread_mutex_unlock (&agent->async_queues_mutex);
+  return true;
+
+fail:
+  pthread_mutex_unlock (&agent->async_queues_mutex);
+  return false;
+}
+
+/* Return true if the specified async queue is currently empty.  */
+
+int
+GOMP_OFFLOAD_openacc_async_test (struct goacc_asyncqueue *aq)
+{
+  return queue_empty (aq);
+}
+
+/* Block until the specified queue has executed all its tasks and the
+   queue is empty.  */
+
+bool
+GOMP_OFFLOAD_openacc_async_synchronize (struct goacc_asyncqueue *aq)
+{
+  wait_queue (aq);
+  return true;
+}
+
+/* Add a serialization point across two async queues. Any new tasks added to
+   AQ2, after this call, will not run until all tasks on AQ1, at the time
+   of this call, have completed.  */
+
+bool
+GOMP_OFFLOAD_openacc_async_serialize (struct goacc_asyncqueue *aq1,
+				      struct goacc_asyncqueue *aq2)
+{
+  /* For serialize, stream aq2 waits for aq1 to complete work that has been
+     scheduled to run on it up to this point.  */
+  if (aq1 != aq2)
+    {
+      struct placeholder *placeholderp = queue_push_placeholder (aq1);
+      queue_push_asyncwait (aq2, placeholderp);
+    }
+  return true;
+}
+
+/* Add an opaque callback to the given async queue.  */
+
+void
+GOMP_OFFLOAD_openacc_async_queue_callback (struct goacc_asyncqueue *aq,
+					   void (*fn) (void *), void *data)
+{
+  queue_push_callback (aq, fn, data);
+}
+
+/* Queue up an asynchronous data copy from host to DEVICE.  */
+
+bool
+GOMP_OFFLOAD_openacc_async_host2dev (int device, void *dst, const void *src,
+				     size_t n, struct goacc_asyncqueue *aq)
+{
+  struct agent_info *agent = get_agent_info (device);
+  assert (agent == aq->agent);
+  /* The source data does not necessarily remain live until the deferred
+     copy happens.  Taking a snapshot of the data here avoids reading
+     uninitialised data later, but means that (a) data is copied twice and
+     (b) modifications to the copied data between the "spawning" point of
+     the asynchronous kernel and when it is executed will not be seen.
+     But, that is probably correct.  */
+  void *src_copy = GOMP_PLUGIN_malloc (n);
+  memcpy (src_copy, src, n);
+  queue_push_copy (aq, dst, src_copy, n, true);
+  return true;
+}
+
+/* Queue up an asynchronous data copy from DEVICE to host.  */
+
+bool
+GOMP_OFFLOAD_openacc_async_dev2host (int device, void *dst, const void *src,
+				     size_t n, struct goacc_asyncqueue *aq)
+{
+  struct agent_info *agent = get_agent_info (device);
+  assert (agent == aq->agent);
+  queue_push_copy (aq, dst, src, n, false);
+  return true;
+}
+
+/* Set up plugin-specific thread-local-data (host-side).  */
+
+void *
+GOMP_OFFLOAD_openacc_create_thread_data (int ord __attribute__((unused)))
+{
+  struct gcn_thread *thread_data
+    = GOMP_PLUGIN_malloc (sizeof (struct gcn_thread));
+
+  thread_data->async = GOMP_ASYNC_SYNC;
+
+  return (void *) thread_data;
+}
+
+/* Clean up plugin-specific thread-local-data.  */
+
+void
+GOMP_OFFLOAD_openacc_destroy_thread_data (void *data)
+{
+  free (data);
+}
+
+/* }}} */
diff --git a/libgomp/plugin/plugin-hsa.c b/libgomp/plugin/plugin-hsa.c
index e0bc87c9552..409e138aaca 100644
--- a/libgomp/plugin/plugin-hsa.c
+++ b/libgomp/plugin/plugin-hsa.c
@@ -28,11 +28,14 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include "config.h"
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <pthread.h>
+#ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
+#endif
 #include <stdbool.h>
 #include <hsa.h>
 #include <plugin/hsa_ext_finalize.h>
@@ -41,6 +44,13 @@
 #include "gomp-constants.h"
 #include "secure_getenv.h"
 
+#ifdef HAVE_INTTYPES_H
+typedef uint64_t print_uint64_t;
+#else
+#define PRIu64 "lu"
+typedef unsigned long print_uint64_t; 
+#endif
+
 /* As an HSA runtime is dlopened, following structure defines function
    pointers utilized by the HSA plug-in.  */
 
@@ -279,7 +289,7 @@ hsa_warn (const char *str, hsa_status_t status)
   if (!debug)
     return;
 
-  const char *hsa_error_msg;
+  const char *hsa_error_msg = "[unknown]";
   hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);
 
   fprintf (stderr, "HSA warning: %s\nRuntime message: %s", str, hsa_error_msg);
@@ -291,7 +301,7 @@ hsa_warn (const char *str, hsa_status_t status)
 static void
 hsa_fatal (const char *str, hsa_status_t status)
 {
-  const char *hsa_error_msg;
+  const char *hsa_error_msg = "[unknown]";
   hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);
   GOMP_PLUGIN_fatal ("HSA fatal error: %s\nRuntime message: %s", str,
 		     hsa_error_msg);
@@ -303,7 +313,7 @@ hsa_fatal (const char *str, hsa_status_t status)
 static bool
 hsa_error (const char *str, hsa_status_t status)
 {
-  const char *hsa_error_msg;
+  const char *hsa_error_msg = "[unknown]";
   hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);
   GOMP_PLUGIN_error ("HSA fatal error: %s\nRuntime message: %s", str,
 		     hsa_error_msg);
@@ -1155,7 +1165,7 @@ static void
 release_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *shadow)
 {
   HSA_DEBUG ("Released kernel dispatch: %p has value: %" PRIu64 " (%p)\n",
-	     shadow, shadow->debug,
+	     shadow, (print_uint64_t) shadow->debug,
 	     (void *) (uintptr_t) shadow->debug);
 
   hsa_fns.hsa_memory_free_fn (shadow->kernarg_address);
@@ -1277,9 +1287,9 @@ print_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *dispatch, unsigned inden
   indent_stream (stderr, indent);
   fprintf (stderr, "kernarg_address: %p\n", dispatch->kernarg_address);
   indent_stream (stderr, indent);
-  fprintf (stderr, "object: %" PRIu64 "\n", dispatch->object);
+  fprintf (stderr, "object: %" PRIu64 "\n", (print_uint64_t) dispatch->object);
   indent_stream (stderr, indent);
-  fprintf (stderr, "signal: %" PRIu64 "\n", dispatch->signal);
+  fprintf (stderr, "signal: %" PRIu64 "\n", (print_uint64_t) dispatch->signal);
   indent_stream (stderr, indent);
   fprintf (stderr, "private_segment_size: %u\n",
 	   dispatch->private_segment_size);
@@ -1288,7 +1298,7 @@ print_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *dispatch, unsigned inden
 	   dispatch->group_segment_size);
   indent_stream (stderr, indent);
   fprintf (stderr, "children dispatches: %" PRIu64 "\n",
-	   dispatch->kernel_dispatch_count);
+	   (print_uint64_t) dispatch->kernel_dispatch_count);
   indent_stream (stderr, indent);
   fprintf (stderr, "omp_num_threads: %u\n",
 	   dispatch->omp_num_threads);
@@ -1596,7 +1606,7 @@ run_kernel (struct kernel_info *kernel, void *vars,
 	child_s.handle = shadow->children_dispatches[i]->signal;
 
 	HSA_DEBUG ("Waiting for children completion signal: %" PRIu64 "\n",
-		   shadow->children_dispatches[i]->signal);
+		   (print_uint64_t) shadow->children_dispatches[i]->signal);
 	hsa_fns.hsa_signal_load_acquire_fn (child_s);
       }
 
diff --git a/libgomp/plugin/plugin-nvptx.c b/libgomp/plugin/plugin-nvptx.c
index 387e7cc6dd3..911d0f66a6e 100644
--- a/libgomp/plugin/plugin-nvptx.c
+++ b/libgomp/plugin/plugin-nvptx.c
@@ -37,11 +37,11 @@
 #include "libgomp-plugin.h"
 #include "oacc-plugin.h"
 #include "gomp-constants.h"
+#include "oacc-int.h"
 
 #include <pthread.h>
 #include <cuda.h>
 #include <stdbool.h>
-#include <stdint.h>
 #include <limits.h>
 #include <string.h>
 #include <stdio.h>
@@ -192,175 +192,30 @@ cuda_error (CUresult r)
 static unsigned int instantiated_devices = 0;
 static pthread_mutex_t ptx_dev_lock = PTHREAD_MUTEX_INITIALIZER;
 
-struct cuda_map
+/* NVPTX/CUDA specific definition of asynchronous queues.  */
+struct goacc_asyncqueue
 {
-  CUdeviceptr d;
-  size_t size;
-  bool active;
-  struct cuda_map *next;
+  CUstream cuda_stream;
 };
 
-struct ptx_stream
+struct nvptx_callback
 {
-  CUstream stream;
-  pthread_t host_thread;
-  bool multithreaded;
-  struct cuda_map *map;
-  struct ptx_stream *next;
+  void (*fn) (void *);
+  void *ptr;
+  struct goacc_asyncqueue *aq;
+  struct nvptx_callback *next;
 };
 
 /* Thread-specific data for PTX.  */
 
 struct nvptx_thread
 {
-  struct ptx_stream *current_stream;
+  /* We currently have this embedded inside the plugin because libgomp manages
+     devices through integer target_ids.  This might be better if using an
+     opaque target-specific pointer directly from gomp_device_descr.  */
   struct ptx_device *ptx_dev;
 };
 
-static struct cuda_map *
-cuda_map_create (size_t size)
-{
-  struct cuda_map *map = GOMP_PLUGIN_malloc (sizeof (struct cuda_map));
-
-  assert (map);
-
-  map->next = NULL;
-  map->size = size;
-  map->active = false;
-
-  CUDA_CALL_ERET (NULL, cuMemAlloc, &map->d, size);
-  assert (map->d);
-
-  return map;
-}
-
-static void
-cuda_map_destroy (struct cuda_map *map)
-{
-  if (map->active)
-    /* Possible reasons for the map to be still active:
-       - the associated async kernel might still be running.
-       - the associated async kernel might have finished, but the
-         corresponding event that should trigger the pop_map has not been
-	 processed by event_gc.
-       - the associated sync kernel might have aborted
-
-       The async cases could happen if the user specified an async region
-       without adding a corresponding wait that is guaranteed to be executed
-       (before returning from main, or in an atexit handler).
-       We do not want to deallocate a device pointer that is still being
-       used, so skip it.
-
-       In the sync case, the device pointer is no longer used, but deallocating
-       it using cuMemFree will not succeed, so skip it.
-
-       TODO: Handle this in a more constructive way, by f.i. waiting for streams
-       to finish before de-allocating them (PR88981), or by ensuring the CUDA
-       lib atexit handler is called before rather than after the libgomp plugin
-       atexit handler (PR83795).  */
-    ;
-  else
-    CUDA_CALL_NOCHECK (cuMemFree, map->d);
-
-  free (map);
-}
-
-/* The following map_* routines manage the CUDA device memory that
-   contains the data mapping arguments for cuLaunchKernel.  Each
-   asynchronous PTX stream may have multiple pending kernel
-   invocations, which are launched in a FIFO order.  As such, the map
-   routines maintains a queue of cuLaunchKernel arguments.
-
-   Calls to map_push and map_pop must be guarded by ptx_event_lock.
-   Likewise, calls to map_init and map_fini are guarded by
-   ptx_dev_lock inside GOMP_OFFLOAD_init_device and
-   GOMP_OFFLOAD_fini_device, respectively.  */
-
-static bool
-map_init (struct ptx_stream *s)
-{
-  int size = getpagesize ();
-
-  assert (s);
-
-  s->map = cuda_map_create (size);
-
-  return true;
-}
-
-static bool
-map_fini (struct ptx_stream *s)
-{
-  assert (s->map->next == NULL);
-
-  cuda_map_destroy (s->map);
-
-  return true;
-}
-
-static void
-map_pop (struct ptx_stream *s)
-{
-  struct cuda_map *next;
-
-  assert (s != NULL);
-
-  if (s->map->next == NULL)
-    {
-      s->map->active = false;
-      return;
-    }
-
-  next = s->map->next;
-  cuda_map_destroy (s->map);
-  s->map = next;
-}
-
-static CUdeviceptr
-map_push (struct ptx_stream *s, size_t size)
-{
-  struct cuda_map *map = NULL;
-  struct cuda_map **t;
-
-  assert (s);
-  assert (s->map);
-
-  /* Select an element to push.  */
-  if (s->map->active)
-    map = cuda_map_create (size);
-  else
-    {
-      /* Pop the inactive front element.  */
-      struct cuda_map *pop = s->map;
-      s->map = pop->next;
-      pop->next = NULL;
-
-      if (pop->size < size)
-	{
-	  cuda_map_destroy (pop);
-
-	  map = cuda_map_create (size);
-	}
-      else
-	map = pop;
-    }
-
-  /* Check that the element is as expected.  */
-  assert (map->next == NULL);
-  assert (!map->active);
-
-  /* Mark the element active.  */
-  map->active = true;
-
-  /* Push the element to the back of the list.  */
-  for (t = &s->map; (*t) != NULL; t = &(*t)->next)
-    ;
-  assert (t != NULL && *t == NULL);
-  *t = map;
-
-  return map->d;
-}
-
 /* Target data function launch information.  */
 
 struct targ_fn_launch
@@ -412,22 +267,18 @@ struct ptx_image_data
   struct ptx_image_data *next;
 };
 
+struct ptx_free_block
+{
+  void *ptr;
+  struct ptx_free_block *next;
+};
+
 struct ptx_device
 {
   CUcontext ctx;
   bool ctx_shared;
   CUdevice dev;
-  struct ptx_stream *null_stream;
-  /* All non-null streams associated with this device (actually context),
-     either created implicitly or passed in from the user (via
-     acc_set_cuda_stream).  */
-  struct ptx_stream *active_streams;
-  struct {
-    struct ptx_stream **arr;
-    int size;
-  } async_streams;
-  /* A lock for use when manipulating the above stream list and array.  */
-  pthread_mutex_t stream_lock;
+
   int ord;
   bool overlap;
   bool map;
@@ -445,32 +296,13 @@ struct ptx_device
 
   struct ptx_image_data *images;  /* Images loaded on device.  */
   pthread_mutex_t image_lock;     /* Lock for above list.  */
-  
-  struct ptx_device *next;
-};
 
-enum ptx_event_type
-{
-  PTX_EVT_MEM,
-  PTX_EVT_KNL,
-  PTX_EVT_SYNC,
-  PTX_EVT_ASYNC_CLEANUP
-};
-
-struct ptx_event
-{
-  CUevent *evt;
-  int type;
-  void *addr;
-  int ord;
-  int val;
+  struct ptx_free_block *free_blocks;
+  pthread_mutex_t free_blocks_lock;
 
-  struct ptx_event *next;
+  struct ptx_device *next;
 };
 
-static pthread_mutex_t ptx_event_lock;
-static struct ptx_event *ptx_events;
-
 static struct ptx_device **ptx_devices;
 
 static inline struct nvptx_thread *
@@ -479,193 +311,6 @@ nvptx_thread (void)
   return (struct nvptx_thread *) GOMP_PLUGIN_acc_thread ();
 }
 
-static bool
-init_streams_for_device (struct ptx_device *ptx_dev, int concurrency)
-{
-  int i;
-  struct ptx_stream *null_stream
-    = GOMP_PLUGIN_malloc (sizeof (struct ptx_stream));
-
-  null_stream->stream = NULL;
-  null_stream->host_thread = pthread_self ();
-  null_stream->multithreaded = true;
-  if (!map_init (null_stream))
-    return false;
-
-  ptx_dev->null_stream = null_stream;
-  ptx_dev->active_streams = NULL;
-  pthread_mutex_init (&ptx_dev->stream_lock, NULL);
-
-  if (concurrency < 1)
-    concurrency = 1;
-
-  /* This is just a guess -- make space for as many async streams as the
-     current device is capable of concurrently executing.  This can grow
-     later as necessary.  No streams are created yet.  */
-  ptx_dev->async_streams.arr
-    = GOMP_PLUGIN_malloc (concurrency * sizeof (struct ptx_stream *));
-  ptx_dev->async_streams.size = concurrency;
-
-  for (i = 0; i < concurrency; i++)
-    ptx_dev->async_streams.arr[i] = NULL;
-
-  return true;
-}
-
-static bool
-fini_streams_for_device (struct ptx_device *ptx_dev)
-{
-  free (ptx_dev->async_streams.arr);
-
-  bool ret = true;
-  while (ptx_dev->active_streams != NULL)
-    {
-      struct ptx_stream *s = ptx_dev->active_streams;
-      ptx_dev->active_streams = ptx_dev->active_streams->next;
-
-      ret &= map_fini (s);
-
-      CUresult r = CUDA_CALL_NOCHECK (cuStreamDestroy, s->stream);
-      if (r != CUDA_SUCCESS)
-	{
-	  GOMP_PLUGIN_error ("cuStreamDestroy error: %s", cuda_error (r));
-	  ret = false;
-	}
-      free (s);
-    }
-
-  ret &= map_fini (ptx_dev->null_stream);
-  free (ptx_dev->null_stream);
-  return ret;
-}
-
-/* Select a stream for (OpenACC-semantics) ASYNC argument for the current
-   thread THREAD (and also current device/context).  If CREATE is true, create
-   the stream if it does not exist (or use EXISTING if it is non-NULL), and
-   associate the stream with the same thread argument.  Returns stream to use
-   as result.  */
-
-static struct ptx_stream *
-select_stream_for_async (int async, pthread_t thread, bool create,
-			 CUstream existing)
-{
-  struct nvptx_thread *nvthd = nvptx_thread ();
-  /* Local copy of TLS variable.  */
-  struct ptx_device *ptx_dev = nvthd->ptx_dev;
-  struct ptx_stream *stream = NULL;
-  int orig_async = async;
-
-  /* The special value acc_async_noval (-1) maps (for now) to an
-     implicitly-created stream, which is then handled the same as any other
-     numbered async stream.  Other options are available, e.g. using the null
-     stream for anonymous async operations, or choosing an idle stream from an
-     active set.  But, stick with this for now.  */
-  if (async > acc_async_sync)
-    async++;
-
-  if (create)
-    pthread_mutex_lock (&ptx_dev->stream_lock);
-
-  /* NOTE: AFAICT there's no particular need for acc_async_sync to map to the
-     null stream, and in fact better performance may be obtainable if it doesn't
-     (because the null stream enforces overly-strict synchronisation with
-     respect to other streams for legacy reasons, and that's probably not
-     needed with OpenACC).  Maybe investigate later.  */
-  if (async == acc_async_sync)
-    stream = ptx_dev->null_stream;
-  else if (async >= 0 && async < ptx_dev->async_streams.size
-	   && ptx_dev->async_streams.arr[async] && !(create && existing))
-    stream = ptx_dev->async_streams.arr[async];
-  else if (async >= 0 && create)
-    {
-      if (async >= ptx_dev->async_streams.size)
-	{
-	  int i, newsize = ptx_dev->async_streams.size * 2;
-
-	  if (async >= newsize)
-	    newsize = async + 1;
-
-	  ptx_dev->async_streams.arr
-	    = GOMP_PLUGIN_realloc (ptx_dev->async_streams.arr,
-				   newsize * sizeof (struct ptx_stream *));
-
-	  for (i = ptx_dev->async_streams.size; i < newsize; i++)
-	    ptx_dev->async_streams.arr[i] = NULL;
-
-	  ptx_dev->async_streams.size = newsize;
-	}
-
-      /* Create a new stream on-demand if there isn't one already, or if we're
-	 setting a particular async value to an existing (externally-provided)
-	 stream.  */
-      if (!ptx_dev->async_streams.arr[async] || existing)
-        {
-	  CUresult r;
-	  struct ptx_stream *s
-	    = GOMP_PLUGIN_malloc (sizeof (struct ptx_stream));
-
-	  if (existing)
-	    s->stream = existing;
-	  else
-	    {
-	      r = CUDA_CALL_NOCHECK (cuStreamCreate, &s->stream,
-				     CU_STREAM_DEFAULT);
-	      if (r != CUDA_SUCCESS)
-		{
-		  pthread_mutex_unlock (&ptx_dev->stream_lock);
-		  GOMP_PLUGIN_fatal ("cuStreamCreate error: %s",
-				     cuda_error (r));
-		}
-	    }
-
-	  /* If CREATE is true, we're going to be queueing some work on this
-	     stream.  Associate it with the current host thread.  */
-	  s->host_thread = thread;
-	  s->multithreaded = false;
-
-	  if (!map_init (s))
-	    {
-	      pthread_mutex_unlock (&ptx_dev->stream_lock);
-	      GOMP_PLUGIN_fatal ("map_init fail");
-	    }
-
-	  s->next = ptx_dev->active_streams;
-	  ptx_dev->active_streams = s;
-	  ptx_dev->async_streams.arr[async] = s;
-	}
-
-      stream = ptx_dev->async_streams.arr[async];
-    }
-  else if (async < 0)
-    {
-      if (create)
-	pthread_mutex_unlock (&ptx_dev->stream_lock);
-      GOMP_PLUGIN_fatal ("bad async %d", async);
-    }
-
-  if (create)
-    {
-      assert (stream != NULL);
-
-      /* If we're trying to use the same stream from different threads
-	 simultaneously, set stream->multithreaded to true.  This affects the
-	 behaviour of acc_async_test_all and acc_wait_all, which are supposed to
-	 only wait for asynchronous launches from the same host thread they are
-	 invoked on.  If multiple threads use the same async value, we make note
-	 of that here and fall back to testing/waiting for all threads in those
-	 functions.  */
-      if (thread != stream->host_thread)
-        stream->multithreaded = true;
-
-      pthread_mutex_unlock (&ptx_dev->stream_lock);
-    }
-  else if (stream && !stream->multithreaded
-	   && !pthread_equal (stream->host_thread, thread))
-    GOMP_PLUGIN_fatal ("async %d used on wrong thread", orig_async);
-
-  return stream;
-}
-
 /* Initialize the device.  Return TRUE on success, else FALSE.  PTX_DEV_LOCK
    should be locked on entry and remains locked on exit.  */
 
@@ -677,9 +322,6 @@ nvptx_init (void)
   if (instantiated_devices != 0)
     return true;
 
-  ptx_events = NULL;
-  pthread_mutex_init (&ptx_event_lock, NULL);
-
   if (!init_cuda_lib ())
     return false;
 
@@ -703,6 +345,11 @@ nvptx_attach_host_thread_to_device (int n)
   CUcontext thd_ctx;
 
   r = CUDA_CALL_NOCHECK (cuCtxGetDevice, &dev);
+  if (r == CUDA_ERROR_NOT_PERMITTED)
+    {
+      /* Assume we're in a CUDA callback, just return true.  */
+      return true;
+    }
   if (r != CUDA_SUCCESS && r != CUDA_ERROR_INVALID_CONTEXT)
     {
       GOMP_PLUGIN_error ("cuCtxGetDevice error: %s", cuda_error (r));
@@ -847,8 +494,8 @@ nvptx_open_device (int n)
   ptx_dev->images = NULL;
   pthread_mutex_init (&ptx_dev->image_lock, NULL);
 
-  if (!init_streams_for_device (ptx_dev, async_engines))
-    return NULL;
+  ptx_dev->free_blocks = NULL;
+  pthread_mutex_init (&ptx_dev->free_blocks_lock, NULL);
 
   return ptx_dev;
 }
@@ -859,9 +506,15 @@ nvptx_close_device (struct ptx_device *ptx_dev)
   if (!ptx_dev)
     return true;
 
-  if (!fini_streams_for_device (ptx_dev))
-    return false;
-  
+  for (struct ptx_free_block *b = ptx_dev->free_blocks; b;)
+    {
+      struct ptx_free_block *b_next = b->next;
+      CUDA_CALL (cuMemFree, (CUdeviceptr) b->ptr);
+      free (b);
+      b = b_next;
+    }
+
+  pthread_mutex_destroy (&ptx_dev->free_blocks_lock);
   pthread_mutex_destroy (&ptx_dev->image_lock);
 
   if (!ptx_dev->ctx_shared)
@@ -1040,140 +693,20 @@ link_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,
   return true;
 }
 
-static void
-event_gc (bool memmap_lockable)
-{
-  struct ptx_event *ptx_event = ptx_events;
-  struct ptx_event *async_cleanups = NULL;
-  struct nvptx_thread *nvthd = nvptx_thread ();
-
-  pthread_mutex_lock (&ptx_event_lock);
-
-  while (ptx_event != NULL)
-    {
-      CUresult r;
-      struct ptx_event *e = ptx_event;
-
-      ptx_event = ptx_event->next;
-
-      if (e->ord != nvthd->ptx_dev->ord)
-	continue;
-
-      r = CUDA_CALL_NOCHECK (cuEventQuery, *e->evt);
-      if (r == CUDA_SUCCESS)
-	{
-	  bool append_async = false;
-	  CUevent *te;
-
-	  te = e->evt;
-
-	  switch (e->type)
-	    {
-	    case PTX_EVT_MEM:
-	    case PTX_EVT_SYNC:
-	      break;
-
-	    case PTX_EVT_KNL:
-	      map_pop (e->addr);
-	      break;
-
-	    case PTX_EVT_ASYNC_CLEANUP:
-	      {
-		/* The function gomp_plugin_async_unmap_vars needs to claim the
-		   memory-map splay tree lock for the current device, so we
-		   can't call it when one of our callers has already claimed
-		   the lock.  In that case, just delay the GC for this event
-		   until later.  */
-		if (!memmap_lockable)
-		  continue;
-
-		append_async = true;
-	      }
-	      break;
-	    }
-
-	  CUDA_CALL_NOCHECK (cuEventDestroy, *te);
-	  free ((void *)te);
-
-	  /* Unlink 'e' from ptx_events list.  */
-	  if (ptx_events == e)
-	    ptx_events = ptx_events->next;
-	  else
-	    {
-	      struct ptx_event *e_ = ptx_events;
-	      while (e_->next != e)
-		e_ = e_->next;
-	      e_->next = e_->next->next;
-	    }
-
-	  if (append_async)
-	    {
-	      e->next = async_cleanups;
-	      async_cleanups = e;
-	    }
-	  else
-	    free (e);
-	}
-    }
-
-  pthread_mutex_unlock (&ptx_event_lock);
-
-  /* We have to do these here, after ptx_event_lock is released.  */
-  while (async_cleanups)
-    {
-      struct ptx_event *e = async_cleanups;
-      async_cleanups = async_cleanups->next;
-
-      GOMP_PLUGIN_async_unmap_vars (e->addr, e->val);
-      free (e);
-    }
-}
-
-static void
-event_add (enum ptx_event_type type, CUevent *e, void *h, int val)
-{
-  struct ptx_event *ptx_event;
-  struct nvptx_thread *nvthd = nvptx_thread ();
-
-  assert (type == PTX_EVT_MEM || type == PTX_EVT_KNL || type == PTX_EVT_SYNC
-	  || type == PTX_EVT_ASYNC_CLEANUP);
-
-  ptx_event = GOMP_PLUGIN_malloc (sizeof (struct ptx_event));
-  ptx_event->type = type;
-  ptx_event->evt = e;
-  ptx_event->addr = h;
-  ptx_event->ord = nvthd->ptx_dev->ord;
-  ptx_event->val = val;
-
-  pthread_mutex_lock (&ptx_event_lock);
-
-  ptx_event->next = ptx_events;
-  ptx_events = ptx_event;
-
-  pthread_mutex_unlock (&ptx_event_lock);
-}
-
 static void
 nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,
-	    int async, unsigned *dims, void *targ_mem_desc)
+	    unsigned *dims, void *targ_mem_desc,
+	    CUdeviceptr dp, CUstream stream)
 {
   struct targ_fn_descriptor *targ_fn = (struct targ_fn_descriptor *) fn;
   CUfunction function;
-  CUresult r;
   int i;
-  struct ptx_stream *dev_str;
   void *kargs[1];
-  void *hp;
-  CUdeviceptr dp = 0;
   struct nvptx_thread *nvthd = nvptx_thread ();
   int warp_size = nvthd->ptx_dev->warp_size;
-  const char *maybe_abort_msg = "(perhaps abort was called)";
 
   function = targ_fn->fn;
 
-  dev_str = select_stream_for_async (async, pthread_self (), false, NULL);
-  assert (dev_str == nvthd->current_stream);
-
   /* Initialize the launch dimensions.  Typically this is constant,
      provided by the device compiler, but we must permit runtime
      values.  */
@@ -1361,27 +894,6 @@ nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,
 			   dims[GOMP_DIM_VECTOR]);
     }
 
-  if (mapnum > 0)
-    {
-      /* This reserves a chunk of a pre-allocated page of memory mapped on both
-	 the host and the device. HP is a host pointer to the new chunk, and DP is
-	 the corresponding device pointer.  */
-      pthread_mutex_lock (&ptx_event_lock);
-      dp = map_push (dev_str, mapnum * sizeof (void *));
-      pthread_mutex_unlock (&ptx_event_lock);
-
-      GOMP_PLUGIN_debug (0, "  %s: prepare mappings\n", __FUNCTION__);
-
-      /* Copy the array of arguments to the mapped page.  */
-      hp = alloca(sizeof(void *) * mapnum);
-      for (i = 0; i < mapnum; i++)
-	((void **) hp)[i] = devaddrs[i];
-
-      /* Copy the (device) pointers to arguments to the device */
-      CUDA_CALL_ASSERT (cuMemcpyHtoD, dp, hp,
-			mapnum * sizeof (void *));
-    }
-
   GOMP_PLUGIN_debug (0, "  %s: kernel %s: launch"
 		     " gangs=%u, workers=%u, vectors=%u\n",
 		     __FUNCTION__, targ_fn->launch->fn, dims[GOMP_DIM_GANG],
@@ -1393,77 +905,137 @@ nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,
   // num_workers	ntid.y
   // vector length	ntid.x
 
+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();
+  acc_prof_info *prof_info = thr->prof_info;
+  acc_event_info enqueue_launch_event_info;
+  acc_api_info *api_info = thr->api_info;
+  bool profiling_p = __builtin_expect (prof_info != NULL, false);
+  if (profiling_p)
+    {
+      prof_info->event_type = acc_ev_enqueue_launch_start;
+
+      enqueue_launch_event_info.launch_event.event_type
+	= prof_info->event_type;
+      enqueue_launch_event_info.launch_event.valid_bytes
+	= _ACC_LAUNCH_EVENT_INFO_VALID_BYTES;
+      enqueue_launch_event_info.launch_event.parent_construct
+	= acc_construct_parallel;
+      enqueue_launch_event_info.launch_event.implicit = 1;
+      enqueue_launch_event_info.launch_event.tool_info = NULL;
+      enqueue_launch_event_info.launch_event.kernel_name = targ_fn->launch->fn;
+      enqueue_launch_event_info.launch_event.num_gangs
+	= dims[GOMP_DIM_GANG];
+      enqueue_launch_event_info.launch_event.num_workers
+	= dims[GOMP_DIM_WORKER];
+      enqueue_launch_event_info.launch_event.vector_length
+	= dims[GOMP_DIM_VECTOR];
+
+      api_info->device_api = acc_device_api_cuda;
+
+      GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &enqueue_launch_event_info,
+					    api_info);
+    }
+
   kargs[0] = &dp;
   CUDA_CALL_ASSERT (cuLaunchKernel, function,
 		    dims[GOMP_DIM_GANG], 1, 1,
 		    dims[GOMP_DIM_VECTOR], dims[GOMP_DIM_WORKER], 1,
-		    0, dev_str->stream, kargs, 0);
+		    0, stream, kargs, 0);
 
-#ifndef DISABLE_ASYNC
-  if (async < acc_async_noval)
+  if (profiling_p)
     {
-      r = CUDA_CALL_NOCHECK (cuStreamSynchronize, dev_str->stream);
-      if (r == CUDA_ERROR_LAUNCH_FAILED)
-	GOMP_PLUGIN_fatal ("cuStreamSynchronize error: %s %s\n", cuda_error (r),
-			   maybe_abort_msg);
-      else if (r != CUDA_SUCCESS)
-        GOMP_PLUGIN_fatal ("cuStreamSynchronize error: %s", cuda_error (r));
+      prof_info->event_type = acc_ev_enqueue_launch_end;
+      enqueue_launch_event_info.launch_event.event_type
+	= prof_info->event_type;
+      GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &enqueue_launch_event_info,
+					    api_info);
     }
-  else
-    {
-      CUevent *e;
 
-      e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));
+  GOMP_PLUGIN_debug (0, "  %s: kernel %s: finished\n", __FUNCTION__,
+		     targ_fn->launch->fn);
+}
 
-      r = CUDA_CALL_NOCHECK (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);
-      if (r == CUDA_ERROR_LAUNCH_FAILED)
-	GOMP_PLUGIN_fatal ("cuEventCreate error: %s %s\n", cuda_error (r),
-			   maybe_abort_msg);
-      else if (r != CUDA_SUCCESS)
-        GOMP_PLUGIN_fatal ("cuEventCreate error: %s", cuda_error (r));
+void * openacc_get_current_cuda_context (void);
 
-      event_gc (true);
+static void
+goacc_profiling_acc_ev_alloc (struct goacc_thread *thr, void *dp, size_t s)
+{
+  acc_prof_info *prof_info = thr->prof_info;
+  acc_event_info data_event_info;
+  acc_api_info *api_info = thr->api_info;
 
-      CUDA_CALL_ASSERT (cuEventRecord, *e, dev_str->stream);
+  prof_info->event_type = acc_ev_alloc;
 
-      if (mapnum > 0)
-	event_add (PTX_EVT_KNL, e, (void *)dev_str, 0);
-    }
-#else
-  r = CUDA_CALL_NOCHECK (cuCtxSynchronize, );
-  if (r == CUDA_ERROR_LAUNCH_FAILED)
-    GOMP_PLUGIN_fatal ("cuCtxSynchronize error: %s %s\n", cuda_error (r),
-		       maybe_abort_msg);
-  else if (r != CUDA_SUCCESS)
-    GOMP_PLUGIN_fatal ("cuCtxSynchronize error: %s", cuda_error (r));
-#endif
+  data_event_info.data_event.event_type = prof_info->event_type;
+  data_event_info.data_event.valid_bytes = _ACC_DATA_EVENT_INFO_VALID_BYTES;
+  data_event_info.data_event.parent_construct = acc_construct_parallel;
+  data_event_info.data_event.implicit = 1;
+  data_event_info.data_event.tool_info = NULL;
+  data_event_info.data_event.var_name = NULL;
+  data_event_info.data_event.bytes = s;
+  data_event_info.data_event.host_ptr = NULL;
+  data_event_info.data_event.device_ptr = dp;
 
-  GOMP_PLUGIN_debug (0, "  %s: kernel %s: finished\n", __FUNCTION__,
-		     targ_fn->launch->fn);
+  api_info->device_api = acc_device_api_cuda;
 
-#ifndef DISABLE_ASYNC
-  if (async < acc_async_noval)
-#endif
-    {
-      if (mapnum > 0)
-	map_pop (dev_str);
-    }
+  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info, api_info);
 }
 
-void * openacc_get_current_cuda_context (void);
-
 static void *
 nvptx_alloc (size_t s)
 {
   CUdeviceptr d;
 
   CUDA_CALL_ERET (NULL, cuMemAlloc, &d, s);
+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();
+  bool profiling_p
+    = __builtin_expect (thr != NULL && thr->prof_info != NULL, false);
+  if (profiling_p)
+    goacc_profiling_acc_ev_alloc (thr, (void *) d, s);
+
   return (void *) d;
 }
 
+static void
+goacc_profiling_acc_ev_free (struct goacc_thread *thr, void *p)
+{
+  acc_prof_info *prof_info = thr->prof_info;
+  acc_event_info data_event_info;
+  acc_api_info *api_info = thr->api_info;
+
+  prof_info->event_type = acc_ev_free;
+
+  data_event_info.data_event.event_type = prof_info->event_type;
+  data_event_info.data_event.valid_bytes = _ACC_DATA_EVENT_INFO_VALID_BYTES;
+  data_event_info.data_event.parent_construct = acc_construct_parallel;
+  data_event_info.data_event.implicit = 1;
+  data_event_info.data_event.tool_info = NULL;
+  data_event_info.data_event.var_name = NULL;
+  data_event_info.data_event.bytes = -1;
+  data_event_info.data_event.host_ptr = NULL;
+  data_event_info.data_event.device_ptr = p;
+
+  api_info->device_api = acc_device_api_cuda;
+
+  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info, api_info);
+}
+
 static bool
-nvptx_free (void *p)
+nvptx_free (void *p, struct ptx_device *ptx_dev)
 {
+  /* Assume callback context if this is null.  */
+  if (GOMP_PLUGIN_acc_thread () == NULL)
+    {
+      struct ptx_free_block *n
+	= GOMP_PLUGIN_malloc (sizeof (struct ptx_free_block));
+      n->ptr = p;
+      pthread_mutex_lock (&ptx_dev->free_blocks_lock);
+      n->next = ptx_dev->free_blocks;
+      ptx_dev->free_blocks = n;
+      pthread_mutex_unlock (&ptx_dev->free_blocks_lock);
+      return true;
+    }
+
   CUdeviceptr pb;
   size_t ps;
 
@@ -1475,398 +1047,36 @@ nvptx_free (void *p)
     }
 
   CUDA_CALL (cuMemFree, (CUdeviceptr) p);
+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();
+  bool profiling_p
+    = __builtin_expect (thr != NULL && thr->prof_info != NULL, false);
+  if (profiling_p)
+    goacc_profiling_acc_ev_free (thr, p);
+
   return true;
 }
 
+static void *
+nvptx_get_current_cuda_device (void)
+{
+  struct nvptx_thread *nvthd = nvptx_thread ();
 
-static bool
-nvptx_host2dev (void *d, const void *h, size_t s)
+  if (!nvthd || !nvthd->ptx_dev)
+    return NULL;
+
+  return &nvthd->ptx_dev->dev;
+}
+
+static void *
+nvptx_get_current_cuda_context (void)
 {
-  CUdeviceptr pb;
-  size_t ps;
   struct nvptx_thread *nvthd = nvptx_thread ();
 
-  if (!s)
-    return true;
-  if (!d)
-    {
-      GOMP_PLUGIN_error ("invalid device address");
-      return false;
-    }
+  if (!nvthd || !nvthd->ptx_dev)
+    return NULL;
 
-  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);
-
-  if (!pb)
-    {
-      GOMP_PLUGIN_error ("invalid device address");
-      return false;
-    }
-  if (!h)
-    {
-      GOMP_PLUGIN_error ("invalid host address");
-      return false;
-    }
-  if (d == h)
-    {
-      GOMP_PLUGIN_error ("invalid host or device address");
-      return false;
-    }
-  if ((void *)(d + s) > (void *)(pb + ps))
-    {
-      GOMP_PLUGIN_error ("invalid size");
-      return false;
-    }
-
-#ifndef DISABLE_ASYNC
-  if (nvthd && nvthd->current_stream != nvthd->ptx_dev->null_stream)
-    {
-      CUevent *e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));
-      CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);
-      event_gc (false);
-      CUDA_CALL (cuMemcpyHtoDAsync,
-		 (CUdeviceptr) d, h, s, nvthd->current_stream->stream);
-      CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);
-      event_add (PTX_EVT_MEM, e, (void *)h, 0);
-    }
-  else
-#endif
-    CUDA_CALL (cuMemcpyHtoD, (CUdeviceptr) d, h, s);
-
-  return true;
-}
-
-static bool
-nvptx_dev2host (void *h, const void *d, size_t s)
-{
-  CUdeviceptr pb;
-  size_t ps;
-  struct nvptx_thread *nvthd = nvptx_thread ();
-
-  if (!s)
-    return true;
-  if (!d)
-    {
-      GOMP_PLUGIN_error ("invalid device address");
-      return false;
-    }
-
-  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);
-
-  if (!pb)
-    {
-      GOMP_PLUGIN_error ("invalid device address");
-      return false;
-    }
-  if (!h)
-    {
-      GOMP_PLUGIN_error ("invalid host address");
-      return false;
-    }
-  if (d == h)
-    {
-      GOMP_PLUGIN_error ("invalid host or device address");
-      return false;
-    }
-  if ((void *)(d + s) > (void *)(pb + ps))
-    {
-      GOMP_PLUGIN_error ("invalid size");
-      return false;
-    }
-
-#ifndef DISABLE_ASYNC
-  if (nvthd && nvthd->current_stream != nvthd->ptx_dev->null_stream)
-    {
-      CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));
-      CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);
-      event_gc (false);
-      CUDA_CALL (cuMemcpyDtoHAsync,
-		 h, (CUdeviceptr) d, s, nvthd->current_stream->stream);
-      CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);
-      event_add (PTX_EVT_MEM, e, (void *)h, 0);
-    }
-  else
-#endif
-    CUDA_CALL (cuMemcpyDtoH, h, (CUdeviceptr) d, s);
-
-  return true;
-}
-
-static void
-nvptx_set_async (int async)
-{
-  struct nvptx_thread *nvthd = nvptx_thread ();
-  nvthd->current_stream
-    = select_stream_for_async (async, pthread_self (), true, NULL);
-}
-
-static int
-nvptx_async_test (int async)
-{
-  CUresult r;
-  struct ptx_stream *s;
-
-  s = select_stream_for_async (async, pthread_self (), false, NULL);
-  if (!s)
-    return 1;
-
-  r = CUDA_CALL_NOCHECK (cuStreamQuery, s->stream);
-  if (r == CUDA_SUCCESS)
-    {
-      /* The oacc-parallel.c:goacc_wait function calls this hook to determine
-	 whether all work has completed on this stream, and if so omits the call
-	 to the wait hook.  If that happens, event_gc might not get called
-	 (which prevents variables from getting unmapped and their associated
-	 device storage freed), so call it here.  */
-      event_gc (true);
-      return 1;
-    }
-  else if (r == CUDA_ERROR_NOT_READY)
-    return 0;
-
-  GOMP_PLUGIN_fatal ("cuStreamQuery error: %s", cuda_error (r));
-
-  return 0;
-}
-
-static int
-nvptx_async_test_all (void)
-{
-  struct ptx_stream *s;
-  pthread_t self = pthread_self ();
-  struct nvptx_thread *nvthd = nvptx_thread ();
-
-  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);
-
-  for (s = nvthd->ptx_dev->active_streams; s != NULL; s = s->next)
-    {
-      if ((s->multithreaded || pthread_equal (s->host_thread, self))
-	  && CUDA_CALL_NOCHECK (cuStreamQuery,
-				s->stream) == CUDA_ERROR_NOT_READY)
-	{
-	  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);
-	  return 0;
-	}
-    }
-
-  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);
-
-  event_gc (true);
-
-  return 1;
-}
-
-static void
-nvptx_wait (int async)
-{
-  struct ptx_stream *s;
-
-  s = select_stream_for_async (async, pthread_self (), false, NULL);
-  if (!s)
-    return;
-
-  CUDA_CALL_ASSERT (cuStreamSynchronize, s->stream);
-
-  event_gc (true);
-}
-
-static void
-nvptx_wait_async (int async1, int async2)
-{
-  CUevent *e;
-  struct ptx_stream *s1, *s2;
-  pthread_t self = pthread_self ();
-
-  s1 = select_stream_for_async (async1, self, false, NULL);
-  if (!s1)
-    return;
-
-  /* The stream that is waiting (rather than being waited for) doesn't
-     necessarily have to exist already.  */
-  s2 = select_stream_for_async (async2, self, true, NULL);
-
-  /* A stream is always synchronized with itself.  */
-  if (s1 == s2)
-    return;
-
-  e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));
-
-  CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);
-
-  event_gc (true);
-
-  CUDA_CALL_ASSERT (cuEventRecord, *e, s1->stream);
-
-  event_add (PTX_EVT_SYNC, e, NULL, 0);
-
-  CUDA_CALL_ASSERT (cuStreamWaitEvent, s2->stream, *e, 0);
-}
-
-static void
-nvptx_wait_all (void)
-{
-  CUresult r;
-  struct ptx_stream *s;
-  pthread_t self = pthread_self ();
-  struct nvptx_thread *nvthd = nvptx_thread ();
-
-  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);
-
-  /* Wait for active streams initiated by this thread (or by multiple threads)
-     to complete.  */
-  for (s = nvthd->ptx_dev->active_streams; s != NULL; s = s->next)
-    {
-      if (s->multithreaded || pthread_equal (s->host_thread, self))
-	{
-	  r = CUDA_CALL_NOCHECK (cuStreamQuery, s->stream);
-	  if (r == CUDA_SUCCESS)
-	    continue;
-	  else if (r != CUDA_ERROR_NOT_READY)
-	    GOMP_PLUGIN_fatal ("cuStreamQuery error: %s", cuda_error (r));
-
-	  CUDA_CALL_ASSERT (cuStreamSynchronize, s->stream);
-	}
-    }
-
-  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);
-
-  event_gc (true);
-}
-
-static void
-nvptx_wait_all_async (int async)
-{
-  struct ptx_stream *waiting_stream, *other_stream;
-  CUevent *e;
-  struct nvptx_thread *nvthd = nvptx_thread ();
-  pthread_t self = pthread_self ();
-
-  /* The stream doing the waiting.  This could be the first mention of the
-     stream, so create it if necessary.  */
-  waiting_stream
-    = select_stream_for_async (async, pthread_self (), true, NULL);
-
-  /* Launches on the null stream already block on other streams in the
-     context.  */
-  if (!waiting_stream || waiting_stream == nvthd->ptx_dev->null_stream)
-    return;
-
-  event_gc (true);
-
-  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);
-
-  for (other_stream = nvthd->ptx_dev->active_streams;
-       other_stream != NULL;
-       other_stream = other_stream->next)
-    {
-      if (!other_stream->multithreaded
-	  && !pthread_equal (other_stream->host_thread, self))
-	continue;
-
-      e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));
-
-      CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);
-
-      /* Record an event on the waited-for stream.  */
-      CUDA_CALL_ASSERT (cuEventRecord, *e, other_stream->stream);
-
-      event_add (PTX_EVT_SYNC, e, NULL, 0);
-
-      CUDA_CALL_ASSERT (cuStreamWaitEvent, waiting_stream->stream, *e, 0);
-   }
-
-  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);
-}
-
-static void *
-nvptx_get_current_cuda_device (void)
-{
-  struct nvptx_thread *nvthd = nvptx_thread ();
-
-  if (!nvthd || !nvthd->ptx_dev)
-    return NULL;
-
-  return &nvthd->ptx_dev->dev;
-}
-
-static void *
-nvptx_get_current_cuda_context (void)
-{
-  struct nvptx_thread *nvthd = nvptx_thread ();
-
-  if (!nvthd || !nvthd->ptx_dev)
-    return NULL;
-
-  return nvthd->ptx_dev->ctx;
-}
-
-static void *
-nvptx_get_cuda_stream (int async)
-{
-  struct ptx_stream *s;
-  struct nvptx_thread *nvthd = nvptx_thread ();
-
-  if (!nvthd || !nvthd->ptx_dev)
-    return NULL;
-
-  s = select_stream_for_async (async, pthread_self (), false, NULL);
-
-  return s ? s->stream : NULL;
-}
-
-static int
-nvptx_set_cuda_stream (int async, void *stream)
-{
-  struct ptx_stream *oldstream;
-  pthread_t self = pthread_self ();
-  struct nvptx_thread *nvthd = nvptx_thread ();
-
-  /* Due to the "null_stream" usage for "acc_async_sync", this cannot be used
-     to change the stream handle associated with "acc_async_sync".  */
-  if (async == acc_async_sync)
-    {
-      GOMP_PLUGIN_debug (0, "Refusing request to set CUDA stream associated"
-			 " with \"acc_async_sync\"\n");
-      return 0;
-    }
-
-  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);
-
-  /* We have a list of active streams and an array mapping async values to
-     entries of that list.  We need to take "ownership" of the passed-in stream,
-     and add it to our list, removing the previous entry also (if there was one)
-     in order to prevent resource leaks.  Note the potential for surprise
-     here: maybe we should keep track of passed-in streams and leave it up to
-     the user to tidy those up, but that doesn't work for stream handles
-     returned from acc_get_cuda_stream above...  */
-
-  oldstream = select_stream_for_async (async, self, false, NULL);
-
-  if (oldstream)
-    {
-      if (nvthd->ptx_dev->active_streams == oldstream)
-	nvthd->ptx_dev->active_streams = nvthd->ptx_dev->active_streams->next;
-      else
-	{
-	  struct ptx_stream *s = nvthd->ptx_dev->active_streams;
-	  while (s->next != oldstream)
-	    s = s->next;
-	  s->next = s->next->next;
-	}
-
-      CUDA_CALL_ASSERT (cuStreamDestroy, oldstream->stream);
-
-      if (!map_fini (oldstream))
-	GOMP_PLUGIN_fatal ("error when freeing host memory");
-
-      free (oldstream);
-    }
-
-  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);
-
-  (void) select_stream_for_async (async, self, true, (CUstream) stream);
-
-  return 1;
-}
+  return nvthd->ptx_dev->ctx;
+}
 
 /* Plugin entry points.  */
 
@@ -2107,6 +1317,23 @@ GOMP_OFFLOAD_alloc (int ord, size_t size)
 {
   if (!nvptx_attach_host_thread_to_device (ord))
     return NULL;
+
+  struct ptx_device *ptx_dev = ptx_devices[ord];
+  struct ptx_free_block *blocks, *tmp;
+
+  pthread_mutex_lock (&ptx_dev->free_blocks_lock);
+  blocks = ptx_dev->free_blocks;
+  ptx_dev->free_blocks = NULL;
+  pthread_mutex_unlock (&ptx_dev->free_blocks_lock);
+
+  while (blocks)
+    {
+      tmp = blocks->next;
+      nvptx_free (blocks->ptr, ptx_dev);
+      free (blocks);
+      blocks = tmp;
+    }
+
   return nvptx_alloc (size);
 }
 
@@ -2114,93 +1341,174 @@ bool
 GOMP_OFFLOAD_free (int ord, void *ptr)
 {
   return (nvptx_attach_host_thread_to_device (ord)
-	  && nvptx_free (ptr));
+	  && nvptx_free (ptr, ptx_devices[ord]));
 }
 
-bool
-GOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)
+void
+GOMP_OFFLOAD_openacc_exec (void (*fn) (void *), size_t mapnum,
+			   void **hostaddrs, void **devaddrs,
+			   unsigned *dims, void *targ_mem_desc)
 {
-  return (nvptx_attach_host_thread_to_device (ord)
-	  && nvptx_dev2host (dst, src, n));
-}
+  GOMP_PLUGIN_debug (0, "  %s: prepare mappings\n", __FUNCTION__);
 
-bool
-GOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)
-{
-  return (nvptx_attach_host_thread_to_device (ord)
-	  && nvptx_host2dev (dst, src, n));
-}
+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();
+  acc_prof_info *prof_info = thr->prof_info;
+  acc_event_info data_event_info;
+  acc_api_info *api_info = thr->api_info;
+  bool profiling_p = __builtin_expect (prof_info != NULL, false);
 
-bool
-GOMP_OFFLOAD_dev2dev (int ord, void *dst, const void *src, size_t n)
-{
-  struct ptx_device *ptx_dev = ptx_devices[ord];
-  CUDA_CALL (cuMemcpyDtoDAsync, (CUdeviceptr) dst, (CUdeviceptr) src, n,
-				ptx_dev->null_stream->stream);
-  return true;
-}
+  void **hp = NULL;
+  CUdeviceptr dp = 0;
 
-void (*device_run) (int n, void *fn_ptr, void *vars) = NULL;
+  if (mapnum > 0)
+    {
+      size_t s = mapnum * sizeof (void *);
+      hp = alloca (s);
+      for (int i = 0; i < mapnum; i++)
+	hp[i] = (devaddrs[i] ? devaddrs[i] : hostaddrs[i]);
+      CUDA_CALL_ASSERT (cuMemAlloc, &dp, s);
+      if (profiling_p)
+	goacc_profiling_acc_ev_alloc (thr, (void *) dp, s);
+    }
 
-void
-GOMP_OFFLOAD_openacc_exec (void (*fn) (void *), size_t mapnum,
-			   void **hostaddrs, void **devaddrs,
-			   int async, unsigned *dims, void *targ_mem_desc)
-{
-  nvptx_exec (fn, mapnum, hostaddrs, devaddrs, async, dims, targ_mem_desc);
-}
+  /* Copy the (device) pointers to arguments to the device (dp and hp might in
+     fact have the same value on a unified-memory system).  */
+  if (mapnum > 0)
+    {
+      if (profiling_p)
+	{
+	  prof_info->event_type = acc_ev_enqueue_upload_start;
+
+	  data_event_info.data_event.event_type = prof_info->event_type;
+	  data_event_info.data_event.valid_bytes
+	    = _ACC_DATA_EVENT_INFO_VALID_BYTES;
+	  data_event_info.data_event.parent_construct
+	    = acc_construct_parallel;
+	  data_event_info.data_event.implicit = 1; /* Always implicit.  */
+	  data_event_info.data_event.tool_info = NULL;
+	  data_event_info.data_event.var_name = NULL;
+	  data_event_info.data_event.bytes = mapnum * sizeof (void *);
+	  data_event_info.data_event.host_ptr = hp;
+	  data_event_info.data_event.device_ptr = (const void *) dp;
+
+	  api_info->device_api = acc_device_api_cuda;
+
+	  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,
+						api_info);
+	}
+      CUDA_CALL_ASSERT (cuMemcpyHtoD, dp, (void *) hp,
+			mapnum * sizeof (void *));
+      if (profiling_p)
+	{
+	  prof_info->event_type = acc_ev_enqueue_upload_end;
+	  data_event_info.data_event.event_type = prof_info->event_type;
+	  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,
+						api_info);
+	}
+    }
 
-void
-GOMP_OFFLOAD_openacc_register_async_cleanup (void *targ_mem_desc, int async)
-{
-  struct nvptx_thread *nvthd = nvptx_thread ();
-  CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));
+  nvptx_exec (fn, mapnum, hostaddrs, devaddrs, dims, targ_mem_desc,
+	      dp, NULL);
 
-  CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);
-  CUDA_CALL_ASSERT (cuEventRecord, *e, nvthd->current_stream->stream);
-  event_add (PTX_EVT_ASYNC_CLEANUP, e, targ_mem_desc, async);
-}
+  CUresult r = CUDA_CALL_NOCHECK (cuStreamSynchronize, NULL);
+  const char *maybe_abort_msg = "(perhaps abort was called)";
+  if (r == CUDA_ERROR_LAUNCH_FAILED)
+    GOMP_PLUGIN_fatal ("cuStreamSynchronize error: %s %s\n", cuda_error (r),
+		       maybe_abort_msg);
+  else if (r != CUDA_SUCCESS)
+    GOMP_PLUGIN_fatal ("cuStreamSynchronize error: %s", cuda_error (r));
 
-int
-GOMP_OFFLOAD_openacc_async_test (int async)
-{
-  return nvptx_async_test (async);
+  CUDA_CALL_ASSERT (cuMemFree, dp);
+  if (profiling_p)
+    goacc_profiling_acc_ev_free (thr, (void *) dp);
 }
 
-int
-GOMP_OFFLOAD_openacc_async_test_all (void)
+static void
+cuda_free_argmem (void *ptr)
 {
-  return nvptx_async_test_all ();
+  void **block = (void **) ptr;
+  nvptx_free (block[0], (struct ptx_device *) block[1]);
+  free (block);
 }
 
 void
-GOMP_OFFLOAD_openacc_async_wait (int async)
+GOMP_OFFLOAD_openacc_async_exec (void (*fn) (void *), size_t mapnum,
+				 void **hostaddrs, void **devaddrs,
+				 unsigned *dims, void *targ_mem_desc,
+				 struct goacc_asyncqueue *aq)
 {
-  nvptx_wait (async);
-}
+  GOMP_PLUGIN_debug (0, "  %s: prepare mappings\n", __FUNCTION__);
 
-void
-GOMP_OFFLOAD_openacc_async_wait_async (int async1, int async2)
-{
-  nvptx_wait_async (async1, async2);
-}
+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();
+  acc_prof_info *prof_info = thr->prof_info;
+  acc_event_info data_event_info;
+  acc_api_info *api_info = thr->api_info;
+  bool profiling_p = __builtin_expect (prof_info != NULL, false);
 
-void
-GOMP_OFFLOAD_openacc_async_wait_all (void)
-{
-  nvptx_wait_all ();
-}
+  void **hp = NULL;
+  CUdeviceptr dp = 0;
+  void **block = NULL;
 
-void
-GOMP_OFFLOAD_openacc_async_wait_all_async (int async)
-{
-  nvptx_wait_all_async (async);
-}
+  if (mapnum > 0)
+    {
+      size_t s = mapnum * sizeof (void *);
+      block = (void **) GOMP_PLUGIN_malloc (2 * sizeof (void *) + s);
+      hp = block + 2;
+      for (int i = 0; i < mapnum; i++)
+	hp[i] = (devaddrs[i] ? devaddrs[i] : hostaddrs[i]);
+      CUDA_CALL_ASSERT (cuMemAlloc, &dp, s);
+      if (profiling_p)
+	goacc_profiling_acc_ev_alloc (thr, (void *) dp, s);
+    }
 
-void
-GOMP_OFFLOAD_openacc_async_set_async (int async)
-{
-  nvptx_set_async (async);
+  /* Copy the (device) pointers to arguments to the device (dp and hp might in
+     fact have the same value on a unified-memory system).  */
+  if (mapnum > 0)
+    {
+      if (profiling_p)
+	{
+	  prof_info->event_type = acc_ev_enqueue_upload_start;
+
+	  data_event_info.data_event.event_type = prof_info->event_type;
+	  data_event_info.data_event.valid_bytes
+	    = _ACC_DATA_EVENT_INFO_VALID_BYTES;
+	  data_event_info.data_event.parent_construct
+	    = acc_construct_parallel;
+	  data_event_info.data_event.implicit = 1; /* Always implicit.  */
+	  data_event_info.data_event.tool_info = NULL;
+	  data_event_info.data_event.var_name = NULL;
+	  data_event_info.data_event.bytes = mapnum * sizeof (void *);
+	  data_event_info.data_event.host_ptr = hp;
+	  data_event_info.data_event.device_ptr = (const void *) dp;
+
+	  api_info->device_api = acc_device_api_cuda;
+
+	  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,
+						api_info);
+	}
+
+      CUDA_CALL_ASSERT (cuMemcpyHtoDAsync, dp, (void *) hp,
+			mapnum * sizeof (void *), aq->cuda_stream);
+      block[0] = (void *) dp;
+
+      struct nvptx_thread *nvthd =
+	(struct nvptx_thread *) GOMP_PLUGIN_acc_thread ();
+      block[1] = (void *) nvthd->ptx_dev;
+
+      if (profiling_p)
+	{
+	  prof_info->event_type = acc_ev_enqueue_upload_end;
+	  data_event_info.data_event.event_type = prof_info->event_type;
+	  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,
+						api_info);
+	}
+    }
+
+  nvptx_exec (fn, mapnum, hostaddrs, devaddrs, dims, targ_mem_desc,
+	      dp, aq->cuda_stream);
+
+  if (mapnum > 0)
+    GOMP_OFFLOAD_openacc_async_queue_callback (aq, cuda_free_argmem, block);
 }
 
 void *
@@ -2222,7 +1530,6 @@ GOMP_OFFLOAD_openacc_create_thread_data (int ord)
   if (!thd_ctx)
     CUDA_CALL_ASSERT (cuCtxPushCurrent, ptx_dev->ctx);
 
-  nvthd->current_stream = ptx_dev->null_stream;
   nvthd->ptx_dev = ptx_dev;
 
   return (void *) nvthd;
@@ -2246,20 +1553,184 @@ GOMP_OFFLOAD_openacc_cuda_get_current_context (void)
   return nvptx_get_current_cuda_context ();
 }
 
-/* NOTE: This returns a CUstream, not a ptx_stream pointer.  */
-
+/* This returns a CUstream.  */
 void *
-GOMP_OFFLOAD_openacc_cuda_get_stream (int async)
+GOMP_OFFLOAD_openacc_cuda_get_stream (struct goacc_asyncqueue *aq)
+{
+  return (void *) aq->cuda_stream;
+}
+
+/* This takes a CUstream.  */
+int
+GOMP_OFFLOAD_openacc_cuda_set_stream (struct goacc_asyncqueue *aq, void *stream)
+{
+  if (aq->cuda_stream)
+    {
+      CUDA_CALL_ASSERT (cuStreamSynchronize, aq->cuda_stream);
+      CUDA_CALL_ASSERT (cuStreamDestroy, aq->cuda_stream);
+    }
+
+  aq->cuda_stream = (CUstream) stream;
+  return 1;
+}
+
+struct goacc_asyncqueue *
+GOMP_OFFLOAD_openacc_async_construct (int device __attribute__((unused)))
 {
-  return nvptx_get_cuda_stream (async);
+  CUstream stream = NULL;
+  CUDA_CALL_ERET (NULL, cuStreamCreate, &stream, CU_STREAM_DEFAULT);
+
+  struct goacc_asyncqueue *aq
+    = GOMP_PLUGIN_malloc (sizeof (struct goacc_asyncqueue));
+  aq->cuda_stream = stream;
+  return aq;
 }
 
-/* NOTE: This takes a CUstream, not a ptx_stream pointer.  */
+bool
+GOMP_OFFLOAD_openacc_async_destruct (struct goacc_asyncqueue *aq)
+{
+  CUDA_CALL_ERET (false, cuStreamDestroy, aq->cuda_stream);
+  free (aq);
+  return true;
+}
 
 int
-GOMP_OFFLOAD_openacc_cuda_set_stream (int async, void *stream)
+GOMP_OFFLOAD_openacc_async_test (struct goacc_asyncqueue *aq)
+{
+  CUresult r = CUDA_CALL_NOCHECK (cuStreamQuery, aq->cuda_stream);
+  if (r == CUDA_SUCCESS)
+    return 1;
+  if (r == CUDA_ERROR_NOT_READY)
+    return 0;
+
+  GOMP_PLUGIN_error ("cuStreamQuery error: %s", cuda_error (r));
+  return -1;
+}
+
+bool
+GOMP_OFFLOAD_openacc_async_synchronize (struct goacc_asyncqueue *aq)
+{
+  CUDA_CALL_ERET (false, cuStreamSynchronize, aq->cuda_stream);
+  return true;
+}
+
+bool
+GOMP_OFFLOAD_openacc_async_serialize (struct goacc_asyncqueue *aq1,
+				      struct goacc_asyncqueue *aq2)
+{
+  CUevent e;
+  CUDA_CALL_ERET (false, cuEventCreate, &e, CU_EVENT_DISABLE_TIMING);
+  CUDA_CALL_ERET (false, cuEventRecord, e, aq1->cuda_stream);
+  CUDA_CALL_ERET (false, cuStreamWaitEvent, aq2->cuda_stream, e, 0);
+  return true;
+}
+
+static void
+cuda_callback_wrapper (CUstream stream, CUresult res, void *ptr)
 {
-  return nvptx_set_cuda_stream (async, stream);
+  if (res != CUDA_SUCCESS)
+    GOMP_PLUGIN_fatal ("%s error: %s", __FUNCTION__, cuda_error (res));
+  struct nvptx_callback *cb = (struct nvptx_callback *) ptr;
+  cb->fn (cb->ptr);
+  free (ptr);
+}
+
+void
+GOMP_OFFLOAD_openacc_async_queue_callback (struct goacc_asyncqueue *aq,
+					   void (*callback_fn)(void *),
+					   void *userptr)
+{
+  struct nvptx_callback *b = GOMP_PLUGIN_malloc (sizeof (*b));
+  b->fn = callback_fn;
+  b->ptr = userptr;
+  b->aq = aq;
+  CUDA_CALL_ASSERT (cuStreamAddCallback, aq->cuda_stream,
+		    cuda_callback_wrapper, (void *) b, 0);
+}
+
+static bool
+cuda_memcpy_sanity_check (const void *h, const void *d, size_t s)
+{
+  CUdeviceptr pb;
+  size_t ps;
+  if (!s)
+    return true;
+  if (!d)
+    {
+      GOMP_PLUGIN_error ("invalid device address");
+      return false;
+    }
+  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);
+  if (!pb)
+    {
+      GOMP_PLUGIN_error ("invalid device address");
+      return false;
+    }
+  if (!h)
+    {
+      GOMP_PLUGIN_error ("invalid host address");
+      return false;
+    }
+  if (d == h)
+    {
+      GOMP_PLUGIN_error ("invalid host or device address");
+      return false;
+    }
+  if ((void *)(d + s) > (void *)(pb + ps))
+    {
+      GOMP_PLUGIN_error ("invalid size");
+      return false;
+    }
+  return true;
+}
+
+bool
+GOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)
+{
+  if (!nvptx_attach_host_thread_to_device (ord)
+      || !cuda_memcpy_sanity_check (src, dst, n))
+    return false;
+  CUDA_CALL (cuMemcpyHtoD, (CUdeviceptr) dst, src, n);
+  return true;
+}
+
+bool
+GOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)
+{
+  if (!nvptx_attach_host_thread_to_device (ord)
+      || !cuda_memcpy_sanity_check (dst, src, n))
+    return false;
+  CUDA_CALL (cuMemcpyDtoH, dst, (CUdeviceptr) src, n);
+  return true;
+}
+
+bool
+GOMP_OFFLOAD_dev2dev (int ord, void *dst, const void *src, size_t n)
+{
+  CUDA_CALL (cuMemcpyDtoDAsync, (CUdeviceptr) dst, (CUdeviceptr) src, n, NULL);
+  return true;
+}
+
+bool
+GOMP_OFFLOAD_openacc_async_host2dev (int ord, void *dst, const void *src,
+				     size_t n, struct goacc_asyncqueue *aq)
+{
+  if (!nvptx_attach_host_thread_to_device (ord)
+      || !cuda_memcpy_sanity_check (src, dst, n))
+    return false;
+  CUDA_CALL (cuMemcpyHtoDAsync, (CUdeviceptr) dst, src, n, aq->cuda_stream);
+  return true;
+}
+
+bool
+GOMP_OFFLOAD_openacc_async_dev2host (int ord, void *dst, const void *src,
+				     size_t n, struct goacc_asyncqueue *aq)
+{
+  if (!nvptx_attach_host_thread_to_device (ord)
+      || !cuda_memcpy_sanity_check (dst, src, n))
+    return false;
+  CUDA_CALL (cuMemcpyDtoHAsync, dst, (CUdeviceptr) src, n, aq->cuda_stream);
+  return true;
 }
 
 /* Adjust launch dimensions: pick good values for number of blocks and warps
@@ -2360,8 +1831,7 @@ GOMP_OFFLOAD_run (int ord, void *tgt_fn, void *tgt_vars, void **args)
     CU_LAUNCH_PARAM_END
   };
   r = CUDA_CALL_NOCHECK (cuLaunchKernel, function, teams, 1, 1,
-			 32, threads, 1, 0, ptx_dev->null_stream->stream,
-			 NULL, config);
+			 32, threads, 1, 0, NULL, NULL, config);
   if (r != CUDA_SUCCESS)
     GOMP_PLUGIN_fatal ("cuLaunchKernel error: %s", cuda_error (r));
 
diff --git a/libgomp/target.c b/libgomp/target.c
index 31148003d0a..82ed38c01ec 100644
--- a/libgomp/target.c
+++ b/libgomp/target.c
@@ -25,7 +25,6 @@
 
 /* This file contains the support of offloading.  */
 
-#include "config.h"
 #include "libgomp.h"
 #include "oacc-plugin.h"
 #include "oacc-int.h"
@@ -45,6 +44,8 @@
 #include "plugin-suffix.h"
 #endif
 
+#define FIELD_TGT_EMPTY (~(size_t) 0)
+
 static void gomp_target_init (void);
 
 /* The whole initialization code for offloading plugins is only run one.  */
@@ -177,6 +178,22 @@ gomp_device_copy (struct gomp_device_descr *devicep,
     }
 }
 
+static inline void
+goacc_device_copy_async (struct gomp_device_descr *devicep,
+			 bool (*copy_func) (int, void *, const void *, size_t,
+					    struct goacc_asyncqueue *),
+			 const char *dst, void *dstaddr,
+			 const char *src, const void *srcaddr,
+			 size_t size, struct goacc_asyncqueue *aq)
+{
+  if (!copy_func (devicep->target_id, dstaddr, srcaddr, size, aq))
+    {
+      gomp_mutex_unlock (&devicep->lock);
+      gomp_fatal ("Copying of %s object [%p..%p) to %s object [%p..%p) failed",
+		  src, srcaddr, srcaddr + size, dst, dstaddr, dstaddr + size);
+    }
+}
+
 /* Infrastructure for coalescing adjacent or nearly adjacent (in device addresses)
    host to device memory transfers.  */
 
@@ -269,8 +286,9 @@ gomp_to_device_kind_p (int kind)
     }
 }
 
-static void
+attribute_hidden void
 gomp_copy_host2dev (struct gomp_device_descr *devicep,
+		    struct goacc_asyncqueue *aq,
 		    void *d, const void *h, size_t sz,
 		    struct gomp_coalesce_buf *cbuf)
 {
@@ -299,14 +317,23 @@ gomp_copy_host2dev (struct gomp_device_descr *devicep,
 	    }
 	}
     }
-  gomp_device_copy (devicep, devicep->host2dev_func, "dev", d, "host", h, sz);
+  if (__builtin_expect (aq != NULL, 0))
+    goacc_device_copy_async (devicep, devicep->openacc.async.host2dev_func,
+			     "dev", d, "host", h, sz, aq);
+  else
+    gomp_device_copy (devicep, devicep->host2dev_func, "dev", d, "host", h, sz);
 }
 
-static void
+attribute_hidden void
 gomp_copy_dev2host (struct gomp_device_descr *devicep,
+		    struct goacc_asyncqueue *aq,
 		    void *h, const void *d, size_t sz)
 {
-  gomp_device_copy (devicep, devicep->dev2host_func, "host", h, "dev", d, sz);
+  if (__builtin_expect (aq != NULL, 0))
+    goacc_device_copy_async (devicep, devicep->openacc.async.dev2host_func,
+			     "host", h, "dev", d, sz, aq);
+  else
+    gomp_device_copy (devicep, devicep->dev2host_func, "host", h, "dev", d, sz);
 }
 
 static void
@@ -324,7 +351,8 @@ gomp_free_device_memory (struct gomp_device_descr *devicep, void *devptr)
    Helper function of gomp_map_vars.  */
 
 static inline void
-gomp_map_vars_existing (struct gomp_device_descr *devicep, splay_tree_key oldn,
+gomp_map_vars_existing (struct gomp_device_descr *devicep,
+			struct goacc_asyncqueue *aq, splay_tree_key oldn,
 			splay_tree_key newn, struct target_var_desc *tgt_var,
 			unsigned char kind, struct gomp_coalesce_buf *cbuf)
 {
@@ -346,7 +374,7 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep, splay_tree_key oldn,
     }
 
   if (GOMP_MAP_ALWAYS_TO_P (kind))
-    gomp_copy_host2dev (devicep,
+    gomp_copy_host2dev (devicep, aq,
 			(void *) (oldn->tgt->tgt_start + oldn->tgt_offset
 				  + newn->host_start - oldn->host_start),
 			(void *) newn->host_start,
@@ -364,8 +392,8 @@ get_kind (bool short_mapkind, void *kinds, int idx)
 }
 
 static void
-gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,
-		  uintptr_t target_offset, uintptr_t bias,
+gomp_map_pointer (struct target_mem_desc *tgt, struct goacc_asyncqueue *aq,
+		  uintptr_t host_ptr, uintptr_t target_offset, uintptr_t bias,
 		  struct gomp_coalesce_buf *cbuf)
 {
   struct gomp_device_descr *devicep = tgt->device_descr;
@@ -376,7 +404,7 @@ gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,
   if (cur_node.host_start == (uintptr_t) NULL)
     {
       cur_node.tgt_offset = (uintptr_t) NULL;
-      gomp_copy_host2dev (devicep,
+      gomp_copy_host2dev (devicep, aq,
 			  (void *) (tgt->tgt_start + target_offset),
 			  (void *) &cur_node.tgt_offset,
 			  sizeof (void *), cbuf);
@@ -398,12 +426,13 @@ gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,
      array section.  Now subtract bias to get what we want
      to initialize the pointer with.  */
   cur_node.tgt_offset -= bias;
-  gomp_copy_host2dev (devicep, (void *) (tgt->tgt_start + target_offset),
+  gomp_copy_host2dev (devicep, aq, (void *) (tgt->tgt_start + target_offset),
 		      (void *) &cur_node.tgt_offset, sizeof (void *), cbuf);
 }
 
 static void
-gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,
+gomp_map_fields_existing (struct target_mem_desc *tgt,
+			  struct goacc_asyncqueue *aq, splay_tree_key n,
 			  size_t first, size_t i, void **hostaddrs,
 			  size_t *sizes, void *kinds,
 			  struct gomp_coalesce_buf *cbuf)
@@ -423,7 +452,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,
       && n2->tgt == n->tgt
       && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)
     {
-      gomp_map_vars_existing (devicep, n2, &cur_node,
+      gomp_map_vars_existing (devicep, aq, n2, &cur_node,
 			      &tgt->list[i], kind & typemask, cbuf);
       return;
     }
@@ -439,8 +468,8 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,
 	      && n2->host_start - n->host_start
 		 == n2->tgt_offset - n->tgt_offset)
 	    {
-	      gomp_map_vars_existing (devicep, n2, &cur_node, &tgt->list[i],
-				      kind & typemask, cbuf);
+	      gomp_map_vars_existing (devicep, aq, n2, &cur_node,
+				      &tgt->list[i], kind & typemask, cbuf);
 	      return;
 	    }
 	}
@@ -451,7 +480,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,
 	  && n2->tgt == n->tgt
 	  && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)
 	{
-	  gomp_map_vars_existing (devicep, n2, &cur_node, &tgt->list[i],
+	  gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],
 				  kind & typemask, cbuf);
 	  return;
 	}
@@ -470,23 +499,33 @@ gomp_map_val (struct target_mem_desc *tgt, void **hostaddrs, size_t i)
     return tgt->list[i].key->tgt->tgt_start
 	   + tgt->list[i].key->tgt_offset
 	   + tgt->list[i].offset;
-  if (tgt->list[i].offset == ~(uintptr_t) 0)
-    return (uintptr_t) hostaddrs[i];
-  if (tgt->list[i].offset == ~(uintptr_t) 1)
-    return 0;
-  if (tgt->list[i].offset == ~(uintptr_t) 2)
-    return tgt->list[i + 1].key->tgt->tgt_start
-	   + tgt->list[i + 1].key->tgt_offset
-	   + tgt->list[i + 1].offset
-	   + (uintptr_t) hostaddrs[i]
-	   - (uintptr_t) hostaddrs[i + 1];
-  return tgt->tgt_start + tgt->list[i].offset;
+
+  switch (tgt->list[i].offset)
+    {
+    case OFFSET_INLINED:
+      return (uintptr_t) hostaddrs[i];
+
+    case OFFSET_POINTER:
+      return 0;
+
+    case OFFSET_STRUCT:
+      return tgt->list[i + 1].key->tgt->tgt_start
+	     + tgt->list[i + 1].key->tgt_offset
+	     + tgt->list[i + 1].offset
+	     + (uintptr_t) hostaddrs[i]
+	     - (uintptr_t) hostaddrs[i + 1];
+
+    default:
+      return tgt->tgt_start + tgt->list[i].offset;
+    }
 }
 
-attribute_hidden struct target_mem_desc *
-gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
-	       void **hostaddrs, void **devaddrs, size_t *sizes, void *kinds,
-	       bool short_mapkind, enum gomp_map_vars_kind pragma_kind)
+static inline __attribute__((always_inline)) struct target_mem_desc *
+gomp_map_vars_internal (struct gomp_device_descr *devicep,
+			struct goacc_asyncqueue *aq, size_t mapnum,
+			void **hostaddrs, void **devaddrs, size_t *sizes,
+			void *kinds, bool short_mapkind,
+			enum gomp_map_vars_kind pragma_kind)
 {
   size_t i, tgt_align, tgt_size, not_found_cnt = 0;
   bool has_firstprivate = false;
@@ -546,25 +585,41 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 	  || (kind & typemask) == GOMP_MAP_FIRSTPRIVATE_INT)
 	{
 	  tgt->list[i].key = NULL;
-	  tgt->list[i].offset = ~(uintptr_t) 0;
+	  tgt->list[i].offset = OFFSET_INLINED;
 	  continue;
 	}
       else if ((kind & typemask) == GOMP_MAP_USE_DEVICE_PTR)
 	{
-	  cur_node.host_start = (uintptr_t) hostaddrs[i];
-	  cur_node.host_end = cur_node.host_start;
-	  splay_tree_key n = gomp_map_lookup (mem_map, &cur_node);
-	  if (n == NULL)
+	  tgt->list[i].key = NULL;
+	  if (!not_found_cnt)
 	    {
-	      gomp_mutex_unlock (&devicep->lock);
-	      gomp_fatal ("use_device_ptr pointer wasn't mapped");
+	      /* In OpenMP < 5.0 and OpenACC the mapping has to be done
+		 on a separate construct prior to using use_device_{addr,ptr}.
+		 In OpenMP 5.0, map directives need to be ordered by the
+		 middle-end before the use_device_* clauses.  If
+		 !not_found_cnt, all mappings requested (if any) are already
+		 mapped, so use_device_{addr,ptr} can be resolved right away.
+		 Otherwise, if not_found_cnt, gomp_map_lookup might fail
+		 now but would succeed after performing the mappings in the
+		 following loop.  We can't defer this always to the second
+		 loop, because it is not even invoked when !not_found_cnt
+		 after the first loop.  */
+	      cur_node.host_start = (uintptr_t) hostaddrs[i];
+	      cur_node.host_end = cur_node.host_start;
+	      splay_tree_key n = gomp_map_lookup (mem_map, &cur_node);
+	      if (n == NULL)
+		{
+		  gomp_mutex_unlock (&devicep->lock);
+		  gomp_fatal ("use_device_ptr pointer wasn't mapped");
+		}
+	      cur_node.host_start -= n->host_start;
+	      hostaddrs[i]
+		= (void *) (n->tgt->tgt_start + n->tgt_offset
+			    + cur_node.host_start);
+	      tgt->list[i].offset = ~(uintptr_t) 0;
 	    }
-	  cur_node.host_start -= n->host_start;
-	  hostaddrs[i]
-	    = (void *) (n->tgt->tgt_start + n->tgt_offset
-			+ cur_node.host_start);
-	  tgt->list[i].key = NULL;
-	  tgt->list[i].offset = ~(uintptr_t) 0;
+	  else
+	    tgt->list[i].offset = 0;
 	  continue;
 	}
       else if ((kind & typemask) == GOMP_MAP_STRUCT)
@@ -575,7 +630,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 	  cur_node.host_end = (uintptr_t) hostaddrs[last]
 			      + sizes[last];
 	  tgt->list[i].key = NULL;
-	  tgt->list[i].offset = ~(uintptr_t) 2;
+	  tgt->list[i].offset = OFFSET_STRUCT;
 	  splay_tree_key n = splay_tree_lookup (mem_map, &cur_node);
 	  if (n == NULL)
 	    {
@@ -600,7 +655,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 	      continue;
 	    }
 	  for (i = first; i <= last; i++)
-	    gomp_map_fields_existing (tgt, n, first, i, hostaddrs,
+	    gomp_map_fields_existing (tgt, aq, n, first, i, hostaddrs,
 				      sizes, kinds, NULL);
 	  i--;
 	  continue;
@@ -608,7 +663,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
       else if ((kind & typemask) == GOMP_MAP_ALWAYS_POINTER)
 	{
 	  tgt->list[i].key = NULL;
-	  tgt->list[i].offset = ~(uintptr_t) 1;
+	  tgt->list[i].offset = OFFSET_POINTER;
 	  has_firstprivate = true;
 	  continue;
 	}
@@ -638,14 +693,14 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 	  if (!n)
 	    {
 	      tgt->list[i].key = NULL;
-	      tgt->list[i].offset = ~(uintptr_t) 1;
+	      tgt->list[i].offset = OFFSET_POINTER;
 	      continue;
 	    }
 	}
       else
 	n = splay_tree_lookup (mem_map, &cur_node);
       if (n && n->refcount != REFCOUNT_LINK)
-	gomp_map_vars_existing (devicep, n, &cur_node, &tgt->list[i],
+	gomp_map_vars_existing (devicep, aq, n, &cur_node, &tgt->list[i],
 				kind & typemask, NULL);
       else
 	{
@@ -756,15 +811,32 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 		tgt_size = (tgt_size + align - 1) & ~(align - 1);
 		tgt->list[i].offset = tgt_size;
 		len = sizes[i];
-		gomp_copy_host2dev (devicep,
+		gomp_copy_host2dev (devicep, aq,
 				    (void *) (tgt->tgt_start + tgt_size),
 				    (void *) hostaddrs[i], len, cbufp);
 		tgt_size += len;
 		continue;
 	      case GOMP_MAP_FIRSTPRIVATE_INT:
-	      case GOMP_MAP_USE_DEVICE_PTR:
 	      case GOMP_MAP_ZERO_LEN_ARRAY_SECTION:
 		continue;
+	      case GOMP_MAP_USE_DEVICE_PTR:
+		if (tgt->list[i].offset == 0)
+		  {
+		    cur_node.host_start = (uintptr_t) hostaddrs[i];
+		    cur_node.host_end = cur_node.host_start;
+		    n = gomp_map_lookup (mem_map, &cur_node);
+		    if (n == NULL)
+		      {
+			gomp_mutex_unlock (&devicep->lock);
+			gomp_fatal ("use_device_ptr pointer wasn't mapped");
+		      }
+		    cur_node.host_start -= n->host_start;
+		    hostaddrs[i]
+		      = (void *) (n->tgt->tgt_start + n->tgt_offset
+				  + cur_node.host_start);
+		    tgt->list[i].offset = ~(uintptr_t) 0;
+		  }
+		continue;
 	      case GOMP_MAP_STRUCT:
 		first = i + 1;
 		last = i + sizes[i];
@@ -790,7 +862,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 		    continue;
 		  }
 		for (i = first; i <= last; i++)
-		  gomp_map_fields_existing (tgt, n, first, i, hostaddrs,
+		  gomp_map_fields_existing (tgt, aq, n, first, i, hostaddrs,
 					    sizes, kinds, cbufp);
 		i--;
 		continue;
@@ -810,7 +882,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 		  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i - 1);
 		if (cur_node.tgt_offset)
 		  cur_node.tgt_offset -= sizes[i];
-		gomp_copy_host2dev (devicep,
+		gomp_copy_host2dev (devicep, aq,
 				    (void *) (n->tgt->tgt_start
 					      + n->tgt_offset
 					      + cur_node.host_start
@@ -831,7 +903,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 	      k->host_end = k->host_start + sizeof (void *);
 	    splay_tree_key n = splay_tree_lookup (mem_map, k);
 	    if (n && n->refcount != REFCOUNT_LINK)
-	      gomp_map_vars_existing (devicep, n, k, &tgt->list[i],
+	      gomp_map_vars_existing (devicep, aq, n, k, &tgt->list[i],
 				      kind & typemask, cbufp);
 	    else
 	      {
@@ -846,12 +918,12 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 		size_t align = (size_t) 1 << (kind >> rshift);
 		tgt->list[i].key = k;
 		k->tgt = tgt;
-		if (field_tgt_clear != ~(size_t) 0)
+		if (field_tgt_clear != FIELD_TGT_EMPTY)
 		  {
 		    k->tgt_offset = k->host_start - field_tgt_base
 				    + field_tgt_offset;
 		    if (i == field_tgt_clear)
-		      field_tgt_clear = ~(size_t) 0;
+		      field_tgt_clear = FIELD_TGT_EMPTY;
 		  }
 		else
 		  {
@@ -884,18 +956,19 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 		  case GOMP_MAP_FORCE_TOFROM:
 		  case GOMP_MAP_ALWAYS_TO:
 		  case GOMP_MAP_ALWAYS_TOFROM:
-		    gomp_copy_host2dev (devicep,
+		    gomp_copy_host2dev (devicep, aq,
 					(void *) (tgt->tgt_start
 						  + k->tgt_offset),
 					(void *) k->host_start,
 					k->host_end - k->host_start, cbufp);
 		    break;
 		  case GOMP_MAP_POINTER:
-		    gomp_map_pointer (tgt, (uintptr_t) *(void **) k->host_start,
+		    gomp_map_pointer (tgt, aq,
+				      (uintptr_t) *(void **) k->host_start,
 				      k->tgt_offset, sizes[i], cbufp);
 		    break;
 		  case GOMP_MAP_TO_PSET:
-		    gomp_copy_host2dev (devicep,
+		    gomp_copy_host2dev (devicep, aq,
 					(void *) (tgt->tgt_start
 						  + k->tgt_offset),
 					(void *) k->host_start,
@@ -917,7 +990,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 			  tgt->list[j].always_copy_from = false;
 			  if (k->refcount != REFCOUNT_INFINITY)
 			    k->refcount++;
-			  gomp_map_pointer (tgt,
+			  gomp_map_pointer (tgt, aq,
 					    (uintptr_t) *(void **) hostaddrs[j],
 					    k->tgt_offset
 					    + ((uintptr_t) hostaddrs[j]
@@ -946,7 +1019,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 		    break;
 		  case GOMP_MAP_FORCE_DEVICEPTR:
 		    assert (k->host_end - k->host_start == sizeof (void *));
-		    gomp_copy_host2dev (devicep,
+		    gomp_copy_host2dev (devicep, aq,
 					(void *) (tgt->tgt_start
 						  + k->tgt_offset),
 					(void *) k->host_start,
@@ -965,7 +1038,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
 		    void *tgt_addr = (void *) (tgt->tgt_start + k->tgt_offset);
 		    /* We intentionally do not use coalescing here, as it's not
 		       data allocated by the current call to this function.  */
-		    gomp_copy_host2dev (devicep, (void *) n->tgt_offset,
+		    gomp_copy_host2dev (devicep, aq, (void *) n->tgt_offset,
 					&tgt_addr, sizeof (void *), NULL);
 		  }
 		array++;
@@ -978,7 +1051,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
       for (i = 0; i < mapnum; i++)
 	{
 	  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i);
-	  gomp_copy_host2dev (devicep,
+	  gomp_copy_host2dev (devicep, aq,
 			      (void *) (tgt->tgt_start + i * sizeof (void *)),
 			      (void *) &cur_node.tgt_offset, sizeof (void *),
 			      cbufp);
@@ -989,7 +1062,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
     {
       long c = 0;
       for (c = 0; c < cbuf.chunk_cnt; ++c)
-	gomp_copy_host2dev (devicep,
+	gomp_copy_host2dev (devicep, aq,
 			    (void *) (tgt->tgt_start + cbuf.chunks[c].start),
 			    (char *) cbuf.buf + (cbuf.chunks[c].start
 						 - cbuf.chunks[0].start),
@@ -1012,7 +1085,27 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
   return tgt;
 }
 
-static void
+attribute_hidden struct target_mem_desc *
+gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,
+	       void **hostaddrs, void **devaddrs, size_t *sizes, void *kinds,
+	       bool short_mapkind, enum gomp_map_vars_kind pragma_kind)
+{
+  return gomp_map_vars_internal (devicep, NULL, mapnum, hostaddrs, devaddrs,
+				 sizes, kinds, short_mapkind, pragma_kind);
+}
+
+attribute_hidden struct target_mem_desc *
+gomp_map_vars_async (struct gomp_device_descr *devicep,
+		     struct goacc_asyncqueue *aq, size_t mapnum,
+		     void **hostaddrs, void **devaddrs, size_t *sizes,
+		     void *kinds, bool short_mapkind,
+		     enum gomp_map_vars_kind pragma_kind)
+{
+  return gomp_map_vars_internal (devicep, aq, mapnum, hostaddrs, devaddrs,
+				 sizes, kinds, short_mapkind, pragma_kind);
+}
+
+attribute_hidden void
 gomp_unmap_tgt (struct target_mem_desc *tgt)
 {
   /* Deallocate on target the tgt->tgt_start .. tgt->tgt_end region.  */
@@ -1023,29 +1116,72 @@ gomp_unmap_tgt (struct target_mem_desc *tgt)
   free (tgt);
 }
 
-attribute_hidden bool
-gomp_remove_var (struct gomp_device_descr *devicep, splay_tree_key k)
+static bool
+gomp_unref_tgt (void *ptr)
 {
   bool is_tgt_unmapped = false;
-  splay_tree_remove (&devicep->mem_map, k);
-  if (k->link_key)
-    splay_tree_insert (&devicep->mem_map, (splay_tree_node) k->link_key);
-  if (k->tgt->refcount > 1)
-    k->tgt->refcount--;
+
+  struct target_mem_desc *tgt = (struct target_mem_desc *) ptr;
+
+  if (tgt->refcount > 1)
+    tgt->refcount--;
   else
     {
+      gomp_unmap_tgt (tgt);
       is_tgt_unmapped = true;
-      gomp_unmap_tgt (k->tgt);
     }
+
   return is_tgt_unmapped;
 }
 
+static void
+gomp_unref_tgt_void (void *ptr)
+{
+  (void) gomp_unref_tgt (ptr);
+}
+
+static inline __attribute__((always_inline)) bool
+gomp_remove_var_internal (struct gomp_device_descr *devicep, splay_tree_key k,
+			  struct goacc_asyncqueue *aq)
+{
+  bool is_tgt_unmapped = false;
+  splay_tree_remove (&devicep->mem_map, k);
+  if (k->link_key)
+    splay_tree_insert (&devicep->mem_map, (splay_tree_node) k->link_key);
+  if (aq)
+    devicep->openacc.async.queue_callback_func (aq, gomp_unref_tgt_void,
+						(void *) k->tgt);
+  else
+    is_tgt_unmapped = gomp_unref_tgt ((void *) k->tgt);
+  return is_tgt_unmapped;
+}
+
+attribute_hidden bool
+gomp_remove_var (struct gomp_device_descr *devicep, splay_tree_key k)
+{
+  return gomp_remove_var_internal (devicep, k, NULL);
+}
+
+/* Remove a variable asynchronously.  This actually removes the variable
+   mapping immediately, but retains the linked target_mem_desc until the
+   asynchronous operation has completed (as it may still refer to target
+   memory).  The device lock must be held before entry, and remains locked on
+   exit.  */
+
+attribute_hidden void
+gomp_remove_var_async (struct gomp_device_descr *devicep, splay_tree_key k,
+		       struct goacc_asyncqueue *aq)
+{
+  (void) gomp_remove_var_internal (devicep, k, aq);
+}
+
 /* Unmap variables described by TGT.  If DO_COPYFROM is true, copy relevant
    variables back from device to host: if it is false, it is assumed that this
    has been done already.  */
 
-attribute_hidden void
-gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)
+static inline __attribute__((always_inline)) void
+gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,
+			  struct goacc_asyncqueue *aq)
 {
   struct gomp_device_descr *devicep = tgt->device_descr;
 
@@ -1082,7 +1218,7 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)
 
       if ((do_unmap && do_copyfrom && tgt->list[i].copy_from)
 	  || tgt->list[i].always_copy_from)
-	gomp_copy_dev2host (devicep,
+	gomp_copy_dev2host (devicep, aq,
 			    (void *) (k->host_start + tgt->list[i].offset),
 			    (void *) (k->tgt->tgt_start + k->tgt_offset
 				      + tgt->list[i].offset),
@@ -1091,14 +1227,28 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)
 	gomp_remove_var (devicep, k);
     }
 
-  if (tgt->refcount > 1)
-    tgt->refcount--;
+  if (aq)
+    devicep->openacc.async.queue_callback_func (aq, gomp_unref_tgt_void,
+						(void *) tgt);
   else
-    gomp_unmap_tgt (tgt);
+    gomp_unref_tgt ((void *) tgt);
 
   gomp_mutex_unlock (&devicep->lock);
 }
 
+attribute_hidden void
+gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)
+{
+  gomp_unmap_vars_internal (tgt, do_copyfrom, NULL);
+}
+
+attribute_hidden void
+gomp_unmap_vars_async (struct target_mem_desc *tgt, bool do_copyfrom,
+		       struct goacc_asyncqueue *aq)
+{
+  gomp_unmap_vars_internal (tgt, do_copyfrom, aq);
+}
+
 static void
 gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,
 	     size_t *sizes, void *kinds, bool short_mapkind)
@@ -1148,9 +1298,10 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,
 	    size_t size = cur_node.host_end - cur_node.host_start;
 
 	    if (GOMP_MAP_COPY_TO_P (kind & typemask))
-	      gomp_copy_host2dev (devicep, devaddr, hostaddr, size, NULL);
+	      gomp_copy_host2dev (devicep, NULL, devaddr, hostaddr, size,
+				  NULL);
 	    if (GOMP_MAP_COPY_FROM_P (kind & typemask))
-	      gomp_copy_dev2host (devicep, hostaddr, devaddr, size);
+	      gomp_copy_dev2host (devicep, NULL, hostaddr, devaddr, size);
 	  }
       }
   gomp_mutex_unlock (&devicep->lock);
@@ -1214,6 +1365,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,
       k->tgt = tgt;
       k->tgt_offset = target_table[i].start;
       k->refcount = REFCOUNT_INFINITY;
+      k->dynamic_refcount = 0;
       k->link_key = NULL;
       array->left = NULL;
       array->right = NULL;
@@ -1246,6 +1398,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,
       k->tgt = tgt;
       k->tgt_offset = target_var->start;
       k->refcount = target_size & link_bit ? REFCOUNT_LINK : REFCOUNT_INFINITY;
+      k->dynamic_refcount = 0;
       k->link_key = NULL;
       array->left = NULL;
       array->right = NULL;
@@ -1443,9 +1596,24 @@ gomp_init_device (struct gomp_device_descr *devicep)
 				   false);
     }
 
+  /* Initialize OpenACC asynchronous queues.  */
+  goacc_init_asyncqueues (devicep);
+
   devicep->state = GOMP_DEVICE_INITIALIZED;
 }
 
+/* This function finalizes the target device, specified by DEVICEP.  DEVICEP
+   must be locked on entry, and remains locked on return.  */
+
+attribute_hidden bool
+gomp_fini_device (struct gomp_device_descr *devicep)
+{
+  bool ret = goacc_fini_asyncqueues (devicep);
+  ret &= devicep->fini_device_func (devicep->target_id);
+  devicep->state = GOMP_DEVICE_FINALIZED;
+  return ret;
+}
+
 attribute_hidden void
 gomp_unload_device (struct gomp_device_descr *devicep)
 {
@@ -1954,22 +2122,13 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,
 
 	  if ((kind == GOMP_MAP_FROM && k->refcount == 0)
 	      || kind == GOMP_MAP_ALWAYS_FROM)
-	    gomp_copy_dev2host (devicep, (void *) cur_node.host_start,
+	    gomp_copy_dev2host (devicep, NULL, (void *) cur_node.host_start,
 				(void *) (k->tgt->tgt_start + k->tgt_offset
 					  + cur_node.host_start
 					  - k->host_start),
 				cur_node.host_end - cur_node.host_start);
 	  if (k->refcount == 0)
-	    {
-	      splay_tree_remove (&devicep->mem_map, k);
-	      if (k->link_key)
-		splay_tree_insert (&devicep->mem_map,
-				   (splay_tree_node) k->link_key);
-	      if (k->tgt->refcount > 1)
-		k->tgt->refcount--;
-	      else
-		gomp_unmap_tgt (k->tgt);
-	    }
+	    gomp_remove_var (devicep, k);
 
 	  break;
 	default:
@@ -2501,6 +2660,7 @@ omp_target_associate_ptr (const void *host_ptr, const void *device_ptr,
       k->tgt = tgt;
       k->tgt_offset = (uintptr_t) device_ptr + device_offset;
       k->refcount = REFCOUNT_INFINITY;
+      k->dynamic_refcount = 0;
       array->left = NULL;
       array->right = NULL;
       splay_tree_insert (&devicep->mem_map, array);
@@ -2636,20 +2796,20 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,
   if (device->capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)
     {
       if (!DLSYM_OPT (openacc.exec, openacc_exec)
-	  || !DLSYM_OPT (openacc.register_async_cleanup,
-			 openacc_register_async_cleanup)
-	  || !DLSYM_OPT (openacc.async_test, openacc_async_test)
-	  || !DLSYM_OPT (openacc.async_test_all, openacc_async_test_all)
-	  || !DLSYM_OPT (openacc.async_wait, openacc_async_wait)
-	  || !DLSYM_OPT (openacc.async_wait_async, openacc_async_wait_async)
-	  || !DLSYM_OPT (openacc.async_wait_all, openacc_async_wait_all)
-	  || !DLSYM_OPT (openacc.async_wait_all_async,
-			 openacc_async_wait_all_async)
-	  || !DLSYM_OPT (openacc.async_set_async, openacc_async_set_async)
 	  || !DLSYM_OPT (openacc.create_thread_data,
 			 openacc_create_thread_data)
 	  || !DLSYM_OPT (openacc.destroy_thread_data,
-			 openacc_destroy_thread_data))
+			 openacc_destroy_thread_data)
+	  || !DLSYM_OPT (openacc.async.construct, openacc_async_construct)
+	  || !DLSYM_OPT (openacc.async.destruct, openacc_async_destruct)
+	  || !DLSYM_OPT (openacc.async.test, openacc_async_test)
+	  || !DLSYM_OPT (openacc.async.synchronize, openacc_async_synchronize)
+	  || !DLSYM_OPT (openacc.async.serialize, openacc_async_serialize)
+	  || !DLSYM_OPT (openacc.async.queue_callback,
+			 openacc_async_queue_callback)
+	  || !DLSYM_OPT (openacc.async.exec, openacc_async_exec)
+	  || !DLSYM_OPT (openacc.async.dev2host, openacc_async_dev2host)
+	  || !DLSYM_OPT (openacc.async.host2dev, openacc_async_host2dev))
 	{
 	  /* Require all the OpenACC handlers if we have
 	     GOMP_OFFLOAD_CAP_OPENACC_200.  */
@@ -2700,10 +2860,7 @@ gomp_target_fini (void)
       struct gomp_device_descr *devicep = &devices[i];
       gomp_mutex_lock (&devicep->lock);
       if (devicep->state == GOMP_DEVICE_INITIALIZED)
-	{
-	  ret = devicep->fini_device_func (devicep->target_id);
-	  devicep->state = GOMP_DEVICE_FINALIZED;
-	}
+	ret = gomp_fini_device (devicep);
       gomp_mutex_unlock (&devicep->lock);
       if (!ret)
 	gomp_fatal ("device finalization failed");
@@ -2774,7 +2931,6 @@ gomp_target_init (void)
 		current_device.type = current_device.get_type_func ();
 		current_device.mem_map.root = NULL;
 		current_device.state = GOMP_DEVICE_UNINITIALIZED;
-		current_device.openacc.data_environ = NULL;
 		for (i = 0; i < new_num_devices; i++)
 		  {
 		    current_device.target_id = i;
diff --git a/libgomp/task.c b/libgomp/task.c
index 15177ac8824..1ecb5d918c6 100644
--- a/libgomp/task.c
+++ b/libgomp/task.c
@@ -23,7 +23,7 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
-/* This file handles the maintainence of tasks in response to task
+/* This file handles the maintenance of tasks in response to task
    creation and termination.  */
 
 #include "libgomp.h"
@@ -1157,7 +1157,7 @@ gomp_task_run_post_handle_dependers (struct gomp_task *child_task,
 
       /* CHILD_TASK satisfies a dependency for TASK.  Keep track of
 	 TASK's remaining dependencies.  Once TASK has no other
-	 depenencies, put it into the various queues so it will get
+	 dependencies, put it into the various queues so it will get
 	 scheduled for execution.  */
       if (--task->num_dependees != 0)
 	continue;
@@ -1674,7 +1674,7 @@ gomp_task_maybe_wait_for_dependencies (void **depend)
 	      {
 		tsk->parent_depends_on = true;
 		++num_awaited;
-		/* If depenency TSK itself has no dependencies and is
+		/* If dependency TSK itself has no dependencies and is
 		   ready to run, move it up front so that we run it as
 		   soon as possible.  */
 		if (tsk->num_dependees == 0 && tsk->kind == GOMP_TASK_WAITING)
diff --git a/libgomp/team.c b/libgomp/team.c
index c422da3701d..c1633fafa48 100644
--- a/libgomp/team.c
+++ b/libgomp/team.c
@@ -23,7 +23,7 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
-/* This file handles the maintainence of threads in response to team
+/* This file handles the maintenance of threads in response to team
    creation and termination.  */
 
 #include "libgomp.h"
@@ -171,7 +171,7 @@ gomp_new_team (unsigned nthreads)
     {
       size_t extra = sizeof (team->ordered_release[0])
 		     + sizeof (team->implicit_task[0]);
-      team = gomp_malloc (sizeof (*team) + nthreads * extra);
+      team = team_malloc (sizeof (*team) + nthreads * extra);
 
 #ifndef HAVE_SYNC_BUILTINS
       gomp_mutex_init (&team->work_share_list_free_lock);
@@ -221,7 +221,7 @@ free_team (struct gomp_team *team)
   gomp_barrier_destroy (&team->barrier);
   gomp_mutex_destroy (&team->task_lock);
   priority_queue_free (&team->task_queue);
-  free (team);
+  team_free (team);
 }
 
 static void
@@ -239,6 +239,9 @@ gomp_free_pool_helper (void *thread_pool)
   pthread_exit (NULL);
 #elif defined(__nvptx__)
   asm ("exit;");
+#elif defined(__AMDGCN__)
+  asm ("s_dcache_wb\n\t"
+       "s_endpgm");
 #else
 #error gomp_free_pool_helper must terminate the thread
 #endif
@@ -282,8 +285,8 @@ gomp_free_thread (void *arg __attribute__((unused)))
       if (pool->last_team)
 	free_team (pool->last_team);
 #ifndef __nvptx__
-      free (pool->threads);
-      free (pool);
+      team_free (pool->threads);
+      team_free (pool);
 #endif
       thr->thread_pool = NULL;
     }
@@ -1079,8 +1082,8 @@ gomp_pause_host (void)
       if (pool->last_team)
 	free_team (pool->last_team);
 #ifndef __nvptx__
-      free (pool->threads);
-      free (pool);
+      team_free (pool->threads);
+      team_free (pool);
 #endif
       thr->thread_pool = NULL;
     }
diff --git a/libgomp/testsuite/Makefile.am b/libgomp/testsuite/Makefile.am
index 2100f49e53b..62b1855695c 100644
--- a/libgomp/testsuite/Makefile.am
+++ b/libgomp/testsuite/Makefile.am
@@ -69,11 +69,11 @@ distclean-DEJAGNU:
 distclean-am: distclean-DEJAGNU
 check-am:
 	@if test -n "$(filter -j%, $(MFLAGS))"; then \
-	  num_cpus=1; \
+	  num_cpus=@CPU_COUNT@; \
 	  if type -p getconf 2>/dev/null >/dev/null; then \
 	    num_cpus=`getconf _NPROCESSORS_ONLN 2>/dev/null`; \
 	    case "$$num_cpus" in \
-	      '' | 0* | *[!0-9]*) num_cpus=1;; \
+	      '' | 0* | *[!0-9]*) num_cpus=@CPU_COUNT@;; \
 	    esac; \
 	  fi; \
 	  if test $$num_cpus -gt 8 && test -z "$$OMP_NUM_THREADS"; then \
diff --git a/libgomp/testsuite/Makefile.in b/libgomp/testsuite/Makefile.in
index 80315b15a7d..f0da16d3161 100644
--- a/libgomp/testsuite/Makefile.in
+++ b/libgomp/testsuite/Makefile.in
@@ -91,6 +91,7 @@ target_triplet = @target@
 subdir = testsuite
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/ax_count_cpus.m4 \
 	$(top_srcdir)/../config/depstand.m4 \
 	$(top_srcdir)/../config/enable.m4 \
 	$(top_srcdir)/../config/futex.m4 \
@@ -98,7 +99,6 @@ am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
 	$(top_srcdir)/../config/lthostflags.m4 \
 	$(top_srcdir)/../config/multi.m4 \
 	$(top_srcdir)/../config/override.m4 \
-	$(top_srcdir)/../config/stdint.m4 \
 	$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../ltoptions.m4 \
 	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
 	$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \
@@ -143,6 +143,7 @@ CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CPU_COUNT = @CPU_COUNT@
 CUDA_DRIVER_INCLUDE = @CUDA_DRIVER_INCLUDE@
 CUDA_DRIVER_LIB = @CUDA_DRIVER_LIB@
 CYGPATH_W = @CYGPATH_W@
@@ -205,6 +206,10 @@ PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PERL = @PERL@
+PLUGIN_GCN = @PLUGIN_GCN@
+PLUGIN_GCN_CPPFLAGS = @PLUGIN_GCN_CPPFLAGS@
+PLUGIN_GCN_LDFLAGS = @PLUGIN_GCN_LDFLAGS@
+PLUGIN_GCN_LIBS = @PLUGIN_GCN_LIBS@
 PLUGIN_HSA = @PLUGIN_HSA@
 PLUGIN_HSA_CPPFLAGS = @PLUGIN_HSA_CPPFLAGS@
 PLUGIN_HSA_LDFLAGS = @PLUGIN_HSA_LDFLAGS@
@@ -521,11 +526,11 @@ distclean-DEJAGNU:
 distclean-am: distclean-DEJAGNU
 check-am:
 	@if test -n "$(filter -j%, $(MFLAGS))"; then \
-	  num_cpus=1; \
+	  num_cpus=@CPU_COUNT@; \
 	  if type -p getconf 2>/dev/null >/dev/null; then \
 	    num_cpus=`getconf _NPROCESSORS_ONLN 2>/dev/null`; \
 	    case "$$num_cpus" in \
-	      '' | 0* | *[!0-9]*) num_cpus=1;; \
+	      '' | 0* | *[!0-9]*) num_cpus=@CPU_COUNT@;; \
 	    esac; \
 	  fi; \
 	  if test $$num_cpus -gt 8 && test -z "$$OMP_NUM_THREADS"; then \
diff --git a/libgomp/testsuite/lib/libgomp.exp b/libgomp/testsuite/lib/libgomp.exp
index 14d9b5f1305..f52ed7184e4 100644
--- a/libgomp/testsuite/lib/libgomp.exp
+++ b/libgomp/testsuite/lib/libgomp.exp
@@ -174,6 +174,20 @@ proc libgomp_init { args } {
     # For build-tree testing, also consider the library paths used for builing.
     # For installed testing, we assume all that to be provided in the sysroot.
     if { $blddir != "" } {
+	# The `-fopenacc' and `-fopenmp' options imply `-pthread', and
+	# that implies `-latomic' on some hosts, so wire in libatomic
+	# build directories.
+	if [ishost "riscv*-*-linux*"] {
+	    set shlib_ext [get_shlib_extension]
+	    set atomic_library_path "${blddir}/../libatomic/.libs"
+	    if { [file exists "${atomic_library_path}/libatomic.a"]
+		 || [file exists \
+		     "${atomic_library_path}/libatomic.${shlib_ext}"] } {
+		lappend ALWAYS_CFLAGS \
+		    "additional_flags=-L${atomic_library_path}"
+		append always_ld_library_path ":${atomic_library_path}"
+	    }
+	}
 	global cuda_driver_include
 	global cuda_driver_lib
 	if { $cuda_driver_include != "" } {
@@ -304,6 +318,9 @@ proc libgomp_option_proc { option } {
 # not supported, and 'host' for offload target 'disable'.
 proc offload_target_to_openacc_device_type { offload_target } {
     switch -glob $offload_target {
+	amdgcn* {
+	    return "gcn"
+	}
 	disable {
 	    return "host"
 	}
@@ -322,6 +339,27 @@ proc offload_target_to_openacc_device_type { offload_target } {
     }
 }
 
+# Return 1 if compiling for offload target nvptx.
+proc check_effective_target_offload_target_nvptx { } {
+    # Consider all actual options, including the flags passed to
+    # 'gcc-dg-runtest', or 'gfortran-dg-runtest' (see the 'libgomp.*/*.exp'
+    # files; in particular, '-foffload', 'libgomp.oacc-*/*.exp'), which don't
+    # get passed on to 'check_effective_target_*' functions.  (Not caching the
+    # result due to that.)
+    set options [current_compiler_flags]
+    # Instead of inspecting command-line options, look what the compiler driver
+    # decides.  This is somewhat modelled after
+    # 'gcc/testsuite/lib/target-supports.exp:check_configured_with'.
+    set gcc_output [libgomp_target_compile "-v $options" "" "none" ""]
+    if [regexp "(?n)^OFFLOAD_TARGET_NAMES=(.*)" $gcc_output dummy offload_targets] {
+	verbose "compiling for offload targets: $offload_targets"
+	return [string match "*:nvptx*:*" ":$offload_targets:"]
+    }
+
+    verbose "not compiling for any offload targets"
+    return 0
+}
+
 # Return 1 if offload device is available.
 proc check_effective_target_offload_device { } {
     return [check_runtime_nocache offload_device_available_ {
@@ -444,3 +482,29 @@ proc check_effective_target_hsa_offloading_selected {} {
 	check_effective_target_hsa_offloading_selected_nocache
     }]
 }
+
+# Return 1 if at least one AMD GCN board is present.
+
+proc check_effective_target_openacc_amdgcn_accel_present { } {
+    return [check_runtime openacc_amdgcn_accel_present {
+	#include <openacc.h>
+	int main () {
+	return !(acc_get_num_devices (acc_device_gcn) > 0);
+	}
+    } "" ]
+}
+
+# Return 1 if at least one AMD GCN board is present, and the AMD GCN device
+# type is selected by default.
+
+proc check_effective_target_openacc_amdgcn_accel_selected { } {
+    if { ![check_effective_target_openacc_amdgcn_accel_present] } {
+	return 0;
+    }
+    global offload_target
+    if { [string match "amdgcn*" $offload_target] } {
+        return 1;
+    }
+    return 0;
+}
+
diff --git a/libgomp/testsuite/libgomp.c++/lastprivate-conditional-1.C b/libgomp/testsuite/libgomp.c++/lastprivate-conditional-1.C
new file mode 100644
index 00000000000..e0ec5d5209f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/lastprivate-conditional-1.C
@@ -0,0 +1,62 @@
+extern "C" void abort ();
+int w;
+struct S { int s, &t; S () : s (0), t (w) {}; void foo (short &); bool bar (int, int); void baz (short &); };
+
+bool
+S::bar (int i, int q)
+{
+  switch (q)
+    {
+    case 0: return (i % 17) == 7;
+    case 1: return (i % 19) == 2;
+    case 2: return (i % 23) == 5;
+    default: abort ();
+    }
+}
+
+void
+S::foo (short &x)
+{
+  #pragma omp for lastprivate (conditional: x, s, t)
+  for (int i = 0; i < 1025; ++i)
+    {
+      if (bar (i, 0))
+	x = i;
+      if (bar (i, 1))
+	s = i + 3;
+      if (bar (i, 2))
+	t = i + 6;
+    }
+}
+
+void
+S::baz (short &x)
+{
+  #pragma omp parallel for lastprivate (conditional: x, s, t) collapse (3)
+  for (int i = 0; i < 15; ++i)
+    for (int j = -4; j < 9; j++)
+      for (int k = 12; k > 7; --k)
+	{
+	  int l = (k - 8) + (j + 4) * 5 + i * 13 * 5;
+	  if (bar (l, 0))
+	    x = l;
+	  if (bar (l, 1))
+	    s = l + 3;
+	  if (bar (l, 2))
+	    t = l + 6;
+	}
+}
+
+int
+main ()
+{
+  short x;
+  S s;
+  #pragma omp parallel
+  s.foo (x);
+  if (x != 1010 || s.s != 1012 || s.t != 1023)
+    abort ();
+  s.baz (x);
+  if (x != 959 || s.s != 974 || s.t != 977)
+    abort ();
+}
diff --git a/libgomp/testsuite/libgomp.c++/lastprivate-conditional-2.C b/libgomp/testsuite/libgomp.c++/lastprivate-conditional-2.C
new file mode 100644
index 00000000000..742ef2151db
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/lastprivate-conditional-2.C
@@ -0,0 +1,104 @@
+extern "C" void abort ();
+int w;
+struct S {
+  int s, &t;
+  int *p;
+  S (int *x) : s (0), t (w), p(x) {};
+  void foo (short &);
+  void bar (short &);
+  void baz (short &);
+  void qux (short &);
+};
+
+void
+S::foo (short &x)
+{
+  #pragma omp simd lastprivate (conditional: x, s, t)
+  for (int i = 0; i < 1025; ++i)
+    {
+      if (p[i])
+	x = i;
+      if (p[i + 1025])
+	s = i + 3;
+      if (p[i + 2 * 1025])
+	t = i + 6;
+    }
+}
+
+void
+S::bar (short &x)
+{
+  #pragma omp simd lastprivate (conditional: x, s, t) collapse (3) if (0)
+  for (int i = 0; i < 15; ++i)
+    for (int j = -4; j < 9; j++)
+      for (int k = 12; k > 7; --k)
+	{
+	  int l = (k - 8) + (j + 4) * 5 + i * 13 * 5;
+	  if (p[l])
+	    x = l;
+	  if (p[l + 1025])
+	    s = l + 3;
+	  if (p[l + 1025 * 2])
+	    t = l + 6;
+	}
+}
+
+void
+S::baz (short &x)
+{
+  #pragma omp parallel for simd lastprivate (conditional: x, s, t) if (simd: 0)
+  for (int i = 0; i < 1025; ++i)
+    {
+      if (p[i])
+	x = i;
+      if (p[i + 1025])
+	s = i + 3;
+      if (p[i + 2 * 1025])
+	t = i + 6;
+    }
+}
+
+void
+S::qux (short &x)
+{
+  #pragma omp for simd lastprivate (conditional: x, s, t) collapse (3) schedule (simd: guided, 8)
+  for (int i = 0; i < 15; ++i)
+    for (int j = -4; j < 9; j++)
+      for (int k = 12; k > 7; --k)
+	{
+	  int l = (k - 8) + (j + 4) * 5 + i * 13 * 5;
+	  if (p[l])
+	    x = l;
+	  if (p[l + 1025])
+	    s = l + 3;
+	  if (p[l + 1025 * 2])
+	    t = l + 6;
+	}
+}
+
+int
+main ()
+{
+  short x;
+  int a[3 * 1025];
+  for (int i = 0; i < 1025; ++i)
+    {
+      a[i] = ((i % 17) == 7);
+      a[1025 + i] = ((i % 19) == 2);
+      a[2 * 1025 + i] = ((i % 23) == 5);
+    }
+  S s = a;
+  s.foo (x);
+  if (x != 1010 || s.s != 1012 || s.t != 1023)
+    abort ();
+  s.bar (x);
+  if (x != 959 || s.s != 974 || s.t != 977)
+    abort ();
+  #pragma omp parallel
+  s.baz (x);
+  if (x != 1010 || s.s != 1012 || s.t != 1023)
+    abort ();
+  s.qux (x);
+  if (x != 959 || s.s != 974 || s.t != 977)
+    abort ();
+}
diff --git a/libgomp/testsuite/libgomp.c++/loop-13.C b/libgomp/testsuite/libgomp.c++/loop-13.C
new file mode 100644
index 00000000000..663212c1f74
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/loop-13.C
@@ -0,0 +1,298 @@
+// { dg-do run }
+
+typedef __PTRDIFF_TYPE__ ptrdiff_t;
+extern "C" void abort ();
+
+template <typename T>
+class I
+{
+public:
+  typedef ptrdiff_t difference_type;
+  I ();
+  ~I ();
+  I (T *);
+  I (const I &);
+  T &operator * ();
+  T *operator -> ();
+  T &operator [] (const difference_type &) const;
+  I &operator = (const I &);
+  I &operator ++ ();
+  I operator ++ (int);
+  I &operator -- ();
+  I operator -- (int);
+  I &operator += (const difference_type &);
+  I &operator -= (const difference_type &);
+  I operator + (const difference_type &) const;
+  I operator - (const difference_type &) const;
+  template <typename S> friend bool operator == (I<S> &, I<S> &);
+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator < (I<S> &, I<S> &);
+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator <= (I<S> &, I<S> &);
+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator > (I<S> &, I<S> &);
+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator >= (I<S> &, I<S> &);
+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);
+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);
+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);
+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);
+private:
+  T *p;
+};
+template <typename T> I<T>::I () : p (0) {}
+template <typename T> I<T>::~I () {}
+template <typename T> I<T>::I (T *x) : p (x) {}
+template <typename T> I<T>::I (const I &x) : p (x.p) {}
+template <typename T> T &I<T>::operator * () { return *p; }
+template <typename T> T *I<T>::operator -> () { return p; }
+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }
+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }
+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }
+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }
+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }
+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }
+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }
+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }
+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }
+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }
+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }
+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }
+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }
+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }
+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }
+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }
+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }
+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }
+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }
+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }
+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }
+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }
+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }
+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }
+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }
+
+template <typename T>
+class J
+{
+public:
+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}
+  const I<T> &begin ();
+  const I<T> &end ();
+private:
+  I<T> b, e;
+};
+
+template <typename T> const I<T> &J<T>::begin () { return b; }
+template <typename T> const I<T> &J<T>::end () { return e; }
+
+int results[2000];
+
+template <typename T>
+static inline void
+baz (I<T> &i)
+{
+  results[*i]++;
+}
+
+void
+f1 (const I<int> &x, const I<int> &y)
+{
+#pragma omp parallel loop order(concurrent)
+  for (I<int> i = x; i <= y; i += 6)
+    baz (i);
+}
+
+void
+f2 (const I<int> &x, const I<int> &y)
+{
+  I<int> i;
+#pragma omp loop private(i) bind(parallel)
+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)
+    baz (i);
+}
+
+template <typename T>
+void
+f3 (const I<int> &x, const I<int> &y)
+{
+#pragma omp loop bind(thread) order(concurrent)
+  for (I<int> i = x; i <= y; i = i + 9 - 8)
+    baz (i);
+}
+
+template <typename T>
+void
+f4 (const I<int> &x, const I<int> &y)
+{
+  I<int> i;
+#pragma omp parallel loop lastprivate(i)
+  for (i = x + 2000 - 64; i > y + 10; --i)
+    baz (i);
+}
+
+void
+f5 (const I<int> &x, const I<int> &y)
+{
+#pragma omp loop bind(teams)
+  for (I<int> i = x + 2000 - 64; i > y + 10; i -= 10)
+    baz (i);
+}
+
+template <int N>
+void
+f6 (const I<int> &x, const I<int> &y)
+{
+  I<int> i;
+#pragma omp teams loop order(concurrent)
+  for (i = x + 2000 - 64; i > y + 10; i = i - 12 + 2)
+    {
+      I<int> j = i + N;
+      baz (j);
+    }
+}
+
+template <int N>
+void
+f7 (I<int> i, const I<int> &x, const I<int> &y)
+{
+#pragma omp master
+#pragma omp loop
+  for (i = x - 10; i <= y + 10; i += N)
+    baz (i);
+}
+
+template <int N>
+void
+f8 (J<int> j)
+{
+  I<int> i;
+#pragma omp parallel loop
+  for (i = j.begin (); i <= j.end () + N; i += 2)
+    baz (i);
+}
+
+template <typename T, int N>
+void
+f9 (const I<T> &x, const I<T> &y)
+{
+  I<T> i;
+#pragma omp loop bind(teams) private(i)
+  for (i = x; i <= y; i = i + N)
+    baz (i);
+}
+
+template <typename T, int N>
+void
+f10 (const I<T> &x, const I<T> &y)
+{
+  I<T> i;
+#pragma omp loop bind(thread) private(i)
+  for (i = x; i > y; i = i + N)
+    baz (i);
+}
+
+template <typename T>
+void
+f11 (const T &x, const T &y)
+{
+#pragma omp parallel
+  {
+#pragma omp loop
+    for (T i = x; i <= y; i += 3)
+      baz (i);
+#pragma omp single
+    {
+      T j = y + 3;
+      baz (j);
+    }
+  }
+}
+
+template <typename T>
+void
+f12 (const T &x, const T &y)
+{
+  T i;
+#pragma omp loop lastprivate(i) bind(thread)
+  for (i = x; i > y; --i)
+    baz (i);
+}
+
+template <int N>
+struct K
+{
+  template <typename T>
+  static void
+  f13 (const T &x, const T &y)
+  {
+    T i;
+#pragma omp teams loop order(concurrent) bind(teams) lastprivate (i)
+    for (i = x; i <= y + N; i += N)
+      baz (i);
+  }
+};
+
+#define check(expr) \
+  for (int i = 0; i < 2000; i++)			\
+    if (expr)						\
+      {							\
+	if (results[i] != 1)				\
+	  abort ();					\
+	results[i] = 0;					\
+      }							\
+    else if (results[i])				\
+      abort ()
+
+int
+main ()
+{
+  int a[2000];
+  long b[2000];
+  for (int i = 0; i < 2000; i++)
+    {
+      a[i] = i;
+      b[i] = i;
+    }
+  f1 (&a[10], &a[1990]);
+  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);
+  #pragma omp parallel
+  f2 (&a[0], &a[1999]);
+  check (i < 1998 && (i & 1) == 0);
+  f3<char> (&a[20], &a[1837]);
+  check (i >= 20 && i <= 1837);
+  f4<int> (&a[0], &a[30]);
+  check (i > 40 && i <= 2000 - 64);
+  #pragma omp teams
+  f5 (&a[0], &a[100]);
+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);
+  f6<-10> (&a[10], &a[110]);
+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);
+  #pragma omp parallel num_threads(2)
+  f7<6> (I<int> (), &a[12], &a[1800]);
+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);
+  f8<121> (J<int> (&a[14], &a[1803]));
+  check (i >= 14 && i <= 1924 && (i & 1) == 0);
+  #pragma omp teams
+  f9<int, 7> (&a[33], &a[1967]);
+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);
+  f10<int, -7> (&a[1939], &a[17]);
+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);
+  f11<I<int> > (&a[16], &a[1981]);
+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);
+  f12<I<int> > (&a[1761], &a[37]);
+  check (i > 37 && i <= 1761);
+  K<5>::f13<I<int> > (&a[1], &a[1935]);
+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);
+  #pragma omp teams
+  f9<long, 7> (&b[33], &b[1967]);
+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);
+  f10<long, -7> (&b[1939], &b[17]);
+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);
+  f11<I<long> > (&b[16], &b[1981]);
+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);
+  f12<I<long> > (&b[1761], &b[37]);
+  check (i > 37 && i <= 1761);
+  K<5>::f13<I<long> > (&b[1], &b[1935]);
+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);
+}
diff --git a/libgomp/testsuite/libgomp.c++/loop-14.C b/libgomp/testsuite/libgomp.c++/loop-14.C
new file mode 100644
index 00000000000..191ab681b3c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/loop-14.C
@@ -0,0 +1,301 @@
+// { dg-do run }
+
+typedef __PTRDIFF_TYPE__ ptrdiff_t;
+extern "C" void abort ();
+
+template <typename T>
+class I
+{
+public:
+  typedef ptrdiff_t difference_type;
+  I ();
+  ~I ();
+  I (T *);
+  I (const I &);
+  T &operator * ();
+  T *operator -> ();
+  T &operator [] (const difference_type &) const;
+  I &operator = (const I &);
+  I &operator ++ ();
+  I operator ++ (int);
+  I &operator -- ();
+  I operator -- (int);
+  I &operator += (const difference_type &);
+  I &operator -= (const difference_type &);
+  I operator + (const difference_type &) const;
+  I operator - (const difference_type &) const;
+  template <typename S> friend bool operator == (I<S> &, I<S> &);
+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator < (I<S> &, I<S> &);
+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator <= (I<S> &, I<S> &);
+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator > (I<S> &, I<S> &);
+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator >= (I<S> &, I<S> &);
+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);
+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);
+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);
+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);
+private:
+  T *p;
+};
+template <typename T> I<T>::I () : p (0) {}
+template <typename T> I<T>::~I () { p = (T *) 0; }
+template <typename T> I<T>::I (T *x) : p (x) {}
+template <typename T> I<T>::I (const I &x) : p (x.p) {}
+template <typename T> T &I<T>::operator * () { return *p; }
+template <typename T> T *I<T>::operator -> () { return p; }
+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }
+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }
+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }
+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }
+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }
+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }
+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }
+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }
+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }
+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }
+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }
+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }
+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }
+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }
+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }
+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }
+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }
+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }
+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }
+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }
+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }
+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }
+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }
+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }
+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }
+
+template <typename T>
+class J
+{
+public:
+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}
+  const I<T> &begin ();
+  const I<T> &end ();
+private:
+  I<T> b, e;
+};
+
+template <typename T> const I<T> &J<T>::begin () { return b; }
+template <typename T> const I<T> &J<T>::end () { return e; }
+
+int results[2000];
+
+template <typename T>
+static inline void
+baz (I<T> &i)
+{
+  results[*i]++;
+}
+
+I<int>
+f1 (const I<int> &x, const I<int> &y)
+{
+  I<int> i;
+#pragma omp parallel shared (i)
+  {
+  #pragma omp loop lastprivate (i) order(concurrent)
+    for (i = x; i < y - 1; ++i)
+      baz (i);
+  #pragma omp single
+    i += 3;
+  }
+  return I<int> (i);
+}
+
+I<int>
+f2 (const I<int> &x, const I<int> &y)
+{
+  I<int> i;
+#pragma omp parallel loop bind(parallel)
+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)
+    baz (i);
+  return I<int> (i);
+}
+
+template <typename T>
+I<int>
+f3 (const I<int> &x, const I<int> &y)
+{
+  I<int> i;
+#pragma omp teams
+  #pragma omp loop order(concurrent)
+    for (i = x + 1000 - 64; i <= y - 10; i++)
+      baz (i);
+  return i;
+}
+
+template <typename T>
+I<int>
+f4 (const I<int> &x, const I<int> &y)
+{
+  I<int> i;
+#pragma omp teams loop lastprivate (i)
+  for (i = x + 2000 - 64; i > y + 10; --i)
+    baz (i);
+  return I<int> (i);
+}
+
+template <typename T>
+I<int>
+f5 (const I<int> &x, const I<int> &y)
+{
+  I<int> i;
+#pragma omp loop lastprivate (i) bind(thread)
+  for (i = x; i > y + T (6); i--)
+    baz (i);
+  return i;
+}
+
+template <typename T>
+I<int>
+f6 (const I<int> &x, const I<int> &y)
+{
+  I<int> i;
+#pragma omp loop bind(thread)
+  for (i = x - T (7); i > y; i -= T (2))
+    baz (i);
+  return I<int> (i);
+}
+
+template <int N>
+I<int>
+f7 (I<int> i, const I<int> &x, const I<int> &y)
+{
+#pragma omp parallel for lastprivate (i)
+  for (i = x - 10; i <= y + 10; i += N)
+    baz (i);
+  return I<int> (i);
+}
+
+template <int N>
+I<int>
+f8 (J<int> j)
+{
+  I<int> i;
+#pragma omp parallel shared (i)
+  #pragma omp loop lastprivate (i)
+    for (i = j.begin (); i <= j.end () + N; i += 2)
+      baz (i);
+  return i;
+}
+
+I<int> i9;
+
+template <long N>
+I<int> &
+f9 (J<int> j)
+{
+#pragma omp loop bind(parallel)
+  for (i9 = j.begin () + N; i9 <= j.end () - N; i9 = i9 - N)
+    baz (i9);
+  return i9;
+}
+
+template <typename T, int N>
+I<T>
+f10 (const I<T> &x, const I<T> &y)
+{
+  I<T> i;
+#pragma omp parallel loop lastprivate (i)
+  for (i = x; i > y; i = i + N)
+    baz (i);
+  return i;
+}
+
+template <typename T, typename U>
+T
+f11 (T i, const T &x, const T &y)
+{
+  #pragma omp loop bind(thread)
+  for (i = x + U (2); i <= y + U (1); i = U (2) + U (3) + i)
+    baz (i);
+  return T (i);
+}
+
+template <typename T>
+T
+f12 (const T &x, const T &y)
+{
+  T i;
+#pragma omp teams loop
+  for (i = x; i > y; --i)
+    baz (i);
+  return i;
+}
+
+#define check(expr) \
+  for (int i = 0; i < 2000; i++)			\
+    if (expr)						\
+      {							\
+	if (results[i] != 1)				\
+	  abort ();					\
+	results[i] = 0;					\
+      }							\
+    else if (results[i])				\
+      abort ()
+
+int
+main ()
+{
+  int a[2000];
+  long b[2000];
+  for (int i = 0; i < 2000; i++)
+    {
+      a[i] = i;
+      b[i] = i;
+    }
+  if (*f1 (&a[10], &a[1873]) != 1875)
+    abort ();
+  check (i >= 10 && i < 1872);
+  if (*f2 (&a[0], &a[1998]) != 1998)
+    abort ();
+  check (i < 1997 && (i & 1) == 0);
+  if (*f3<int> (&a[10], &a[1971]) != 1962)
+    abort ();
+  check (i >= 946 && i <= 1961);
+  if (*f4<int> (&a[0], &a[30]) != 40)
+    abort ();
+  check (i > 40 && i <= 2000 - 64);
+  if (*f5<short> (&a[1931], &a[17]) != 23)
+    abort ();
+  check (i > 23 && i <= 1931);
+  if (*f6<long> (&a[1931], &a[17]) != 16)
+    abort ();
+  check (i > 17 && i <= 1924 && (i & 1) == 0);
+  if (*f7<6> (I<int> (), &a[12], &a[1800]) != 1814)
+    abort ();
+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);
+  if (*f8<121> (J<int> (&a[14], &a[1803])) != 1926)
+    abort ();
+  check (i >= 14 && i <= 1924 && (i & 1) == 0);
+  #pragma omp parallel
+  if (*f9<-3L> (J<int> (&a[27], &a[1761])) != 1767)
+    abort ();
+  check (i >= 24 && i <= 1764 && (i % 3) == 0);
+  if (*f10<int, -7> (&a[1939], &a[17]) != 14)
+    abort ();
+  check (i >= 21 && i <= 1939 && i % 7 == 0);
+  if (*f11<I<int>, short> (I<int> (), &a[71], &a[1941]) != 1943)
+    abort ();
+  check (i >= 73 && i <= 1938 && (i - 73) % 5 == 0);
+  if (*f12<I<int> > (&a[1761], &a[37]) != 37)
+    abort ();
+  check (i > 37 && i <= 1761);
+  if (*f10<long, -7> (&b[1939], &b[17]) != 14)
+    abort ();
+  check (i >= 21 && i <= 1939 && i % 7 == 0);
+  if (*f11<I<long>, short> (I<long> (), &b[71], &b[1941]) != 1943)
+    abort ();
+  check (i >= 73 && i <= 1938 && (i - 73) % 5 == 0);
+  if (*f12<I<long> > (&b[1761], &b[37]) != 37)
+    abort ();
+  check (i > 37 && i <= 1761);
+}
diff --git a/libgomp/testsuite/libgomp.c++/loop-15.C b/libgomp/testsuite/libgomp.c++/loop-15.C
new file mode 100644
index 00000000000..b523b9bd2f9
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/loop-15.C
@@ -0,0 +1,417 @@
+// { dg-do run }
+// { dg-additional-options "-std=c++17" }
+
+typedef __PTRDIFF_TYPE__ ptrdiff_t;
+extern "C" void abort ();
+
+namespace std {
+  template<typename T> struct tuple_size;
+  template<int, typename> struct tuple_element;
+}
+
+template <typename T>
+class I
+{
+public:
+  typedef ptrdiff_t difference_type;
+  I ();
+  ~I ();
+  I (T *);
+  I (const I &);
+  T &operator * ();
+  T *operator -> ();
+  T &operator [] (const difference_type &) const;
+  I &operator = (const I &);
+  I &operator ++ ();
+  I operator ++ (int);
+  I &operator -- ();
+  I operator -- (int);
+  I &operator += (const difference_type &);
+  I &operator -= (const difference_type &);
+  I operator + (const difference_type &) const;
+  I operator - (const difference_type &) const;
+  template <typename S> friend bool operator == (I<S> &, I<S> &);
+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator < (I<S> &, I<S> &);
+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator <= (I<S> &, I<S> &);
+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator > (I<S> &, I<S> &);
+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);
+  template <typename S> friend bool operator >= (I<S> &, I<S> &);
+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);
+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);
+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);
+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);
+private:
+  T *p;
+};
+template <typename T> I<T>::I () : p (0) {}
+template <typename T> I<T>::~I () {}
+template <typename T> I<T>::I (T *x) : p (x) {}
+template <typename T> I<T>::I (const I &x) : p (x.p) {}
+template <typename T> T &I<T>::operator * () { return *p; }
+template <typename T> T *I<T>::operator -> () { return p; }
+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }
+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }
+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }
+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }
+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }
+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }
+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }
+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }
+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }
+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }
+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }
+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }
+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }
+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }
+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }
+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }
+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }
+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }
+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }
+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }
+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }
+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }
+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }
+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }
+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }
+
+template <typename T>
+class J
+{
+public:
+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}
+  const I<T> &begin ();
+  const I<T> &end ();
+private:
+  I<T> b, e;
+};
+
+template <typename T> const I<T> &J<T>::begin () { return b; }
+template <typename T> const I<T> &J<T>::end () { return e; }
+
+template <typename T>
+class K
+{
+public:
+  K ();
+  ~K ();
+  template <int N> T &get () { if (N == 0) return c; else if (N == 1) return b; return a; }
+  T a, b, c;
+};
+
+template <typename T> K<T>::K () : a {}, b {}, c {} {}
+template <typename T> K<T>::~K () {}
+template <typename T> struct std::tuple_size<K<T>> { static constexpr int value = 3; };
+template <typename T, int N> struct std::tuple_element<N, K<T>> { using type = T; };
+
+template <typename T>
+class L
+{
+public:
+  L ();
+  ~L ();
+  T a, b, c;
+};
+
+template <typename T> L<T>::L () : a {}, b {}, c {} {}
+template <typename T> L<T>::~L () {}
+
+int a[2000];
+long b[40];
+short c[50];
+int d[1024];
+K<int> e[1089];
+L<int> f[1093];
+int results[2000];
+
+template <typename T>
+static inline void
+baz (I<T> &i)
+{
+  results[*i]++;
+}
+
+static inline void
+baz (int i)
+{
+  results[i]++;
+}
+
+void
+f1 ()
+{
+#pragma omp parallel loop shared(a) default(none)
+  for (auto i : a)
+    baz (i);
+}
+
+void
+f2 ()
+{
+#pragma omp loop order(concurrent) bind(parallel)
+  for (auto &i : a)
+    if (&i != &a[i])
+      abort ();
+    else
+      baz (i);
+}
+
+void
+f3 ()
+{
+#pragma omp teams loop collapse(3) default(none) shared(b, c)
+  for (auto &i : b)
+    for (int j = 9; j < 10; j++)
+      for (auto k : c)
+	if (&i != &b[i] || i < 0 || i >= 40 || j != 9 || k < 0 || k >= 50)
+	  abort ();
+	else
+	  baz (i * 50 + k);
+}
+
+void
+f4 (J<int> j)
+{
+#pragma omp loop bind(teams)
+  for (auto &i : j)
+    if (&i != &a[i])
+      abort ();
+    else
+      baz (i);
+}
+
+void
+f5 ()
+{
+#pragma omp loop bind(thread)
+  for (auto i : d)
+    results[i % 1024] += 2 * ((unsigned) i >> 10) + 1;
+}
+
+void
+f6 (J<K<int>> j)
+{
+#pragma omp loop bind(parallel)
+  for (auto & [k, l, m] : j)
+    if (&k != &e[m].c || &l != &e[m].b || &m != &e[m].a || k != m * 3 || l != m * 2)
+      abort ();
+    else
+      baz (m);
+}
+
+void
+f7 (J<L<int>> j)
+{
+#pragma omp parallel loop default(none) shared(j, f)
+  for (auto & [k, l, m] : j)
+    if (&k != &f[k].a || &l != &f[k].b || &m != &f[k].c || l != k * 4 || m != k * 5)
+      abort ();
+    else
+      baz (k);
+}
+
+void
+f8 (J<K<int>> j)
+{
+#pragma omp parallel loop default(none) shared(j)
+  for (auto [k, l, m] : j)
+    if (k != m * 3 || l != m * 2)
+      abort ();
+    else
+      baz (m);
+}
+
+void
+f9 (J<L<int>> j)
+{
+#pragma omp teams loop default(none) shared(j)
+  for (auto [k, l, m] : j)
+    if (l != k * 4 || m != k * 5)
+      abort ();
+    else
+      baz (k);
+}
+
+template <int N>
+void
+f10 ()
+{
+#pragma omp loop bind(teams)
+  for (auto i : a)
+    baz (i);
+}
+
+template <int N>
+void
+f11 ()
+{
+#pragma omp loop bind(thread)
+  for (auto &i : a)
+    if (&i != &a[i])
+      abort ();
+    else
+      baz (i);
+}
+
+template <int N>
+void
+f12 ()
+{
+#pragma omp parallel loop collapse(3) default(none) shared(a, b, c) bind(parallel)
+  for (auto &i : b)
+    for (I<int> j = I<int> (&a[9]); j < I<int> (&a[10]); j++)
+      for (auto k : c)
+	if (&i != &b[i] || i < 0 || i >= 40 || *j != 9 || k < 0 || k >= 50)
+	  abort ();
+	else
+	  baz (i * 50 + k);
+}
+
+template <typename T>
+void
+f13 (J<T> j)
+{
+#pragma omp loop bind(thread)
+  for (auto &i : j)
+    if (&i != &a[i])
+      abort ();
+    else
+      baz (i);
+}
+
+template <int N>
+void
+f14 ()
+{
+#pragma omp parallel loop default(none) shared(d, results)
+  for (auto i : d)
+    results[i % N] += 2 * ((unsigned) i >> 10) + 1;
+}
+
+template <typename T>
+void
+f15 (J<K<T>> j)
+{
+#pragma omp parallel loop default(none) shared(j, e) bind(parallel)
+  for (auto & [k, l, m] : j)
+    if (&k != &e[m].c || &l != &e[m].b || &m != &e[m].a || k != m * 3 || l != m * 2)
+      abort ();
+    else
+      baz (m);
+}
+
+template <typename T>
+void
+f16 (J<L<T>> j)
+{
+#pragma omp loop bind(parallel)
+  for (auto & [k, l, m] : j)
+    if (&k != &f[k].a || &l != &f[k].b || &m != &f[k].c || l != k * 4 || m != k * 5)
+      abort ();
+    else
+      baz (k);
+}
+
+template <int N>
+void
+f17 (J<K<int>> j)
+{
+#pragma omp parallel loop default(none) shared(j)
+  for (auto [k, l, m] : j)
+    if (k != m * 3 || l != m * 2)
+      abort ();
+    else
+      baz (m);
+}
+
+template <int N>
+void
+f18 (J<L<int>> j)
+{
+#pragma omp teams loop default(none) shared(j)
+  for (auto [k, l, m] : j)
+    if (l != k * 4 || m != k * 5)
+      abort ();
+    else
+      baz (k);
+}
+
+#define check(expr) \
+  for (int i = 0; i < 2000; i++)			\
+    if (expr)						\
+      {							\
+	if (results[i] != 1)				\
+	  abort ();					\
+	results[i] = 0;					\
+      }							\
+    else if (results[i])				\
+      abort ()
+
+int
+main ()
+{
+  for (int i = 0; i < 2000; i++)
+    a[i] = i;
+  for (int i = 0; i < 40; i++)
+    b[i] = i;
+  for (int i = 0; i < 50; i++)
+    c[i] = i;
+  for (int i = 0; i < 1024; i++)
+    d[i] = i;
+  for (int i = 0; i < 1089; i++)
+    {
+      e[i].a = i;
+      e[i].b = 2 * i;
+      e[i].c = 3 * i;
+    }
+  for (int i = 0; i < 1093; i++)
+    {
+      f[i].a = i;
+      f[i].b = 4 * i;
+      f[i].c = 5 * i;
+    }
+  f1 ();
+  check (1);
+  #pragma omp parallel
+  f2 ();
+  check (1);
+  f3 ();
+  check (1);
+  #pragma omp teams
+  f4 (J<int> (&a[14], &a[1803]));
+  check (i >= 14 && i < 1803);
+  f5 ();
+  check (i >= 0 && i < 1024);
+  #pragma omp parallel
+  f6 (J<K<int>> (&e[19], &e[1029]));
+  check (i >= 19 && i < 1029);
+  f7 (J<L<int>> (&f[15], &f[1091]));
+  check (i >= 15 && i < 1091);
+  f8 (J<K<int>> (&e[27], &e[1037]));
+  check (i >= 27 && i < 1037);
+  f9 (J<L<int>> (&f[1], &f[1012]));
+  check (i >= 1 && i < 1012);
+  #pragma omp teams
+  f10 <0> ();
+  check (1);
+  f11 <1> ();
+  check (1);
+  f12 <2> ();
+  check (1);
+  f13 (J<int> (&a[24], &a[1703]));
+  check (i >= 24 && i < 1703);
+  f14 <1024> ();
+  check (i >= 0 && i < 1024);
+  f15 (J<K<int>> (&e[39], &e[929]));
+  check (i >= 39 && i < 929);
+  #pragma omp parallel
+  f16 (J<L<int>> (&f[17], &f[1071]));
+  check (i >= 17 && i < 1071);
+  f17 <3> (J<K<int>> (&e[7], &e[1017]));
+  check (i >= 7 && i < 1017);
+  f18 <5> (J<L<int>> (&f[121], &f[1010]));
+  check (i >= 121 && i < 1010);
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-1.C b/libgomp/testsuite/libgomp.c++/scan-1.C
new file mode 100644
index 00000000000..d148dac924b
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-1.C
@@ -0,0 +1,151 @@
+// { dg-require-effective-target size32plus }
+
+extern "C" void abort ();
+
+struct S {
+  inline S ();
+  inline ~S ();
+  inline S (const S &);
+  inline S & operator= (const S &);
+  int s;
+};
+
+S::S () : s (0)
+{
+}
+
+S::~S ()
+{
+}
+
+S::S (const S &x)
+{
+  s = x.s;
+}
+
+S &
+S::operator= (const S &x)
+{
+  s = x.s;
+  return *this;
+}
+
+static inline void
+ini (S &x)
+{
+  x.s = 0;
+}
+
+S r, a[1024], b[1024];
+
+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)
+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))
+
+__attribute__((noipa)) void
+foo (S *a, S *b)
+{
+  #pragma omp for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r.s += a[i].s;
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) S
+bar (void)
+{
+  S s;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s.s += 2 * a[i].s;
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return S (s);
+}
+
+__attribute__((noipa)) void
+baz (S *a, S *b)
+{
+  #pragma omp parallel for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r.s += a[i].s;
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) S
+qux (void)
+{
+  S s;
+  #pragma omp parallel for reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s.s += 2 * a[i].s;
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return S (s);
+}
+
+int
+main ()
+{
+  S s;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i].s = i;
+      b[i].s = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += i;
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+    }
+  if (bar ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += 2 * i;
+      if (b[i].s != s.s)
+	abort ();
+    }
+  r.s = 0;
+  baz (a, b);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += i;
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+    }
+  if (qux ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += 2 * i;
+      if (b[i].s != s.s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-10.C b/libgomp/testsuite/libgomp.c++/scan-10.C
new file mode 100644
index 00000000000..04b8796a24e
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-10.C
@@ -0,0 +1,120 @@
+// { dg-require-effective-target size32plus }
+// { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" }
+// { dg-additional-options "-msse2" { target sse2_runtime } }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+// { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } }
+
+extern "C" void abort ();
+int r, a[1024], b[1024], q;
+
+__attribute__((noipa)) void
+foo (int *a, int *b, int &r)
+{
+  #pragma omp for simd if (0) reduction (inscan, +:r) nowait
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel
+  #pragma omp for simd simdlen(1) reduction (inscan, +:s) nowait
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, int &r)
+{
+  #pragma omp parallel for simd reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel for simd reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-11.C b/libgomp/testsuite/libgomp.c++/scan-11.C
new file mode 100644
index 00000000000..9e83effd077
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-11.C
@@ -0,0 +1,123 @@
+// { dg-require-effective-target size32plus }
+// { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" }
+// { dg-additional-options "-msse2" { target sse2_runtime } }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+// { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } }
+
+extern "C" void abort ();
+int r, a[1024], b[1024], q;
+
+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)
+
+__attribute__((noipa)) void
+foo (int *a, int *b, int &r)
+{
+  #pragma omp for simd reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, foo:s) if (0)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, int &r)
+{
+  #pragma omp parallel for simd simdlen (1) reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel for simd reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-12.C b/libgomp/testsuite/libgomp.c++/scan-12.C
new file mode 100644
index 00000000000..ee911578520
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-12.C
@@ -0,0 +1,154 @@
+// { dg-require-effective-target size32plus }
+// { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" }
+// { dg-additional-options "-msse2" { target sse2_runtime } }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+// { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } }
+
+extern "C" void abort ();
+
+struct S {
+  inline S ();
+  inline ~S ();
+  inline S (const S &);
+  inline S & operator= (const S &);
+  int s;
+};
+
+S::S () : s (0)
+{
+}
+
+S::~S ()
+{
+}
+
+S::S (const S &x)
+{
+  s = x.s;
+}
+
+S &
+S::operator= (const S &x)
+{
+  s = x.s;
+  return *this;
+}
+
+static inline void
+ini (S &x)
+{
+  x.s = 0;
+}
+
+S r, a[1024], b[1024];
+
+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)
+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))
+
+__attribute__((noipa)) void
+foo (S *a, S *b, S &r)
+{
+  #pragma omp for simd reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r.s += a[i].s;
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) S
+bar ()
+{
+  S s;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s.s += 2 * a[i].s;
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (S *a, S *b, S &r)
+{
+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r.s += a[i].s;
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) S
+qux ()
+{
+  S s;
+  #pragma omp parallel for simd reduction (inscan, plus:s) simdlen(1)
+  for (int i = 0; i < 1024; i++)
+    {
+      s.s += 2 * a[i].s;
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  S s;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i].s = i;
+      b[i].s = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += i;
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+    }
+  if (bar ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += 2 * i;
+      if (b[i].s != s.s)
+	abort ();
+    }
+  r.s = 0;
+  baz (a, b, r);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += i;
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+    }
+  if (qux ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += 2 * i;
+      if (b[i].s != s.s)
+	abort ();
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-13.C b/libgomp/testsuite/libgomp.c++/scan-13.C
new file mode 100644
index 00000000000..613045768e7
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-13.C
@@ -0,0 +1,162 @@
+// { dg-require-effective-target size32plus }
+// { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" }
+// { dg-additional-options "-msse2" { target sse2_runtime } }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+// { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } }
+
+extern "C" void abort ();
+
+template <typename T>
+struct S {
+  inline S ();
+  inline ~S ();
+  inline S (const S &);
+  inline S & operator= (const S &);
+  T s;
+};
+
+template <typename T>
+S<T>::S () : s (0)
+{
+}
+
+template <typename T>
+S<T>::~S ()
+{
+}
+
+template <typename T>
+S<T>::S (const S &x)
+{
+  s = x.s;
+}
+
+template <typename T>
+S<T> &
+S<T>::operator= (const S &x)
+{
+  s = x.s;
+  return *this;
+}
+
+template <typename T>
+static inline void
+ini (S<T> &x)
+{
+  x.s = 0;
+}
+
+S<int> r, a[1024], b[1024];
+
+#pragma omp declare reduction (+: S<int>: omp_out.s += omp_in.s)
+#pragma omp declare reduction (plus: S<int>: omp_out.s += omp_in.s) initializer (ini (omp_priv))
+
+template <typename T>
+__attribute__((noipa)) void
+foo (S<T> *a, S<T> *b)
+{
+  #pragma omp for simd if (0) reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r.s += a[i].s;
+    }
+}
+
+template <typename T>
+__attribute__((noipa)) S<T>
+bar (void)
+{
+  S<T> s;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s.s += 2 * a[i].s;
+    }
+  return S<T> (s);
+}
+
+__attribute__((noipa)) void
+baz (S<int> *a, S<int> *b)
+{
+  #pragma omp parallel for simd reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r.s += a[i].s;
+    }
+}
+
+__attribute__((noipa)) S<int>
+qux (void)
+{
+  S<int> s;
+  #pragma omp parallel for simd simdlen(1) reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s.s += 2 * a[i].s;
+    }
+  return S<int> (s);
+}
+
+int
+main ()
+{
+  S<int> s;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i].s = i;
+      b[i].s = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+      s.s += i;
+    }
+  if (bar<int> ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      s.s += 2 * i;
+    }
+  r.s = 0;
+  baz (a, b);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+      s.s += i;
+    }
+  if (qux ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      s.s += 2 * i;
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-14.C b/libgomp/testsuite/libgomp.c++/scan-14.C
new file mode 100644
index 00000000000..8ee4354c7fc
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-14.C
@@ -0,0 +1,124 @@
+// { dg-require-effective-target size32plus }
+// { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" }
+// { dg-additional-options "-msse2" { target sse2_runtime } }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+// { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } }
+
+extern "C" void abort ();
+int r, a[1024], b[1024], q;
+
+template <typename T, typename U>
+__attribute__((noipa)) void
+foo (T a, T b, U r)
+{
+  #pragma omp for simd if (0) reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+template <typename T>
+__attribute__((noipa)) T
+bar ()
+{
+  T &s = q;
+  q = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, +:s) simdlen(1)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+template <typename T>
+__attribute__((noipa)) void
+baz (T *a, T *b, T &r)
+{
+  #pragma omp parallel for simd reduction (inscan, +:r)
+  for (T i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+template <typename T>
+__attribute__((noipa)) int
+qux ()
+{
+  T s = q;
+  q = 0;
+  #pragma omp parallel for simd reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo<int *, int &> (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar<int> () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz<int> (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux<int &> () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-15.C b/libgomp/testsuite/libgomp.c++/scan-15.C
new file mode 100644
index 00000000000..69550af9d62
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-15.C
@@ -0,0 +1,122 @@
+// { dg-require-effective-target size32plus }
+// { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" }
+// { dg-additional-options "-msse2" { target sse2_runtime } }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+// { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } }
+
+extern "C" void abort ();
+int r, a[1024], b[1024], q;
+
+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)
+
+__attribute__((noipa)) void
+foo (int *a, int *b, int &r)
+{
+  #pragma omp for simd reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, foo:s) nowait
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, int &r)
+{
+  #pragma omp parallel for simd reduction (inscan, foo:r) if (simd: 0)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel for simd reduction (inscan, foo:s)simdlen(1)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-16.C b/libgomp/testsuite/libgomp.c++/scan-16.C
new file mode 100644
index 00000000000..3fb6135c343
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-16.C
@@ -0,0 +1,154 @@
+// { dg-require-effective-target size32plus }
+// { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" }
+// { dg-additional-options "-msse2" { target sse2_runtime } }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+// { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } }
+
+extern "C" void abort ();
+
+struct S {
+  inline S ();
+  inline ~S ();
+  inline S (const S &);
+  inline S & operator= (const S &);
+  int s;
+};
+
+S::S () : s (0)
+{
+}
+
+S::~S ()
+{
+}
+
+S::S (const S &x)
+{
+  s = x.s;
+}
+
+S &
+S::operator= (const S &x)
+{
+  s = x.s;
+  return *this;
+}
+
+static inline void
+ini (S &x)
+{
+  x.s = 0;
+}
+
+S r, a[1024], b[1024];
+
+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)
+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))
+
+__attribute__((noipa)) void
+foo (S *a, S *b, S &r)
+{
+  #pragma omp for simd simdlen (1) reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r.s += a[i].s;
+    }
+}
+
+__attribute__((noipa)) S
+bar (void)
+{
+  S s;
+  #pragma omp parallel
+  #pragma omp for simd if (0) reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s.s += 2 * a[i].s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (S *a, S *b, S &r)
+{
+  #pragma omp parallel for simd reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r.s += a[i].s;
+    }
+}
+
+__attribute__((noipa)) S
+qux (void)
+{
+  S s;
+  #pragma omp parallel for simd reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s.s += 2 * a[i].s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  S s;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i].s = i;
+      b[i].s = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+      s.s += i;
+    }
+  if (bar ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      s.s += 2 * i;
+    }
+  r.s = 0;
+  baz (a, b, r);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+      s.s += i;
+    }
+  if (qux ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      s.s += 2 * i;
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-2.C b/libgomp/testsuite/libgomp.c++/scan-2.C
new file mode 100644
index 00000000000..94555ccde30
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-2.C
@@ -0,0 +1,116 @@
+// { dg-require-effective-target size32plus }
+
+extern "C" void abort ();
+int r, a[1024], b[1024], q;
+
+__attribute__((noipa)) void
+foo (int *a, int *b, int &r)
+{
+  #pragma omp for reduction (inscan, +:r) nowait
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, +:s) nowait
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, int &r)
+{
+  #pragma omp parallel for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel for reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-3.C b/libgomp/testsuite/libgomp.c++/scan-3.C
new file mode 100644
index 00000000000..5e83958bf77
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-3.C
@@ -0,0 +1,119 @@
+// { dg-require-effective-target size32plus }
+
+extern "C" void abort ();
+int r, a[1024], b[1024], q;
+
+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)
+
+__attribute__((noipa)) void
+foo (int *a, int *b, int &r)
+{
+  #pragma omp for reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, int &r)
+{
+  #pragma omp parallel for reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel for reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-4.C b/libgomp/testsuite/libgomp.c++/scan-4.C
new file mode 100644
index 00000000000..fc2c682849f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-4.C
@@ -0,0 +1,150 @@
+// { dg-require-effective-target size32plus }
+
+extern "C" void abort ();
+
+struct S {
+  inline S ();
+  inline ~S ();
+  inline S (const S &);
+  inline S & operator= (const S &);
+  int s;
+};
+
+S::S () : s (0)
+{
+}
+
+S::~S ()
+{
+}
+
+S::S (const S &x)
+{
+  s = x.s;
+}
+
+S &
+S::operator= (const S &x)
+{
+  s = x.s;
+  return *this;
+}
+
+static inline void
+ini (S &x)
+{
+  x.s = 0;
+}
+
+S r, a[1024], b[1024];
+
+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)
+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))
+
+__attribute__((noipa)) void
+foo (S *a, S *b, S &r)
+{
+  #pragma omp for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r.s += a[i].s;
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) S
+bar ()
+{
+  S s;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s.s += 2 * a[i].s;
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (S *a, S *b, S &r)
+{
+  #pragma omp parallel for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r.s += a[i].s;
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) S
+qux ()
+{
+  S s;
+  #pragma omp parallel for reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s.s += 2 * a[i].s;
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  S s;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i].s = i;
+      b[i].s = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += i;
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+    }
+  if (bar ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += 2 * i;
+      if (b[i].s != s.s)
+	abort ();
+    }
+  r.s = 0;
+  baz (a, b, r);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += i;
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+    }
+  if (qux ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += 2 * i;
+      if (b[i].s != s.s)
+	abort ();
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-5.C b/libgomp/testsuite/libgomp.c++/scan-5.C
new file mode 100644
index 00000000000..5931a7fe14e
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-5.C
@@ -0,0 +1,158 @@
+// { dg-require-effective-target size32plus }
+
+extern "C" void abort ();
+
+template <typename T>
+struct S {
+  inline S ();
+  inline ~S ();
+  inline S (const S &);
+  inline S & operator= (const S &);
+  T s;
+};
+
+template <typename T>
+S<T>::S () : s (0)
+{
+}
+
+template <typename T>
+S<T>::~S ()
+{
+}
+
+template <typename T>
+S<T>::S (const S &x)
+{
+  s = x.s;
+}
+
+template <typename T>
+S<T> &
+S<T>::operator= (const S &x)
+{
+  s = x.s;
+  return *this;
+}
+
+template <typename T>
+static inline void
+ini (S<T> &x)
+{
+  x.s = 0;
+}
+
+S<int> r, a[1024], b[1024];
+
+#pragma omp declare reduction (+: S<int>: omp_out.s += omp_in.s)
+#pragma omp declare reduction (plus: S<int>: omp_out.s += omp_in.s) initializer (ini (omp_priv))
+
+template <typename T>
+__attribute__((noipa)) void
+foo (S<T> *a, S<T> *b)
+{
+  #pragma omp for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r.s += a[i].s;
+    }
+}
+
+template <typename T>
+__attribute__((noipa)) S<T>
+bar (void)
+{
+  S<T> s;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s.s += 2 * a[i].s;
+    }
+  return S<T> (s);
+}
+
+__attribute__((noipa)) void
+baz (S<int> *a, S<int> *b)
+{
+  #pragma omp parallel for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r.s += a[i].s;
+    }
+}
+
+__attribute__((noipa)) S<int>
+qux (void)
+{
+  S<int> s;
+  #pragma omp parallel for reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s.s += 2 * a[i].s;
+    }
+  return S<int> (s);
+}
+
+int
+main ()
+{
+  S<int> s;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i].s = i;
+      b[i].s = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+      s.s += i;
+    }
+  if (bar<int> ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      s.s += 2 * i;
+    }
+  r.s = 0;
+  baz (a, b);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+      s.s += i;
+    }
+  if (qux ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      s.s += 2 * i;
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-6.C b/libgomp/testsuite/libgomp.c++/scan-6.C
new file mode 100644
index 00000000000..46674e7a243
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-6.C
@@ -0,0 +1,120 @@
+// { dg-require-effective-target size32plus }
+
+extern "C" void abort ();
+int r, a[1024], b[1024], q;
+
+template <typename T, typename U>
+__attribute__((noipa)) void
+foo (T a, T b, U r)
+{
+  #pragma omp for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+template <typename T>
+__attribute__((noipa)) T
+bar ()
+{
+  T &s = q;
+  q = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+template <typename T>
+__attribute__((noipa)) void
+baz (T *a, T *b, T &r)
+{
+  #pragma omp parallel for reduction (inscan, +:r)
+  for (T i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+template <typename T>
+__attribute__((noipa)) int
+qux ()
+{
+  T s = q;
+  q = 0;
+  #pragma omp parallel for reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo<int *, int &> (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar<int> () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz<int> (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux<int &> () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-7.C b/libgomp/testsuite/libgomp.c++/scan-7.C
new file mode 100644
index 00000000000..ebeb20302bf
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-7.C
@@ -0,0 +1,118 @@
+// { dg-require-effective-target size32plus }
+
+extern "C" void abort ();
+int r, a[1024], b[1024], q;
+
+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)
+
+__attribute__((noipa)) void
+foo (int *a, int *b, int &r)
+{
+  #pragma omp for reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, foo:s) nowait
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, int &r)
+{
+  #pragma omp parallel for reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int &s = q;
+  q = 0;
+  #pragma omp parallel for reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz (a, b, r);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-8.C b/libgomp/testsuite/libgomp.c++/scan-8.C
new file mode 100644
index 00000000000..cfdfb6b7624
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-8.C
@@ -0,0 +1,150 @@
+// { dg-require-effective-target size32plus }
+
+extern "C" void abort ();
+
+struct S {
+  inline S ();
+  inline ~S ();
+  inline S (const S &);
+  inline S & operator= (const S &);
+  int s;
+};
+
+S::S () : s (0)
+{
+}
+
+S::~S ()
+{
+}
+
+S::S (const S &x)
+{
+  s = x.s;
+}
+
+S &
+S::operator= (const S &x)
+{
+  s = x.s;
+  return *this;
+}
+
+static inline void
+ini (S &x)
+{
+  x.s = 0;
+}
+
+S r, a[1024], b[1024];
+
+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)
+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))
+
+__attribute__((noipa)) void
+foo (S *a, S *b, S &r)
+{
+  #pragma omp for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r.s += a[i].s;
+    }
+}
+
+__attribute__((noipa)) S
+bar (void)
+{
+  S s;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s.s += 2 * a[i].s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (S *a, S *b, S &r)
+{
+  #pragma omp parallel for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r.s += a[i].s;
+    }
+}
+
+__attribute__((noipa)) S
+qux (void)
+{
+  S s;
+  #pragma omp parallel for reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s.s += 2 * a[i].s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  S s;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i].s = i;
+      b[i].s = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, r);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+      s.s += i;
+    }
+  if (bar ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      s.s += 2 * i;
+    }
+  r.s = 0;
+  baz (a, b, r);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+      s.s += i;
+    }
+  if (qux ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i].s != s.s)
+	abort ();
+      s.s += 2 * i;
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c++/scan-9.C b/libgomp/testsuite/libgomp.c++/scan-9.C
new file mode 100644
index 00000000000..cd08f76895b
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/scan-9.C
@@ -0,0 +1,155 @@
+// { dg-require-effective-target size32plus }
+// { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" }
+// { dg-additional-options "-msse2" { target sse2_runtime } }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+// { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } }
+
+extern "C" void abort ();
+
+struct S {
+  inline S ();
+  inline ~S ();
+  inline S (const S &);
+  inline S & operator= (const S &);
+  int s;
+};
+
+S::S () : s (0)
+{
+}
+
+S::~S ()
+{
+}
+
+S::S (const S &x)
+{
+  s = x.s;
+}
+
+S &
+S::operator= (const S &x)
+{
+  s = x.s;
+  return *this;
+}
+
+static inline void
+ini (S &x)
+{
+  x.s = 0;
+}
+
+S r, a[1024], b[1024];
+
+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)
+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))
+
+__attribute__((noipa)) void
+foo (S *a, S *b)
+{
+  #pragma omp for simd reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r.s += a[i].s;
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) S
+bar (void)
+{
+  S s;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s.s += 2 * a[i].s;
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return S (s);
+}
+
+__attribute__((noipa)) void
+baz (S *a, S *b)
+{
+  #pragma omp parallel for simd simdlen (1) reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r.s += a[i].s;
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) S
+qux (void)
+{
+  S s;
+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, plus:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s.s += 2 * a[i].s;
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return S (s);
+}
+
+int
+main ()
+{
+  S s;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i].s = i;
+      b[i].s = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += i;
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+    }
+  if (bar ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += 2 * i;
+      if (b[i].s != s.s)
+	abort ();
+    }
+  r.s = 0;
+  baz (a, b);
+  if (r.s != 1024 * 1023 / 2)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += i;
+      if (b[i].s != s.s)
+	abort ();
+      else
+	b[i].s = 25;
+    }
+  if (qux ().s != 1024 * 1023)
+    abort ();
+  s.s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s.s += 2 * i;
+      if (b[i].s != s.s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c++/target-22.C b/libgomp/testsuite/libgomp.c++/target-22.C
new file mode 100644
index 00000000000..9d9dea01c75
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/target-22.C
@@ -0,0 +1,99 @@
+extern "C" void abort (void);
+struct S { int e, f; };
+
+void
+foo (int *&p, int (&s)[5], int &t, S &u, int n)
+{
+  int a[4] = { 7, 8, 9, 10 }, b[n], c[3] = { 20, 21, 22 };
+  int *r = a + 1, *q = p - 1, i, err;
+  int v = 27;
+  S w = { 28, 29 };
+  for (i = 0; i < n; i++)
+    b[i] = 9 + i;
+  #pragma omp target data map(to:a) use_device_ptr(r) map(from:err)
+  #pragma omp target is_device_ptr(r) private(i) map(from:err)
+  {
+    err = 0;
+    for (i = 0; i < 4; i++)
+      if (r[i - 1] != 7 + i)
+	err = 1;
+  }
+  if (err)
+    abort ();
+  #pragma omp target data use_device_ptr(p) map(from:err) map(to:q[:4])
+  #pragma omp target is_device_ptr(p) private(i) map(from:err)
+  {
+    err = 0;
+    for (i = 0; i < 4; i++)
+      if (p[i - 1] != i)
+	err = 1;
+  }
+  if (err)
+    abort ();
+  #pragma omp target data map(to:b) use_device_addr(b) map(from:err)
+  #pragma omp target is_device_ptr(b) private(i) map(from:err)
+  {
+    err = 0;
+    for (i = 0; i < n; i++)
+      if (b[i] != 9 + i)
+	err = 1;
+  }
+  if (err)
+    abort ();
+  #pragma omp target data use_device_addr(c) map(to:c) map(from:err)
+  #pragma omp target is_device_ptr(c) private(i) map(from:err)
+  {
+    err = 0;
+    for (i = 0; i < 3; i++)
+      if (c[i] != 20 + i)
+	err = 1;
+  }
+  if (err)
+    abort ();
+  #pragma omp target data map(to:s[:5]) use_device_addr(s) map(from:err)
+  #pragma omp target is_device_ptr(s) private(i) map(from:err)
+  {
+    err = 0;
+    for (i = 0; i < 5; i++)
+      if (s[i] != 17 + i)
+	err = 1;
+  }
+  if (err)
+    abort ();
+  #pragma omp target data use_device_addr (v) map(to: v) map(to:u) use_device_addr (u) map(from:err)
+  {
+    int *z = &v;
+    S *x = &u;
+    #pragma omp target is_device_ptr (z, x) map(from:err)
+    {
+      err = 0;
+      if (*z != 27 || x->e != 25 || x->f != 26)
+	err = 1;
+    }
+  }
+  if (err)
+    abort ();
+  #pragma omp target data map(to: t) use_device_addr (t, w) map (to: w) map(from:err)
+  {
+    int *z = &t;
+    S *x = &w;
+    #pragma omp target is_device_ptr (z) is_device_ptr (x) map(from:err)
+    {
+      err = 0;
+      if (*z != 24 || x->e != 28 || x->f != 29)
+	err = 1;
+    }
+  }
+  if (err)
+    abort ();
+}
+
+int
+main ()
+{
+  int a[4] = { 0, 1, 2, 3 }, b[5] = { 17, 18, 19, 20, 21 };
+  int *p = a + 1;
+  int t = 24;
+  S u = { 25, 26 };
+  foo (p, b, t, u, 9);
+}
diff --git a/libgomp/testsuite/libgomp.c++/target-9.C b/libgomp/testsuite/libgomp.c++/target-9.C
index a5d171b0b3d..83a61cf599b 100644
--- a/libgomp/testsuite/libgomp.c++/target-9.C
+++ b/libgomp/testsuite/libgomp.c++/target-9.C
@@ -1,10 +1,13 @@
 extern "C" void abort (void);
+struct S { int e, f; };
 
 void
-foo (int *&p, int (&s)[5], int n)
+foo (int *&p, int (&s)[5], int &t, S &u, int n)
 {
   int a[4] = { 7, 8, 9, 10 }, b[n], c[3] = { 20, 21, 22 };
   int *r = a + 1, *q = p - 1, i, err;
+  int v = 27;
+  S w = { 28, 29 };
   for (i = 0; i < n; i++)
     b[i] = 9 + i;
   #pragma omp target data map(to:a)
@@ -30,7 +33,7 @@ foo (int *&p, int (&s)[5], int n)
   if (err)
     abort ();
   #pragma omp target data map(to:b)
-  #pragma omp target data use_device_ptr(b) map(from:err)
+  #pragma omp target data use_device_addr(b) map(from:err)
   #pragma omp target is_device_ptr(b) private(i) map(from:err)
   {
     err = 0;
@@ -41,7 +44,7 @@ foo (int *&p, int (&s)[5], int n)
   if (err)
     abort ();
   #pragma omp target data map(to:c)
-  #pragma omp target data use_device_ptr(c) map(from:err)
+  #pragma omp target data use_device_addr(c) map(from:err)
   #pragma omp target is_device_ptr(c) private(i) map(from:err)
   {
     err = 0;
@@ -52,7 +55,7 @@ foo (int *&p, int (&s)[5], int n)
   if (err)
     abort ();
   #pragma omp target data map(to:s[:5])
-  #pragma omp target data use_device_ptr(s) map(from:err)
+  #pragma omp target data use_device_addr(s) map(from:err)
   #pragma omp target is_device_ptr(s) private(i) map(from:err)
   {
     err = 0;
@@ -62,6 +65,34 @@ foo (int *&p, int (&s)[5], int n)
   }
   if (err)
     abort ();
+  #pragma omp target data map(to: v) map(to:u)
+  #pragma omp target data use_device_addr (v) use_device_addr (u) map(from:err)
+  {
+    int *z = &v;
+    S *x = &u;
+    #pragma omp target is_device_ptr (z, x) map(from:err)
+    {
+      err = 0;
+      if (*z != 27 || x->e != 25 || x->f != 26)
+	err = 1;
+    }
+  }
+  if (err)
+    abort ();
+  #pragma omp target data map(to: t, w)
+  #pragma omp target data use_device_addr (t, w) map(from:err)
+  {
+    int *z = &t;
+    S *x = &w;
+    #pragma omp target is_device_ptr (z) is_device_ptr (x) map(from:err)
+    {
+      err = 0;
+      if (*z != 24 || x->e != 28 || x->f != 29)
+	err = 1;
+    }
+  }
+  if (err)
+    abort ();
 }
 
 int
@@ -69,5 +100,7 @@ main ()
 {
   int a[4] = { 0, 1, 2, 3 }, b[5] = { 17, 18, 19, 20, 21 };
   int *p = a + 1;
-  foo (p, b, 9);
+  int t = 24;
+  S u = { 25, 26 };
+  foo (p, b, t, u, 9);
 }
diff --git a/libgomp/testsuite/libgomp.c++/udr-20.C b/libgomp/testsuite/libgomp.c++/udr-20.C
new file mode 100644
index 00000000000..83388758edd
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/udr-20.C
@@ -0,0 +1,54 @@
+// PR c++/60228
+// { dg-additional-options "-std=c++11" }
+
+extern "C" void abort ();
+
+struct A
+{
+  typedef int T;
+  #pragma omp declare reduction (x : T : omp_out += omp_in + [](){ return 0; }()) initializer (omp_priv = [](){ return 0; }())
+  static void foo ();
+};
+
+template <typename T>
+struct B
+{
+  #pragma omp declare reduction (x : T : omp_out += omp_in + [](){ return T (0); }()) initializer (omp_priv = [](){ return T (0); }())
+  static void foo ();
+};
+
+void
+A::foo ()
+{
+  int r = 0, s = 0;
+  #pragma omp parallel for reduction (x : r, s)
+  for (int i = 0; i < 64; i++)
+    {
+      r++;
+      s += i;
+    }
+  if (r != 64 || s != (64 * 63) / 2)
+    abort ();
+}
+
+template <typename T>
+void
+B<T>::foo ()
+{
+  T r = 0, s = 0;
+  #pragma omp parallel for reduction (x : r, s)
+  for (int i = 0; i < 64; i++)
+    {
+      r++;
+      s += i;
+    }
+  if (r != 64 || s != (64 * 63) / 2)
+    abort ();
+}
+
+int
+main ()
+{
+  A::foo ();
+  B<long>::foo ();
+}
diff --git a/libgomp/testsuite/libgomp.c++/udr-21.C b/libgomp/testsuite/libgomp.c++/udr-21.C
new file mode 100644
index 00000000000..9ec655718fd
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/udr-21.C
@@ -0,0 +1,54 @@
+// PR c++/60228
+// { dg-additional-options "-std=c++11" }
+
+extern "C" void abort ();
+
+struct A
+{
+  typedef int T;
+  #pragma omp declare reduction (y : T : [&omp_out, &omp_in]() { omp_out += omp_in; return 0; }()) initializer (omp_priv = [omp_orig]() { return omp_orig; }())
+  static void foo ();
+};
+
+template <typename T>
+struct B
+{
+  #pragma omp declare reduction (y : T : [&omp_out, &omp_in]() { omp_out += omp_in; return 0; }()) initializer (omp_priv = [omp_orig]() { return omp_orig; }())
+  static void foo ();
+};
+
+void
+A::foo ()
+{
+  int r = 0, s = 0;
+  #pragma omp parallel for reduction (y : r, s)
+  for (int i = 0; i < 64; i++)
+    {
+      r++;
+      s += i;
+    }
+  if (r != 64 || s != (64 * 63) / 2)
+    abort ();
+}
+
+template <typename T>
+void
+B<T>::foo ()
+{
+  T r = 0, s = 0;
+  #pragma omp parallel for reduction (y : r, s)
+  for (int i = 0; i < 64; i++)
+    {
+      r++;
+      s += i;
+    }
+  if (r != 64 || s != (64 * 63) / 2)
+    abort ();
+}
+
+int
+main ()
+{
+  A::foo ();
+  B<short>::foo ();
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-1.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-1.c
new file mode 100644
index 00000000000..a7e9f90c5a8
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-1.c
@@ -0,0 +1,144 @@
+/* { dg-do run } */
+/* { dg-require-effective-target tls_runtime } */
+/* { dg-additional-options "-std=gnu99" {target c } } */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int r, s, u, v, r2, s2, u2, v2, r3, s3, u3, v3;
+long long w, w2, w3, p, p2, p3;
+int *x, *x2, *x3;
+short y, y2, y3;
+int z;
+int thr1, thr2;
+#pragma omp threadprivate (thr1, thr2)
+
+void
+foo (int *a, long long int b, long long int c)
+{
+  int i;
+  long long j;
+  #pragma omp for lastprivate (conditional: u, x) nowait
+  for (i = 15; i < 64; i++)
+    {
+      if ((a[i] % 5) == 3)
+	u = i;
+      if ((a[i] % 7) == 2)
+	x = &a[i];
+    }
+  #pragma omp for nowait lastprivate (conditional: v) reduction (+:r, s) schedule (nonmonotonic: static)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s;
+      if ((a[i + 4] % 11) == 9)
+	v = i;
+      else
+	++r;
+    }
+  #pragma omp for schedule (monotonic: static) lastprivate (conditional: w) nowait
+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)
+    if ((a[j] % 13) == 5)
+      w = j * 2;
+  #pragma omp for schedule (auto) lastprivate (conditional: p) collapse(3)
+  for (i = -5; i < (int) (b + 5); i += 2)
+    for (j = b + 12 + c; j > b; --j)
+      for (int k = 0; k < 5; k += c)
+	if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)
+	  p = i * 10000 + j * 100 + k;
+
+  #pragma omp for schedule (nonmonotonic: static, 2) nowait lastprivate (conditional: u2, x2)
+  for (i = 15; i < 64; i++)
+    {
+      if ((a[i] % 5) == 3)
+	u2 = i;
+      if ((a[i] % 7) == 2)
+	x2 = &a[i];
+    }
+  #pragma omp for schedule (static, 3) lastprivate (conditional: v2) reduction (+:r2, s2)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s2;
+      if ((a[i + 4] % 11) == 9)
+	v2 = i;
+      else
+	++r2;
+    }
+  #pragma omp for lastprivate (conditional: w2) schedule (static, 1) nowait
+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)
+    if ((a[j] % 13) == 5)
+      w2 = j * 2;
+  #pragma omp for schedule (static, 3) collapse (3) lastprivate (conditional: p2)
+  for (i = -5; i < (int) (b + 5); i += 2)
+    for (j = b + 12 + c; j > b; --j)
+      for (int k = 0; k < 5; k += c)
+	if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)
+	  p2 = i * 10000 + j * 100 + k;
+
+  #pragma omp for lastprivate (conditional: u3, x3) nowait schedule (runtime)
+  for (i = 15; i < 64; i++)
+    {
+      if ((a[i] % 5) == 3)
+	u3 = i;
+      if ((a[i] % 7) == 2)
+	x3 = &a[i];
+    }
+  #pragma omp for nowait lastprivate (conditional: v3) reduction (+:r3, s3) schedule (nonmonotonic: dynamic)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s3;
+      if ((a[i + 4] % 11) == 9)
+	v3 = i;
+      else
+	++r3;
+    }
+  #pragma omp for schedule (monotonic: guided, 3) lastprivate (conditional: w3) nowait
+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)
+    if ((a[j] % 13) == 5)
+      w3 = j * 2;
+  #pragma omp for schedule (dynamic, 4) lastprivate (conditional: p3) collapse(3)
+  for (i = -5; i < (int) (b + 5); i += 2)
+    for (j = b + 12 + c; j > b; --j)
+      for (int k = 0; k < 5; k += c)
+	if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)
+	  p3 = i * 10000 + j * 100 + k;
+
+  /* Nasty testcase, verify that even a no-op assignment is accounted
+     for in lastprivate(conditional:).  */
+  #pragma omp for schedule (monotonic: static, 2) firstprivate (z) \
+		  lastprivate (conditional: z)
+  for (int k = -2000; k < 8000; ++k)
+    {
+      if (k < 3000 && (k & 3) == 1)
+	{
+	  z = k;
+	  thr1 = k;
+	}
+      else if (k == 7931)
+	{
+	  z = z;
+	  thr2 = 1;
+	}
+    }
+
+  if (thr2 && z != thr1)
+    abort ();
+}
+
+int
+main ()
+{
+  int a[128], i;
+  volatile int j = 0;
+  for (i = 0; i < 128; i++)
+    a[i] = i;
+  w = 1234;
+  #pragma omp parallel
+  foo (a, j, j + 1);
+  if (u != 63 || v != 115 || w != 140 || x != &a[58] || r != 55 || s != 61 || p != 30104)
+    abort ();
+  if (u2 != 63 || v2 != 115 || w2 != 140 || x2 != &a[58] || r2 != 55 || s2 != 61 || p2 != 30104)
+    abort ();
+  if (u3 != 63 || v3 != 115 || w3 != 140 || x3 != &a[58] || r3 != 55 || s3 != 61 || p3 != 30104)
+    abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-10.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-10.c
new file mode 100644
index 00000000000..2f7503903fd
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-10.c
@@ -0,0 +1,57 @@
+/* { dg-do run } */
+
+int v, x;
+
+__attribute__((noipa)) int
+foo (int *a)
+{
+  #pragma omp parallel for simd lastprivate (conditional: x) schedule(simd: static) if (simd: 0)
+  for (int i = 0; i < 128; i++)
+    if (a[i])
+      x = a[i];
+  return x;
+}
+
+__attribute__((noipa)) int
+bar (int *a, int *b)
+{
+  #pragma omp parallel
+  #pragma omp for simd lastprivate (conditional: x, v) schedule(static, 16) simdlen (1)
+  for (int i = 16; i < 128; ++i)
+    {
+      if (a[i])
+	x = a[i];
+      if (b[i])
+	v = b[i] + 10;
+    }
+  return x;
+}
+
+__attribute__((noipa)) int
+baz (int *a)
+{
+  #pragma omp parallel for simd if (simd: 0) lastprivate (conditional: x) schedule(simd: dynamic, 16)
+  for (int i = 0; i < 128; i++)
+    if (a[i])
+      x = a[i] + 5;
+  return x;
+}
+
+int
+main ()
+{
+  int a[128], b[128], i;
+  for (i = 0; i < 128; i++)
+    {
+      a[i] = ((i % 11) == 2) ? i + 10 : 0;
+      asm volatile ("" : "+g" (i));
+      b[i] = ((i % 13) == 5) ? i * 2 : 0;
+    }
+  if (foo (a) != 133)
+    __builtin_abort ();
+  if (bar (b, a) != 244 || v != 143)
+    __builtin_abort ();
+  if (baz (b) != 249)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-2.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-2.c
new file mode 100644
index 00000000000..f252206f5b3
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-2.c
@@ -0,0 +1,171 @@
+/* { dg-do run } */
+/* { dg-require-effective-target tls_runtime } */
+/* { dg-additional-options "-std=gnu99" {target c } } */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int r, s, u, v, r2, s2, u2, v2, r3, s3, u3, v3, t;
+long long w, w2, w3, p, p2, p3;
+int *x, *x2, *x3;
+short y, y2, y3;
+int z;
+int thr1, thr2;
+#pragma omp threadprivate (thr1, thr2)
+
+void
+foo (int *a, long long int b, long long int c)
+{
+  int i;
+  long long j;
+  #pragma omp for lastprivate (conditional: u, x) reduction (task, +: t)
+  for (i = 15; i < 64; i++)
+    {
+      ++t;
+      if ((a[i] % 5) == 3)
+	u = i;
+      if ((a[i] % 7) == 2)
+	x = &a[i];
+    }
+  #pragma omp for lastprivate (conditional: v) reduction (+:r, s) schedule (nonmonotonic: static) reduction (task, +: t)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s;
+      ++t;
+      if ((a[i + 4] % 11) == 9)
+	v = i;
+      else
+	++r;
+    }
+  #pragma omp for schedule (monotonic: static) lastprivate (conditional: w) reduction (task, +: t)
+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)
+    {
+      if ((a[j] % 13) == 5)
+	w = j * 2;
+      ++t;
+    }
+  #pragma omp for schedule (auto) lastprivate (conditional: p) collapse(3) reduction (task, +: t)
+  for (i = -5; i < (int) (b + 5); i += 2)
+    for (j = b + 12 + c; j > b; --j)
+      for (int k = 0; k < 5; k += c)
+	{
+	  ++t;
+	  if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)
+	    p = i * 10000 + j * 100 + k;
+	}
+
+  #pragma omp for schedule (nonmonotonic: static, 2)  reduction (task, +: t) lastprivate (conditional: u2, x2)
+  for (i = 15; i < 64; i++)
+    {
+      if ((a[i] % 5) == 3)
+	u2 = i;
+      if ((a[i] % 7) == 2)
+	x2 = &a[i];
+      t++;
+    }
+  #pragma omp for schedule (static, 3) lastprivate (conditional: v2) reduction (+:r2, s2) reduction (task, +: t)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s2;
+      if ((a[i + 4] % 11) == 9)
+	v2 = i;
+      else
+	++r2;
+      t++;
+    }
+  #pragma omp for lastprivate (conditional: w2) schedule (static, 1) reduction (task, +: t)
+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)
+    {
+      if ((a[j] % 13) == 5)
+	w2 = j * 2;
+      t += 1;
+    }
+  #pragma omp for schedule (static, 3) collapse (3) reduction (task, +: t) lastprivate (conditional: p2)
+  for (i = -5; i < (int) (b + 5); i += 2)
+    for (j = b + 12 + c; j > b; --j)
+      for (int k = 0; k < 5; k += c)
+	{
+	  ++t;
+	  if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)
+	    p2 = i * 10000 + j * 100 + k;
+	}
+
+  #pragma omp for lastprivate (conditional: u3, x3) reduction (task, +: t) schedule (runtime)
+  for (i = 15; i < 64; i++)
+    {
+      t = t + 1;
+      if ((a[i] % 5) == 3)
+	u3 = i;
+      if ((a[i] % 7) == 2)
+	x3 = &a[i];
+    }
+  #pragma omp for reduction (task, +: t) lastprivate (conditional: v3) reduction (+:r3, s3) schedule (nonmonotonic: dynamic)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s3;
+      if ((a[i + 4] % 11) == 9)
+	v3 = i;
+      else
+	++r3;
+      ++t;
+    }
+  #pragma omp for schedule (monotonic: guided, 3) lastprivate (conditional: w3) reduction (task, +: t)
+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)
+    {
+      if ((a[j] % 13) == 5)
+	w3 = j * 2;
+      t++;
+    }
+  #pragma omp for schedule (dynamic, 4) lastprivate (conditional: p3) collapse(3) reduction (task, +: t)
+  for (i = -5; i < (int) (b + 5); i += 2)
+    for (j = b + 12 + c; j > b; --j)
+      for (int k = 0; k < 5; k += c)
+	{
+	  ++t;
+	  if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)
+	    p3 = i * 10000 + j * 100 + k;
+	}
+
+  /* Nasty testcase, verify that even a no-op assignment is accounted
+     for in lastprivate(conditional:).  */
+  #pragma omp for schedule (monotonic: static, 2) firstprivate (z) \
+		  lastprivate (conditional: z) reduction (task, +: t)
+  for (int k = -2000; k < 8000; ++k)
+    {
+      t++;
+      if (k < 3000 && (k & 3) == 1)
+	{
+	  z = k;
+	  thr1 = k;
+	}
+      else if (k == 7931)
+	{
+	  z = z;
+	  thr2 = 1;
+	}
+    }
+
+  if (thr2 && z != thr1)
+    abort ();
+}
+
+int
+main ()
+{
+  int a[128], i;
+  volatile int j = 0;
+  for (i = 0; i < 128; i++)
+    a[i] = i;
+  w = 1234;
+  #pragma omp parallel
+  foo (a, j, j + 1);
+  if (u != 63 || v != 115 || w != 140 || x != &a[58] || r != 55 || s != 61 || p != 30104)
+    abort ();
+  if (u2 != 63 || v2 != 115 || w2 != 140 || x2 != &a[58] || r2 != 55 || s2 != 61 || p2 != 30104)
+    abort ();
+  if (u3 != 63 || v3 != 115 || w3 != 140 || x3 != &a[58] || r3 != 55 || s3 != 61 || p3 != 30104)
+    abort ();
+  if (t != 11356)
+    abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-3.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-3.c
new file mode 100644
index 00000000000..6c4370abaa3
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-3.c
@@ -0,0 +1,57 @@
+/* { dg-do run } */
+/* { dg-require-effective-target tls_runtime } */
+/* { dg-additional-options "-std=gnu99" {target c } } */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int r, s, u, v, t;
+int *x;
+
+void
+foo (int *a)
+{
+  int i;
+  long long j;
+  #pragma omp for lastprivate (conditional: u, x) ordered
+  for (i = 15; i < 64; i++)
+    {
+      #pragma omp critical
+      {
+	if ((a[i] % 5) == 3)
+	  u = i;
+      }
+      #pragma omp ordered
+      {
+	if ((a[i] % 7) == 2)
+	  x = &a[i];
+      }
+    }
+  #pragma omp for lastprivate (conditional: v) reduction (+:r, s) schedule (nonmonotonic: static) reduction (task, +: t)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s;
+      #pragma omp taskgroup
+      {
+	#pragma omp task in_reduction (+: t)
+	  ++t;
+	if ((a[i + 4] % 11) == 9)
+	  v = i;
+	else
+	  ++r;
+      }
+    }
+}
+
+int
+main ()
+{
+  int a[128], i;
+  for (i = 0; i < 128; i++)
+    a[i] = i;
+  #pragma omp parallel
+  foo (a);
+  if (u != 63 || v != 115 || x != &a[58] || r != 55 || s != 61 || t != 61)
+    abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-4.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-4.c
new file mode 100644
index 00000000000..bc102a10cd1
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-4.c
@@ -0,0 +1,161 @@
+#include <stdlib.h>
+
+int x;
+long long y;
+int r, s, t;
+
+void
+foo (const char *a)
+{
+  #pragma omp sections lastprivate (conditional: x, y)
+  {
+    if (a[0])
+      x = a[0];
+    #pragma omp section
+    {
+      if (a[1])
+	x = a[1];
+      if (a[2])
+	y = a[2];
+    }
+    #pragma omp section
+    if (a[3])
+      y = a[3];
+    #pragma omp section
+    if (a[4])
+      x = a[4];
+    #pragma omp section
+    {
+      if (a[5])
+	x = a[5];
+      if (a[6])
+	y = a[6];
+    }
+  }
+}
+
+void
+bar (const char *a)
+{
+  #pragma omp sections lastprivate (conditional: x, y) reduction (task, +: t)
+  {
+    if (a[0])
+      x = a[0];
+    #pragma omp section
+    {
+      if (a[1])
+	x = a[1];
+      if (a[2])
+	y = a[2];
+      #pragma omp task in_reduction (+: t)
+      t++;
+    }
+    #pragma omp section
+    if (a[3])
+      y = a[3];
+    #pragma omp section
+    if (a[4])
+      x = a[4];
+    #pragma omp section
+    {
+      #pragma omp task in_reduction (+: t)
+      ++t;
+      if (a[5])
+	x = a[5];
+      if (a[6])
+	y = a[6];
+    }
+  }
+}
+
+void
+baz (const char *a)
+{
+  #pragma omp sections lastprivate (conditional: x, y) reduction (+: r, s)
+  {
+    if (a[0])
+      x = a[0];
+    #pragma omp section
+    {
+      if (a[1])
+	x = a[1];
+      ++r;
+      ++s;
+      if (a[2])
+	y = a[2];
+    }
+    #pragma omp section
+    if (a[3])
+      y = a[3];
+    #pragma omp section
+    {
+      ++s;
+      if (a[4])
+	x = a[4];
+    }
+    #pragma omp section
+    {
+      if (a[5])
+	x = a[5];
+      if (a[6])
+	y = a[6];
+      ++s;
+    }
+  }
+}
+
+int
+main ()
+{
+  #pragma omp parallel
+  {
+    foo ("\0\1\2\3\0\5");
+    if (x != 5 || y != 3)
+      abort ();
+    #pragma omp barrier
+    foo ("\6\0\0\0\0\0\7");
+    if (x != 6 || y != 7)
+      abort ();
+    #pragma omp barrier
+    foo ("\7\6\5\4\3\2\1");
+    if (x != 2 || y != 1)
+      abort ();
+    #pragma omp barrier
+    foo ("\0\0\4\3\0\7");
+    if (x != 7 || y != 3)
+      abort ();
+    #pragma omp barrier
+    bar ("\0\1\2\4\0\5");
+    if (x != 5 || y != 4 || t != 2)
+      abort ();
+    #pragma omp barrier
+    bar ("\6\0\0\0\0\0\7");
+    if (x != 6 || y != 7 || t != 4)
+      abort ();
+    #pragma omp barrier
+    bar ("\7\6\5\4\3\2\1");
+    if (x != 2 || y != 1 || t != 6)
+      abort ();
+    #pragma omp barrier
+    bar ("\0\0\4\3\0\7");
+    if (x != 7 || y != 3 || t != 8)
+      abort ();
+    #pragma omp barrier
+    baz ("\0\1\2\4\0\5");
+    if (x != 5 || y != 4 || r != 1 || s != 3)
+      abort ();
+    #pragma omp barrier
+    baz ("\6\0\0\0\0\0\7");
+    if (x != 6 || y != 7 || r != 2 || s != 6)
+      abort ();
+    #pragma omp barrier
+    baz ("\7\6\5\4\3\2\1");
+    if (x != 2 || y != 1 || r != 3 || s != 9)
+      abort ();
+    #pragma omp barrier
+    baz ("\0\0\4\3\0\7");
+    if (x != 7 || y != 3 || r != 4 || s != 12)
+      abort ();
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-5.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-5.c
new file mode 100644
index 00000000000..de6b9a87c1f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-5.c
@@ -0,0 +1,143 @@
+/* { dg-do run } */
+/* { dg-require-effective-target tls_runtime } */
+/* { dg-additional-options "-std=gnu99" {target c } } */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int r, s, u, v, r2, s2, u2, v2, r3, s3, u3, v3;
+long long w, w2, w3, p, p2, p3;
+int *x, *x2, *x3;
+short y, y2, y3;
+int z;
+int thr1, thr2;
+#pragma omp threadprivate (thr1, thr2)
+
+void
+foo (int *a, long long int b, long long int c)
+{
+  int i;
+  long long j;
+  #pragma omp parallel for lastprivate (conditional: u, x)
+  for (i = 15; i < 64; i++)
+    {
+      if ((a[i] % 5) == 3)
+	u = i;
+      if ((a[i] % 7) == 2)
+	x = &a[i];
+    }
+  #pragma omp parallel for lastprivate (conditional: v) reduction (+:r, s) schedule (nonmonotonic: static)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s;
+      if ((a[i + 4] % 11) == 9)
+	v = i;
+      else
+	++r;
+    }
+  #pragma omp parallel for schedule (monotonic: static) lastprivate (conditional: w)
+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)
+    if ((a[j] % 13) == 5)
+      w = j * 2;
+  #pragma omp parallel for schedule (auto) lastprivate (conditional: p) collapse(3)
+  for (i = -5; i < (int) (b + 5); i += 2)
+    for (j = b + 12 + c; j > b; --j)
+      for (int k = 0; k < 5; k += c)
+	if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)
+	  p = i * 10000 + j * 100 + k;
+
+  #pragma omp parallel for schedule (nonmonotonic: static, 2) lastprivate (conditional: u2, x2)
+  for (i = 15; i < 64; i++)
+    {
+      if ((a[i] % 5) == 3)
+	u2 = i;
+      if ((a[i] % 7) == 2)
+	x2 = &a[i];
+    }
+  #pragma omp parallel for schedule (static, 3) lastprivate (conditional: v2) reduction (+:r2, s2)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s2;
+      if ((a[i + 4] % 11) == 9)
+	v2 = i;
+      else
+	++r2;
+    }
+  #pragma omp parallel for lastprivate (conditional: w2) schedule (static, 1)
+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)
+    if ((a[j] % 13) == 5)
+      w2 = j * 2;
+  #pragma omp parallel for schedule (static, 3) collapse (3) lastprivate (conditional: p2)
+  for (i = -5; i < (int) (b + 5); i += 2)
+    for (j = b + 12 + c; j > b; --j)
+      for (int k = 0; k < 5; k += c)
+	if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)
+	  p2 = i * 10000 + j * 100 + k;
+
+  #pragma omp parallel for lastprivate (conditional: u3, x3) schedule (runtime)
+  for (i = 15; i < 64; i++)
+    {
+      if ((a[i] % 5) == 3)
+	u3 = i;
+      if ((a[i] % 7) == 2)
+	x3 = &a[i];
+    }
+  #pragma omp parallel for lastprivate (conditional: v3) reduction (+:r3, s3) schedule (nonmonotonic: dynamic)
+  for (i = -3; i < 119; i += 2)
+    {
+      ++s3;
+      if ((a[i + 4] % 11) == 9)
+	v3 = i;
+      else
+	++r3;
+    }
+  #pragma omp parallel for schedule (monotonic: guided, 3) lastprivate (conditional: w3)
+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)
+    if ((a[j] % 13) == 5)
+      w3 = j * 2;
+  #pragma omp parallel for schedule (dynamic, 4) lastprivate (conditional: p3) collapse(3)
+  for (i = -5; i < (int) (b + 5); i += 2)
+    for (j = b + 12 + c; j > b; --j)
+      for (int k = 0; k < 5; k += c)
+	if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)
+	  p3 = i * 10000 + j * 100 + k;
+
+  /* Nasty testcase, verify that even a no-op assignment is accounted
+     for in lastprivate(conditional:).  */
+  #pragma omp parallel for schedule (monotonic: static, 2) firstprivate (z) \
+			   lastprivate (conditional: z)
+  for (int k = -2000; k < 8000; ++k)
+    {
+      if (k < 3000 && (k & 3) == 1)
+	{
+	  z = k;
+	  thr1 = k;
+	}
+      else if (k == 7931)
+	{
+	  z = z;
+	  thr2 = 1;
+	}
+    }
+
+  if (thr2 && z != thr1)
+    abort ();
+}
+
+int
+main ()
+{
+  int a[128], i;
+  volatile int j = 0;
+  for (i = 0; i < 128; i++)
+    a[i] = i;
+  w = 1234;
+  foo (a, j, j + 1);
+  if (u != 63 || v != 115 || w != 140 || x != &a[58] || r != 55 || s != 61 || p != 30104)
+    abort ();
+  if (u2 != 63 || v2 != 115 || w2 != 140 || x2 != &a[58] || r2 != 55 || s2 != 61 || p2 != 30104)
+    abort ();
+  if (u3 != 63 || v3 != 115 || w3 != 140 || x3 != &a[58] || r3 != 55 || s3 != 61 || p3 != 30104)
+    abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-6.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-6.c
new file mode 100644
index 00000000000..d2137935859
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-6.c
@@ -0,0 +1,159 @@
+#include <stdlib.h>
+
+int x;
+long long y;
+int r, s, t;
+
+void
+foo (const char *a)
+{
+  #pragma omp parallel sections lastprivate (conditional: x, y)
+  {
+    if (a[0])
+      x = a[0];
+    #pragma omp section
+    {
+      if (a[1])
+	x = a[1];
+      if (a[2])
+	y = a[2];
+    }
+    #pragma omp section
+    if (a[3])
+      y = a[3];
+    #pragma omp section
+    if (a[4])
+      x = a[4];
+    #pragma omp section
+    {
+      if (a[5])
+	x = a[5];
+      if (a[6])
+	y = a[6];
+    }
+  }
+}
+
+void
+bar (const char *a)
+{
+  #pragma omp parallel sections lastprivate (conditional: x, y) reduction (task, +: t)
+  {
+    if (a[0])
+      x = a[0];
+    #pragma omp section
+    {
+      if (a[1])
+	x = a[1];
+      if (a[2])
+	y = a[2];
+      #pragma omp task in_reduction (+: t)
+      t++;
+    }
+    #pragma omp section
+    if (a[3])
+      y = a[3];
+    #pragma omp section
+    if (a[4])
+      x = a[4];
+    #pragma omp section
+    {
+      #pragma omp task in_reduction (+: t)
+      ++t;
+      if (a[5])
+	x = a[5];
+      if (a[6])
+	y = a[6];
+    }
+  }
+}
+
+void
+baz (const char *a)
+{
+  #pragma omp parallel sections lastprivate (conditional: x, y) reduction (+: r, s)
+  {
+    if (a[0])
+      x = a[0];
+    #pragma omp section
+    {
+      if (a[1])
+	x = a[1];
+      ++r;
+      ++s;
+      if (a[2])
+	y = a[2];
+    }
+    #pragma omp section
+    if (a[3])
+      y = a[3];
+    #pragma omp section
+    {
+      ++s;
+      if (a[4])
+	x = a[4];
+    }
+    #pragma omp section
+    {
+      if (a[5])
+	x = a[5];
+      if (a[6])
+	y = a[6];
+      ++s;
+    }
+  }
+}
+
+int
+main ()
+{
+  foo ("\0\1\2\3\0\5");
+  if (x != 5 || y != 3)
+    abort ();
+
+  foo ("\6\0\0\0\0\0\7");
+  if (x != 6 || y != 7)
+    abort ();
+
+  foo ("\7\6\5\4\3\2\1");
+  if (x != 2 || y != 1)
+    abort ();
+
+  foo ("\0\0\4\3\0\7");
+  if (x != 7 || y != 3)
+    abort ();
+
+  bar ("\0\1\2\4\0\5");
+  if (x != 5 || y != 4 || t != 2)
+    abort ();
+
+  bar ("\6\0\0\0\0\0\7");
+  if (x != 6 || y != 7 || t != 4)
+    abort ();
+
+  bar ("\7\6\5\4\3\2\1");
+  if (x != 2 || y != 1 || t != 6)
+    abort ();
+
+  bar ("\0\0\4\3\0\7");
+  if (x != 7 || y != 3 || t != 8)
+    abort ();
+
+  baz ("\0\1\2\4\0\5");
+  if (x != 5 || y != 4 || r != 1 || s != 3)
+    abort ();
+
+  baz ("\6\0\0\0\0\0\7");
+  if (x != 6 || y != 7 || r != 2 || s != 6)
+    abort ();
+
+  baz ("\7\6\5\4\3\2\1");
+  if (x != 2 || y != 1 || r != 3 || s != 9)
+    abort ();
+
+  baz ("\0\0\4\3\0\7");
+  if (x != 7 || y != 3 || r != 4 || s != 12)
+    abort ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-7.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-7.c
new file mode 100644
index 00000000000..2d542d6d56c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-7.c
@@ -0,0 +1,63 @@
+/* { dg-do run } */
+/* { dg-additional-options "-O2 -fdump-tree-vect-details" } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" { target avx_runtime } } } */
+
+int v, x;
+
+__attribute__((noipa)) void
+foo (int *a)
+{
+  #pragma omp for simd lastprivate (conditional: x) schedule(simd: static)
+  for (int i = 0; i < 128; i++)
+    if (a[i])
+      x = a[i];
+}
+
+__attribute__((noipa)) void
+bar (int *a, int *b)
+{
+  #pragma omp for simd lastprivate (conditional: x, v) schedule(static, 16)
+  for (int i = 16; i < 128; ++i)
+    {
+      if (a[i])
+	x = a[i];
+      if (b[i])
+	v = b[i] + 10;
+    }
+}
+
+__attribute__((noipa)) void
+baz (int *a)
+{
+  #pragma omp for simd lastprivate (conditional: x) schedule(simd: dynamic, 16)
+  for (int i = 0; i < 128; i++)
+    if (a[i])
+      x = a[i] + 5;
+}
+
+int
+main ()
+{
+  int a[128], b[128], i;
+  for (i = 0; i < 128; i++)
+    {
+      a[i] = ((i % 11) == 2) ? i + 10 : 0;
+      asm volatile ("" : "+g" (i));
+      b[i] = ((i % 13) == 5) ? i * 2 : 0;
+    }
+  #pragma omp parallel
+  foo (a);
+  if (x != 133)
+    __builtin_abort ();
+  x = -3;
+  #pragma omp parallel
+  bar (b, a);
+  if (x != 244 || v != 143)
+    __builtin_abort ();
+  #pragma omp parallel
+  baz (b);
+  if (x != 249)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-8.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-8.c
new file mode 100644
index 00000000000..b935a6c2dbf
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-8.c
@@ -0,0 +1,60 @@
+/* { dg-do run } */
+/* { dg-additional-options "-O2 -fdump-tree-vect-details" } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" { target avx_runtime } } } */
+
+int v, x;
+
+__attribute__((noipa)) int
+foo (int *a)
+{
+  #pragma omp parallel for simd lastprivate (conditional: x) schedule(simd: static)
+  for (int i = 0; i < 128; i++)
+    if (a[i])
+      x = a[i];
+  return x;
+}
+
+__attribute__((noipa)) int
+bar (int *a, int *b)
+{
+  #pragma omp parallel
+  #pragma omp for simd lastprivate (conditional: x, v) schedule(static, 16)
+  for (int i = 16; i < 128; ++i)
+    {
+      if (a[i])
+	x = a[i];
+      if (b[i])
+	v = b[i] + 10;
+    }
+  return x;
+}
+
+__attribute__((noipa)) int
+baz (int *a)
+{
+  #pragma omp parallel for simd lastprivate (conditional: x) schedule(simd: dynamic, 16)
+  for (int i = 0; i < 128; i++)
+    if (a[i])
+      x = a[i] + 5;
+  return x;
+}
+
+int
+main ()
+{
+  int a[128], b[128], i;
+  for (i = 0; i < 128; i++)
+    {
+      a[i] = ((i % 11) == 2) ? i + 10 : 0;
+      asm volatile ("" : "+g" (i));
+      b[i] = ((i % 13) == 5) ? i * 2 : 0;
+    }
+  if (foo (a) != 133)
+    __builtin_abort ();
+  if (bar (b, a) != 244 || v != 143)
+    __builtin_abort ();
+  if (baz (b) != 249)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-9.c b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-9.c
new file mode 100644
index 00000000000..746b2a74c97
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-9.c
@@ -0,0 +1,60 @@
+/* { dg-do run } */
+
+int v, x;
+
+__attribute__((noipa)) void
+foo (int *a)
+{
+  #pragma omp for simd lastprivate (conditional: x) schedule(simd: static) if (simd: 0)
+  for (int i = 0; i < 128; i++)
+    if (a[i])
+      x = a[i];
+}
+
+__attribute__((noipa)) void
+bar (int *a, int *b)
+{
+  #pragma omp for simd lastprivate (conditional: x, v) schedule(static, 16) simdlen(1)
+  for (int i = 16; i < 128; ++i)
+    {
+      if (a[i])
+	x = a[i];
+      if (b[i])
+	v = b[i] + 10;
+    }
+}
+
+__attribute__((noipa)) void
+baz (int *a)
+{
+  #pragma omp for simd lastprivate (conditional: x) schedule(simd: dynamic, 16) if (0)
+  for (int i = 0; i < 128; i++)
+    if (a[i])
+      x = a[i] + 5;
+}
+
+int
+main ()
+{
+  int a[128], b[128], i;
+  for (i = 0; i < 128; i++)
+    {
+      a[i] = ((i % 11) == 2) ? i + 10 : 0;
+      asm volatile ("" : "+g" (i));
+      b[i] = ((i % 13) == 5) ? i * 2 : 0;
+    }
+  #pragma omp parallel
+  foo (a);
+  if (x != 133)
+    __builtin_abort ();
+  x = -3;
+  #pragma omp parallel
+  bar (b, a);
+  if (x != 244 || v != 143)
+    __builtin_abort ();
+  #pragma omp parallel
+  baz (b);
+  if (x != 249)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/loop-1.c b/libgomp/testsuite/libgomp.c-c++-common/loop-1.c
new file mode 100644
index 00000000000..de696081d16
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/loop-1.c
@@ -0,0 +1,127 @@
+extern
+#ifdef __cplusplus
+"C"
+#endif
+void abort (void);
+#define N 256
+int r;
+
+void
+foo (int *a)
+{
+  int i, j;
+  #pragma omp loop bind(thread) order(concurrent) private (j) lastprivate (i) reduction(+:r) collapse(1)
+  for (i = 0; i < N; i++)
+    {
+      j = i - 2;
+      a[i] = j;
+      r += j;
+    }
+}
+
+void
+bar (int *a)
+{
+  int i, j;
+  #pragma omp loop bind(parallel) order(concurrent) private (j) lastprivate (i) reduction(+:r) collapse(1)
+  for (i = 0; i < N; i++)
+    {
+      j = i;
+      a[i] = j;
+      r += j;
+    }
+}
+
+void
+baz (int *a)
+{
+  int i, j;
+  #pragma omp loop bind(teams) order(concurrent) private (j) lastprivate (i) reduction(+:r)
+  for (i = 0; i < N; i++)
+    {
+      j = i + 2;
+      a[i] = j;
+      r += j;
+    }
+}
+
+int
+main ()
+{
+  int a[N], i, j;
+  foo (a);
+  for (i = 0; i < N; ++i)
+    if (a[i] != i - 2)
+      abort ();
+    else
+      a[i] = -35;
+  if (r != N * (N - 5) / 2)
+    abort ();
+  else
+    r = 0;
+  bar (a);
+  for (i = 0; i < N; ++i)
+    if (a[i] != i)
+      abort ();
+    else
+      a[i] = -35;
+  if (r != N * (N - 1) / 2)
+    abort ();
+  else
+    r = 0;
+  #pragma omp parallel loop private (j) lastprivate (i) reduction(+:r)
+  for (i = 0; i < N; i++)
+    {
+      j = i + 4;
+      a[i] = j;
+      r += j;
+    }
+  if (i != N)
+    abort ();
+  for (i = 0; i < N; ++i)
+    if (a[i] != i + 4)
+      abort ();
+    else
+      a[i] = -35;
+  if (r != N * (N + 7) / 2)
+    abort ();
+  else
+    r = 0;
+  #pragma omp parallel
+  bar (a);
+  for (i = 0; i < N; ++i)
+    if (a[i] != i)
+      abort ();
+    else
+      a[i] = -35;
+  if (r != N * (N - 1) / 2)
+    abort ();
+  else
+    r = 0;
+  #pragma omp teams
+  baz (a);
+  for (i = 0; i < N; ++i)
+    if (a[i] != i + 2)
+      abort ();
+    else
+      a[i] = -35;
+  if (r != N * (N + 3) / 2)
+    abort ();
+  else
+    r = 0;
+  #pragma omp teams loop order(concurrent) private (j) lastprivate (i) reduction(+:r) collapse(1)
+  for (i = 0; i < N; i++)
+    {
+      j = i - 4;
+      a[i] = j;
+      r += j;
+    }
+  if (i != N)
+    abort ();
+  for (i = 0; i < N; ++i)
+    if (a[i] != i - 4)
+      abort ();
+  if (r != N * (N - 9) / 2)
+    abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/pr39591-1.c b/libgomp/testsuite/libgomp.c/pr39591-1.c
index df326f85424..a22bc337819 100644
--- a/libgomp/testsuite/libgomp.c/pr39591-1.c
+++ b/libgomp/testsuite/libgomp.c/pr39591-1.c
@@ -3,7 +3,7 @@
 
 extern void abort (void);
 
-int err;
+int e;
 
 int
 main (void)
@@ -23,10 +23,10 @@ main (void)
 	for (j = 0; j < sizeof array / sizeof array[0]; j++)
 	  if (array[j] != 0x55555555)
 #pragma omp atomic
-	    err++;
+	    e++;
       }
   }
-  if (err)
+  if (e)
     abort ();
   return 0;
 }
diff --git a/libgomp/testsuite/libgomp.c/pr39591-2.c b/libgomp/testsuite/libgomp.c/pr39591-2.c
index 2fe6421aef4..ba8b862f49c 100644
--- a/libgomp/testsuite/libgomp.c/pr39591-2.c
+++ b/libgomp/testsuite/libgomp.c/pr39591-2.c
@@ -3,7 +3,7 @@
 
 extern void abort (void);
 
-int err;
+int e;
 
 void __attribute__((noinline))
 foo (int *array)
@@ -14,7 +14,7 @@ foo (int *array)
     for (j = 0; j < 40; j++)
       if (array[j] != 0x55555555)
 #pragma omp atomic
-	err++;
+	e++;
   }
 }
 
@@ -32,7 +32,7 @@ main (void)
     for (i = 0; i < 50; i++)
       foo (array);
   }
-  if (err)
+  if (e)
     abort ();
   return 0;
 }
diff --git a/libgomp/testsuite/libgomp.c/pr39591-3.c b/libgomp/testsuite/libgomp.c/pr39591-3.c
index 81e8ca8e497..590553437ea 100644
--- a/libgomp/testsuite/libgomp.c/pr39591-3.c
+++ b/libgomp/testsuite/libgomp.c/pr39591-3.c
@@ -3,7 +3,7 @@
 
 extern void abort (void);
 
-int err, a[40];
+int e, a[40];
 
 void __attribute__((noinline))
 foo (int *array)
@@ -14,7 +14,7 @@ foo (int *array)
     for (j = 0; j < 40; j++)
       if (array[j] != 0x55555555)
 #pragma omp atomic
-	err++;
+	e++;
   }
 }
 
@@ -33,7 +33,7 @@ main (void)
     for (i = 0; i < 50; i++)
       foo (a);
   }
-  if (err)
+  if (e)
     abort ();
   return 0;
 }
diff --git a/libgomp/testsuite/libgomp.c/pr90779.c b/libgomp/testsuite/libgomp.c/pr90779.c
new file mode 100644
index 00000000000..0dd1c105a38
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/pr90779.c
@@ -0,0 +1,18 @@
+/* PR middle-end/90779 */
+
+extern void abort (void);
+
+int
+main ()
+{
+  int i, j;
+  for (i = 0; i < 2; ++i)
+    #pragma omp target map(from: j)
+    {
+      static int k = 5;
+      j = ++k;
+    }
+  if (j != 7)
+    abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/private-1.c b/libgomp/testsuite/libgomp.c/private-1.c
index 1d3659b25fa..10c092a12c6 100644
--- a/libgomp/testsuite/libgomp.c/private-1.c
+++ b/libgomp/testsuite/libgomp.c/private-1.c
@@ -20,7 +20,7 @@ f1 (int i, int j, int k)
 }
 
 int v1 = 1, v2 = 2, v5 = 5;
-int err;
+int e;
 
 void
 f2 (void)
@@ -35,11 +35,11 @@ f2 (void)
       #pragma omp parallel num_threads(1) firstprivate(v1, v2, v3, v4)
 	{
 	  if (++v1 != 8 || ++v2 != 3 || ++v3 != 4 || ++v4 != 5 || ++v5 != 6)
-	    err = 1;
+	    e = 1;
 	}
       if (v1 != 7 || v2 != 2 || v3 != 3 || v4 != 4 || v5 != 6)
 	abort ();
-      if (err)
+      if (e)
 	abort ();
     }
   }
diff --git a/libgomp/testsuite/libgomp.c/scan-1.c b/libgomp/testsuite/libgomp.c/scan-1.c
new file mode 100644
index 00000000000..dd34f33a694
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-1.c
@@ -0,0 +1,115 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-10.c b/libgomp/testsuite/libgomp.c/scan-10.c
new file mode 100644
index 00000000000..0005ce109b2
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-10.c
@@ -0,0 +1,116 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+int r, a[1024], b[1024], x, y, z;
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for reduction (inscan, +:r) lastprivate (conditional: z) firstprivate (x) private (y)
+  for (int i = 0; i < 1024; i++)
+    {
+      { b[i] = r; if ((i & 1) == 0 && i < 937) z = r; }
+      #pragma omp scan exclusive(r)
+      { y = a[i]; r += y + x + 12; }
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, +:s) firstprivate (x) private (y) lastprivate (z)
+  for (int i = 0; i < 1024; i++)
+    {
+      { y = s; b[i] = y + x + 12; }
+      #pragma omp scan exclusive(s)
+      { y = 2 * a[i]; s += y; z = y; }
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for reduction (inscan, +:r) firstprivate (x) lastprivate (x)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      { r += a[i] + x + 12; if (i == 1023) x = 29; }
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for reduction (inscan, +:s) lastprivate (conditional: x, y)
+  for (int i = 0; i < 1024; i++)
+    {
+      { b[i] = s; if ((a[i] & 1) == 0 && i < 829) y = a[i]; }
+      #pragma omp scan exclusive(s)
+      { s += 2 * a[i]; if ((a[i] & 1) == 1 && i < 825) x = a[i]; }
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  x = -12;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2 || x != -12 || z != b[936])
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar () != 1024 * 1023 || x != -12 || z != 2 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2 || x != 29)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux () != 1024 * 1023 || x != 823 || y != 828)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-11.c b/libgomp/testsuite/libgomp.c/scan-11.c
new file mode 100644
index 00000000000..3bc2d3a1d7c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-11.c
@@ -0,0 +1,119 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for simd reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, +:s) if (0)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for simd reduction (inscan, +:r) simdlen(1)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for simd reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-12.c b/libgomp/testsuite/libgomp.c/scan-12.c
new file mode 100644
index 00000000000..f769d17e8ca
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-12.c
@@ -0,0 +1,121 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+
+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for simd reduction (inscan, foo:r) simdlen (1)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for simd reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-13.c b/libgomp/testsuite/libgomp.c/scan-13.c
new file mode 100644
index 00000000000..9cf1623d262
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-13.c
@@ -0,0 +1,92 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+float r = 1.0f, a[1024], b[1024];
+
+__attribute__((noipa)) void
+foo (float *a, float *b)
+{
+  #pragma omp for simd reduction (inscan, *:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r *= a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) float
+bar (void)
+{
+  float s = -__builtin_inff ();
+  #pragma omp parallel for simd reduction (inscan, max:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s = s > a[i] ? s : a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  float s = 1.0f;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (i < 80)
+	a[i] = (i & 1) ? 0.25f : 0.5f;
+      else if (i < 200)
+	a[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;
+      else if (i < 280)
+	a[i] = (i & 1) ? 0.25f : 0.5f;
+      else if (i < 380)
+	a[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;
+      else
+	switch (i % 6)
+	  {
+	  case 0: a[i] = 0.25f; break;
+	  case 1: a[i] = 2.0f; break;
+	  case 2: a[i] = -1.0f; break;
+	  case 3: a[i] = -4.0f; break;
+	  case 4: a[i] = 0.5f; break;
+	  case 5: a[i] = 1.0f; break;
+	  default: a[i] = 0.0f; break;
+	  }
+      b[i] = -19.0f;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r * 16384.0f != 0.125f)
+    abort ();
+  float m = -175.25f;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s *= a[i];
+      if (b[i] != s)
+	abort ();
+      else
+	{
+	  a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);
+	  b[i] = -231.75f;
+	  m += 0.75f;
+	}
+    }
+  if (bar () != 592.0f)
+    abort ();
+  s = -__builtin_inff ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (s < a[i])
+	s = a[i];
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-14.c b/libgomp/testsuite/libgomp.c/scan-14.c
new file mode 100644
index 00000000000..3a20a75b2e9
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-14.c
@@ -0,0 +1,183 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+unsigned short r2, b2[1024];
+unsigned char r3, b3[1024];
+
+__attribute__((noipa)) void
+foo (int *a, int *b, unsigned short *b2, unsigned char *b3)
+{
+  #pragma omp for simd reduction (inscan, +:r, r2, r3) if (simd:0)
+  for (int i = 0; i < 1024; i++)
+    {
+      { r += a[i]; r2 += a[i]; r3 += a[i]; }
+      #pragma omp scan inclusive(r, r2, r3)
+      {
+	b[i] = r;
+	b2[i] = r2;
+	b3[i] = r3;
+      }
+    }
+}
+
+__attribute__((noipa)) int
+bar (unsigned short *s2p, unsigned char *s3p)
+{
+  int s = 0;
+  unsigned short s2 = 0;
+  unsigned char s3 = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, +:s, s2, s3) simdlen (1)
+  for (int i = 0; i < 1024; i++)
+    {
+      {
+	s += 2 * a[i];
+	s2 += 2 * a[i];
+	s3 += 2 * a[i];
+      }
+      #pragma omp scan inclusive(s, s2, s3)
+      { b[i] = s; b2[i] = s2; b3[i] = s3; }
+    }
+  *s2p = s2;
+  *s3p = s3;
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, unsigned short *b2, unsigned char *b3)
+{
+  #pragma omp parallel for simd reduction (inscan, +:r, r2, r3)
+  for (int i = 0; i < 1024; i++)
+    {
+      {
+	r += a[i];
+	r2 += a[i];
+	r3 += a[i];
+      }
+      #pragma omp scan inclusive(r, r2, r3)
+      {
+	b[i] = r;
+	b2[i] = r2;
+	b3[i] = r3;
+      }
+    }
+}
+
+__attribute__((noipa)) int
+qux (unsigned short *s2p, unsigned char *s3p)
+{
+  int s = 0;
+  unsigned short s2 = 0;
+  unsigned char s3 = 0;
+  #pragma omp parallel for simd reduction (inscan, +:s, s2, s3)
+  for (int i = 0; i < 1024; i++)
+    {
+      { s += 2 * a[i]; s2 += 2 * a[i]; s3 += 2 * a[i]; }
+      #pragma omp scan inclusive(s, s2, s3)
+      { b[i] = s; b2[i] = s2; b3[i] = s3; }
+    }
+  *s2p = s2;
+  *s3p = s3;
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  unsigned short s2;
+  unsigned char s3;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      b2[i] = -1;
+      b3[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, b2, b3);
+  if (r != 1024 * 1023 / 2
+      || r2 != (unsigned short) r
+      || r3 != (unsigned char) r)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = 25;
+	  b2[i] = 24;
+	  b3[i] = 26;
+	}
+    }
+  if (bar (&s2, &s3) != 1024 * 1023)
+    abort ();
+  if (s2 != (unsigned short) (1024 * 1023)
+      || s3 != (unsigned char) (1024 * 1023))
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = -1;
+	  b2[i] = -1;
+	  b3[i] = -1;
+	}
+    }
+  r = 0;
+  r2 = 0;
+  r3 = 0;
+  baz (a, b, b2, b3);
+  if (r != 1024 * 1023 / 2
+      || r2 != (unsigned short) r
+      || r3 != (unsigned char) r)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = 25;
+	  b2[i] = 24;
+	  b3[i] = 26;
+	}
+    }
+  s2 = 0;
+  s3 = 0;
+  if (qux (&s2, &s3) != 1024 * 1023)
+    abort ();
+  if (s2 != (unsigned short) (1024 * 1023)
+      || s3 != (unsigned char) (1024 * 1023))
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-15.c b/libgomp/testsuite/libgomp.c/scan-15.c
new file mode 100644
index 00000000000..c0c6dfd3b99
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-15.c
@@ -0,0 +1,119 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for simd reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for simd simdlen (1) reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-16.c b/libgomp/testsuite/libgomp.c/scan-16.c
new file mode 100644
index 00000000000..8b816781dd8
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-16.c
@@ -0,0 +1,121 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+
+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for simd reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for simd simdlen (1) reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for simd reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-17.c b/libgomp/testsuite/libgomp.c/scan-17.c
new file mode 100644
index 00000000000..57e4390462a
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-17.c
@@ -0,0 +1,90 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+float r = 1.0f, a[1024], b[1024];
+
+__attribute__((noipa)) void
+foo (float *a, float *b)
+{
+  #pragma omp for simd reduction (inscan, *:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r *= a[i];
+    }
+}
+
+__attribute__((noipa)) float
+bar (void)
+{
+  float s = -__builtin_inff ();
+  #pragma omp parallel for simd reduction (inscan, max:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s = s > a[i] ? s : a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  float s = 1.0f;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (i < 80)
+	a[i] = (i & 1) ? 0.25f : 0.5f;
+      else if (i < 200)
+	a[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;
+      else if (i < 280)
+	a[i] = (i & 1) ? 0.25f : 0.5f;
+      else if (i < 380)
+	a[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;
+      else
+	switch (i % 6)
+	  {
+	  case 0: a[i] = 0.25f; break;
+	  case 1: a[i] = 2.0f; break;
+	  case 2: a[i] = -1.0f; break;
+	  case 3: a[i] = -4.0f; break;
+	  case 4: a[i] = 0.5f; break;
+	  case 5: a[i] = 1.0f; break;
+	  default: a[i] = 0.0f; break;
+	  }
+      b[i] = -19.0f;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r * 16384.0f != 0.125f)
+    abort ();
+  float m = -175.25f;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -231.75f;
+      s *= a[i];
+      a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);
+      m += 0.75f;
+    }
+  if (bar () != 592.0f)
+    abort ();
+  s = -__builtin_inff ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      if (s < a[i])
+	s = a[i];
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-18.c b/libgomp/testsuite/libgomp.c/scan-18.c
new file mode 100644
index 00000000000..ae467fc7bdb
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-18.c
@@ -0,0 +1,183 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+unsigned short r2, b2[1024];
+unsigned char r3, b3[1024];
+
+__attribute__((noipa)) void
+foo (int *a, int *b, unsigned short *b2, unsigned char *b3)
+{
+  #pragma omp for simd reduction (inscan, +:r, r2, r3)
+  for (int i = 0; i < 1024; i++)
+    {
+      {
+	b[i] = r;
+	b2[i] = r2;
+	b3[i] = r3;
+      }
+      #pragma omp scan exclusive(r, r2, r3)
+      { r += a[i]; r2 += a[i]; r3 += a[i]; }
+    }
+}
+
+__attribute__((noipa)) int
+bar (unsigned short *s2p, unsigned char *s3p)
+{
+  int s = 0;
+  unsigned short s2 = 0;
+  unsigned char s3 = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, +:s, s2, s3)
+  for (int i = 0; i < 1024; i++)
+    {
+      { b[i] = s; b2[i] = s2; b3[i] = s3; }
+      #pragma omp scan exclusive(s, s2, s3)
+      {
+	s += 2 * a[i];
+	s2 += 2 * a[i];
+	s3 += 2 * a[i];
+      }
+    }
+  *s2p = s2;
+  *s3p = s3;
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, unsigned short *b2, unsigned char *b3)
+{
+  #pragma omp parallel for simd reduction (inscan, +:r, r2, r3) if (simd: 0)
+  for (int i = 0; i < 1024; i++)
+    {
+      {
+	b[i] = r;
+	b2[i] = r2;
+	b3[i] = r3;
+      }
+      #pragma omp scan exclusive(r, r2, r3)
+      {
+	r += a[i];
+	r2 += a[i];
+	r3 += a[i];
+      }
+    }
+}
+
+__attribute__((noipa)) int
+qux (unsigned short *s2p, unsigned char *s3p)
+{
+  int s = 0;
+  unsigned short s2 = 0;
+  unsigned char s3 = 0;
+  #pragma omp parallel for simd simdlen (1) reduction (inscan, +:s, s2, s3)
+  for (int i = 0; i < 1024; i++)
+    {
+      { b[i] = s; b2[i] = s2; b3[i] = s3; }
+      #pragma omp scan exclusive(s, s2, s3)
+      { s += 2 * a[i]; s2 += 2 * a[i]; s3 += 2 * a[i]; }
+    }
+  *s2p = s2;
+  *s3p = s3;
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  unsigned short s2;
+  unsigned char s3;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      b2[i] = -1;
+      b3[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, b2, b3);
+  if (r != 1024 * 1023 / 2
+      || r2 != (unsigned short) r
+      || r3 != (unsigned char) r)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = 25;
+	  b2[i] = 24;
+	  b3[i] = 26;
+	}
+      s += i;
+    }
+  if (bar (&s2, &s3) != 1024 * 1023)
+    abort ();
+  if (s2 != (unsigned short) (1024 * 1023)
+      || s3 != (unsigned char) (1024 * 1023))
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = -1;
+	  b2[i] = -1;
+	  b3[i] = -1;
+	}
+      s += 2 * i;
+    }
+  r = 0;
+  r2 = 0;
+  r3 = 0;
+  baz (a, b, b2, b3);
+  if (r != 1024 * 1023 / 2
+      || r2 != (unsigned short) r
+      || r3 != (unsigned char) r)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = 25;
+	  b2[i] = 24;
+	  b3[i] = 26;
+	}
+      s += i;
+    }
+  s2 = 0;
+  s3 = 0;
+  if (qux (&s2, &s3) != 1024 * 1023)
+    abort ();
+  if (s2 != (unsigned short) (1024 * 1023)
+      || s3 != (unsigned char) (1024 * 1023))
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      s += 2 * i;
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-19.c b/libgomp/testsuite/libgomp.c/scan-19.c
new file mode 100644
index 00000000000..b4205012902
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-19.c
@@ -0,0 +1,120 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+int r, a[1024], b[1024], x, y, z;
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for simd reduction (inscan, +:r) lastprivate (conditional: z) firstprivate (x) private (y)
+  for (int i = 0; i < 1024; i++)
+    {
+      { y = a[i]; r += y + x + 12; }
+      #pragma omp scan inclusive(r)
+      { b[i] = r; if ((i & 1) == 0 && i < 937) z = r; }
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, +:s) firstprivate (x) private (y) lastprivate (z)
+  for (int i = 0; i < 1024; i++)
+    {
+      { y = 2 * a[i]; s += y; z = y; }
+      #pragma omp scan inclusive(s)
+      { y = s; b[i] = y + x + 12; }
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for simd reduction (inscan, +:r) firstprivate (x) lastprivate (x) if (simd: 0)
+  for (int i = 0; i < 1024; i++)
+    {
+      { r += a[i]; if (i == 1023) x = 29; }
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for simd simdlen (1) reduction (inscan, +:s) lastprivate (conditional: x, y)
+  for (int i = 0; i < 1024; i++)
+    {
+      { s += 2 * a[i]; if ((a[i] & 1) == 1 && i < 825) x = a[i]; }
+      #pragma omp scan inclusive(s)
+      { b[i] = s; if ((a[i] & 1) == 0 && i < 829) y = a[i]; }
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  x = -12;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2 || x != -12 || z != b[936])
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023 || x != -12 || z != 2 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2 || x != 29)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023 || x != 823 || y != 828)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-2.c b/libgomp/testsuite/libgomp.c/scan-2.c
new file mode 100644
index 00000000000..476bbedfd60
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-2.c
@@ -0,0 +1,117 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+
+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r += a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s += 2 * a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-20.c b/libgomp/testsuite/libgomp.c/scan-20.c
new file mode 100644
index 00000000000..3ef88d78d9d
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-20.c
@@ -0,0 +1,120 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" { target sse2_runtime } } } */
+
+extern void abort (void);
+int r, a[1024], b[1024], x, y, z;
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for simd reduction (inscan, +:r) lastprivate (conditional: z) firstprivate (x) private (y) simdlen(1)
+  for (int i = 0; i < 1024; i++)
+    {
+      { b[i] = r; if ((i & 1) == 0 && i < 937) z = r; }
+      #pragma omp scan exclusive(r)
+      { y = a[i]; r += y + x + 12; }
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for simd reduction (inscan, +:s) firstprivate (x) private (y) lastprivate (z) if (0)
+  for (int i = 0; i < 1024; i++)
+    {
+      { y = s; b[i] = y + x + 12; }
+      #pragma omp scan exclusive(s)
+      { y = 2 * a[i]; s += y; z = y; }
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for simd reduction (inscan, +:r) firstprivate (x) lastprivate (x)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      { r += a[i]; if (i == 1023) x = 29; }
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for simd reduction (inscan, +:s) lastprivate (conditional: x, y)
+  for (int i = 0; i < 1024; i++)
+    {
+      { b[i] = s; if ((a[i] & 1) == 0 && i < 829) y = a[i]; }
+      #pragma omp scan exclusive(s)
+      { s += 2 * a[i]; if ((a[i] & 1) == 1 && i < 825) x = a[i]; }
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  x = -12;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2 || x != -12 || z != b[936])
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar () != 1024 * 1023 || x != -12 || z != 2 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2 || x != 29)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux () != 1024 * 1023 || x != 823 || y != 828)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-21.c b/libgomp/testsuite/libgomp.c/scan-21.c
new file mode 100644
index 00000000000..c531961ffe4
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-21.c
@@ -0,0 +1,6 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-require-effective-target avx_runtime } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details -msse2 -mno-sse3" } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" } } */
+
+#include "scan-13.c"
diff --git a/libgomp/testsuite/libgomp.c/scan-22.c b/libgomp/testsuite/libgomp.c/scan-22.c
new file mode 100644
index 00000000000..96fead7d54d
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-22.c
@@ -0,0 +1,6 @@
+/* { dg-require-effective-target size32plus } */
+/* { dg-require-effective-target avx_runtime } */
+/* { dg-additional-options "-O2 -fopenmp -fdump-tree-vect-details -msse2 -mno-sse3" } */
+/* { dg-final { scan-tree-dump-times "vectorized \[2-6] loops" 2 "vect" } } */
+
+#include "scan-17.c"
diff --git a/libgomp/testsuite/libgomp.c/scan-3.c b/libgomp/testsuite/libgomp.c/scan-3.c
new file mode 100644
index 00000000000..2e1fcadba04
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-3.c
@@ -0,0 +1,88 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+float r = 1.0f, a[1024], b[1024];
+
+__attribute__((noipa)) void
+foo (float *a, float *b)
+{
+  #pragma omp for reduction (inscan, *:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      r *= a[i];
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) float
+bar (void)
+{
+  float s = -__builtin_inff ();
+  #pragma omp parallel for reduction (inscan, max:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      s = s > a[i] ? s : a[i];
+      #pragma omp scan inclusive(s)
+      b[i] = s;
+    }
+  return s;
+}
+
+int
+main ()
+{
+  float s = 1.0f;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (i < 80)
+	a[i] = (i & 1) ? 0.25f : 0.5f;
+      else if (i < 200)
+	a[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;
+      else if (i < 280)
+	a[i] = (i & 1) ? 0.25f : 0.5f;
+      else if (i < 380)
+	a[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;
+      else
+	switch (i % 6)
+	  {
+	  case 0: a[i] = 0.25f; break;
+	  case 1: a[i] = 2.0f; break;
+	  case 2: a[i] = -1.0f; break;
+	  case 3: a[i] = -4.0f; break;
+	  case 4: a[i] = 0.5f; break;
+	  case 5: a[i] = 1.0f; break;
+	  default: a[i] = 0.0f; break;
+	  }
+      b[i] = -19.0f;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r * 16384.0f != 0.125f)
+    abort ();
+  float m = -175.25f;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s *= a[i];
+      if (b[i] != s)
+	abort ();
+      else
+	{
+	  a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);
+	  b[i] = -231.75f;
+	  m += 0.75f;
+	}
+    }
+  if (bar () != 592.0f)
+    abort ();
+  s = -__builtin_inff ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (s < a[i])
+	s = a[i];
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-4.c b/libgomp/testsuite/libgomp.c/scan-4.c
new file mode 100644
index 00000000000..b1e999352fa
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-4.c
@@ -0,0 +1,179 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+unsigned short r2, b2[1024];
+unsigned char r3, b3[1024];
+
+__attribute__((noipa)) void
+foo (int *a, int *b, unsigned short *b2, unsigned char *b3)
+{
+  #pragma omp for reduction (inscan, +:r, r2, r3)
+  for (int i = 0; i < 1024; i++)
+    {
+      { r += a[i]; r2 += a[i]; r3 += a[i]; }
+      #pragma omp scan inclusive(r, r2, r3)
+      {
+	b[i] = r;
+	b2[i] = r2;
+	b3[i] = r3;
+      }
+    }
+}
+
+__attribute__((noipa)) int
+bar (unsigned short *s2p, unsigned char *s3p)
+{
+  int s = 0;
+  unsigned short s2 = 0;
+  unsigned char s3 = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, +:s, s2, s3)
+  for (int i = 0; i < 1024; i++)
+    {
+      {
+	s += 2 * a[i];
+	s2 += 2 * a[i];
+	s3 += 2 * a[i];
+      }
+      #pragma omp scan inclusive(s, s2, s3)
+      { b[i] = s; b2[i] = s2; b3[i] = s3; }
+    }
+  *s2p = s2;
+  *s3p = s3;
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, unsigned short *b2, unsigned char *b3)
+{
+  #pragma omp parallel for reduction (inscan, +:r, r2, r3)
+  for (int i = 0; i < 1024; i++)
+    {
+      {
+	r += a[i];
+	r2 += a[i];
+	r3 += a[i];
+      }
+      #pragma omp scan inclusive(r, r2, r3)
+      {
+	b[i] = r;
+	b2[i] = r2;
+	b3[i] = r3;
+      }
+    }
+}
+
+__attribute__((noipa)) int
+qux (unsigned short *s2p, unsigned char *s3p)
+{
+  int s = 0;
+  unsigned short s2 = 0;
+  unsigned char s3 = 0;
+  #pragma omp parallel for reduction (inscan, +:s, s2, s3)
+  for (int i = 0; i < 1024; i++)
+    {
+      { s += 2 * a[i]; s2 += 2 * a[i]; s3 += 2 * a[i]; }
+      #pragma omp scan inclusive(s, s2, s3)
+      { b[i] = s; b2[i] = s2; b3[i] = s3; }
+    }
+  *s2p = s2;
+  *s3p = s3;
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  unsigned short s2;
+  unsigned char s3;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      b2[i] = -1;
+      b3[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, b2, b3);
+  if (r != 1024 * 1023 / 2
+      || r2 != (unsigned short) r
+      || r3 != (unsigned char) r)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = 25;
+	  b2[i] = 24;
+	  b3[i] = 26;
+	}
+    }
+  if (bar (&s2, &s3) != 1024 * 1023)
+    abort ();
+  if (s2 != (unsigned short) (1024 * 1023)
+      || s3 != (unsigned char) (1024 * 1023))
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = -1;
+	  b2[i] = -1;
+	  b3[i] = -1;
+	}
+    }
+  r = 0;
+  r2 = 0;
+  r3 = 0;
+  baz (a, b, b2, b3);
+  if (r != 1024 * 1023 / 2
+      || r2 != (unsigned short) r
+      || r3 != (unsigned char) r)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = 25;
+	  b2[i] = 24;
+	  b3[i] = 26;
+	}
+    }
+  s2 = 0;
+  s3 = 0;
+  if (qux (&s2, &s3) != 1024 * 1023)
+    abort ();
+  if (s2 != (unsigned short) (1024 * 1023)
+      || s3 != (unsigned char) (1024 * 1023))
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-5.c b/libgomp/testsuite/libgomp.c/scan-5.c
new file mode 100644
index 00000000000..c50418264ef
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-5.c
@@ -0,0 +1,115 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for reduction (inscan, +:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for reduction (inscan, +:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-6.c b/libgomp/testsuite/libgomp.c/scan-6.c
new file mode 100644
index 00000000000..9434ebb2b5a
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-6.c
@@ -0,0 +1,117 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+
+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for reduction (inscan, foo:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r += a[i];
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for reduction (inscan, foo:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s += 2 * a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+      s += i;
+    }
+  if (bar () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+      s += 2 * i;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+      s += i;
+    }
+  if (qux () != 1024 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      s += 2 * i;
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-7.c b/libgomp/testsuite/libgomp.c/scan-7.c
new file mode 100644
index 00000000000..20b7071e8f6
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-7.c
@@ -0,0 +1,86 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+float r = 1.0f, a[1024], b[1024];
+
+__attribute__((noipa)) void
+foo (float *a, float *b)
+{
+  #pragma omp for reduction (inscan, *:r)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = r;
+      #pragma omp scan exclusive(r)
+      r *= a[i];
+    }
+}
+
+__attribute__((noipa)) float
+bar (void)
+{
+  float s = -__builtin_inff ();
+  #pragma omp parallel for reduction (inscan, max:s)
+  for (int i = 0; i < 1024; i++)
+    {
+      b[i] = s;
+      #pragma omp scan exclusive(s)
+      s = s > a[i] ? s : a[i];
+    }
+  return s;
+}
+
+int
+main ()
+{
+  float s = 1.0f;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (i < 80)
+	a[i] = (i & 1) ? 0.25f : 0.5f;
+      else if (i < 200)
+	a[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;
+      else if (i < 280)
+	a[i] = (i & 1) ? 0.25f : 0.5f;
+      else if (i < 380)
+	a[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;
+      else
+	switch (i % 6)
+	  {
+	  case 0: a[i] = 0.25f; break;
+	  case 1: a[i] = 2.0f; break;
+	  case 2: a[i] = -1.0f; break;
+	  case 3: a[i] = -4.0f; break;
+	  case 4: a[i] = 0.5f; break;
+	  case 5: a[i] = 1.0f; break;
+	  default: a[i] = 0.0f; break;
+	  }
+      b[i] = -19.0f;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r * 16384.0f != 0.125f)
+    abort ();
+  float m = -175.25f;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -231.75f;
+      s *= a[i];
+      a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);
+      m += 0.75f;
+    }
+  if (bar () != 592.0f)
+    abort ();
+  s = -__builtin_inff ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s)
+	abort ();
+      if (s < a[i])
+	s = a[i];
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-8.c b/libgomp/testsuite/libgomp.c/scan-8.c
new file mode 100644
index 00000000000..f09c85c36e7
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-8.c
@@ -0,0 +1,179 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+int r, a[1024], b[1024];
+unsigned short r2, b2[1024];
+unsigned char r3, b3[1024];
+
+__attribute__((noipa)) void
+foo (int *a, int *b, unsigned short *b2, unsigned char *b3)
+{
+  #pragma omp for reduction (inscan, +:r, r2, r3)
+  for (int i = 0; i < 1024; i++)
+    {
+      {
+	b[i] = r;
+	b2[i] = r2;
+	b3[i] = r3;
+      }
+      #pragma omp scan exclusive(r, r2, r3)
+      { r += a[i]; r2 += a[i]; r3 += a[i]; }
+    }
+}
+
+__attribute__((noipa)) int
+bar (unsigned short *s2p, unsigned char *s3p)
+{
+  int s = 0;
+  unsigned short s2 = 0;
+  unsigned char s3 = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, +:s, s2, s3)
+  for (int i = 0; i < 1024; i++)
+    {
+      { b[i] = s; b2[i] = s2; b3[i] = s3; }
+      #pragma omp scan exclusive(s, s2, s3)
+      {
+	s += 2 * a[i];
+	s2 += 2 * a[i];
+	s3 += 2 * a[i];
+      }
+    }
+  *s2p = s2;
+  *s3p = s3;
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b, unsigned short *b2, unsigned char *b3)
+{
+  #pragma omp parallel for reduction (inscan, +:r, r2, r3)
+  for (int i = 0; i < 1024; i++)
+    {
+      {
+	b[i] = r;
+	b2[i] = r2;
+	b3[i] = r3;
+      }
+      #pragma omp scan exclusive(r, r2, r3)
+      {
+	r += a[i];
+	r2 += a[i];
+	r3 += a[i];
+      }
+    }
+}
+
+__attribute__((noipa)) int
+qux (unsigned short *s2p, unsigned char *s3p)
+{
+  int s = 0;
+  unsigned short s2 = 0;
+  unsigned char s3 = 0;
+  #pragma omp parallel for reduction (inscan, +:s, s2, s3)
+  for (int i = 0; i < 1024; i++)
+    {
+      { b[i] = s; b2[i] = s2; b3[i] = s3; }
+      #pragma omp scan exclusive(s, s2, s3)
+      { s += 2 * a[i]; s2 += 2 * a[i]; s3 += 2 * a[i]; }
+    }
+  *s2p = s2;
+  *s3p = s3;
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  unsigned short s2;
+  unsigned char s3;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      b2[i] = -1;
+      b3[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b, b2, b3);
+  if (r != 1024 * 1023 / 2
+      || r2 != (unsigned short) r
+      || r3 != (unsigned char) r)
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = 25;
+	  b2[i] = 24;
+	  b3[i] = 26;
+	}
+      s += i;
+    }
+  if (bar (&s2, &s3) != 1024 * 1023)
+    abort ();
+  if (s2 != (unsigned short) (1024 * 1023)
+      || s3 != (unsigned char) (1024 * 1023))
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = -1;
+	  b2[i] = -1;
+	  b3[i] = -1;
+	}
+      s += 2 * i;
+    }
+  r = 0;
+  r2 = 0;
+  r3 = 0;
+  baz (a, b, b2, b3);
+  if (r != 1024 * 1023 / 2
+      || r2 != (unsigned short) r
+      || r3 != (unsigned char) r)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      else
+	{
+	  b[i] = 25;
+	  b2[i] = 24;
+	  b3[i] = 26;
+	}
+      s += i;
+    }
+  s2 = 0;
+  s3 = 0;
+  if (qux (&s2, &s3) != 1024 * 1023)
+    abort ();
+  if (s2 != (unsigned short) (1024 * 1023)
+      || s3 != (unsigned char) (1024 * 1023))
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      if (b[i] != s
+	  || b2[i] != (unsigned short) s
+	  || b3[i] != (unsigned char) s)
+	abort ();
+      s += 2 * i;
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/scan-9.c b/libgomp/testsuite/libgomp.c/scan-9.c
new file mode 100644
index 00000000000..822752306ae
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/scan-9.c
@@ -0,0 +1,116 @@
+/* { dg-require-effective-target size32plus } */
+
+extern void abort (void);
+int r, a[1024], b[1024], x, y, z;
+
+__attribute__((noipa)) void
+foo (int *a, int *b)
+{
+  #pragma omp for reduction (inscan, +:r) lastprivate (conditional: z) firstprivate (x) private (y)
+  for (int i = 0; i < 1024; i++)
+    {
+      { y = a[i]; r += y + x + 12; }
+      #pragma omp scan inclusive(r)
+      { b[i] = r; if ((i & 1) == 0 && i < 937) z = r; }
+    }
+}
+
+__attribute__((noipa)) int
+bar (void)
+{
+  int s = 0;
+  #pragma omp parallel
+  #pragma omp for reduction (inscan, +:s) firstprivate (x) private (y) lastprivate (z)
+  for (int i = 0; i < 1024; i++)
+    {
+      { y = 2 * a[i]; s += y; z = y; }
+      #pragma omp scan inclusive(s)
+      { y = s; b[i] = y + x + 12; }
+    }
+  return s;
+}
+
+__attribute__((noipa)) void
+baz (int *a, int *b)
+{
+  #pragma omp parallel for reduction (inscan, +:r) firstprivate (x) lastprivate (x)
+  for (int i = 0; i < 1024; i++)
+    {
+      { r += a[i] + x + 12; if (i == 1023) x = 29; }
+      #pragma omp scan inclusive(r)
+      b[i] = r;
+    }
+}
+
+__attribute__((noipa)) int
+qux (void)
+{
+  int s = 0;
+  #pragma omp parallel for reduction (inscan, +:s) lastprivate (conditional: x, y)
+  for (int i = 0; i < 1024; i++)
+    {
+      { s += 2 * a[i]; if ((a[i] & 1) == 1 && i < 825) x = a[i]; }
+      #pragma omp scan inclusive(s)
+      { b[i] = s; if ((a[i] & 1) == 0 && i < 829) y = a[i]; }
+    }
+  return s;
+}
+
+int
+main ()
+{
+  int s = 0;
+  x = -12;
+  for (int i = 0; i < 1024; ++i)
+    {
+      a[i] = i;
+      b[i] = -1;
+      asm ("" : "+g" (i));
+    }
+  #pragma omp parallel
+  foo (a, b);
+  if (r != 1024 * 1023 / 2 || x != -12 || z != b[936])
+    abort ();
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = 25;
+    }
+  if (bar () != 1024 * 1023 || x != -12 || z != 2 * 1023)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -1;
+    }
+  r = 0;
+  baz (a, b);
+  if (r != 1024 * 1023 / 2 || x != 29)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += i;
+      if (b[i] != s)
+	abort ();
+      else
+	b[i] = -25;
+    }
+  if (qux () != 1024 * 1023 || x != 823 || y != 828)
+    abort ();
+  s = 0;
+  for (int i = 0; i < 1024; ++i)
+    {
+      s += 2 * i;
+      if (b[i] != s)
+	abort ();
+    }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/target-18.c b/libgomp/testsuite/libgomp.c/target-18.c
index cbacaf6a77a..dd511fb98cb 100644
--- a/libgomp/testsuite/libgomp.c/target-18.c
+++ b/libgomp/testsuite/libgomp.c/target-18.c
@@ -1,9 +1,11 @@
 extern void abort (void);
+struct S { int e, f; };
 
 void
 foo (int n)
 {
-  int a[4] = { 0, 1, 2, 3 }, b[n];
+  int a[4] = { 0, 1, 2, 3 }, b[n], c = 4;
+  struct S d = { 5, 6 };
   int *p = a + 1, i, err;
   for (i = 0; i < n; i++)
     b[i] = 9 + i;
@@ -21,7 +23,7 @@ foo (int n)
   for (i = 0; i < 4; i++)
     a[i] = 23 + i;
   #pragma omp target data map(to:a)
-  #pragma omp target data use_device_ptr(a) map(from:err)
+  #pragma omp target data use_device_addr(a) map(from:err)
   #pragma omp target is_device_ptr(a) private(i) map(from:err)
   {
     err = 0;
@@ -32,7 +34,7 @@ foo (int n)
   if (err)
     abort ();
   #pragma omp target data map(to:b)
-  #pragma omp target data use_device_ptr(b) map(from:err)
+  #pragma omp target data use_device_addr(b) map(from:err)
   #pragma omp target is_device_ptr(b) private(i) map(from:err)
   {
     err = 0;
@@ -42,6 +44,28 @@ foo (int n)
   }
   if (err)
     abort ();
+  #pragma omp target data map(to:c)
+  #pragma omp target data use_device_addr(c) map(from:err)
+  {
+    int *q = &c;
+    #pragma omp target is_device_ptr(q) map(from:err)
+    {
+      err = *q != 4;
+    }
+  }
+  if (err)
+    abort ();
+  #pragma omp target data map(to:d)
+  #pragma omp target data use_device_addr(d) map(from:err)
+  {
+    struct S *r = &d;
+    #pragma omp target is_device_ptr(r) map(from:err)
+    {
+      err = r->e != 5 || r->f != 6;
+    }
+  }
+  if (err)
+    abort ();
 }
 
 int
diff --git a/libgomp/testsuite/libgomp.c/target-37.c b/libgomp/testsuite/libgomp.c/target-37.c
new file mode 100644
index 00000000000..b3cc6a25215
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/target-37.c
@@ -0,0 +1,71 @@
+extern void abort (void);
+struct S { int e, f; };
+
+void
+foo (int n)
+{
+  int a[4] = { 0, 1, 2, 3 }, b[n], c = 4;
+  struct S d = { 5, 6 };
+  int *p = a + 1, i, err;
+  for (i = 0; i < n; i++)
+    b[i] = 9 + i;
+  #pragma omp target data use_device_ptr(p) map(from:err) map(to:a)
+  #pragma omp target is_device_ptr(p) private(i) map(from:err)
+  {
+    err = 0;
+    for (i = 0; i < 4; i++)
+      if (p[i - 1] != i)
+	err = 1;
+  }
+  if (err)
+    abort ();
+  for (i = 0; i < 4; i++)
+    a[i] = 23 + i;
+  #pragma omp target data map(to:a) use_device_addr(a) map(from:err)
+  #pragma omp target is_device_ptr(a) private(i) map(from:err)
+  {
+    err = 0;
+    for (i = 0; i < 4; i++)
+      if (a[i] != 23 + i)
+	err = 1;
+  }
+  if (err)
+    abort ();
+  #pragma omp target data use_device_addr(b) map(from:err) map(to:b)
+  #pragma omp target is_device_ptr(b) private(i) map(from:err)
+  {
+    err = 0;
+    for (i = 0; i < 4; i++)
+      if (b[i] != 9 + i)
+	err = 1;
+  }
+  if (err)
+    abort ();
+  #pragma omp target data map(to:c) use_device_addr(c) map(from:err)
+  {
+    int *q = &c;
+    #pragma omp target is_device_ptr(q) map(from:err)
+    {
+      err = *q != 4;
+    }
+  }
+  if (err)
+    abort ();
+  #pragma omp target data use_device_addr(d) map(to:d) map(from:err)
+  {
+    struct S *r = &d;
+    #pragma omp target is_device_ptr(r) map(from:err)
+    {
+      err = r->e != 5 || r->f != 6;
+    }
+  }
+  if (err)
+    abort ();
+}
+
+int
+main ()
+{
+  foo (9);
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/target-print-1.c b/libgomp/testsuite/libgomp.c/target-print-1.c
new file mode 100644
index 00000000000..5857b875ced
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/target-print-1.c
@@ -0,0 +1,17 @@
+/* Ensure that printf on the offload device works.  */
+
+/* { dg-do run } */
+/* { dg-output "The answer is 42(\n|\r\n|\r)+" } */
+
+#include <stdio.h>
+
+int var = 42;
+
+int
+main ()
+{
+#pragma omp target
+    {
+      printf ("The answer is %d\n", var);
+    }
+}
diff --git a/libgomp/testsuite/libgomp.c/task-1.c b/libgomp/testsuite/libgomp.c/task-1.c
index 66f58a29b87..d17c3c61c2f 100644
--- a/libgomp/testsuite/libgomp.c/task-1.c
+++ b/libgomp/testsuite/libgomp.c/task-1.c
@@ -20,7 +20,7 @@ f1 (int i, int j, int k)
 }
 
 int v1 = 1, v2 = 2, v5 = 5;
-int err;
+int e;
 
 void
 f2 (void)
@@ -35,12 +35,12 @@ f2 (void)
       #pragma omp task
 	{
 	  if (++v1 != 8 || ++v2 != 3 || ++v3 != 4 || ++v4 != 5 || ++v5 != 6)
-	    err = 1;
+	    e = 1;
 	}
       #pragma omp taskwait
       if (v1 != 7 || v2 != 2 || v3 != 3 || v4 != 4 || v5 != 6)
 	abort ();
-      if (err)
+      if (e)
 	abort ();
     }
   }
diff --git a/libgomp/testsuite/libgomp.c/task-5.c b/libgomp/testsuite/libgomp.c/task-5.c
index b1523712760..bf44ddd012b 100644
--- a/libgomp/testsuite/libgomp.c/task-5.c
+++ b/libgomp/testsuite/libgomp.c/task-5.c
@@ -3,42 +3,42 @@
 #include <omp.h>
 #include <stdlib.h>
 
-int err;
+int serr;
 
 int
 main ()
 {
   int e;
-#pragma omp parallel shared(err)
+#pragma omp parallel shared(serr)
   {
     if (omp_in_final ())
       #pragma omp atomic write
-	err = 1;
-    #pragma omp task if (0) shared(err)
+	serr = 1;
+    #pragma omp task if (0) shared(serr)
       {
 	if (omp_in_final ())
 	  #pragma omp atomic write
-	    err = 1;
-	#pragma omp task if (0) shared(err)
+	    serr = 1;
+	#pragma omp task if (0) shared(serr)
 	  if (omp_in_final ())
 	    #pragma omp atomic write
-	      err = 1;
+	      serr = 1;
       }
-    #pragma omp task final (1) shared(err)
+    #pragma omp task final (1) shared(serr)
       {
 	if (!omp_in_final ())
 	  #pragma omp atomic write
-	    err = 1;
+	    serr = 1;
 	#pragma omp taskyield
 	#pragma omp taskwait
-	#pragma omp task shared(err)
+	#pragma omp task shared(serr)
 	  if (!omp_in_final ())
 	    #pragma omp atomic write
-	      err = 1;
+	      serr = 1;
       }
   }
   #pragma omp atomic read
-    e = err;
+    e = serr;
   if (e)
     abort ();
   return 0;
diff --git a/libgomp/testsuite/libgomp.fortran/aligned1.f03 b/libgomp/testsuite/libgomp.fortran/aligned1.f03
index 19daed80f02..a0b80d4555f 100644
--- a/libgomp/testsuite/libgomp.fortran/aligned1.f03
+++ b/libgomp/testsuite/libgomp.fortran/aligned1.f03
@@ -42,12 +42,12 @@
   end do
   call foo (p, q, c_loc (r(1)), s)
   do i = 1, 1024
-    if (p(i) /= i * i + 3 * i + 2) STOP 1
+    if (p(i) /= i * i + 3 * i + 2) stop 1
     p(i) = i
   end do
   call bar (p, q, c_loc (r(1)), s)
   do i = 1, 1024
-    if (p(i) /= i * i + 3 * i + 2) STOP 2
+    if (p(i) /= i * i + 3 * i + 2) stop 2
   end do
   ! Attempt to create 64-byte aligned allocatable
   do i = 1, 64
@@ -65,7 +65,7 @@
     end do
     call baz (p, c)
     do i = 1, 1024
-      if (p(i) /= i * i + 5 * i + 2) STOP 3
+      if (p(i) /= i * i + 5 * i + 2) stop 3
     end do
   end if
 end
diff --git a/libgomp/testsuite/libgomp.fortran/alloc-comp-1.f90 b/libgomp/testsuite/libgomp.fortran/alloc-comp-1.f90
index fac03653da0..ea76bc1e7e8 100644
--- a/libgomp/testsuite/libgomp.fortran/alloc-comp-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/alloc-comp-1.f90
@@ -22,19 +22,19 @@ contains
     type (dl), intent (in) :: obj
     integer, intent (in) :: val, cl1, cu1, cl2, cu2
     logical, intent (in) :: c, f
-    if ((c .neqv. allocated (obj%c)) .or. (f .neqv. allocated (obj%f))) STOP 1
+    if ((c .neqv. allocated (obj%c)) .or. (f .neqv. allocated (obj%f))) stop 1
     if (c) then
-      if (lbound (obj%c, 1) /= cl1 .or. ubound (obj%c, 1) /= cu1) STOP 2
-      if (lbound (obj%c, 2) /= cl2 .or. ubound (obj%c, 2) /= cu2) STOP 3
+      if (lbound (obj%c, 1) /= cl1 .or. ubound (obj%c, 1) /= cu1) stop 2
+      if (lbound (obj%c, 2) /= cl2 .or. ubound (obj%c, 2) /= cu2) stop 3
     end if
     if (val /= 0) then
-      if (obj%a /= val .or. obj%b /= val) STOP 4
-      if (obj%d /= val .or. obj%e /= val) STOP 5
+      if (obj%a /= val .or. obj%b /= val) stop 4
+      if (obj%d /= val .or. obj%e /= val) stop 5
       if (c) then
-        if (any (obj%c /= val)) STOP 6
+        if (any (obj%c /= val)) stop 6
       end if
       if (f) then
-        if (obj%f /= val) STOP 7
+        if (obj%f /= val) stop 7
       end if
     end if
   end subroutine ver_dl
@@ -43,9 +43,9 @@ contains
     integer, intent (in) :: val, hl, hu, cl1, cu1, cl2, cu2
     logical, intent (in) :: h, k, c, f
     integer :: i, j
-    if ((h .neqv. allocated (obj%h)) .or. (k .neqv. allocated (obj%k))) STOP 8
+    if ((h .neqv. allocated (obj%h)) .or. (k .neqv. allocated (obj%k))) stop 8
     if (h) then
-      if (lbound (obj%h, 1) /= hl .or. ubound (obj%h, 1) /= hu) STOP 9
+      if (lbound (obj%h, 1) /= hl .or. ubound (obj%h, 1) /= hu) stop 9
       do i = hl, hu
         call ver_dl (obj%h(i), val, c, cl1, cu1, cl2, cu2, f)
       end do
@@ -57,7 +57,7 @@ contains
     end do
     if (k) call ver_dl (obj%k, val, c, cl1, cu1, cl2, cu2, f)
     if (val /= 0) then
-      if (obj%g /= val .or. obj%i /= val) STOP 10
+      if (obj%g /= val .or. obj%i /= val) stop 10
     end if
   end subroutine ver_dt
   subroutine alloc_dl (obj, val, c, cl1, cu1, cl2, cu2, f)
diff --git a/libgomp/testsuite/libgomp.fortran/alloc-comp-2.f90 b/libgomp/testsuite/libgomp.fortran/alloc-comp-2.f90
index 7d035387a3e..111005e1879 100644
--- a/libgomp/testsuite/libgomp.fortran/alloc-comp-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/alloc-comp-2.f90
@@ -22,19 +22,19 @@ contains
     type (dl), intent (in) :: obj
     integer, intent (in) :: val, cl1, cu1, cl2, cu2
     logical, intent (in) :: c, f
-    if ((c .neqv. allocated (obj%c)) .or. (f .neqv. allocated (obj%f))) STOP 1
+    if ((c .neqv. allocated (obj%c)) .or. (f .neqv. allocated (obj%f))) stop 1
     if (c) then
-      if (lbound (obj%c, 1) /= cl1 .or. ubound (obj%c, 1) /= cu1) STOP 2
-      if (lbound (obj%c, 2) /= cl2 .or. ubound (obj%c, 2) /= cu2) STOP 3
+      if (lbound (obj%c, 1) /= cl1 .or. ubound (obj%c, 1) /= cu1) stop 2
+      if (lbound (obj%c, 2) /= cl2 .or. ubound (obj%c, 2) /= cu2) stop 3
     end if
     if (val /= 0) then
-      if (obj%a /= val .or. obj%b /= val) STOP 4
-      if (obj%d /= val .or. obj%e /= val) STOP 5
+      if (obj%a /= val .or. obj%b /= val) stop 4
+      if (obj%d /= val .or. obj%e /= val) stop 5
       if (c) then
-        if (any (obj%c /= val)) STOP 6
+        if (any (obj%c /= val)) stop 6
       end if
       if (f) then
-        if (obj%f /= val) STOP 7
+        if (obj%f /= val) stop 7
       end if
     end if
   end subroutine ver_dl
@@ -43,9 +43,9 @@ contains
     integer, intent (in) :: val, hl, hu, cl1, cu1, cl2, cu2
     logical, intent (in) :: h, k, c, f
     integer :: i, j
-    if ((h .neqv. allocated (obj%h)) .or. (k .neqv. allocated (obj%k))) STOP 8
+    if ((h .neqv. allocated (obj%h)) .or. (k .neqv. allocated (obj%k))) stop 8
     if (h) then
-      if (lbound (obj%h, 1) /= hl .or. ubound (obj%h, 1) /= hu) STOP 9
+      if (lbound (obj%h, 1) /= hl .or. ubound (obj%h, 1) /= hu) stop 9
       do i = hl, hu
         call ver_dl (obj%h(i), val, c, cl1, cu1, cl2, cu2, f)
       end do
@@ -57,7 +57,7 @@ contains
     end do
     if (k) call ver_dl (obj%k, val, c, cl1, cu1, cl2, cu2, f)
     if (val /= 0) then
-      if (obj%g /= val .or. obj%i /= val) STOP 10
+      if (obj%g /= val .or. obj%i /= val) stop 10
     end if
   end subroutine ver_dt
   subroutine alloc_dl (obj, val, c, cl1, cu1, cl2, cu2, f)
@@ -122,20 +122,20 @@ contains
     logical, parameter :: T = .true.
     logical :: l
 !$omp parallel private (x, y, z)
-    if (allocated (x) .or. allocated (y) .or. allocated (z)) STOP 11
+    if (allocated (x) .or. allocated (y) .or. allocated (z)) stop 11
 !$omp end parallel
 !$omp parallel firstprivate (x, y, z)
-    if (allocated (x) .or. allocated (y) .or. allocated (z)) STOP 12
+    if (allocated (x) .or. allocated (y) .or. allocated (z)) stop 12
 !$omp end parallel
     l = F
 !$omp parallel sections lastprivate (x, y, z) firstprivate (l)
 !$omp section
     if (.not. l) then
-      if (allocated (x) .or. allocated (y) .or. allocated (z)) STOP 13
+      if (allocated (x) .or. allocated (y) .or. allocated (z)) stop 13
     end if
 !$omp section
     if (.not. l) then
-      if (allocated (x) .or. allocated (y) .or. allocated (z)) STOP 14
+      if (allocated (x) .or. allocated (y) .or. allocated (z)) stop 14
     end if
     allocate (x, y, z(-3:-3,2:3))
     call alloc_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)
@@ -148,10 +148,10 @@ contains
     call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)
 !$omp section
 !$omp end parallel sections
-    if (.not.allocated (x) .or. .not.allocated (y)) STOP 15
-    if (.not.allocated (z)) STOP 16
-    if (lbound (z, 1) /= -3 .or. ubound (z, 1) /= -3) STOP 17
-    if (lbound (z, 2) /= 2 .or. ubound (z, 2) /= 3) STOP 18
+    if (.not.allocated (x) .or. .not.allocated (y)) stop 15
+    if (.not.allocated (z)) stop 16
+    if (lbound (z, 1) /= -3 .or. ubound (z, 1) /= -3) stop 17
+    if (lbound (z, 2) /= 2 .or. ubound (z, 2) /= 3) stop 18
     call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)
     call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)
     call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)
diff --git a/libgomp/testsuite/libgomp.fortran/alloc-comp-3.f90 b/libgomp/testsuite/libgomp.fortran/alloc-comp-3.f90
index 42ba7b4b7e2..0185859cb26 100644
--- a/libgomp/testsuite/libgomp.fortran/alloc-comp-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/alloc-comp-3.f90
@@ -22,19 +22,19 @@ contains
     type (dl), intent (in) :: obj
     integer, intent (in) :: val, cl1, cu1, cl2, cu2
     logical, intent (in) :: c, f
-    if ((c .neqv. allocated (obj%c)) .or. (f .neqv. allocated (obj%f))) STOP 1
+    if ((c .neqv. allocated (obj%c)) .or. (f .neqv. allocated (obj%f))) stop 1
     if (c) then
-      if (lbound (obj%c, 1) /= cl1 .or. ubound (obj%c, 1) /= cu1) STOP 2
-      if (lbound (obj%c, 2) /= cl2 .or. ubound (obj%c, 2) /= cu2) STOP 3
+      if (lbound (obj%c, 1) /= cl1 .or. ubound (obj%c, 1) /= cu1) stop 2
+      if (lbound (obj%c, 2) /= cl2 .or. ubound (obj%c, 2) /= cu2) stop 3
     end if
     if (val /= 0) then
-      if (obj%a /= val .or. obj%b /= val) STOP 4
-      if (obj%d /= val .or. obj%e /= val) STOP 5
+      if (obj%a /= val .or. obj%b /= val) stop 4
+      if (obj%d /= val .or. obj%e /= val) stop 5
       if (c) then
-        if (any (obj%c /= val)) STOP 6
+        if (any (obj%c /= val)) stop 6
       end if
       if (f) then
-        if (obj%f /= val) STOP 7
+        if (obj%f /= val) stop 7
       end if
     end if
   end subroutine ver_dl
@@ -43,9 +43,9 @@ contains
     integer, intent (in) :: val, hl, hu, cl1, cu1, cl2, cu2
     logical, intent (in) :: h, k, c, f
     integer :: i, j
-    if ((h .neqv. allocated (obj%h)) .or. (k .neqv. allocated (obj%k))) STOP 8
+    if ((h .neqv. allocated (obj%h)) .or. (k .neqv. allocated (obj%k))) stop 8
     if (h) then
-      if (lbound (obj%h, 1) /= hl .or. ubound (obj%h, 1) /= hu) STOP 9
+      if (lbound (obj%h, 1) /= hl .or. ubound (obj%h, 1) /= hu) stop 9
       do i = hl, hu
         call ver_dl (obj%h(i), val, c, cl1, cu1, cl2, cu2, f)
       end do
@@ -57,7 +57,7 @@ contains
     end do
     if (k) call ver_dl (obj%k, val, c, cl1, cu1, cl2, cu2, f)
     if (val /= 0) then
-      if (obj%g /= val .or. obj%i /= val) STOP 10
+      if (obj%g /= val .or. obj%i /= val) stop 10
     end if
   end subroutine ver_dt
   subroutine alloc_dl (obj, val, c, cl1, cu1, cl2, cu2, f)
@@ -124,27 +124,27 @@ contains
     logical, parameter :: F = .false.
     logical, parameter :: T = .true.
     logical :: l
-    if (lbound (x, 1) /= 2 .or. ubound (x, 1) /= 4) STOP 11
-    if (lbound (y, 1) /= 3 .or. ubound (y, 1) /= 4) STOP 12
+    if (lbound (x, 1) /= 2 .or. ubound (x, 1) /= 4) stop 11
+    if (lbound (y, 1) /= 3 .or. ubound (y, 1) /= 4) stop 12
     call ver_dt (x(2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)
     call ver_dt (x(n), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)
     call ver_dt (y(3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)
     call ver_dt (y(4), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)
 !$omp parallel private (z)
-    if (allocated (z)) STOP 13
+    if (allocated (z)) stop 13
 !$omp end parallel
 !$omp parallel firstprivate (z)
-    if (allocated (z)) STOP 14
+    if (allocated (z)) stop 14
 !$omp end parallel
     l = F
 !$omp parallel sections lastprivate (z) firstprivate (l)
 !$omp section
     if (.not. l) then
-      if (allocated (z)) STOP 15
+      if (allocated (z)) stop 15
     end if
 !$omp section
     if (.not. l) then
-      if (allocated (z)) STOP 16
+      if (allocated (z)) stop 16
     end if
     allocate (z(-3:-3,2:3))
     call alloc_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)
@@ -153,9 +153,9 @@ contains
     call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)
 !$omp section
 !$omp end parallel sections
-    if (.not.allocated (z)) STOP 17
-    if (lbound (z, 1) /= -3 .or. ubound (z, 1) /= -3) STOP 18
-    if (lbound (z, 2) /= 2 .or. ubound (z, 2) /= 3) STOP 19
+    if (.not.allocated (z)) stop 17
+    if (lbound (z, 1) /= -3 .or. ubound (z, 1) /= -3) stop 18
+    if (lbound (z, 2) /= 2 .or. ubound (z, 2) /= 3) stop 19
     call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)
     call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)
     call ver_dt (x(n - 1), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)
@@ -203,8 +203,8 @@ contains
     call alloc_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)
     call alloc_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)
 !$omp parallel firstprivate (x, y, z)
-    if (lbound (x, 1) /= 2 .or. ubound (x, 1) /= 4) STOP 20
-    if (lbound (y, 1) /= 3 .or. ubound (y, 1) /= 4) STOP 21
+    if (lbound (x, 1) /= 2 .or. ubound (x, 1) /= 4) stop 20
+    if (lbound (y, 1) /= 3 .or. ubound (y, 1) /= 4) stop 21
     call ver_dt (x(n - 1), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)
     call alloc_dt (x(n - 1), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)
     call ver_dt (x(n - 1), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable1.f90 b/libgomp/testsuite/libgomp.fortran/allocatable1.f90
index b9fd2ee6dbc..59e14406082 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable1.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable1.f90
@@ -7,7 +7,7 @@
   logical :: k, l
   b(:, :) = 16
   l = .false.
-  if (allocated (a)) STOP 1
+  if (allocated (a)) stop 1
 !$omp parallel private (a, b) reduction (.or.:l)
   l = l.or.allocated (a)
   allocate (a(3, 6))
@@ -18,18 +18,18 @@
   deallocate (a)
   l = l.or.allocated (a)
 !$omp end parallel
-  if (allocated (a).or.l) STOP 2
+  if (allocated (a).or.l) stop 2
   allocate (a(6, 3))
   a(:, :) = 3
-  if (.not.allocated (a)) STOP 3
+  if (.not.allocated (a)) stop 3
   l = l.or.size(a).ne.18.or.size(a,1).ne.6.or.size(a,2).ne.3
-  if (l) STOP 4
+  if (l) stop 4
 !$omp parallel private (a, b) reduction (.or.:l)
   l = l.or..not.allocated (a)
   a(3, 2) = 1
   b(3, 2) = 1
 !$omp end parallel
-  if (l.or..not.allocated (a)) STOP 5
+  if (l.or..not.allocated (a)) stop 5
 !$omp parallel firstprivate (a, b) reduction (.or.:l)
   l = l.or..not.allocated (a)
   l = l.or.size(a).ne.18.or.size(a,1).ne.6.or.size(a,2).ne.3
@@ -41,7 +41,7 @@
   a(:, :) = omp_get_thread_num ()
   b(:, :) = omp_get_thread_num ()
 !$omp end parallel
-  if (any (a.ne.3).or.any (b.ne.16).or.l) STOP 6
+  if (any (a.ne.3).or.any (b.ne.16).or.l) stop 6
   k = .true.
 !$omp parallel do firstprivate (a, b, k) lastprivate (a, b) &
 !$omp & reduction (.or.:l)
@@ -59,9 +59,9 @@
     a(:, :) = i + 2
     b(:, :) = i
   end do
-  if (any (a.ne.38).or.any (b.ne.36).or.l) STOP 7
+  if (any (a.ne.38).or.any (b.ne.36).or.l) stop 7
   deallocate (a)
-  if (allocated (a)) STOP 8
+  if (allocated (a)) stop 8
   allocate (a (0:1, 0:3))
   a(:, :) = 0
 !$omp parallel do reduction (+:a) reduction (.or.:l) &
@@ -72,10 +72,10 @@
     a(modulo (i, 2), i / 2) = a(modulo (i, 2), i / 2) + i
     a(i / 4, modulo (i, 4)) = a(i / 4, modulo (i, 4)) + i
   end do
-  if (l) STOP 9
+  if (l) stop 9
   do i = 0, 1
     do j = 0, 3
-      if (a(i, j) .ne. (5*i + 3*j)) STOP 10
+      if (a(i, j) .ne. (5*i + 3*j)) stop 10
     end do
   end do
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable10.f90 b/libgomp/testsuite/libgomp.fortran/allocatable10.f90
index 9b05dc74143..9ebceb814da 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable10.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable10.f90
@@ -4,109 +4,109 @@
   integer :: i
 !$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) &
 !$omp & initializer (omp_priv = 0)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 1
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 1
   allocate (a, b(6:9), c(3, 8:9))
   a = 0
   b = 0
   c = 0
-  if (.not.allocated (a)) STOP 2
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 3
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 4
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 5
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 6
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 7
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 8
+  if (.not.allocated (a)) stop 2
+  if (.not.allocated (b) .or. size (b) /= 4) stop 3
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 4
+  if (.not.allocated (c) .or. size (c) /= 6) stop 5
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 6
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 7
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 8
 !$omp parallel do reduction (+:a, b, c)
   do i = 1, 10
-    if (.not.allocated (a)) STOP 9
-    if (.not.allocated (b) .or. size (b) /= 4) STOP 10
-    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 11
-    if (.not.allocated (c) .or. size (c) /= 6) STOP 12
-    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 13
-    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 14
-    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 15
+    if (.not.allocated (a)) stop 9
+    if (.not.allocated (b) .or. size (b) /= 4) stop 10
+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 11
+    if (.not.allocated (c) .or. size (c) /= 6) stop 12
+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 13
+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 14
+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 15
     a = a + i
     b = b + 2 * i
     c = c + 3 * i
   end do
-  if (.not.allocated (a)) STOP 16
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 17
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 18
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 19
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 20
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 21
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 22
-  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) STOP 23
+  if (.not.allocated (a)) stop 16
+  if (.not.allocated (b) .or. size (b) /= 4) stop 17
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 18
+  if (.not.allocated (c) .or. size (c) /= 6) stop 19
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 20
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 21
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 22
+  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) stop 23
   a = 0
   b = 0
   c = 0
 !$omp parallel do reduction (foo : a, b, c)
   do i = 1, 10
-    if (.not.allocated (a)) STOP 24
-    if (.not.allocated (b) .or. size (b) /= 4) STOP 25
-    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 26
-    if (.not.allocated (c) .or. size (c) /= 6) STOP 27
-    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 28
-    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 29
-    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 30
+    if (.not.allocated (a)) stop 24
+    if (.not.allocated (b) .or. size (b) /= 4) stop 25
+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 26
+    if (.not.allocated (c) .or. size (c) /= 6) stop 27
+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 28
+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 29
+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 30
     a = a + i
     b = b + 2 * i
     c = c + 3 * i
   end do
-  if (.not.allocated (a)) STOP 31
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 32
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 33
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 34
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 35
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 36
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 37
-  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) STOP 38
+  if (.not.allocated (a)) stop 31
+  if (.not.allocated (b) .or. size (b) /= 4) stop 32
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 33
+  if (.not.allocated (c) .or. size (c) /= 6) stop 34
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 35
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 36
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 37
+  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) stop 38
   a = 0
   b = 0
   c = 0
 !$omp simd reduction (+:a, b, c)
   do i = 1, 10
-    if (.not.allocated (a)) STOP 39
-    if (.not.allocated (b) .or. size (b) /= 4) STOP 40
-    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 41
-    if (.not.allocated (c) .or. size (c) /= 6) STOP 42
-    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 43
-    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 44
-    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 45
+    if (.not.allocated (a)) stop 39
+    if (.not.allocated (b) .or. size (b) /= 4) stop 40
+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 41
+    if (.not.allocated (c) .or. size (c) /= 6) stop 42
+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 43
+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 44
+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 45
     a = a + i
     b = b + 2 * i
     c = c + 3 * i
   end do
-  if (.not.allocated (a)) STOP 46
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 47
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 48
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 49
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 50
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 51
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 52
-  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) STOP 53
+  if (.not.allocated (a)) stop 46
+  if (.not.allocated (b) .or. size (b) /= 4) stop 47
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 48
+  if (.not.allocated (c) .or. size (c) /= 6) stop 49
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 50
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 51
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 52
+  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) stop 53
   a = 0
   b = 0
   c = 0
 !$omp simd reduction (foo : a, b, c)
   do i = 1, 10
-    if (.not.allocated (a)) STOP 54
-    if (.not.allocated (b) .or. size (b) /= 4) STOP 55
-    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 56
-    if (.not.allocated (c) .or. size (c) /= 6) STOP 57
-    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 58
-    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 59
-    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 60
+    if (.not.allocated (a)) stop 54
+    if (.not.allocated (b) .or. size (b) /= 4) stop 55
+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 56
+    if (.not.allocated (c) .or. size (c) /= 6) stop 57
+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 58
+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 59
+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 60
     a = a + i
     b = b + 2 * i
     c = c + 3 * i
   end do
-  if (.not.allocated (a)) STOP 61
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 62
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 63
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 64
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 65
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 66
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 67
-  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) STOP 68
+  if (.not.allocated (a)) stop 61
+  if (.not.allocated (b) .or. size (b) /= 4) stop 62
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 63
+  if (.not.allocated (c) .or. size (c) /= 6) stop 64
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 65
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 66
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 67
+  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) stop 68
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable11.f90 b/libgomp/testsuite/libgomp.fortran/allocatable11.f90
index 916dc6e596e..c3b82942f30 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable11.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable11.f90
@@ -5,68 +5,68 @@
   integer, allocatable, save :: a, b(:), c(:,:)
   integer :: p
 !$omp threadprivate (a, b, c)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 1
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 1
 
   call omp_set_dynamic (.false.)
   call omp_set_num_threads (4)
 
 !$omp parallel num_threads (4)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 2
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 2
 !$omp end parallel
 
   allocate (a, b(6:9), c(3, 8:9))
   a = 4
   b = 5
   c = 6
-  if (.not.allocated (a)) STOP 3
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 4
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 5
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 6
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 7
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 8
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 9
+  if (.not.allocated (a)) stop 3
+  if (.not.allocated (b) .or. size (b) /= 4) stop 4
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 5
+  if (.not.allocated (c) .or. size (c) /= 6) stop 6
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 7
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 8
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 9
 
 !$omp parallel num_threads (4) copyin (a, b, c) private (p)
   p = omp_get_thread_num ()
-  if (.not.allocated (a)) STOP 10
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 11
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 12
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 13
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 14
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 15
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 16
-  if (a /= 4 .or. any (b /= 5) .or. any (c /= 6)) STOP 17
+  if (.not.allocated (a)) stop 10
+  if (.not.allocated (b) .or. size (b) /= 4) stop 11
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 12
+  if (.not.allocated (c) .or. size (c) /= 6) stop 13
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 14
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 15
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 16
+  if (a /= 4 .or. any (b /= 5) .or. any (c /= 6)) stop 17
   deallocate (a, b, c)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 18
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 18
   allocate (a, b(p:9), c(3, p:7))
   a = p
   b = p
   c = p
-  if (.not.allocated (a)) STOP 19
-  if (.not.allocated (b) .or. size (b) /= (10 - p)) STOP 20
-  if (lbound (b, 1) /= p .or. ubound (b, 1) /= 9) STOP 21
-  if (.not.allocated (c) .or. size (c) /= (3 * (8 - p))) STOP 22
-  if (size (c, 1) /= 3 .or. size (c, 2) /= (8 - p)) STOP 23
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 24
-  if (lbound (c, 2) /= p .or. ubound (c, 2) /= 7) STOP 25
-  if (a /= p .or. any (b /= p) .or. any (c /= p)) STOP 26
+  if (.not.allocated (a)) stop 19
+  if (.not.allocated (b) .or. size (b) /= (10 - p)) stop 20
+  if (lbound (b, 1) /= p .or. ubound (b, 1) /= 9) stop 21
+  if (.not.allocated (c) .or. size (c) /= (3 * (8 - p))) stop 22
+  if (size (c, 1) /= 3 .or. size (c, 2) /= (8 - p)) stop 23
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 24
+  if (lbound (c, 2) /= p .or. ubound (c, 2) /= 7) stop 25
+  if (a /= p .or. any (b /= p) .or. any (c /= p)) stop 26
 !$omp end parallel
 
 !$omp parallel num_threads (4) copyin (a, b, c)
-  if (.not.allocated (a)) STOP 27
-  if (.not.allocated (b) .or. size (b) /= 10) STOP 28
-  if (lbound (b, 1) /= 0 .or. ubound (b, 1) /= 9) STOP 29
-  if (.not.allocated (c) .or. size (c) /= 24) STOP 30
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 8) STOP 31
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 32
-  if (lbound (c, 2) /= 0 .or. ubound (c, 2) /= 7) STOP 33
-  if (a /= 0 .or. any (b /= 0) .or. any (c /= 0)) STOP 34
+  if (.not.allocated (a)) stop 27
+  if (.not.allocated (b) .or. size (b) /= 10) stop 28
+  if (lbound (b, 1) /= 0 .or. ubound (b, 1) /= 9) stop 29
+  if (.not.allocated (c) .or. size (c) /= 24) stop 30
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 8) stop 31
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 32
+  if (lbound (c, 2) /= 0 .or. ubound (c, 2) /= 7) stop 33
+  if (a /= 0 .or. any (b /= 0) .or. any (c /= 0)) stop 34
 !$omp end parallel
 
   deallocate (a, b, c)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 35
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 35
 
 !$omp parallel num_threads (4) copyin (a, b, c)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 36
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 36
 !$omp end parallel
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable12.f90 b/libgomp/testsuite/libgomp.fortran/allocatable12.f90
index 6ccf1c0323c..8ce4dd2f3fe 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable12.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable12.f90
@@ -2,11 +2,11 @@
 
   integer, allocatable :: a, b(:), c(:,:)
   logical :: l
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 1
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 1
 
 !$omp parallel private (a, b, c, l)
   l = .false.
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 2
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 2
 
 !$omp single
   allocate (a, b(6:9), c(3, 8:9))
@@ -15,60 +15,60 @@
   c = 6
 !$omp end single copyprivate (a, b, c)
 
-  if (.not.allocated (a)) STOP 3
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 4
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 5
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 6
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 7
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 8
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 9
-  if (a /= 4 .or. any (b /= 5) .or. any (c /= 6)) STOP 10
+  if (.not.allocated (a)) stop 3
+  if (.not.allocated (b) .or. size (b) /= 4) stop 4
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 5
+  if (.not.allocated (c) .or. size (c) /= 6) stop 6
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 7
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 8
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 9
+  if (a /= 4 .or. any (b /= 5) .or. any (c /= 6)) stop 10
 
 !$omp single
   deallocate (a, b, c)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 11
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 11
   allocate (a, b(0:4), c(3, 2:7))
   a = 1
   b = 2
   c = 3
 !$omp end single copyprivate (a, b, c)
 
-  if (.not.allocated (a)) STOP 12
-  if (.not.allocated (b) .or. size (b) /= 5) STOP 13
-  if (lbound (b, 1) /= 0 .or. ubound (b, 1) /= 4) STOP 14
-  if (.not.allocated (c) .or. size (c) /= 18) STOP 15
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 6) STOP 16
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 17
-  if (lbound (c, 2) /= 2 .or. ubound (c, 2) /= 7) STOP 18
-  if (a /= 1 .or. any (b /= 2) .or. any (c /= 3)) STOP 19
+  if (.not.allocated (a)) stop 12
+  if (.not.allocated (b) .or. size (b) /= 5) stop 13
+  if (lbound (b, 1) /= 0 .or. ubound (b, 1) /= 4) stop 14
+  if (.not.allocated (c) .or. size (c) /= 18) stop 15
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 6) stop 16
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 17
+  if (lbound (c, 2) /= 2 .or. ubound (c, 2) /= 7) stop 18
+  if (a /= 1 .or. any (b /= 2) .or. any (c /= 3)) stop 19
 
 !$omp single
   l = .true.
   deallocate (a, b, c)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 20
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 20
   allocate (a, b(2:6), c(3:5, 3:8))
   a = 7
   b = 8
   c = 9
 !$omp end single copyprivate (a, b, c)
 
-  if (.not.allocated (a)) STOP 21
-  if (.not.allocated (b) .or. size (b) /= 5) STOP 22
+  if (.not.allocated (a)) stop 21
+  if (.not.allocated (b) .or. size (b) /= 5) stop 22
   if (l) then
-    if (lbound (b, 1) /= 2 .or. ubound (b, 1) /= 6) STOP 23
+    if (lbound (b, 1) /= 2 .or. ubound (b, 1) /= 6) stop 23
   else
-    if (lbound (b, 1) /= 0 .or. ubound (b, 1) /= 4) STOP 24
+    if (lbound (b, 1) /= 0 .or. ubound (b, 1) /= 4) stop 24
   end if
-  if (.not.allocated (c) .or. size (c) /= 18) STOP 25
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 6) STOP 26
+  if (.not.allocated (c) .or. size (c) /= 18) stop 25
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 6) stop 26
   if (l) then
-    if (lbound (c, 1) /= 3 .or. ubound (c, 1) /= 5) STOP 27
-    if (lbound (c, 2) /= 3 .or. ubound (c, 2) /= 8) STOP 28
+    if (lbound (c, 1) /= 3 .or. ubound (c, 1) /= 5) stop 27
+    if (lbound (c, 2) /= 3 .or. ubound (c, 2) /= 8) stop 28
   else
-    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 29
-    if (lbound (c, 2) /= 2 .or. ubound (c, 2) /= 7) STOP 30
+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 29
+    if (lbound (c, 2) /= 2 .or. ubound (c, 2) /= 7) stop 30
   end if
-  if (a /= 7 .or. any (b /= 8) .or. any (c /= 9)) STOP 31
+  if (a /= 7 .or. any (b /= 8) .or. any (c /= 9)) stop 31
 
 !$omp end parallel
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable2.f90 b/libgomp/testsuite/libgomp.fortran/allocatable2.f90
index 1361e6d1a91..fbf81c214b8 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable2.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable2.f90
@@ -7,7 +7,7 @@
   integer :: n
   logical :: l
 !$omp threadprivate (a)
-  if (allocated (a)) STOP 1
+  if (allocated (a)) stop 1
   call omp_set_dynamic (.false.)
   l = .false.
 !$omp parallel num_threads (4) reduction(.or.:l)
@@ -16,7 +16,7 @@
   l = l.or..not.allocated (a)
   l = l.or.size(a).ne.12.or.size(a,1).ne.3.or.size(a,2).ne.4
 !$omp end parallel
-  if (l.or.any(a.ne.6)) STOP 1
+  if (l.or.any(a.ne.6)) stop 2
 !$omp parallel num_threads (4) copyin (a) reduction(.or.:l) private (b)
   l = l.or.allocated (b)
   l = l.or..not.allocated (a)
@@ -37,11 +37,11 @@
   deallocate (b)
   l = l.or.allocated (b)
 !$omp end parallel
-  if (n.lt.0 .or. n.ge.4) STOP 2
-  if (l.or.any(a.ne.(n + 36))) STOP 3
+  if (n.lt.0 .or. n.ge.4) stop 3
+  if (l.or.any(a.ne.(n + 36))) stop 4
 !$omp parallel num_threads (4) reduction(.or.:l)
   deallocate (a)
   l = l.or.allocated (a)
 !$omp end parallel
-  if (l.or.allocated (a)) STOP 4
+  if (l.or.allocated (a)) stop 5
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable3.f90 b/libgomp/testsuite/libgomp.fortran/allocatable3.f90
index 03ed1ac3f1a..4663b15988f 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable3.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable3.f90
@@ -4,7 +4,7 @@
   integer :: i
   logical :: l
   l = .false.
-  if (allocated (a)) STOP 1
+  if (allocated (a)) stop 1
 !$omp parallel private (a) reduction (.or.:l)
   allocate (a (-7:-5))
   l = l.or..not.allocated (a)
@@ -18,4 +18,5 @@
   l = l.or.any (a.ne.0)
   deallocate (a)
 !$omp end parallel
+  if (l.or.allocated (a)) stop 2
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable4.f90 b/libgomp/testsuite/libgomp.fortran/allocatable4.f90
index 0b0ac174fad..2a8cf22901d 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable4.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable4.f90
@@ -6,7 +6,7 @@
   logical :: k, l
   b(:, :) = 16
   l = .false.
-  if (allocated (a)) STOP 1
+  if (allocated (a)) stop 1
 !$omp task private (a, b) shared (l)
   l = l.or.allocated (a)
   allocate (a(3, 6))
@@ -18,19 +18,19 @@
   l = l.or.allocated (a)
 !$omp end task
 !$omp taskwait
-  if (allocated (a).or.l) STOP 2
+  if (allocated (a).or.l) stop 2
   allocate (a(6, 3))
   a(:, :) = 3
-  if (.not.allocated (a)) STOP 3
+  if (.not.allocated (a)) stop 3
   l = l.or.size(a).ne.18.or.size(a,1).ne.6.or.size(a,2).ne.3
-  if (l) STOP 4
+  if (l) stop 4
 !$omp task private (a, b) shared (l)
   l = l.or..not.allocated (a)
   a(3, 2) = 1
   b(3, 2) = 1
 !$omp end task
 !$omp taskwait
-  if (l.or..not.allocated (a)) STOP 5
+  if (l.or..not.allocated (a)) stop 5
 !$omp task firstprivate (a, b) shared (l)
   l = l.or..not.allocated (a)
   l = l.or.size(a).ne.18.or.size(a,1).ne.6.or.size(a,2).ne.3
@@ -43,5 +43,5 @@
   b(:, :) = 8
 !$omp end task
 !$omp taskwait
-  if (any (a.ne.3).or.any (b.ne.16).or.l) STOP 6
+  if (any (a.ne.3).or.any (b.ne.16).or.l) stop 6
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable5.f90 b/libgomp/testsuite/libgomp.fortran/allocatable5.f90
index 20ac6012ebd..73027e7082c 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable5.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable5.f90
@@ -12,6 +12,6 @@ program pr42866
       a = a + 2
     !$omp end sections
   !$omp end parallel
-  if (any (a.ne.3)) STOP 1
+  if (any (a.ne.3)) stop 1
   deallocate (a)
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable6.f90 b/libgomp/testsuite/libgomp.fortran/allocatable6.f90
index 444af1dd713..b7bfba9c53d 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable6.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable6.f90
@@ -25,10 +25,10 @@
     else if (i .gt. 1 .and. i .lt. 9) then
       j = 7
     end if
-    if (c(i) .ne. j) STOP 1
+    if (c(i) .ne. j) stop 1
     j = 179 - modulo (i, 11)
     if (i .gt. 1 .and. i .lt. 9) j = i
-    if (d(i) .ne. j) STOP 2
+    if (d(i) .ne. j) stop 2
   end do
   deallocate (a, b, c, d)
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable7.f90 b/libgomp/testsuite/libgomp.fortran/allocatable7.f90
index 787b03559e2..77cd5be6c82 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable7.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable7.f90
@@ -12,5 +12,5 @@
   deallocate (a)
   l = l .or. allocated (a)
 !$omp end parallel
-  if (l) STOP 1
+  if (l) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable8.f90 b/libgomp/testsuite/libgomp.fortran/allocatable8.f90
index 84b18f34940..d1a216a9f46 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable8.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable8.f90
@@ -5,10 +5,10 @@
   integer, save, allocatable :: a(:, :)
   logical :: l
 !$omp threadprivate (a)
-  if (allocated (a)) STOP 1
+  if (allocated (a)) stop 1
   l = .false.
 !$omp parallel copyin (a) num_threads (4) reduction(.or.:l)
   l = l.or.allocated (a)
 !$omp end parallel
-  if (l.or.allocated (a)) STOP 2
+  if (l.or.allocated (a)) stop 2
 end
diff --git a/libgomp/testsuite/libgomp.fortran/allocatable9.f90 b/libgomp/testsuite/libgomp.fortran/allocatable9.f90
index c7decfb4b33..a9929f7506a 100644
--- a/libgomp/testsuite/libgomp.fortran/allocatable9.f90
+++ b/libgomp/testsuite/libgomp.fortran/allocatable9.f90
@@ -2,155 +2,155 @@
 
   integer, allocatable :: a, b(:), c(:,:)
   logical :: l
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 1
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 1
 !$omp parallel private (a, b, c)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 2
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 2
   allocate (a, b(-7:-1), c(2:3, 3:5))
-  if (.not.allocated (a)) STOP 3
-  if (.not.allocated (b) .or. size (b) /= 7) STOP 4
-  if (lbound (b, 1) /= -7 .or. ubound (b, 1) /= -1) STOP 5
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 6
-  if (size (c, 1) /= 2 .or. size (c, 2) /= 3) STOP 7
-  if (lbound (c, 1) /= 2 .or. ubound (c, 1) /= 3) STOP 8
-  if (lbound (c, 2) /= 3 .or. ubound (c, 2) /= 5) STOP 9
+  if (.not.allocated (a)) stop 3
+  if (.not.allocated (b) .or. size (b) /= 7) stop 4
+  if (lbound (b, 1) /= -7 .or. ubound (b, 1) /= -1) stop 5
+  if (.not.allocated (c) .or. size (c) /= 6) stop 6
+  if (size (c, 1) /= 2 .or. size (c, 2) /= 3) stop 7
+  if (lbound (c, 1) /= 2 .or. ubound (c, 1) /= 3) stop 8
+  if (lbound (c, 2) /= 3 .or. ubound (c, 2) /= 5) stop 9
   a = 4
   b = 3
   c = 2
 !$omp end parallel
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 10
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 10
 !$omp parallel firstprivate (a, b, c)
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 11
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 11
   allocate (a, b(-7:-1), c(2:3, 3:5))
-  if (.not.allocated (a)) STOP 12
-  if (.not.allocated (b) .or. size (b) /= 7) STOP 13
-  if (lbound (b, 1) /= -7 .or. ubound (b, 1) /= -1) STOP 14
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 15
-  if (size (c, 1) /= 2 .or. size (c, 2) /= 3) STOP 16
-  if (lbound (c, 1) /= 2 .or. ubound (c, 1) /= 3) STOP 17
-  if (lbound (c, 2) /= 3 .or. ubound (c, 2) /= 5) STOP 18
+  if (.not.allocated (a)) stop 12
+  if (.not.allocated (b) .or. size (b) /= 7) stop 13
+  if (lbound (b, 1) /= -7 .or. ubound (b, 1) /= -1) stop 14
+  if (.not.allocated (c) .or. size (c) /= 6) stop 15
+  if (size (c, 1) /= 2 .or. size (c, 2) /= 3) stop 16
+  if (lbound (c, 1) /= 2 .or. ubound (c, 1) /= 3) stop 17
+  if (lbound (c, 2) /= 3 .or. ubound (c, 2) /= 5) stop 18
   a = 4
   b = 3
   c = 2
 !$omp end parallel
-  if (allocated (a) .or. allocated (b) .or. allocated (c)) STOP 19
+  if (allocated (a) .or. allocated (b) .or. allocated (c)) stop 19
   allocate (a, b(6:9), c(3, 8:9))
   a = 2
   b = 4
   c = 5
-  if (.not.allocated (a)) STOP 20
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 21
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 22
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 23
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 24
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 25
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 26
+  if (.not.allocated (a)) stop 20
+  if (.not.allocated (b) .or. size (b) /= 4) stop 21
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 22
+  if (.not.allocated (c) .or. size (c) /= 6) stop 23
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 24
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 25
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 26
 !$omp parallel firstprivate (a, b, c)
-  if (.not.allocated (a)) STOP 27
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 28
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 29
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 30
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 31
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 32
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 33
-  if (a /= 2 .or. any (b .ne. 4) .or. any (c .ne. 5)) STOP 34
+  if (.not.allocated (a)) stop 27
+  if (.not.allocated (b) .or. size (b) /= 4) stop 28
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 29
+  if (.not.allocated (c) .or. size (c) /= 6) stop 30
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 31
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 32
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 33
+  if (a /= 2 .or. any (b .ne. 4) .or. any (c .ne. 5)) stop 34
   deallocate (a)
-  if (allocated (a)) STOP 35
+  if (allocated (a)) stop 35
   allocate (a)
   a = 8
   b = (/ 1, 2, 3 /)
   c = reshape ((/ 1, 2, 3, 4, 5, 6, 7, 8 /), (/ 2, 4 /))
-  if (.not.allocated (a)) STOP 36
-  if (.not.allocated (b) .or. size (b) /= 3) STOP 37
-  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 3) STOP 38
-  if (.not.allocated (c) .or. size (c) /= 8) STOP 39
-  if (size (c, 1) /= 2 .or. size (c, 2) /= 4) STOP 40
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 2) STOP 41
-  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 4) STOP 42
-  if (a /= 8 .or. b(2) /= 2 .or. c(1, 2) /= 3) STOP 43
+  if (.not.allocated (a)) stop 36
+  if (.not.allocated (b) .or. size (b) /= 3) stop 37
+  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 3) stop 38
+  if (.not.allocated (c) .or. size (c) /= 8) stop 39
+  if (size (c, 1) /= 2 .or. size (c, 2) /= 4) stop 40
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 2) stop 41
+  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 4) stop 42
+  if (a /= 8 .or. b(2) /= 2 .or. c(1, 2) /= 3) stop 43
 !$omp end parallel
-  if (.not.allocated (a)) STOP 44
-  if (.not.allocated (b) .or. size (b) /= 4) STOP 45
-  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 46
-  if (.not.allocated (c) .or. size (c) /= 6) STOP 47
-  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 48
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 49
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 50
-  if (a /= 2 .or. any (b .ne. 4) .or. any (c .ne. 5)) STOP 51
+  if (.not.allocated (a)) stop 44
+  if (.not.allocated (b) .or. size (b) /= 4) stop 45
+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 46
+  if (.not.allocated (c) .or. size (c) /= 6) stop 47
+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 48
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 49
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 50
+  if (a /= 2 .or. any (b .ne. 4) .or. any (c .ne. 5)) stop 51
   l = .false.
 !$omp parallel sections lastprivate (a, b, c) firstprivate (l)
 !$omp section
-  if (.not.allocated (a)) STOP 52
+  if (.not.allocated (a)) stop 52
   if (l) then
-    if (.not.allocated (b) .or. size (b) /= 6) STOP 53
-    if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 6) STOP 54
-    if (.not.allocated (c) .or. size (c) /= 8) STOP 55
-    if (size (c, 1) /= 4 .or. size (c, 2) /= 2) STOP 56
-    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 4) STOP 57
-    if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 2) STOP 58
-    if (a /= 12 .or. b(2) /= 8 .or. c(1, 2) /= 5) STOP 59
+    if (.not.allocated (b) .or. size (b) /= 6) stop 53
+    if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 6) stop 54
+    if (.not.allocated (c) .or. size (c) /= 8) stop 55
+    if (size (c, 1) /= 4 .or. size (c, 2) /= 2) stop 56
+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 4) stop 57
+    if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 2) stop 58
+    if (a /= 12 .or. b(2) /= 8 .or. c(1, 2) /= 5) stop 59
   else
-    if (.not.allocated (b) .or. size (b) /= 4) STOP 60
-    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 61
-    if (.not.allocated (c) .or. size (c) /= 6) STOP 62
-    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 63
-    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 64
-    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 65
+    if (.not.allocated (b) .or. size (b) /= 4) stop 60
+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 61
+    if (.not.allocated (c) .or. size (c) /= 6) stop 62
+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 63
+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 64
+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 65
   end if
   l = .true.
   deallocate (a)
-  if (allocated (a)) STOP 66
+  if (allocated (a)) stop 66
   allocate (a)
   a = 8
   b = (/ 1, 2, 3 /)
   c = reshape ((/ 1, 2, 3, 4, 5, 6, 7, 8 /), (/ 2, 4 /))
-  if (.not.allocated (a)) STOP 67
-  if (.not.allocated (b) .or. size (b) /= 3) STOP 68
-  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 3) STOP 69
-  if (.not.allocated (c) .or. size (c) /= 8) STOP 70
-  if (size (c, 1) /= 2 .or. size (c, 2) /= 4) STOP 71
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 2) STOP 72
-  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 4) STOP 73
-  if (a /= 8 .or. b(2) /= 2 .or. c(1, 2) /= 3) STOP 74
+  if (.not.allocated (a)) stop 67
+  if (.not.allocated (b) .or. size (b) /= 3) stop 68
+  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 3) stop 69
+  if (.not.allocated (c) .or. size (c) /= 8) stop 70
+  if (size (c, 1) /= 2 .or. size (c, 2) /= 4) stop 71
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 2) stop 72
+  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 4) stop 73
+  if (a /= 8 .or. b(2) /= 2 .or. c(1, 2) /= 3) stop 74
 !$omp section
-  if (.not.allocated (a)) STOP 75
+  if (.not.allocated (a)) stop 75
   if (l) then
-    if (.not.allocated (b) .or. size (b) /= 3) STOP 76
-    if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 3) STOP 77
-    if (.not.allocated (c) .or. size (c) /= 8) STOP 78
-    if (size (c, 1) /= 2 .or. size (c, 2) /= 4) STOP 79
-    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 2) STOP 80
-    if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 4) STOP 81
-    if (a /= 8 .or. b(2) /= 2 .or. c(1, 2) /= 3) STOP 82
+    if (.not.allocated (b) .or. size (b) /= 3) stop 76
+    if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 3) stop 77
+    if (.not.allocated (c) .or. size (c) /= 8) stop 78
+    if (size (c, 1) /= 2 .or. size (c, 2) /= 4) stop 79
+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 2) stop 80
+    if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 4) stop 81
+    if (a /= 8 .or. b(2) /= 2 .or. c(1, 2) /= 3) stop 82
   else
-    if (.not.allocated (b) .or. size (b) /= 4) STOP 83
-    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) STOP 84
-    if (.not.allocated (c) .or. size (c) /= 6) STOP 85
-    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) STOP 86
-    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) STOP 87
-    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) STOP 88
+    if (.not.allocated (b) .or. size (b) /= 4) stop 83
+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) stop 84
+    if (.not.allocated (c) .or. size (c) /= 6) stop 85
+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) stop 86
+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) stop 87
+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) stop 88
   end if
   l = .true.
   deallocate (a)
-  if (allocated (a)) STOP 89
+  if (allocated (a)) stop 89
   allocate (a)
   a = 12
   b = (/ 9, 8, 7, 6, 5, 4 /)
   c = reshape ((/ 1, 2, 3, 4, 5, 6, 7, 8 /), (/ 4, 2 /))
-  if (.not.allocated (a)) STOP 90
-  if (.not.allocated (b) .or. size (b) /= 6) STOP 91
-  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 6) STOP 92
-  if (.not.allocated (c) .or. size (c) /= 8) STOP 93
-  if (size (c, 1) /= 4 .or. size (c, 2) /= 2) STOP 94
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 4) STOP 95
-  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 2) STOP 96
-  if (a /= 12 .or. b(2) /= 8 .or. c(1, 2) /= 5) STOP 97
+  if (.not.allocated (a)) stop 90
+  if (.not.allocated (b) .or. size (b) /= 6) stop 91
+  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 6) stop 92
+  if (.not.allocated (c) .or. size (c) /= 8) stop 93
+  if (size (c, 1) /= 4 .or. size (c, 2) /= 2) stop 94
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 4) stop 95
+  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 2) stop 96
+  if (a /= 12 .or. b(2) /= 8 .or. c(1, 2) /= 5) stop 97
 !$omp end parallel sections
-  if (.not.allocated (a)) STOP 98
-  if (.not.allocated (b) .or. size (b) /= 6) STOP 99
-  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 6) STOP 100
-  if (.not.allocated (c) .or. size (c) /= 8) STOP 101
-  if (size (c, 1) /= 4 .or. size (c, 2) /= 2) STOP 102
-  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 4) STOP 103
-  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 2) STOP 104
-  if (a /= 12 .or. b(2) /= 8 .or. c(1, 2) /= 5) STOP 105
+  if (.not.allocated (a)) stop 98
+  if (.not.allocated (b) .or. size (b) /= 6) stop 99
+  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 6) stop 100
+  if (.not.allocated (c) .or. size (c) /= 8) stop 101
+  if (size (c, 1) /= 4 .or. size (c, 2) /= 2) stop 102
+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 4) stop 103
+  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 2) stop 104
+  if (a /= 12 .or. b(2) /= 8 .or. c(1, 2) /= 5) stop 105
 end
diff --git a/libgomp/testsuite/libgomp.fortran/appendix-a/a.28.5.f90 b/libgomp/testsuite/libgomp.fortran/appendix-a/a.28.5.f90
index 08de997f8c4..a3f56dd4757 100644
--- a/libgomp/testsuite/libgomp.fortran/appendix-a/a.28.5.f90
+++ b/libgomp/testsuite/libgomp.fortran/appendix-a/a.28.5.f90
@@ -1,5 +1,5 @@
 ! { dg-do compile }
-! { dg-options "-w" }
+! { dg-options "-w -std=legacy" }
 !
 ! "-w" added as libgomp/testsuite seemingly cannot parse with
 ! dg-warning Fortran's output. Fortran warns for "call sub1(a)"
diff --git a/libgomp/testsuite/libgomp.fortran/associate1.f90 b/libgomp/testsuite/libgomp.fortran/associate1.f90
index c7930c7644a..31ecaf04200 100644
--- a/libgomp/testsuite/libgomp.fortran/associate1.f90
+++ b/libgomp/testsuite/libgomp.fortran/associate1.f90
@@ -12,12 +12,12 @@ program associate1
 !$omp parallel private(v, a) default(none)
   v = -1
   a = 2.5
-  if (v /= -1 .or. u /= 15) STOP 1
-  if (a(2,1) /= 2.5 .or. b /= 3.5) STOP 2
+  if (v /= -1 .or. u /= 15) stop 1
+  if (a(2,1) /= 2.5 .or. b /= 3.5) stop 2
   associate(u => v, b => a(2, 1))
-  if (u /= -1 .or. b /= 2.5) STOP 3
+  if (u /= -1 .or. b /= 2.5) stop 3
   end associate
-  if (u /= 15 .or. b /= 3.5) STOP 4
+  if (u /= 15 .or. b /= 3.5) stop 4
 !$omp end parallel
   end associate
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/associate2.f90 b/libgomp/testsuite/libgomp.fortran/associate2.f90
index fbeae95b18f..63d172b476c 100644
--- a/libgomp/testsuite/libgomp.fortran/associate2.f90
+++ b/libgomp/testsuite/libgomp.fortran/associate2.f90
@@ -20,12 +20,12 @@ program associate2
 !$omp parallel private(v, a) default(none)
   v = -1
   forall (k = 1:3, l = 1:3) a(k, l)%a(:,:) = 2.5
-  if (v(3) /= -1 .or. u(3) /= 15) STOP 1
-  if (a(2,1)%a(1,2) /= 2.5 .or. b(1,2) /= 3.5) STOP 2
+  if (v(3) /= -1 .or. u(3) /= 15) stop 1
+  if (a(2,1)%a(1,2) /= 2.5 .or. b(1,2) /= 3.5) stop 2
   associate(u => v, b => a(2, 1)%a)
-  if (u(3) /= -1 .or. b(1,2) /= 2.5) STOP 3
+  if (u(3) /= -1 .or. b(1,2) /= 2.5) stop 3
   end associate
-  if (u(3) /= 15 .or. b(1,2) /= 3.5) STOP 4
+  if (u(3) /= 15 .or. b(1,2) /= 3.5) stop 4
 !$omp end parallel
   end associate
   forall (k = 1:3, l = 1:3) a(k, l)%c(:,:)%i = 7
@@ -35,12 +35,12 @@ program associate2
   associate(d => a(i, j)%c(2,:)%i)
 !$omp parallel private(a) default(none)
   forall (k = 1:3, l = 1:3) a(k, l)%c(:,:)%i = 15
-  if (a(1,2)%c(2,1)%i /= 15 .or. d(1) /= 9) STOP 5
-  if (a(1,2)%c(2,2)%i /= 15 .or. d(2) /= 7) STOP 6
+  if (a(1,2)%c(2,1)%i /= 15 .or. d(1) /= 9) stop 5
+  if (a(1,2)%c(2,2)%i /= 15 .or. d(2) /= 7) stop 6
   associate(d => a(2,1)%c(2,:)%i)
-  if (d(1) /= 15 .or. d(2) /= 15) STOP 7
+  if (d(1) /= 15 .or. d(2) /= 15) stop 7
   end associate
-  if (d(1) /= 9 .or. d(2) /= 7) STOP 8
+  if (d(1) /= 9 .or. d(2) /= 7) stop 8
 !$omp end parallel
   end associate
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/associate3.f90 b/libgomp/testsuite/libgomp.fortran/associate3.f90
index da788a467ea..29c2dd3fc1d 100644
--- a/libgomp/testsuite/libgomp.fortran/associate3.f90
+++ b/libgomp/testsuite/libgomp.fortran/associate3.f90
@@ -16,5 +16,5 @@
     if (j.eq.1) k = 7
   end do
   end associate
-  if (any (v%f(:).ne.21.) .or. i.ne.7) STOP 1
+  if (any (v%f(:).ne.21.) .or. i.ne.7) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/async_io_4.f90 b/libgomp/testsuite/libgomp.fortran/async_io_4.f90
index a21ffaef478..1ff76b4f162 100644
--- a/libgomp/testsuite/libgomp.fortran/async_io_4.f90
+++ b/libgomp/testsuite/libgomp.fortran/async_io_4.f90
@@ -17,13 +17,13 @@ program main
   i = 41
   read (20,*, asynchronous="yes") i
   wait (20)
-  if (i .ne. 1) STOP 1
+  if (i .ne. 1) stop 1
   write (*,*) ' '
   backspace (20)
   i = 42
   read (20,*, asynchronous="yes") i
   close (20)
-  if (i .ne. 1) STOP 2
+  if (i .ne. 1) stop 2
 
   ! PR libfortran/20125
   open (20, status='scratch', asynchronous="yes")
@@ -31,14 +31,14 @@ program main
   backspace (20)
   read (20,*, asynchronous="yes") i
   wait (20)
-  if (i .ne. 7) STOP 3
+  if (i .ne. 7) stop 3
   close (20)
 
   open (20, status='scratch', form='unformatted')
   write (20) 8
   backspace (20)
   read (20) i
-  if (i .ne. 8) STOP 4
+  if (i .ne. 8) stop 4
   close (20)
 
   ! PR libfortran/20471
@@ -52,7 +52,7 @@ program main
   read (3) (y(n),n=1,10)
 
   do n = 1, 10
-     if (abs(x(n)-y(n)) > 0.00001) STOP 5
+     if (abs(x(n)-y(n)) > 0.00001) stop 5
   end do
   close (3)
 
@@ -69,7 +69,7 @@ program main
   nr = nr + 1
   goto 20
 30 continue
-  if (nr .ne. 5) STOP 6
+  if (nr .ne. 5) stop 6
 
   do i = 1, nr+1
      backspace (3)
@@ -77,14 +77,14 @@ program main
 
   do i = 1, nr
      read(3,end=70,err=90) n, (x(n),n=1,10)
-     if (abs(x(1) - i) .gt. 0.001) STOP 7
+     if (abs(x(1) - i) .gt. 0.001) stop 7
   end do
   close (3)
   stop
 
 70 continue
-  STOP 8
+  stop 8
 90 continue
-  STOP 9
+  stop 9
 
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/async_io_5.f90 b/libgomp/testsuite/libgomp.fortran/async_io_5.f90
index 916e78aa001..56487bbd3fa 100644
--- a/libgomp/testsuite/libgomp.fortran/async_io_5.f90
+++ b/libgomp/testsuite/libgomp.fortran/async_io_5.f90
@@ -20,20 +20,20 @@ close(99)
 ! Test character kind
 open(99, file="test.dat")
 read (99,*, iostat=stat) cvar
-if (stat /= 0 .or. cvar /= "1") STOP 1
+if (stat /= 0 .or. cvar /= "1") stop 1
 read (99,*, iostat=stat) cvar
-if (stat /= 0 .or. cvar /= "2") STOP 2
+if (stat /= 0 .or. cvar /= "2") stop 2
 read (99,*, iostat=stat) cvar              ! << FAILS: stat /= 0
-if (stat /= 0 .or. cvar /= "3") STOP 3 ! << aborts here
+if (stat /= 0 .or. cvar /= "3") stop 3 ! << aborts here
 
 ! Test real kind
 rewind(99)
 read (99,*, iostat=stat) var
-if (stat /= 0 .or. var /= 1.0) STOP 4
+if (stat /= 0 .or. var /= 1.0) stop 4
 read (99,*, iostat=stat) var
-if (stat /= 0 .or. var /= 2.0) STOP 5
+if (stat /= 0 .or. var /= 2.0) stop 5
 read (99,*, iostat=stat) var ! << FAILS: stat /= 0
-if (stat /= 0 .or. var /= 3.0) STOP 6
+if (stat /= 0 .or. var /= 3.0) stop 6
 close(99, status="delete")
 
 ! Test real kind with exponents
@@ -45,11 +45,11 @@ close(99)
 
 open(99, file="test.dat")
 read (99,*, iostat=stat) var
-if (stat /= 0) STOP 7
+if (stat /= 0) stop 7
 read (99,*, iostat=stat) var
-if (stat /= 0) STOP 8
+if (stat /= 0) stop 8
 read (99,*) var ! << FAILS: stat /= 0
-if (stat /= 0) STOP 9
+if (stat /= 0) stop 9
 close(99, status="delete")
 
 ! Test logical kind
@@ -61,11 +61,11 @@ close(99)
 
 open(99, file="test.dat")
 read (99,*, iostat=stat) lvar
-if (stat /= 0 .or. (.not.lvar)) STOP 10
+if (stat /= 0 .or. (.not.lvar)) stop 10
 read (99,*, iostat=stat) lvar
-if (stat /= 0 .or. lvar) STOP 11
+if (stat /= 0 .or. lvar) stop 11
 read (99,*) lvar ! << FAILS: stat /= 0
-if (stat /= 0 .or. (.not.lvar)) STOP 12
+if (stat /= 0 .or. (.not.lvar)) stop 12
 close(99, status="delete")
 
 ! Test combinations of Inf and Nan
@@ -77,11 +77,11 @@ close(99)
 
 open(99, file="test.dat")
 read (99,*, iostat=stat) var
-if (stat /= 0) STOP 13
+if (stat /= 0) stop 13
 read (99,*, iostat=stat) var
-if (stat /= 0) STOP 14
+if (stat /= 0) stop 14
 read (99,*) var          ! << FAILS: stat /= 0
-if (stat /= 0) STOP 1! << aborts here
+if (stat /= 0) stop 1! << aborts here
 close(99, status="delete")
 
 open(99, file="test.dat", access="stream", form="unformatted", status="new")
@@ -92,11 +92,11 @@ close(99)
 
 open(99, file="test.dat")
 read (99,*, iostat=stat) var
-if (stat /= 0) STOP 15
+if (stat /= 0) stop 15
 read (99,*, iostat=stat) var
-if (stat /= 0) STOP 16
+if (stat /= 0) stop 16
 read (99,*) var          ! << FAILS: stat /= 0
-if (stat /= 0) STOP 2! << aborts here
+if (stat /= 0) stop 2! << aborts here
 close(99, status="delete")
 
 open(99, file="test.dat", access="stream", form="unformatted", status="new")
@@ -107,11 +107,11 @@ close(99)
 
 open(99, file="test.dat")
 read (99,*, iostat=stat) var
-if (stat /= 0) STOP 17
+if (stat /= 0) stop 17
 read (99,*, iostat=stat) var
-if (stat /= 0) STOP 18
+if (stat /= 0) stop 18
 read (99,*) var          ! << FAILS: stat /= 0
-if (stat /= 0) STOP 3! << aborts here
+if (stat /= 0) stop 3! << aborts here
 close(99, status="delete")
 
 ! Test complex kind
@@ -123,10 +123,10 @@ close(99)
 
 open(99, file="test.dat")
 read (99,*, iostat=stat) cval
-if (stat /= 0 .or. cval /= cmplx(1,2)) STOP 19
+if (stat /= 0 .or. cval /= cmplx(1,2)) stop 19
 read (99,*, iostat=stat) cval
-if (stat /= 0 .or. cval /= cmplx(2,3)) STOP 20
+if (stat /= 0 .or. cval /= cmplx(2,3)) stop 20
 read (99,*, iostat=stat) cval      ! << FAILS: stat /= 0, value is okay
-if (stat /= 0 .or. cval /= cmplx(4,5)) STOP 21
+if (stat /= 0 .or. cval /= cmplx(4,5)) stop 21
 close(99, status="delete")
 end
diff --git a/libgomp/testsuite/libgomp.fortran/async_io_6.f90 b/libgomp/testsuite/libgomp.fortran/async_io_6.f90
index f19c0379202..75f5ca7a2af 100644
--- a/libgomp/testsuite/libgomp.fortran/async_io_6.f90
+++ b/libgomp/testsuite/libgomp.fortran/async_io_6.f90
@@ -17,12 +17,12 @@ program flush_1
 
    write (10, *) 42
    flush(unit=10, iostat=ios)
-   if (ios /= 0) STOP 1
+   if (ios /= 0) stop 1
 
    write (10, *) 42
    flush (unit=10, err=20)
    goto 30
-20 STOP 2
+20 stop 2
 30 continue
 
    call flush(10)
diff --git a/libgomp/testsuite/libgomp.fortran/async_io_7.f90 b/libgomp/testsuite/libgomp.fortran/async_io_7.f90
index a7ce9ba47a7..0c8dd1b8056 100644
--- a/libgomp/testsuite/libgomp.fortran/async_io_7.f90
+++ b/libgomp/testsuite/libgomp.fortran/async_io_7.f90
@@ -16,7 +16,7 @@ program newunit_1
   rewind(myunit)
   rewind(myunit2)
   read(myunit2,'(a)') str
-  if (str.ne." abcdefghijklmnop") STOP 1
+  if (str.ne." abcdefghijklmnop") stop 1
   close(myunit)
   close(myunit2, status="delete")
 end program newunit_1
diff --git a/libgomp/testsuite/libgomp.fortran/atomic1.f90 b/libgomp/testsuite/libgomp.fortran/atomic1.f90
new file mode 100644
index 00000000000..e0c13536f94
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/atomic1.f90
@@ -0,0 +1,46 @@
+! PR fortran/92899
+
+program pr92899
+  real :: x = 1.0
+  double precision :: y
+  integer(kind=4) :: z = 4
+  integer(kind=8) :: w
+  !$omp atomic capture
+  y = x
+  x = 2.0
+  !$omp end atomic
+  if (y /= 1.0 .or. x /= 2.0) stop 1
+  !$omp atomic capture
+  x = y
+  y = 3.0
+  !$omp end atomic
+  if (x /= 1.0 .or. y /= 3.0) stop 2
+  !$omp atomic capture
+  w = z
+  z = 5
+  !$omp end atomic
+  if (w /= 4 .or. z /= 5) stop 3
+  !$omp atomic capture
+  z = w
+  w = 6
+  !$omp end atomic
+  if (z /= 4 .or. w /= 6) stop 4
+  !$omp atomic write
+  x = y
+  !$omp end atomic
+  if (x /= 3.0 .or. y /= 3.0) stop 5
+  x = 7.0
+  !$omp atomic write
+  y = x
+  !$omp end atomic
+  if (x /= 7.0 .or. y /= 7.0) stop 6
+  !$omp atomic write
+  z = w
+  !$omp end atomic
+  if (z /= 6 .or. w /= 6) stop 7
+  z = 8
+  !$omp atomic write
+  w = z
+  !$omp end atomic
+  if (z /= 8 .or. w /= 8) stop 8
+end
diff --git a/libgomp/testsuite/libgomp.fortran/cancel-do-1.f90 b/libgomp/testsuite/libgomp.fortran/cancel-do-1.f90
index 84009ec2ac9..1c44e25d77d 100644
--- a/libgomp/testsuite/libgomp.fortran/cancel-do-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/cancel-do-1.f90
@@ -8,7 +8,7 @@
     !$omp do
       do i = 0, 999
 	!$omp cancel do
-	if (omp_get_cancellation ()) STOP 1
+	if (omp_get_cancellation ()) stop 1
       enddo
   !$omp endparallel
 end
diff --git a/libgomp/testsuite/libgomp.fortran/cancel-do-2.f90 b/libgomp/testsuite/libgomp.fortran/cancel-do-2.f90
index 9d8e91cec98..b5cca934291 100644
--- a/libgomp/testsuite/libgomp.fortran/cancel-do-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/cancel-do-2.f90
@@ -22,7 +22,7 @@ contains
       !$omp do
 	do i = 0, 999
 	  !$omp cancel do if (x(1))
-	  STOP 1
+	  stop 1
 	end do
       !$omp do
 	do i = 0, 999
@@ -47,7 +47,7 @@ contains
 	end do
       !$omp end do
     !$omp end parallel
-    if (v.ne.3000.or.w.ne.0) STOP 2
+    if (v.ne.3000.or.w.ne.0) stop 2
     !$omp parallel num_threads (32) shared (v, w)
       ! None of these cancel directives should actually cancel anything,
       ! but the compiler shouldn't know that and thus should use cancellable
@@ -56,7 +56,7 @@ contains
       !$omp do
 	do i = 0, 999
 	  !$omp cancel do if (x(1))
-	  STOP 3
+	  stop 3
 	end do
       !$omp cancel parallel if (omp_get_thread_num ().eq.2.and.x(5))
       !$omp do
@@ -85,6 +85,6 @@ contains
       !$omp end do
       !$omp cancel parallel if (omp_get_thread_num ().eq.5.and.x(5))
     !$omp end parallel
-    if (v.ne.6000.or.w.ne.0) STOP 4
+    if (v.ne.6000.or.w.ne.0) stop 4
   end subroutine
 end
diff --git a/libgomp/testsuite/libgomp.fortran/cancel-parallel-1.f90 b/libgomp/testsuite/libgomp.fortran/cancel-parallel-1.f90
index dc0f69b13ed..759870189ef 100644
--- a/libgomp/testsuite/libgomp.fortran/cancel-parallel-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/cancel-parallel-1.f90
@@ -5,6 +5,6 @@
 
   !$omp parallel num_threads(32)
     !$omp cancel parallel
-    if (omp_get_cancellation ()) STOP 1
+    if (omp_get_cancellation ()) stop 1
   !$omp end parallel
 end
diff --git a/libgomp/testsuite/libgomp.fortran/cancel-sections-1.f90 b/libgomp/testsuite/libgomp.fortran/cancel-sections-1.f90
index 7e1d4b37534..cfc3903592f 100644
--- a/libgomp/testsuite/libgomp.fortran/cancel-sections-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/cancel-sections-1.f90
@@ -7,16 +7,16 @@
     !$omp parallel num_threads(32)
       !$omp sections
 	  !$omp cancel sections
-	  STOP 1
+	  stop 1
 	!$omp section
 	  !$omp cancel sections
-	  STOP 2
+	  stop 2
 	!$omp section
 	  !$omp cancel sections
-	  STOP 3
+	  stop 3
 	!$omp section
 	  !$omp cancel sections
-	  STOP 4
+	  stop 4
       !$omp end sections
     !$omp end parallel
   end if
diff --git a/libgomp/testsuite/libgomp.fortran/cancel-taskgroup-2.f90 b/libgomp/testsuite/libgomp.fortran/cancel-taskgroup-2.f90
index 54c52208b97..693241ef71c 100644
--- a/libgomp/testsuite/libgomp.fortran/cancel-taskgroup-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/cancel-taskgroup-2.f90
@@ -8,7 +8,7 @@
     !$omp taskgroup
       !$omp task
 	!$omp cancel taskgroup
-	STOP 1
+	stop 1
       !$omp endtask
     !$omp endtaskgroup
   !$omp endparallel
diff --git a/libgomp/testsuite/libgomp.fortran/character1.f90 b/libgomp/testsuite/libgomp.fortran/character1.f90
index a672b7d2fdc..eb3c21d068d 100644
--- a/libgomp/testsuite/libgomp.fortran/character1.f90
+++ b/libgomp/testsuite/libgomp.fortran/character1.f90
@@ -67,6 +67,6 @@ contains
       l = l .or. f .ne. 'YY' .or. p .ne. 'm3' .or. r .ne. 'M3'
     end if
 !$omp end parallel
-    if (l) STOP 1
+    if (l) stop 1
   end subroutine test
 end
diff --git a/libgomp/testsuite/libgomp.fortran/character2.f90 b/libgomp/testsuite/libgomp.fortran/character2.f90
index 20a3f07c4b3..67ce63ac624 100644
--- a/libgomp/testsuite/libgomp.fortran/character2.f90
+++ b/libgomp/testsuite/libgomp.fortran/character2.f90
@@ -56,6 +56,6 @@ contains
       l = l .or. t .ne. '456'
     end if
 !$omp end parallel
-    if (l) STOP 1
+    if (l) stop 1
   end subroutine test
 end
diff --git a/libgomp/testsuite/libgomp.fortran/collapse1.f90 b/libgomp/testsuite/libgomp.fortran/collapse1.f90
index 3777b520245..c22085599c2 100644
--- a/libgomp/testsuite/libgomp.fortran/collapse1.f90
+++ b/libgomp/testsuite/libgomp.fortran/collapse1.f90
@@ -22,5 +22,5 @@ program collapse1
       end do
     end do
   !$omp end parallel do
-  if (l) STOP 1
+  if (l) stop 1
 end program collapse1
diff --git a/libgomp/testsuite/libgomp.fortran/collapse2.f90 b/libgomp/testsuite/libgomp.fortran/collapse2.f90
index 32d9fdd816f..47cd7c9e580 100644
--- a/libgomp/testsuite/libgomp.fortran/collapse2.f90
+++ b/libgomp/testsuite/libgomp.fortran/collapse2.f90
@@ -25,7 +25,7 @@ firstdo: do i = 1, 3
         end do
       end do firstdo
     !$omp end parallel do
-    if (l) STOP 1
+    if (l) stop 1
   end subroutine test1
 
   subroutine test2
@@ -38,7 +38,7 @@ firstdo: do i = 1, 3
           enddo
         enddo dokk
 115   continue
-    if (any(a(1:3,1:3,1:3).ne.1)) STOP 2
+    if (any(a(1:3,1:3,1:3).ne.1)) stop 2
 
     !$omp do collapse(3)
  dol: do 120 l=1,3
@@ -48,7 +48,7 @@ firstdo: do i = 1, 3
           enddo
         enddo doll
 120   end do dol
-    if (any(a(1:3,1:3,1:3).ne.2)) STOP 3
+    if (any(a(1:3,1:3,1:3).ne.2)) stop 3
   end subroutine test2
 
 end program collapse2
diff --git a/libgomp/testsuite/libgomp.fortran/collapse3.f90 b/libgomp/testsuite/libgomp.fortran/collapse3.f90
index 001dc2ac630..d463b4f39cc 100644
--- a/libgomp/testsuite/libgomp.fortran/collapse3.f90
+++ b/libgomp/testsuite/libgomp.fortran/collapse3.f90
@@ -24,8 +24,8 @@ contains
           end do
         end do
       end do
-    if (i.ne.7.or.j.ne.5.or.k.ne.19) STOP 1
-    if (m.ne.(600+40+18)) STOP 2
+    if (i.ne.7.or.j.ne.5.or.k.ne.19) stop 1
+    if (m.ne.(600+40+18)) stop 2
     do i = 1, 7
       do j = -3, 5
         do k = 12, 19
@@ -56,8 +56,8 @@ contains
           end do
         end do
       end do
-    if (i.ne.7.or.j.ne.5.or.k.ne.19) STOP 3
-    if (m.ne.(600+40+18)) STOP 4
+    if (i.ne.7.or.j.ne.5.or.k.ne.19) stop 3
+    if (m.ne.(600+40+18)) stop 4
     do i = 1, 7
       do j = -3, 5
         do k = 12, 19
@@ -88,8 +88,8 @@ contains
           end do
         end do
       end do
-    if (i.ne.7.or.j.ne.5.or.k.ne.19) STOP 5
-    if (m.ne.(600+40+18)) STOP 6
+    if (i.ne.7.or.j.ne.5.or.k.ne.19) stop 5
+    if (m.ne.(600+40+18)) stop 6
     do i = 1, 7
       do j = -3, 5
         do k = 12, 19
@@ -120,8 +120,8 @@ contains
           end do
         end do
       end do
-    if (i.ne.7.or.j.ne.5.or.k.ne.19) STOP 7
-    if (m.ne.(600+40+18)) STOP 8
+    if (i.ne.7.or.j.ne.5.or.k.ne.19) stop 7
+    if (m.ne.(600+40+18)) stop 8
     do i = 1, 7
       do j = -3, 5
         do k = 12, 19
@@ -153,8 +153,8 @@ contains
           end do
         end do
       end do
-    if (i.ne.7.or.j.ne.5.or.k.ne.19) STOP 9
-    if (m.ne.(600+40+18)) STOP 10
+    if (i.ne.7.or.j.ne.5.or.k.ne.19) stop 9
+    if (m.ne.(600+40+18)) stop 10
     do i = 1, 7
       do j = -3, 5
         do k = 12, 19
@@ -186,8 +186,8 @@ contains
           end do
         end do
       end do
-    if (i.ne.7.or.j.ne.5.or.k.ne.19) STOP 11
-    if (m.ne.(600+40+18)) STOP 12
+    if (i.ne.7.or.j.ne.5.or.k.ne.19) stop 11
+    if (m.ne.(600+40+18)) stop 12
     do i = 1, 7
       do j = -3, 5
         do k = 12, 19
diff --git a/libgomp/testsuite/libgomp.fortran/collapse4.f90 b/libgomp/testsuite/libgomp.fortran/collapse4.f90
index 2019d8dcccd..8c28571975b 100644
--- a/libgomp/testsuite/libgomp.fortran/collapse4.f90
+++ b/libgomp/testsuite/libgomp.fortran/collapse4.f90
@@ -8,5 +8,5 @@
         end do
       end do
     end do
-  if (i .ne. 18 .or. j .ne. 7 .or. k .ne. 6) STOP 1
+  if (i .ne. 18 .or. j .ne. 7 .or. k .ne. 6) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/crayptr1.f90 b/libgomp/testsuite/libgomp.fortran/crayptr1.f90
index 28e2aa62d80..2340257f3f6 100644
--- a/libgomp/testsuite/libgomp.fortran/crayptr1.f90
+++ b/libgomp/testsuite/libgomp.fortran/crayptr1.f90
@@ -26,7 +26,7 @@
   l = l .or. p .ne. 3
 !$omp end parallel
 
-  if (l) STOP 1
+  if (l) stop 1
 
   l = .false.
 !$omp parallel num_threads (2) reduction (.or.:l) default (private)
@@ -41,6 +41,6 @@
   l = l .or. p .ne. 3 * omp_get_thread_num () + 5
 !$omp end parallel
 
-  if (l) STOP 2
+  if (l) stop 2
 
 end
diff --git a/libgomp/testsuite/libgomp.fortran/crayptr2.f90 b/libgomp/testsuite/libgomp.fortran/crayptr2.f90
index 2847de92e37..3014be832a3 100644
--- a/libgomp/testsuite/libgomp.fortran/crayptr2.f90
+++ b/libgomp/testsuite/libgomp.fortran/crayptr2.f90
@@ -27,5 +27,5 @@
   l = l .or. (p .ne. d + 1)
 !$omp end parallel
 
-  if (l) STOP 1
+  if (l) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/crayptr3.f90 b/libgomp/testsuite/libgomp.fortran/crayptr3.f90
index bb48f9e7371..2d360fa5a8b 100644
--- a/libgomp/testsuite/libgomp.fortran/crayptr3.f90
+++ b/libgomp/testsuite/libgomp.fortran/crayptr3.f90
@@ -18,7 +18,7 @@
   l = l .or. (p .ne. (2 + omp_get_thread_num ()))
 !$omp end parallel
 
-  if (l) STOP 1
+  if (l) stop 1
 
   l = .false.
   ip = loc (a)
@@ -31,6 +31,6 @@
     l = l .or. (p .ne. (2 + i))
   end do
 
-  if (l) STOP 2
-  if (p .ne. 3) STOP 3
+  if (l) stop 2
+  if (p .ne. 3) stop 3
 end
diff --git a/libgomp/testsuite/libgomp.fortran/declare-simd-1.f90 b/libgomp/testsuite/libgomp.fortran/declare-simd-1.f90
index c5b021dd951..cb8f4df8d62 100644
--- a/libgomp/testsuite/libgomp.fortran/declare-simd-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/declare-simd-1.f90
@@ -61,7 +61,7 @@ end module declare_simd_1_mod
   do i = 1, 128
     b(i) = bar (a(i), 2 * i, b(i))
   end do
-  if (any (b.ne.d)) STOP 1
+  if (any (b.ne.d)) stop 1
   !$omp simd
   do i = 1, 128
     b(i) = i * 2.0
@@ -71,7 +71,7 @@ end module declare_simd_1_mod
     b(i) = baz (7.0_8, 2, b(i))
   end do
   do i = 1, 128
-    if (b(i).ne.(7.0 + 4.0 * i)) STOP 2
+    if (b(i).ne.(7.0 + 4.0 * i)) stop 2
   end do
 contains
   function baz (x, y, z)
diff --git a/libgomp/testsuite/libgomp.fortran/declare-simd-3.f90 b/libgomp/testsuite/libgomp.fortran/declare-simd-3.f90
index 85cea9cab0a..3a20e0aad70 100644
--- a/libgomp/testsuite/libgomp.fortran/declare-simd-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/declare-simd-3.f90
@@ -17,6 +17,6 @@ subroutine bar
     b(i) = foo (7.0_8, 5 * i, b(i))
   end do
   do i = 1, 128
-    if (b(i).ne.(7.0 + 10.0 * i * i)) STOP 1
+    if (b(i).ne.(7.0 + 10.0 * i * i)) stop 1
   end do
 end subroutine bar
diff --git a/libgomp/testsuite/libgomp.fortran/declare-target-2.f90 b/libgomp/testsuite/libgomp.fortran/declare-target-2.f90
index 1fbc0dc0cb7..85fc68c6ede 100644
--- a/libgomp/testsuite/libgomp.fortran/declare-target-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/declare-target-2.f90
@@ -14,5 +14,5 @@ subroutine foo
   !$omp end target
 
   !$omp target update from(var_x)
-  if (var_x /= 20) STOP 1
+  if (var_x /= 20) stop 1
 end subroutine foo
diff --git a/libgomp/testsuite/libgomp.fortran/depend-1.f90 b/libgomp/testsuite/libgomp.fortran/depend-1.f90
index 5f7bb5faf21..85792fa9b4b 100644
--- a/libgomp/testsuite/libgomp.fortran/depend-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/depend-1.f90
@@ -21,7 +21,7 @@ contains
           x = 2
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 1
+          if (x.ne.2) stop 1
         !$omp end task
       !$omp end single
     !$omp end parallel
@@ -36,7 +36,7 @@ contains
           x = 2
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 2
+          if (x.ne.2) stop 2
         !$omp end task
         !$omp taskwait
       !$omp end single
@@ -52,7 +52,7 @@ contains
           x = 2
         !$omp endtask
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 3
+          if (x.ne.2) stop 3
         !$omp endtask
       !$omp endsingle
     !$omp endparallel
@@ -67,7 +67,7 @@ contains
           x = 2
         !$omp end task
         !$omp task depend(in: x)
-          if (x.ne.1) STOP 4
+          if (x.ne.1) stop 4
         !$omp end task
       !$omp end single
     !$omp end parallel
@@ -79,7 +79,7 @@ contains
     !$omp parallel
       !$omp single
         !$omp task shared(x) depend(in: x)
-          if (x.ne.1) STOP 5
+          if (x.ne.1) stop 5
         !$omp end task
         !$omp task shared(x) depend(out: x)
           x = 2
@@ -95,7 +95,7 @@ contains
         x = 1
         !$omp taskgroup
           !$omp task shared(x) depend(in: x)
-            if (x.ne.1) STOP 6
+            if (x.ne.1) stop 6
           !$omp end task
           !$omp task shared(x) depend(out: x)
             x = 2
@@ -111,7 +111,7 @@ contains
       x = 1
       !$omp single
         !$omp task shared(x) depend(in: x)
-          if (x.ne.1) STOP 7
+          if (x.ne.1) stop 7
         !$omp end task
         !$omp task shared(x) depend(out: x)
           x = 2
@@ -132,7 +132,7 @@ contains
           x = 2
         !$omp end task
         !$omp taskwait
-        if (x.ne.2) STOP 8
+        if (x.ne.2) stop 8
       !$omp end single
     !$omp end parallel
   end subroutine outdep
@@ -146,13 +146,13 @@ contains
           x = 2
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 9
+          if (x.ne.2) stop 9
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 10
+          if (x.ne.2) stop 10
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 11
+          if (x.ne.2) stop 11
         !$omp end task
       !$omp end single
     !$omp end parallel
@@ -167,13 +167,13 @@ contains
           x = 2;
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 12
+          if (x.ne.2) stop 12
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 13
+          if (x.ne.2) stop 13
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 14
+          if (x.ne.2) stop 14
         !$omp end task
         !$omp taskwait
       !$omp end single
@@ -189,13 +189,13 @@ contains
           x = 2
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 15
+          if (x.ne.2) stop 15
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 16
+          if (x.ne.2) stop 16
         !$omp end task
         !$omp task shared (x) depend(in: x)
-          if (x.ne.2) STOP 17
+          if (x.ne.2) stop 17
         !$omp end task
       !$omp end single
     !$omp end parallel
diff --git a/libgomp/testsuite/libgomp.fortran/depend-2.f90 b/libgomp/testsuite/libgomp.fortran/depend-2.f90
index b53ba0795e6..4384c1f760e 100644
--- a/libgomp/testsuite/libgomp.fortran/depend-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/depend-2.f90
@@ -6,7 +6,7 @@
     !$omp single
       !$omp taskgroup
         !$omp task depend(in: x(:, :))
-	  if (y.ne.1) STOP 1
+	  if (y.ne.1) stop 1
         !$omp end task
         !$omp task depend(out: x(:, :))
 	  y = 2
@@ -14,7 +14,7 @@
       !$omp end taskgroup
       !$omp taskgroup
         !$omp task depend(in: x(4, 7))
-	  if (y.ne.2) STOP 2
+	  if (y.ne.2) stop 2
         !$omp end task
         !$omp task depend(out: x(4:4, 7:7))
 	  y = 3
@@ -22,7 +22,7 @@
       !$omp end taskgroup
       !$omp taskgroup
         !$omp task depend(in: x(4:, 8:))
-	  if (y.ne.3) STOP 3
+	  if (y.ne.3) stop 3
         !$omp end task
         !$omp task depend(out: x(4:6, 8:12))
 	  y = 4
@@ -30,5 +30,5 @@
       !$omp end taskgroup
     !$omp end single
   !$omp end parallel
-  if (y.ne.4) STOP 4
+  if (y.ne.4) stop 4
 end
diff --git a/libgomp/testsuite/libgomp.fortran/depend-3.f90 b/libgomp/testsuite/libgomp.fortran/depend-3.f90
index 09478da4134..aa948edd916 100644
--- a/libgomp/testsuite/libgomp.fortran/depend-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/depend-3.f90
@@ -13,7 +13,7 @@ contains
       !$omp single
         !$omp taskgroup
           !$omp task depend(in: x)
-  	  if (y.ne.1) STOP 1
+  	  if (y.ne.1) stop 1
           !$omp end task
           !$omp task depend(out: x(1:2, 1:3))
   	  y = 2
@@ -21,7 +21,7 @@ contains
         !$omp end taskgroup
         !$omp taskgroup
           !$omp task depend(in: z)
-  	  if (y.ne.2) STOP 2
+  	  if (y.ne.2) stop 2
           !$omp end task
           !$omp task depend(out: z(-2:3, 2:4))
   	  y = 3
@@ -29,7 +29,7 @@ contains
         !$omp end taskgroup
         !$omp taskgroup
           !$omp task depend(in: x)
-  	  if (y.ne.3) STOP 3
+  	  if (y.ne.3) stop 3
           !$omp end task
           !$omp task depend(out: x(1:, 1:))
   	  y = 4
@@ -37,6 +37,6 @@ contains
         !$omp end taskgroup
       !$omp end single
     !$omp end parallel
-    if (y.ne.4) STOP 4
+    if (y.ne.4) stop 4
   end subroutine
 end
diff --git a/libgomp/testsuite/libgomp.fortran/do1.f90 b/libgomp/testsuite/libgomp.fortran/do1.f90
index bb7b6d83e14..e85f6371a9b 100644
--- a/libgomp/testsuite/libgomp.fortran/do1.f90
+++ b/libgomp/testsuite/libgomp.fortran/do1.f90
@@ -47,7 +47,7 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b)) STOP 1
+  if (any (a .ne. b)) stop 1
   a = -1
 
 !$omp parallel num_threads (4)
@@ -79,7 +79,7 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b)) STOP 2
+  if (any (a .ne. b)) stop 2
   a = -1
 
 !$omp parallel num_threads (4)
@@ -111,7 +111,7 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b)) STOP 3
+  if (any (a .ne. b)) stop 3
   a = -1
 
 !$omp parallel num_threads (4)
@@ -143,7 +143,7 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b)) STOP 4
+  if (any (a .ne. b)) stop 4
   a = -1
 
 !$omp parallel num_threads (4)
@@ -175,5 +175,5 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b)) STOP 5
+  if (any (a .ne. b)) stop 5
 end
diff --git a/libgomp/testsuite/libgomp.fortran/do2.f90 b/libgomp/testsuite/libgomp.fortran/do2.f90
index 11e3b8cec11..b6081831b1f 100644
--- a/libgomp/testsuite/libgomp.fortran/do2.f90
+++ b/libgomp/testsuite/libgomp.fortran/do2.f90
@@ -86,7 +86,7 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b) .or. k) STOP 1
+  if (any (a .ne. b) .or. k) stop 1
   a = -1
   k = .false.
   j = 8
@@ -155,7 +155,7 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b) .or. k) STOP 2
+  if (any (a .ne. b) .or. k) stop 2
   a = -1
   k = .false.
   j = 8
@@ -224,7 +224,7 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b) .or. k) STOP 3
+  if (any (a .ne. b) .or. k) stop 3
   a = -1
   k = .false.
   j = 8
@@ -293,7 +293,7 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b) .or. k) STOP 4
+  if (any (a .ne. b) .or. k) stop 4
   a = -1
   k = .false.
   j = 8
@@ -362,5 +362,5 @@
 
 !$omp end parallel
 
-  if (any (a .ne. b) .or. k) STOP 5
+  if (any (a .ne. b) .or. k) stop 5
 end
diff --git a/libgomp/testsuite/libgomp.fortran/do_concurrent_5.f90 b/libgomp/testsuite/libgomp.fortran/do_concurrent_5.f90
index 6fb9d1e8d96..971cd634a5f 100644
--- a/libgomp/testsuite/libgomp.fortran/do_concurrent_5.f90
+++ b/libgomp/testsuite/libgomp.fortran/do_concurrent_5.f90
@@ -33,7 +33,7 @@ program main
     do concurrent (i = 1:nsplit)
         pi(i) = sum(compute( low(i), high(i) ))
     end do
-    if (abs (sum(pi) - atan(1.0d0)) > 1e-5) STOP 1
+    if (abs (sum(pi) - atan(1.0d0)) > 1e-5) stop 1
     
 contains
     
diff --git a/libgomp/testsuite/libgomp.fortran/doacross1.f90 b/libgomp/testsuite/libgomp.fortran/doacross1.f90
index e3beda05e89..2b15e7d7d11 100644
--- a/libgomp/testsuite/libgomp.fortran/doacross1.f90
+++ b/libgomp/testsuite/libgomp.fortran/doacross1.f90
@@ -17,14 +17,14 @@
       if (i.gt.1) then
         !$omp atomic read
         l = a(i - 1)
-        if (l.lt.2) STOP 1
+        if (l.lt.2) stop 1
       end if
       !$omp atomic write
       a(i) = 2
       if (i.lt.N) then
         !$omp atomic read
         l = a(i + 1)
-        if (l.eq.3) STOP 2
+        if (l.eq.3) stop 2
       end if
       !$omp ordered depend(source)
       !$omp atomic write
@@ -43,19 +43,19 @@
           if (j.gt.2.and.k.gt.2) then
             !$omp atomic read
             l = b(i,j-2,k-1)
-            if (l.lt.2) STOP 3
+            if (l.lt.2) stop 3
           end if
           !$omp atomic write
           b(i,j,k) = 2
           if (i.gt.4.and.j.gt.2.and.k.lt.4) then
             !$omp atomic read
             l = b(i-2,j-2, k+1)
-            if (l.lt.2) STOP 4
+            if (l.lt.2) stop 4
           end if
           if (i.gt.5.and.j.le.N/16-3.and.k.eq.4) then
             !$omp atomic read
             l = b( i - 3, j+2, k-2)
-            if (l.lt.2) STOP 5
+            if (l.lt.2) stop 5
           end if
           !$omp ordered depend(source)
           !$omp atomic write
@@ -94,19 +94,19 @@
             if (k.le.5) then
               !$omp atomic read
               l = c(i, j, k + 2)
-              if (l.lt.2) STOP 6
+              if (l.lt.2) stop 6
             end if
             !$omp atomic write
             c(i, j, k) = 2
             if (i.ge.3.and.j.lt.8.and.k.ge.5) then
               !$omp atomic read
               l = c(i - 2, j + 1, k - 4)
-              if (l.lt.2) STOP 7
+              if (l.lt.2) stop 7
             end if
             if (i.ge.2.and.j.ge.5.and.k.ge.3) then
               !$omp atomic read
               l = c(i - 1, j - 2, k - 2)
-              if (l.lt.2) STOP 8
+              if (l.lt.2) stop 8
             end if
             !$omp ordered depend ( source )
             !$omp atomic write
@@ -137,13 +137,13 @@
           do l = 0, d + 1
             !$omp ordered depend(source)
             !$omp ordered depend(sink: i-2,j+2,k-2,l)
-            if (e.eq.0) STOP 9
+            if (e.eq.0) stop 9
           end do
         end do
       end do
     end do
     !$omp single
-    if (i.ne.1.or.j.ne.-1.or.k.ne.0) STOP 10
+    if (i.ne.1.or.j.ne.-1.or.k.ne.0) stop 10
     i = 8; j = 9; k = 10
     !$omp end single
     !$omp do ordered(4) collapse(2) lastprivate (i, j, k, m)
@@ -153,13 +153,13 @@
           do m = 0, d-1
             !$omp ordered depend(source)
             !$omp ordered depend(sink: i - 2, j + 2, k - 2, m)
-            STOP 11
+            stop 11
           end do
         end do
       end do
     end do
     !$omp single
-    if (i.ne.1.or.j.ne.-1.or.k.ne.2.or.m.ne.0) STOP 12
+    if (i.ne.1.or.j.ne.-1.or.k.ne.2.or.m.ne.0) stop 12
     !$omp end single
     !$omp do collapse(2) ordered(4) lastprivate (i,j,k)
     do i = 0, d
@@ -168,7 +168,7 @@
           do l = 0, d + 3
             !$omp ordered depend(source)
             !$omp ordered depend(sink: i-2,j+2,k-2,l)
-            if (e.eq.0) STOP 13
+            if (e.eq.0) stop 13
           end do
         end do
       end do
@@ -176,7 +176,7 @@
     !$omp end do nowait
     !$omp do
     do i = 1, N
-      if (a(i) .ne. 3) STOP 14
+      if (a(i) .ne. 3) stop 14
     end do
     !$omp end do nowait
     !$omp do collapse(2) private(k)
@@ -184,9 +184,9 @@
       do j = 1, 8
         do k = 1, 4
           if (i.ge.3.and.i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.2) then
-            if (b(i,j,k).ne.3) STOP 15
+            if (b(i,j,k).ne.3) stop 15
           else
-            if (b(i,j,k).ne.0) STOP 16
+            if (b(i,j,k).ne.0) stop 16
           end if
         end do
       end do
@@ -197,9 +197,9 @@
       do j = 1, 8
         do k = 1, 4
           if (j.ge.3.and.iand(k,1).ne.0) then
-            if (c(i,j,k).ne.3) STOP 17
+            if (c(i,j,k).ne.3) stop 17
           else
-            if (c(i,j,k).ne.0) STOP 18
+            if (c(i,j,k).ne.0) stop 18
           end if
         end do
       end do
diff --git a/libgomp/testsuite/libgomp.fortran/doacross2.f90 b/libgomp/testsuite/libgomp.fortran/doacross2.f90
index 226dbe2c14e..213ac715f9e 100644
--- a/libgomp/testsuite/libgomp.fortran/doacross2.f90
+++ b/libgomp/testsuite/libgomp.fortran/doacross2.f90
@@ -20,14 +20,14 @@
       if (i.gt.2) then
         !$omp atomic read
         l = a(i - 1)
-        if (l.lt.2) STOP 1
+        if (l.lt.2) stop 1
       end if
       !$omp atomic write
       a(i) = 2
       if (i.lt.N) then
         !$omp atomic read
         l = a(i + 1)
-        if (l.eq.3) STOP 2
+        if (l.eq.3) stop 2
       end if
       !$omp ordered depend(source)
       !$omp atomic write
@@ -46,19 +46,19 @@
           if (j.gt.2.and.k.gt.2) then
             !$omp atomic read
             l = b(i,j-2,k-1)
-            if (l.lt.2) STOP 3
+            if (l.lt.2) stop 3
           end if
           !$omp atomic write
           b(i,j,k) = 2
           if (i.gt.5.and.j.gt.2.and.k.lt.4) then
             !$omp atomic read
             l = b(i-2,j-2, k+1)
-            if (l.lt.2) STOP 4
+            if (l.lt.2) stop 4
           end if
           if (i.gt.6.and.j.le.N/16-3.and.k.eq.4) then
             !$omp atomic read
             l = b( i - 3, j+2, k-2)
-            if (l.lt.2) STOP 5
+            if (l.lt.2) stop 5
           end if
           !$omp ordered depend(source)
           !$omp atomic write
@@ -97,19 +97,19 @@
             if (k.le.5) then
               !$omp atomic read
               l = c(i, j, k + 2)
-              if (l.lt.2) STOP 6
+              if (l.lt.2) stop 6
             end if
             !$omp atomic write
             c(i, j, k) = 2
             if (i.ge.5.and.j.lt.8.and.k.ge.5) then
               !$omp atomic read
               l = c(i - 2, j + 1, k - 4)
-              if (l.lt.2) STOP 7
+              if (l.lt.2) stop 7
             end if
             if (i.ge.4.and.j.ge.5.and.k.ge.3) then
               !$omp atomic read
               l = c(i - 1, j - 2, k - 2)
-              if (l.lt.2) STOP 8
+              if (l.lt.2) stop 8
             end if
             !$omp ordered depend ( source )
             !$omp atomic write
@@ -145,19 +145,19 @@
           if (k.gt.2.and.i.gt.4) then
             !$omp atomic read
             l = g(j,k-2,i-1)
-            if (l.lt.2) STOP 9
+            if (l.lt.2) stop 9
           end if
           !$omp atomic write
           g(j,k,i) = 2
           if (j.gt.2.and.k.gt.2.and.i.lt.6) then
             !$omp atomic read
             l = g(j-2,k-2, i+1)
-            if (l.lt.2) STOP 10
+            if (l.lt.2) stop 10
           end if
           if (j.gt.3.and.k.le.N/16-3.and.i.eq.6) then
             !$omp atomic read
             l = g( j - 3, k+2, i-2)
-            if (l.lt.2) STOP 11
+            if (l.lt.2) stop 11
           end if
           !$omp ordered depend(source)
           !$omp atomic write
@@ -173,13 +173,13 @@
           do l = 0, d + 1
             !$omp ordered depend(source)
             !$omp ordered depend(sink: i-2,j+2,k-2,l)
-            if (e.eq.0) STOP 12
+            if (e.eq.0) stop 12
           end do
         end do
       end do
     end do
     !$omp single
-    if (i.ne.3.or.j.ne.-1.or.k.ne.0) STOP 13
+    if (i.ne.3.or.j.ne.-1.or.k.ne.0) stop 13
     i = 8; j = 9; k = 10
     !$omp end single
     !$omp do ordered(4) collapse(2) lastprivate (i, j, k, m)
@@ -189,13 +189,13 @@
           do m = 0, d-1
             !$omp ordered depend(source)
             !$omp ordered depend(sink: i - 2, j + 2, k - 2, m)
-            STOP 14
+            stop 14
           end do
         end do
       end do
     end do
     !$omp single
-    if (i.ne.3.or.j.ne.-1.or.k.ne.2.or.m.ne.0) STOP 15
+    if (i.ne.3.or.j.ne.-1.or.k.ne.2.or.m.ne.0) stop 15
     !$omp end single
     !$omp do collapse(2) ordered(4) lastprivate (i,j,k)
     do i = 2, f + 2
@@ -204,18 +204,18 @@
           do l = 0, d + 3
             !$omp ordered depend(source)
             !$omp ordered depend(sink: i-2,j+2,k-2,l)
-            if (e.eq.0) STOP 16
+            if (e.eq.0) stop 16
           end do
         end do
       end do
     end do
     !$omp end do nowait
     !$omp single
-    if (a(1) .ne. 0) STOP 17
+    if (a(1) .ne. 0) stop 17
     !$omp end single nowait
     !$omp do
     do i = 2, N
-      if (a(i) .ne. 3) STOP 18
+      if (a(i) .ne. 3) stop 18
     end do
     !$omp end do nowait
     !$omp do collapse(2) private(k)
@@ -223,9 +223,9 @@
       do j = 1, 8
         do k = 1, 4
           if (i.ge.4.and.i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.2) then
-            if (b(i,j,k).ne.3) STOP 19
+            if (b(i,j,k).ne.3) stop 19
           else
-            if (b(i,j,k).ne.0) STOP 20
+            if (b(i,j,k).ne.0) stop 20
           end if
         end do
       end do
@@ -236,9 +236,9 @@
       do j = 1, 8
         do k = 1, 4
           if (i.ge.3.and.j.ge.3.and.iand(k,1).ne.0) then
-            if (c(i,j,k).ne.3) STOP 21
+            if (c(i,j,k).ne.3) stop 21
           else
-            if (c(i,j,k).ne.0) STOP 22
+            if (c(i,j,k).ne.0) stop 22
           end if
         end do
       end do
@@ -249,9 +249,9 @@
       do j = 1, 8
         do k = 1, 6
           if (i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.4) then
-            if (g(i,j,k).ne.3) STOP 23
+            if (g(i,j,k).ne.3) stop 23
           else
-            if (g(i,j,k).ne.0) STOP 24
+            if (g(i,j,k).ne.0) stop 24
           end if
         end do
       end do
diff --git a/libgomp/testsuite/libgomp.fortran/doacross3.f90 b/libgomp/testsuite/libgomp.fortran/doacross3.f90
index 6649894a8fe..5ba57008c6f 100644
--- a/libgomp/testsuite/libgomp.fortran/doacross3.f90
+++ b/libgomp/testsuite/libgomp.fortran/doacross3.f90
@@ -20,14 +20,14 @@
       if (i.gt.2) then
         !$omp atomic read
         l = a(i - 1)
-        if (l.lt.2) STOP 1
+        if (l.lt.2) stop 1
       end if
       !$omp atomic write
       a(i) = 2
       if (i.lt.N) then
         !$omp atomic read
         l = a(i + 1)
-        if (l.eq.3) STOP 2
+        if (l.eq.3) stop 2
       end if
       !$omp ordered depend(source)
       !$omp atomic write
@@ -46,19 +46,19 @@
           if (j.gt.2.and.k.gt.2) then
             !$omp atomic read
             l = b(i,j-2,k-1)
-            if (l.lt.2) STOP 3
+            if (l.lt.2) stop 3
           end if
           !$omp atomic write
           b(i,j,k) = 2
           if (i.gt.5.and.j.gt.2.and.k.lt.4) then
             !$omp atomic read
             l = b(i-2,j-2, k+1)
-            if (l.lt.2) STOP 4
+            if (l.lt.2) stop 4
           end if
           if (i.gt.6.and.j.le.N/16-3.and.k.eq.4) then
             !$omp atomic read
             l = b( i - 3, j+2, k-2)
-            if (l.lt.2) STOP 5
+            if (l.lt.2) stop 5
           end if
           !$omp ordered depend(source)
           !$omp atomic write
@@ -97,19 +97,19 @@
             if (k.le.5) then
               !$omp atomic read
               l = c(i, j, k + 2)
-              if (l.lt.2) STOP 6
+              if (l.lt.2) stop 6
             end if
             !$omp atomic write
             c(i, j, k) = 2
             if (i.ge.5.and.j.lt.8.and.k.ge.5) then
               !$omp atomic read
               l = c(i - 2, j + 1, k - 4)
-              if (l.lt.2) STOP 7
+              if (l.lt.2) stop 7
             end if
             if (i.ge.4.and.j.ge.5.and.k.ge.3) then
               !$omp atomic read
               l = c(i - 1, j - 2, k - 2)
-              if (l.lt.2) STOP 8
+              if (l.lt.2) stop 8
             end if
             !$omp ordered depend ( source )
             !$omp atomic write
@@ -145,19 +145,19 @@
           if (k.gt.2.and.i.gt.4) then
             !$omp atomic read
             l = g(j,k-2,i-1)
-            if (l.lt.2) STOP 9
+            if (l.lt.2) stop 9
           end if
           !$omp atomic write
           g(j,k,i) = 2
           if (j.gt.2.and.k.gt.2.and.i.lt.6) then
             !$omp atomic read
             l = g(j-2,k-2, i+1)
-            if (l.lt.2) STOP 10
+            if (l.lt.2) stop 10
           end if
           if (j.gt.3.and.k.le.N/16-3.and.i.eq.6) then
             !$omp atomic read
             l = g( j - 3, k+2, i-2)
-            if (l.lt.2) STOP 11
+            if (l.lt.2) stop 11
           end if
           !$omp ordered depend(source)
           !$omp atomic write
@@ -173,13 +173,13 @@
           do l = 0, d + 1, 1 + d
             !$omp ordered depend(source)
             !$omp ordered depend(sink: i-2,j+2,k-2,l)
-            if (e.eq.0) STOP 12
+            if (e.eq.0) stop 12
           end do
         end do
       end do
     end do
     !$omp single
-    if (i.ne.3.or.j.ne.-1.or.k.ne.0) STOP 13
+    if (i.ne.3.or.j.ne.-1.or.k.ne.0) stop 13
     i = 8; j = 9; k = 10
     !$omp end single
     !$omp do ordered(4) collapse(2) lastprivate (i, j, k, m)
@@ -189,13 +189,13 @@
           do m = 0, d-1, d+1
             !$omp ordered depend(source)
             !$omp ordered depend(sink: i - 2, j + 2, k - 2, m)
-            STOP 14
+            stop 14
           end do
         end do
       end do
     end do
     !$omp single
-    if (i.ne.3.or.j.ne.-1.or.k.ne.2.or.m.ne.0) STOP 15
+    if (i.ne.3.or.j.ne.-1.or.k.ne.2.or.m.ne.0) stop 15
     !$omp end single
     !$omp do collapse(2) ordered(4) lastprivate (i,j,k)
     do i = 2, f + 2, 1 + f
@@ -204,18 +204,18 @@
           do l = 0, d + 3, d + 1
             !$omp ordered depend(source)
             !$omp ordered depend(sink: i-2,j+2,k-2,l)
-            if (e.eq.0) STOP 16
+            if (e.eq.0) stop 16
           end do
         end do
       end do
     end do
     !$omp end do nowait
     !$omp single
-    if (a(1) .ne. 0) STOP 17
+    if (a(1) .ne. 0) stop 17
     !$omp end single nowait
     !$omp do
     do i = 2, N
-      if (a(i) .ne. 3) STOP 18
+      if (a(i) .ne. 3) stop 18
     end do
     !$omp end do nowait
     !$omp do collapse(2) private(k)
@@ -223,9 +223,9 @@
       do j = 1, 8
         do k = 1, 4
           if (i.ge.4.and.i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.2) then
-            if (b(i,j,k).ne.3) STOP 19
+            if (b(i,j,k).ne.3) stop 19
           else
-            if (b(i,j,k).ne.0) STOP 20
+            if (b(i,j,k).ne.0) stop 20
           end if
         end do
       end do
@@ -236,9 +236,9 @@
       do j = 1, 8
         do k = 1, 4
           if (i.ge.3.and.j.ge.3.and.iand(k,1).ne.0) then
-            if (c(i,j,k).ne.3) STOP 21
+            if (c(i,j,k).ne.3) stop 21
           else
-            if (c(i,j,k).ne.0) STOP 22
+            if (c(i,j,k).ne.0) stop 22
           end if
         end do
       end do
@@ -249,9 +249,9 @@
       do j = 1, 8
         do k = 1, 6
           if (i.lt.N/16.and.iand(j,1).ne.0.and.k.ge.4) then
-            if (g(i,j,k).ne.3) STOP 23
+            if (g(i,j,k).ne.3) stop 23
           else
-            if (g(i,j,k).ne.0) STOP 24
+            if (g(i,j,k).ne.0) stop 24
           end if
         end do
       end do
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/array_sections-3.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/array_sections-3.f90
index 08091b83fcb..50c71300fb6 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/array_sections-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/array_sections-3.f90
@@ -12,6 +12,6 @@ contains
         p(9) = 777
       !$omp end target
     !$omp end target data
-    if (A(3) /= 777 .or. A(9) /= 777) STOP 1
+    if (A(3) /= 777 .or. A(9) /= 777) stop 1
   end subroutine
 end
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/array_sections-4.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/array_sections-4.f90
index f730894bd95..e6715e37532 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/array_sections-4.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/array_sections-4.f90
@@ -13,6 +13,6 @@ contains
         A(9) = 999
       !$omp end target
     !$omp end target data
-    if (A(3) /= 777 .or. A(9) /= 999) STOP 1
+    if (A(3) /= 777 .or. A(9) /= 999) stop 1
   end subroutine
 end
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/async_target-1.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/async_target-1.f90
index dd6f7f5a791..6d1fc98cb74 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/async_target-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/async_target-1.f90
@@ -27,7 +27,7 @@ subroutine check ()
     else
       err = (Y(i) - Z(i)) / Z(i)
     end if
-    if (err > EPS .or. err < -EPS) STOP 1
+    if (err > EPS .or. err < -EPS) stop 1
   end do
 end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/async_target-2.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/async_target-2.f90
index 2380f3a01f0..ad35539aa44 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/async_target-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/async_target-2.f90
@@ -17,7 +17,7 @@ subroutine check (p, N)
   real :: diff, p(N)
   do i = 1, N
     diff = p(i) - (i + 2.0) * (i - 3.0)
-    if (diff > EPS .or. -diff > EPS) STOP 1
+    if (diff > EPS .or. -diff > EPS) stop 1
   end do
 end subroutine
 
@@ -30,14 +30,14 @@ subroutine vec_mult (p, N)
   !$omp target data map(to: v1, v2, N) map(from: p)
     !$omp task shared(v1, v2, p) depend(out: v1, v2)
       !$omp target map(to: v1, v2, N)
-        if (omp_is_initial_device ()) STOP 2
+        if (omp_is_initial_device ()) stop 2
         allocate (v1(N), v2(N))
         call init (v1, v2, N)
       !$omp end target
     !$omp end task
     !$omp task shared(v1, v2, p) depend(in: v1, v2)
       !$omp target map(to: v1, v2, N) map(from: p)
-        if (omp_is_initial_device ()) STOP 3
+        if (omp_is_initial_device ()) stop 3
         !$omp parallel do
         do i = 1, N
           p(i) = v1(i) * v2(i)
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-1.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-1.f90
index 51de6b26b36..e439fe1b738 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-1.f90
@@ -26,8 +26,8 @@ end module
 
 program e_53_1
   use e_53_1_mod, only : fib, fib_wrapper
-  if (fib (15) /= fib_wrapper (15)) STOP 1
+  if (fib (15) /= fib_wrapper (15)) stop 1
   ! Reduced from 25 to 23, otherwise execution runs out of thread stack on
   ! Nvidia Titan V.
-  if (fib (23) /= fib_wrapper (23)) STOP 2
+  if (fib (23) /= fib_wrapper (23)) stop 2
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-2.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-2.f90
index 76cce01a658..ee582b21632 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-2.f90
@@ -8,7 +8,7 @@ program e_53_2
     ! Nvidia Titan V.
     x = fib (23)
   !$omp end target
-  if (x /= fib (23)) STOP 1
+  if (x /= fib (23)) stop 1
 end program
 
 integer recursive function fib (n) result (f)
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-3.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-3.f90
index 1405ea71793..1d332496ce5 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-3.f90
@@ -21,7 +21,7 @@ subroutine check (p, N)
   real :: diff, p(N)
   do i = 1, N
     diff = p(i) - (i + 2.0) * (i - 3.0)
-    if (diff > EPS .or. -diff > EPS) STOP 1
+    if (diff > EPS .or. -diff > EPS) stop 1
   end do
 end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-4.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-4.f90
index 47d6cd87d5f..a1f6478388f 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-4.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-4.f90
@@ -53,7 +53,7 @@ subroutine check (a, b)
   else
     err = (a - b) / b
   end if
-  if (err > EPS .or. err < -EPS) STOP 1
+  if (err > EPS .or. err < -EPS) stop 1
 end subroutine
 
 program e_53_4
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-5.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-5.f90
index 8fd6af7d738..5b334514a4d 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-5.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/declare_target-5.f90
@@ -68,7 +68,7 @@ subroutine check (a, b)
   else
     err = (a - b) / b
   end if
-  if (err > EPS .or. err < -EPS) STOP 1
+  if (err > EPS .or. err < -EPS) stop 1
 end subroutine
 
 program e_53_5
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/device-1.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/device-1.f90
index a141e058e52..f7db7bdb505 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/device-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/device-1.f90
@@ -20,7 +20,7 @@ program e_57_1
     !$omp end target
   !$omp end target data
 
-  if (b /= 100 .or. .not. c .or. d) STOP 1
+  if (b /= 100 .or. .not. c .or. d) stop 1
 
   a = a + 200
   b = 0
@@ -36,7 +36,7 @@ program e_57_1
     !$omp end target
   !$omp end target data
 
-  if (b /= 0 .or. c .or. d) STOP 2
+  if (b /= 0 .or. c .or. d) stop 2
 
   a = a + 200
   b = 0
@@ -52,5 +52,5 @@ program e_57_1
     !$omp end target
   !$omp end target data
 
-  if (b /= 100 .or. .not. c .or. d) STOP 3
+  if (b /= 100 .or. .not. c .or. d) stop 3
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/device-2.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/device-2.f90
index a7d4f24611f..a63162198d4 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/device-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/device-2.f90
@@ -15,10 +15,10 @@ program e_57_2
   end do
 
   do i = 1, num
-    if (offload(i)) STOP 1
+    if (offload(i)) stop 1
   end do
 
   do i = num+1, N
-    if (.not. offload(i)) STOP 2
+    if (.not. offload(i)) stop 2
   end do
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/device-3.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/device-3.f90
index d6bc042d6c2..50c75c03f14 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/device-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/device-3.f90
@@ -11,11 +11,11 @@ program e_57_3
   !$omp target map(from: res)
     res = omp_is_initial_device ()
   !$omp end target
-  if (res) STOP 1
+  if (res) stop 1
 
   call omp_set_default_device (omp_get_num_devices ())
   !$omp target map(from: res)
     res = omp_is_initial_device ()
   !$omp end target
-  if (.not. res) STOP 2
+  if (.not. res) stop 2
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/simd-1.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/simd-1.f90
index 1d705535cfd..04f659a84f5 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/simd-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/simd-1.f90
@@ -28,7 +28,7 @@ contains
     double precision :: diff, a(*), b(*)
     do i = 1, n
       diff = a(i) - b(i)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/simd-2.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/simd-2.f90
index c9c162fef0d..3bb88388ad2 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/simd-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/simd-2.f90
@@ -49,7 +49,7 @@ contains
       double precision :: diff, a(*), b(*)
       do i = 1, n
         diff = a(i) - b(i)
-        if (diff > EPS .or. -diff > EPS) STOP 1
+        if (diff > EPS .or. -diff > EPS) stop 1
       end do
   end subroutine
 end module
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/simd-3.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/simd-3.f90
index eb8497053bf..5e376f604b9 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/simd-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/simd-3.f90
@@ -57,6 +57,6 @@ program SIMD3
 
   diff = sum - sum_ref
 
-  if (diff > EPS .or. -diff > EPS) STOP 1
+  if (diff > EPS .or. -diff > EPS) stop 1
 
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/simd-4.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/simd-4.f90
index cb78e2c7765..551b8396f13 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/simd-4.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/simd-4.f90
@@ -47,7 +47,7 @@ contains
     real :: diff, a(*), b(*)
     do i = 1, n
       diff = a(i) - b(i)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/simd-5.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/simd-5.f90
index 561deb786c4..d2c266cba55 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/simd-5.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/simd-5.f90
@@ -56,7 +56,7 @@ contains
     do j = 1, n
       do i = 1, n
         diff = a(i,j) - b(i,j)
-        if (diff > EPS .or. -diff > EPS) STOP 1
+        if (diff > EPS .or. -diff > EPS) stop 1
       end do
     end do
   end subroutine
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/simd-6.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/simd-6.f90
index 7f7c5101475..7540a945628 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/simd-6.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/simd-6.f90
@@ -109,14 +109,14 @@ contains
       real :: diff, a(*), b(*)
       do i = 1, n
         diff = a(i) - b(i)
-        if (diff > EPS .or. -diff > EPS) STOP 1
+        if (diff > EPS .or. -diff > EPS) stop 1
       end do
   end subroutine
 
   subroutine checkint (a, b, n)
       integer :: i, n, a(*), b(*)
       do i = 1, n
-        if (a(i) .ne. b(i)) STOP 2
+        if (a(i) .ne. b(i)) stop 2
       end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/simd-7.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/simd-7.f90
index e6af9c8224b..1e2233ee869 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/simd-7.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/simd-7.f90
@@ -23,7 +23,7 @@ program fibonacci
    call fib_ref (a_ref, N)
 
    do i = 0, N-1
-     if (a(i) .ne. a_ref(i)) STOP 1
+     if (a(i) .ne. a_ref(i)) stop 1
    end do
 
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/simd-8.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/simd-8.f90
index 722d9824c5f..5fa4db5cf5a 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/simd-8.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/simd-8.f90
@@ -47,6 +47,6 @@ program simd_8f
 
   diff = pri - 8237.25
 
-  if (diff > EPS .or. -diff > EPS) STOP 1
+  if (diff > EPS .or. -diff > EPS) stop 1
 
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target-1.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target-1.f90
index 2ec4f68f309..b5dfd09dd75 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target-1.f90
@@ -17,7 +17,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target-2.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target-2.f90
index e995ef5a3ac..7e01c57bf80 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target-2.f90
@@ -17,7 +17,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target-3.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target-3.f90
index 338189f6952..76eb6d17bd7 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target-3.f90
@@ -17,7 +17,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target-4.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target-4.f90
index 856ccdb536a..71f0f69e046 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target-4.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target-4.f90
@@ -17,7 +17,7 @@ contains
     real, pointer, dimension(:) :: p
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target-5.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target-5.f90
index bae30414234..b4fd99efa74 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target-5.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target-5.f90
@@ -19,7 +19,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
@@ -29,7 +29,7 @@ contains
     real :: p(N), v1(N), v2(N)
     call init (v1, v2, N)
     !$omp target if(N > THRESHOLD1) map(to: v1,v2) map(from: p)
-      if (omp_is_initial_device ()) STOP 2
+      if (omp_is_initial_device ()) stop 2
       !$omp parallel do if(N > THRESHOLD2)
       do i = 1, N
         p(i) = v1(i) * v2(i)
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-1.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-1.f90
index f9cceb94050..b3b2a48ca5a 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-1.f90
@@ -17,7 +17,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-2.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-2.f90
index 219b450c005..217cc73061a 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-2.f90
@@ -26,7 +26,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - 2 * (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-3.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-3.f90
index b48dbe29836..6d470cfd9e9 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-3.f90
@@ -19,7 +19,7 @@ contains
     do k = 1, cols
       do i = 1, rows
         diff = P(i,k) - Q(i,k)
-        if (diff > EPS .or. -diff > EPS) STOP 1
+        if (diff > EPS .or. -diff > EPS) stop 1
       end do
     end do
   end subroutine
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-4.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-4.f90
index 7499e3b70a5..24554aa5f89 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-4.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-4.f90
@@ -17,7 +17,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-5.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-5.f90
index 8057d058a21..364e2f36a96 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-5.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-5.f90
@@ -17,7 +17,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-6.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-6.f90
index ba6d879ca8b..c578eba4dc1 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-6.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-6.f90
@@ -28,7 +28,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - 2 * (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
@@ -39,7 +39,7 @@ contains
     call init (v1, v2, N)
     !$omp target data if(N > THRESHOLD) map(from: p)
       !$omp target if(N > THRESHOLD) map(to: v1, v2)
-        if (omp_is_initial_device ()) STOP 2
+        if (omp_is_initial_device ()) stop 2
         !$omp parallel do
         do i = 1, N
           p(i) = v1(i) * v2(i)
@@ -47,7 +47,7 @@ contains
       !$omp end target
       call init_again (v1, v2, N)
       !$omp target if(N > THRESHOLD) map(to: v1, v2)
-        if (omp_is_initial_device ()) STOP 3
+        if (omp_is_initial_device ()) stop 3
         !$omp parallel do
         do i = 1, N
           p(i) = p(i) + v1(i) * v2(i)
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-7.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-7.f90
index 629ef2c6c4d..ec8ef07d3d3 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target_data-7.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target_data-7.f90
@@ -19,7 +19,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
@@ -30,7 +30,7 @@ contains
     call init (v1, v2, N)
     !$omp target data if(N > THRESHOLD) map(to: v1, v2) map(from: p)
       !$omp target
-        if (omp_is_initial_device ()) STOP 2
+        if (omp_is_initial_device ()) stop 2
         !$omp parallel do
         do i = 1, N
           p(i) = v1(i) * v2(i)
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target_update-1.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target_update-1.f90
index 1861d4405a5..8a6b23014fa 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target_update-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target_update-1.f90
@@ -26,7 +26,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - 2 * (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/target_update-2.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/target_update-2.f90
index 7734a6adb96..149449239ba 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/target_update-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/target_update-2.f90
@@ -26,7 +26,7 @@ contains
     real :: diff, p(N)
     do i = 1, N
       diff = p(i) - (i * i + (i + 2.0) * (i - 3.0))
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-1.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-1.f90
index f40e36f3bca..1e24a4067d8 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-1.f90
@@ -9,7 +9,7 @@ program example
          x = 2
       !$omp end task
       !$omp task shared(x) depend(in: x)
-         if (x .ne. 2) STOP 1
+         if (x .ne. 2) stop 1
       !$omp end task
    !$omp end single
    !$omp end parallel
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-2.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-2.f90
index 7debb607ff4..e13b3d69a4b 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-2.f90
@@ -6,7 +6,7 @@ program example
    !$omp parallel
    !$omp single
       !$omp task shared(x) depend(in: x)
-         if (x .ne. 1) STOP 1
+         if (x .ne. 1) stop 1
       !$omp end task
       !$omp task shared(x) depend(out: x)
          x = 2
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-3.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-3.f90
index 34cd2c74970..a12998db1e4 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-3.f90
@@ -12,7 +12,7 @@ program example
          x = 2
       !$omp end task
       !$omp taskwait
-      if ((x .ne. 1) .and. (x .ne. 2)) STOP 1
+      if ((x .ne. 1) .and. (x .ne. 2)) stop 1
    !$omp end single
    !$omp end parallel
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-4.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-4.f90
index 47e93f9213b..ab78626dd3b 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-4.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-4.f90
@@ -9,10 +9,10 @@ program example
          x = 2
       !$omp end task
       !$omp task shared(x) depend(in: x)
-         if (x .ne. 2) STOP 1
+         if (x .ne. 2) stop 1
       !$omp end task
       !$omp task shared(x) depend(in: x)
-         if (x .ne. 2) STOP 2
+         if (x .ne. 2) stop 2
       !$omp end task
    !$omp end single
    !$omp end parallel
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-5.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-5.f90
index 9e12db3386c..45054dfba9e 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-5.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/task_dep-5.f90
@@ -51,7 +51,7 @@ contains
       do j = 1, N
         diff = A(i, j) - B(i, j)
         if (diff > EPS .or. -diff > EPS) then
-          STOP 1
+          stop 1
         end if
       end do
     end do
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/teams-2.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/teams-2.f90
index 794c907e975..a288c3a9f6e 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/teams-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/teams-2.f90
@@ -49,7 +49,7 @@ subroutine check (a, b)
   else
     err = (a - b) / b
   end if
-  if (err > EPS .or. err < -EPS) STOP 1
+  if (err > EPS .or. err < -EPS) stop 1
 end subroutine
 
 program e_54_1
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/teams-3.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/teams-3.f90
index 1c8f7d8a43d..f4d95853acc 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/teams-3.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/teams-3.f90
@@ -42,7 +42,7 @@ subroutine check (a, b)
   else
     err = (a - b) / b
   end if
-  if (err > EPS .or. err < -EPS) STOP 1
+  if (err > EPS .or. err < -EPS) stop 1
 end subroutine
 
 program e_54_3
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/teams-4.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/teams-4.f90
index 94de777c71c..4911ea4df75 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/teams-4.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/teams-4.f90
@@ -44,7 +44,7 @@ subroutine check (a, b)
   else
     err = (a - b) / b
   end if
-  if (err > EPS .or. err < -EPS) STOP 1
+  if (err > EPS .or. err < -EPS) stop 1
 end subroutine
 
 program e_54_4
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/teams-5.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/teams-5.f90
index 7e380ad2658..243164ec785 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/teams-5.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/teams-5.f90
@@ -18,7 +18,7 @@ contains
     real :: diff
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/examples-4/teams-6.f90 b/libgomp/testsuite/libgomp.fortran/examples-4/teams-6.f90
index 8121fba67d7..677ce0179a9 100644
--- a/libgomp/testsuite/libgomp.fortran/examples-4/teams-6.f90
+++ b/libgomp/testsuite/libgomp.fortran/examples-4/teams-6.f90
@@ -18,7 +18,7 @@ contains
     real :: diff
     do i = 1, N
       diff = p(i) - (i + 2.0) * (i - 3.0)
-      if (diff > EPS .or. -diff > EPS) STOP 1
+      if (diff > EPS .or. -diff > EPS) stop 1
     end do
   end subroutine
 
diff --git a/libgomp/testsuite/libgomp.fortran/fortran.exp b/libgomp/testsuite/libgomp.fortran/fortran.exp
index d848ed4d47f..eb701311b6a 100644
--- a/libgomp/testsuite/libgomp.fortran/fortran.exp
+++ b/libgomp/testsuite/libgomp.fortran/fortran.exp
@@ -54,11 +54,17 @@ if { $lang_test_file_found } {
 	    # Allow for spec subsitution.
 	    lappend ALWAYS_CFLAGS "additional_flags=-B${blddir}/${quadmath_library_path}/"
 	    set ld_library_path "$always_ld_library_path:${blddir}/${lang_library_path}:${blddir}/${quadmath_library_path}"
+	    append lang_link_flags " -lquadmath"
 	} else {
 	    set ld_library_path "$always_ld_library_path:${blddir}/${lang_library_path}"
 	}
     } else {
         set ld_library_path "$always_ld_library_path"
+        if { [check_no_compiler_messages has_libquadmath executable {
+                 int main() {return 0;}
+              } "-lgfortran -lquadmath"] } then {
+            append lang_link_flags " -lquadmath"
+        }
     }
     append ld_library_path [gcc-set-multilib-library-path $GCC_UNDER_TEST]
     set_ld_library_path_env_vars
diff --git a/libgomp/testsuite/libgomp.fortran/jacobi.f b/libgomp/testsuite/libgomp.fortran/jacobi.f
index b27e20f2766..5e9a2d836aa 100644
--- a/libgomp/testsuite/libgomp.fortran/jacobi.f
+++ b/libgomp/testsuite/libgomp.fortran/jacobi.f
@@ -11,7 +11,7 @@
 * Author:   Joseph Robicheaux, Kuck and Associates, Inc. (KAI), 1998
 * 
 * Directives are used in this code to achieve paralleism. 
-* All do loops are parallized with default 'static' scheduling.
+* All do loops are parallelized with default 'static' scheduling.
 * 
 * Input :  n - grid dimension in x direction 
 *          m - grid dimension in y direction
@@ -70,7 +70,7 @@
       subroutine driver ( ) 
 *************************************************************
 * Subroutine driver () 
-* This is where the arrays are allocated and initialzed. 
+* This is where the arrays are allocated and initialized.
 *
 * Working varaibles/arrays 
 *     dx  - grid spacing in x direction 
@@ -119,7 +119,7 @@
       dx = 2.0 / (n-1)
       dy = 2.0 / (m-1)
 
-* Initilize initial condition and RHS
+* Initialize initial condition and RHS
 
 !$omp parallel do private(xx,yy)
       do j = 1,m
diff --git a/libgomp/testsuite/libgomp.fortran/lastprivate1.f90 b/libgomp/testsuite/libgomp.fortran/lastprivate1.f90
index 132617b5c27..4eae92b39e8 100644
--- a/libgomp/testsuite/libgomp.fortran/lastprivate1.f90
+++ b/libgomp/testsuite/libgomp.fortran/lastprivate1.f90
@@ -1,18 +1,19 @@
+! { dg-do run }
 program lastprivate
   integer :: i
   common /c/ i
   !$omp parallel num_threads (4)
   call test1
   !$omp end parallel
-  if (i .ne. 21) STOP 1
+  if (i .ne. 21) stop 1
   !$omp parallel num_threads (4)
   call test2
   !$omp end parallel
-  if (i .ne. 64) STOP 2
+  if (i .ne. 64) stop 2
   !$omp parallel num_threads (4)
   call test3
   !$omp end parallel
-  if (i .ne. 14) STOP 3
+  if (i .ne. 14) stop 3
   call test4
   call test5
   call test6
@@ -53,21 +54,21 @@ contains
     !$omp parallel do lastprivate (j) num_threads (4) default (none)
     do j = 1, 20
     end do
-    if (j .ne. 21) STOP 4
+    if (j .ne. 21) stop 4
   end subroutine test4
   subroutine test5
     integer :: j
     !$omp parallel do lastprivate (j) num_threads (4) default (none)
     do j = 7, 61, 3
     end do
-    if (j .ne. 64) STOP 5
+    if (j .ne. 64) stop 5
   end subroutine test5
   subroutine test6
     integer :: j
     !$omp parallel do lastprivate (j) num_threads (4) default (none)
     do j = -10, 11, ret3 ()
     end do
-    if (j .ne. 14) STOP 6
+    if (j .ne. 14) stop 6
   end subroutine test6
   subroutine test7
     integer :: i
@@ -75,7 +76,7 @@ contains
     !$omp parallel do lastprivate (i) num_threads (4) default (none)
     do i = 1, 20
     end do
-    if (i .ne. 21) STOP 7
+    if (i .ne. 21) stop 7
   end subroutine test7
   subroutine test8
     integer :: i
@@ -83,7 +84,7 @@ contains
     !$omp parallel do lastprivate (i) num_threads (4) default (none)
     do i = 7, 61, 3
     end do
-    if (i .ne. 64) STOP 8
+    if (i .ne. 64) stop 8
   end subroutine test8
   subroutine test9
     integer :: i
@@ -91,7 +92,7 @@ contains
     !$omp parallel do lastprivate (i) num_threads (4) default (none)
     do i = -10, 11, ret3 ()
     end do
-    if (i .ne. 14) STOP 9
+    if (i .ne. 14) stop 9
   end subroutine test9
   subroutine test10
     integer :: i
@@ -101,7 +102,7 @@ contains
     do i = 1, 20
     end do
     !$omp end parallel
-    if (i .ne. 21) STOP 10
+    if (i .ne. 21) stop 10
   end subroutine test10
   subroutine test11
     integer :: i
@@ -111,7 +112,7 @@ contains
     do i = 7, 61, 3
     end do
     !$omp end parallel
-    if (i .ne. 64) STOP 11
+    if (i .ne. 64) stop 11
   end subroutine test11
   subroutine test12
     integer :: i
@@ -121,6 +122,6 @@ contains
     do i = -10, 11, ret3 ()
     end do
     !$omp end parallel
-    if (i .ne. 14) STOP 12
+    if (i .ne. 14) stop 12
   end subroutine test12
 end program lastprivate
diff --git a/libgomp/testsuite/libgomp.fortran/lastprivate2.f90 b/libgomp/testsuite/libgomp.fortran/lastprivate2.f90
index 6cd5760206c..edaf82325a8 100644
--- a/libgomp/testsuite/libgomp.fortran/lastprivate2.f90
+++ b/libgomp/testsuite/libgomp.fortran/lastprivate2.f90
@@ -1,18 +1,19 @@
+! { dg-do run }
 program lastprivate
   integer :: i, k
   common /c/ i, k
   !$omp parallel num_threads (4)
   call test1
   !$omp end parallel
-  if (i .ne. 21 .or. k .ne. 20) STOP 1
+  if (i .ne. 21 .or. k .ne. 20) stop 1
   !$omp parallel num_threads (4)
   call test2
   !$omp end parallel
-  if (i .ne. 64 .or. k .ne. 61) STOP 2
+  if (i .ne. 64 .or. k .ne. 61) stop 2
   !$omp parallel num_threads (4)
   call test3
   !$omp end parallel
-  if (i .ne. 14 .or. k .ne. 11) STOP 3
+  if (i .ne. 14 .or. k .ne. 11) stop 3
   call test4
   call test5
   call test6
@@ -57,7 +58,7 @@ contains
     do j = 1, 20
       l = j
     end do
-    if (j .ne. 21 .or. l .ne. 20) STOP 4
+    if (j .ne. 21 .or. l .ne. 20) stop 4
   end subroutine test4
   subroutine test5
     integer :: j, l
@@ -66,7 +67,7 @@ contains
     do j = 7, 61, 3
       l = j
     end do
-    if (j .ne. 64 .or. l .ne. 61) STOP 5
+    if (j .ne. 64 .or. l .ne. 61) stop 5
   end subroutine test5
   subroutine test6
     integer :: j, l
@@ -74,7 +75,7 @@ contains
     do j = -10, 11, ret3 ()
       l = j
     end do
-    if (j .ne. 14 .or. l .ne. 11) STOP 6
+    if (j .ne. 14 .or. l .ne. 11) stop 6
   end subroutine test6
   subroutine test7
     integer :: i, k
@@ -83,7 +84,7 @@ contains
     do i = 1, 20
       k = i
     end do
-    if (i .ne. 21 .or. k .ne. 20) STOP 7
+    if (i .ne. 21 .or. k .ne. 20) stop 7
   end subroutine test7
   subroutine test8
     integer :: i, k
@@ -92,7 +93,7 @@ contains
     do i = 7, 61, 3
       k = i
     end do
-    if (i .ne. 64 .or. k .ne. 61) STOP 8
+    if (i .ne. 64 .or. k .ne. 61) stop 8
   end subroutine test8
   subroutine test9
     integer :: i, k
@@ -102,7 +103,7 @@ contains
     do i = -10, 11, ret3 ()
       k = i
     end do
-    if (i .ne. 14 .or. k .ne. 11) STOP 9
+    if (i .ne. 14 .or. k .ne. 11) stop 9
   end subroutine test9
   subroutine test10
     integer :: i, k
@@ -113,7 +114,7 @@ contains
       k = i
     end do
     !$omp end parallel
-    if (i .ne. 21 .or. k .ne. 20) STOP 10
+    if (i .ne. 21 .or. k .ne. 20) stop 10
   end subroutine test10
   subroutine test11
     integer :: i, k
@@ -124,7 +125,7 @@ contains
       k = i
     end do
     !$omp end parallel
-    if (i .ne. 64 .or. k .ne. 61) STOP 11
+    if (i .ne. 64 .or. k .ne. 61) stop 11
   end subroutine test11
   subroutine test12
     integer :: i, k
@@ -136,6 +137,6 @@ contains
       k = i
     end do
     !$omp end parallel
-    if (i .ne. 14 .or. k .ne. 11) STOP 12
+    if (i .ne. 14 .or. k .ne. 11) stop 12
   end subroutine test12
 end program lastprivate
diff --git a/libgomp/testsuite/libgomp.fortran/lib1.f90 b/libgomp/testsuite/libgomp.fortran/lib1.f90
index 92c32508491..4e7f9b24bd5 100644
--- a/libgomp/testsuite/libgomp.fortran/lib1.f90
+++ b/libgomp/testsuite/libgomp.fortran/lib1.f90
@@ -11,42 +11,42 @@
 
   call omp_init_lock (lck)
   call omp_set_lock (lck)
-  if (omp_test_lock (lck)) STOP 1
+  if (omp_test_lock (lck)) stop 1
   call omp_unset_lock (lck)
-  if (.not. omp_test_lock (lck)) STOP 2
-  if (omp_test_lock (lck)) STOP 3
+  if (.not. omp_test_lock (lck)) stop 2
+  if (omp_test_lock (lck)) stop 3
   call omp_unset_lock (lck)
   call omp_destroy_lock (lck)
 
   call omp_init_nest_lock (nlck)
-  if (omp_test_nest_lock (nlck) .ne. 1) STOP 4
+  if (omp_test_nest_lock (nlck) .ne. 1) stop 4
   call omp_set_nest_lock (nlck)
-  if (omp_test_nest_lock (nlck) .ne. 3) STOP 5
+  if (omp_test_nest_lock (nlck) .ne. 3) stop 5
   call omp_unset_nest_lock (nlck)
   call omp_unset_nest_lock (nlck)
-  if (omp_test_nest_lock (nlck) .ne. 2) STOP 6
+  if (omp_test_nest_lock (nlck) .ne. 2) stop 6
   call omp_unset_nest_lock (nlck)
   call omp_unset_nest_lock (nlck)
   call omp_destroy_nest_lock (nlck)
 
   call omp_set_dynamic (.true.)
-  if (.not. omp_get_dynamic ()) STOP 7
+  if (.not. omp_get_dynamic ()) stop 7
   call omp_set_dynamic (.false.)
-  if (omp_get_dynamic ()) STOP 8
+  if (omp_get_dynamic ()) stop 8
 
   call omp_set_nested (.true.)
-  if (.not. omp_get_nested ()) STOP 9
+  if (.not. omp_get_nested ()) stop 9
   call omp_set_nested (.false.)
-  if (omp_get_nested ()) STOP 10
+  if (omp_get_nested ()) stop 10
 
   call omp_set_num_threads (5)
-  if (omp_get_num_threads () .ne. 1) STOP 11
-  if (omp_get_max_threads () .ne. 5) STOP 12
-  if (omp_get_thread_num () .ne. 0) STOP 13
+  if (omp_get_num_threads () .ne. 1) stop 11
+  if (omp_get_max_threads () .ne. 5) stop 12
+  if (omp_get_thread_num () .ne. 0) stop 13
   call omp_set_num_threads (3)
-  if (omp_get_num_threads () .ne. 1) STOP 14
-  if (omp_get_max_threads () .ne. 3) STOP 15
-  if (omp_get_thread_num () .ne. 0) STOP 16
+  if (omp_get_num_threads () .ne. 1) stop 14
+  if (omp_get_max_threads () .ne. 3) stop 15
+  if (omp_get_thread_num () .ne. 0) stop 16
   l = .false.
 !$omp parallel reduction (.or.:l)
   l = omp_get_num_threads () .ne. 3
@@ -56,22 +56,22 @@
   l = l .or. (omp_get_thread_num () .ne. 0)
 !$omp end master
 !$omp end parallel
-  if (l) STOP 17
+  if (l) stop 17
 
-  if (omp_get_num_procs () .le. 0) STOP 18
-  if (omp_in_parallel ()) STOP 19
+  if (omp_get_num_procs () .le. 0) stop 18
+  if (omp_in_parallel ()) stop 19
 !$omp parallel reduction (.or.:l)
   l = .not. omp_in_parallel ()
 !$omp end parallel
 !$omp parallel reduction (.or.:l) if (.true.)
   l = .not. omp_in_parallel ()
 !$omp end parallel
-  if (l) STOP 20
+  if (l) stop 20
 
   e = omp_get_wtime ()
-  if (d .gt. e) STOP 21
+  if (d .gt. e) stop 21
   d = omp_get_wtick ()
   ! Negative precision is definitely wrong,
   ! bigger than 1s clock resolution is also strange
-  if (d .le. 0 .or. d .gt. 1.) STOP 22
+  if (d .le. 0 .or. d .gt. 1.) stop 22
 end
diff --git a/libgomp/testsuite/libgomp.fortran/lib4.f90 b/libgomp/testsuite/libgomp.fortran/lib4.f90
index ce6aa00e521..d551cde35c6 100644
--- a/libgomp/testsuite/libgomp.fortran/lib4.f90
+++ b/libgomp/testsuite/libgomp.fortran/lib4.f90
@@ -6,11 +6,11 @@ program lib4
   integer :: modifier
   call omp_set_schedule (omp_sched_static, 32)
   call omp_get_schedule (kind, modifier)
-  if (kind.ne.omp_sched_static.or.modifier.ne.32) STOP 1
+  if (kind.ne.omp_sched_static.or.modifier.ne.32) stop 1
   call omp_set_schedule (omp_sched_dynamic, 4)
   call omp_get_schedule (kind, modifier)
-  if (kind.ne.omp_sched_dynamic.or.modifier.ne.4) STOP 2
-  if (omp_get_thread_limit ().lt.0) STOP 3
+  if (kind.ne.omp_sched_dynamic.or.modifier.ne.4) stop 2
+  if (omp_get_thread_limit ().lt.0) stop 3
   call omp_set_max_active_levels (6)
-  if (omp_get_max_active_levels ().ne.6) STOP 4
+  if (omp_get_max_active_levels ().ne.6) stop 4
 end program lib4
diff --git a/libgomp/testsuite/libgomp.fortran/lock-1.f90 b/libgomp/testsuite/libgomp.fortran/lock-1.f90
index b3408388c5d..21116078049 100644
--- a/libgomp/testsuite/libgomp.fortran/lock-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/lock-1.f90
@@ -7,16 +7,16 @@
 
   l = .false.
   call omp_init_nest_lock (lock)
-  if (omp_test_nest_lock (lock) .ne. 1) STOP 1
-  if (omp_test_nest_lock (lock) .ne. 2) STOP 2
+  if (omp_test_nest_lock (lock) .ne. 1) stop 1
+  if (omp_test_nest_lock (lock) .ne. 2) stop 2
 !$omp parallel if (.false.) reduction (.or.:l)
   ! In OpenMP 2.5 this was supposed to return 3,
   ! but in OpenMP 3.0 the parallel region has a different
   ! task and omp_*_lock_t are owned by tasks, not by threads.
   if (omp_test_nest_lock (lock) .ne. 0) l = .true.
 !$omp end parallel
-  if (l) STOP 3
-  if (omp_test_nest_lock (lock) .ne. 3) STOP 4
+  if (l) stop 3
+  if (omp_test_nest_lock (lock) .ne. 3) stop 4
   call omp_unset_nest_lock (lock)
   call omp_unset_nest_lock (lock)
   call omp_unset_nest_lock (lock)
diff --git a/libgomp/testsuite/libgomp.fortran/lock-2.f90 b/libgomp/testsuite/libgomp.fortran/lock-2.f90
index 8608027ef54..ddf53c1b70e 100644
--- a/libgomp/testsuite/libgomp.fortran/lock-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/lock-2.f90
@@ -8,8 +8,8 @@
   l = .false.
   call omp_init_nest_lock (lock)
 !$omp parallel num_threads (1) reduction (.or.:l)
-  if (omp_test_nest_lock (lock) .ne. 1) STOP 1
-  if (omp_test_nest_lock (lock) .ne. 2) STOP 2
+  if (omp_test_nest_lock (lock) .ne. 1) stop 1
+  if (omp_test_nest_lock (lock) .ne. 2) stop 2
 !$omp task if (.false.) shared (lock, l)
   if (omp_test_nest_lock (lock) .ne. 0) l = .true.
 !$omp end task
@@ -19,6 +19,6 @@
   call omp_unset_nest_lock (lock)
   call omp_unset_nest_lock (lock)
 !$omp end parallel
-  if (l) STOP 3
+  if (l) stop 3
   call omp_destroy_nest_lock (lock)
 end
diff --git a/libgomp/testsuite/libgomp.fortran/nested1.f90 b/libgomp/testsuite/libgomp.fortran/nested1.f90
index ed1e832ee6e..f521b7bf820 100644
--- a/libgomp/testsuite/libgomp.fortran/nested1.f90
+++ b/libgomp/testsuite/libgomp.fortran/nested1.f90
@@ -8,16 +8,16 @@ program nested1
   e3 = 0
   call omp_set_nested (.true.)
   call omp_set_dynamic (.false.)
-  if (omp_in_parallel ()) STOP 1
-  if (omp_get_num_threads ().ne.1) STOP 2
-  if (omp_get_level ().ne.0) STOP 3
-  if (omp_get_ancestor_thread_num (0).ne.0) STOP 4
-  if (omp_get_ancestor_thread_num (-1).ne.-1) STOP 5
-  if (omp_get_ancestor_thread_num (1).ne.-1) STOP 6
-  if (omp_get_team_size (0).ne.1) STOP 7
-  if (omp_get_team_size (-1).ne.-1) STOP 8
-  if (omp_get_team_size (1).ne.-1) STOP 9
-  if (omp_get_active_level ().ne.0) STOP 10
+  if (omp_in_parallel ()) stop 1
+  if (omp_get_num_threads ().ne.1) stop 2
+  if (omp_get_level ().ne.0) stop 3
+  if (omp_get_ancestor_thread_num (0).ne.0) stop 4
+  if (omp_get_ancestor_thread_num (-1).ne.-1) stop 5
+  if (omp_get_ancestor_thread_num (1).ne.-1) stop 6
+  if (omp_get_team_size (0).ne.1) stop 7
+  if (omp_get_team_size (-1).ne.-1) stop 8
+  if (omp_get_team_size (1).ne.-1) stop 9
+  if (omp_get_active_level ().ne.0) stop 10
 !$omp parallel num_threads (4) private (e, tn1)
   e = 0
   tn1 = omp_get_thread_num ()
@@ -83,5 +83,5 @@ program nested1
 !$omp end parallel
 !$omp end parallel
 !$omp end parallel
-  if (e1.ne.0.or.e2.ne.0.or.e3.ne.0) STOP 11
+  if (e1.ne.0.or.e2.ne.0.or.e3.ne.0) stop 11
 end program nested1
diff --git a/libgomp/testsuite/libgomp.fortran/nestedfn1.f90 b/libgomp/testsuite/libgomp.fortran/nestedfn1.f90
index 833cb9a0884..9949071b4b9 100644
--- a/libgomp/testsuite/libgomp.fortran/nestedfn1.f90
+++ b/libgomp/testsuite/libgomp.fortran/nestedfn1.f90
@@ -5,7 +5,7 @@
   b = 2
   c = 3
   call foo
-  if (a .ne. 7) STOP 1
+  if (a .ne. 7) stop 1
 contains
   subroutine foo
     use omp_lib
@@ -38,6 +38,6 @@ contains
       if (a .ne. 7 .or. b .ne. 8 .or. c .ne. 9) l = .true.
     end if
 !$omp end parallel
-    if (l) STOP 2
+    if (l) stop 2
   end subroutine foo
 end
diff --git a/libgomp/testsuite/libgomp.fortran/nestedfn2.f90 b/libgomp/testsuite/libgomp.fortran/nestedfn2.f90
index 34054ad4937..cd2e505a6e6 100644
--- a/libgomp/testsuite/libgomp.fortran/nestedfn2.f90
+++ b/libgomp/testsuite/libgomp.fortran/nestedfn2.f90
@@ -24,8 +24,8 @@ contains
   subroutine test3
     integer :: i
     common /c/ i
-    if (i .lt. 0 .or. i .ge. 4) STOP 1
-    if (i + 10 .ne. vari) STOP 2
+    if (i .lt. 0 .or. i .ge. 4) stop 1
+    if (i + 10 .ne. vari) stop 2
   end subroutine test3
   subroutine test4
     use omp_lib
diff --git a/libgomp/testsuite/libgomp.fortran/nestedfn3.f90 b/libgomp/testsuite/libgomp.fortran/nestedfn3.f90
index 4e8a18a63ac..fa82d2f23b0 100644
--- a/libgomp/testsuite/libgomp.fortran/nestedfn3.f90
+++ b/libgomp/testsuite/libgomp.fortran/nestedfn3.f90
@@ -5,7 +5,7 @@ program nestomp
   integer :: j
   j = 8
   call bar
-  if (j.ne.10) STOP 1
+  if (j.ne.10) stop 1
 contains
   subroutine foo (i)
     integer :: i
diff --git a/libgomp/testsuite/libgomp.fortran/nestedfn4.f90 b/libgomp/testsuite/libgomp.fortran/nestedfn4.f90
index bc8614a340a..6e4126888c1 100644
--- a/libgomp/testsuite/libgomp.fortran/nestedfn4.f90
+++ b/libgomp/testsuite/libgomp.fortran/nestedfn4.f90
@@ -1,3 +1,4 @@
+! { dg-do run }
 program foo
   integer :: i, j, k
   integer :: a(10), c(10)
@@ -6,19 +7,19 @@ program foo
   call test1
   call test2
   do i = 1, 10
-    if (a(i) .ne. 10 * i) STOP 1
+    if (a(i) .ne. 10 * i) stop 1
   end do
   !$omp parallel do reduction (+:c)
   do i = 1, 10
     c = c + a
   end do
   do i = 1, 10
-    if (c(i) .ne. 10 * a(i)) STOP 2
+    if (c(i) .ne. 10 * a(i)) stop 2
   end do
   !$omp parallel do lastprivate (j)
   do j = 1, 10, k
   end do
-  if (j .ne. 11) STOP 3
+  if (j .ne. 11) stop 3
 contains
   subroutine test1
     integer :: i
@@ -36,6 +37,6 @@ contains
     !$omp parallel do lastprivate (j)
     do j = 1, 10, k
     end do
-    if (j .ne. 11) STOP 4
+    if (j .ne. 11) stop 4
   end subroutine test2
 end program foo
diff --git a/libgomp/testsuite/libgomp.fortran/nestedfn5.f90 b/libgomp/testsuite/libgomp.fortran/nestedfn5.f90
index e65019e2666..28c9b00da67 100644
--- a/libgomp/testsuite/libgomp.fortran/nestedfn5.f90
+++ b/libgomp/testsuite/libgomp.fortran/nestedfn5.f90
@@ -30,7 +30,7 @@ contains
       b = b + 1
     end do
 !$omp end simd
-    if (a /= 21 .or. b /= 12) STOP 1
+    if (a /= 21 .or. b /= 12) stop 1
 !$omp simd aligned(f : c_sizeof (e(1)))
     do b = 1, 64
       g(b) = f
@@ -44,8 +44,8 @@ contains
     d(2:2,4:5) = d(2:2,4:5) + 1
 !$omp end task
 !$omp task depend(in : a, d(2:2,4:5))
-    if (a /= 22) STOP 2
-    if (any (d(2:2,4:5) /= 5)) STOP 3
+    if (a /= 22) stop 2
+    if (any (d(2:2,4:5) /= 5)) stop 3
 !$omp end task
 !$omp end taskgroup
 !$omp end single
@@ -64,8 +64,8 @@ contains
     d(2:3,4:4) = 9
 !$omp end target
 !$omp target update from (a, q, d(2:3,4:4), l)
-    if (a /= 6 .or. l .or. b /= 11 .or. any (q /= 8)) STOP 4
-    if (any (d(2:3,4:4) /= 9) .or. d(2,5) /= 5 .or. d(3,5) /= 4) STOP 5
+    if (a /= 6 .or. l .or. b /= 11 .or. any (q /= 8)) stop 4
+    if (any (d(2:3,4:4) /= 9) .or. d(2,5) /= 5 .or. d(3,5) /= 4) stop 5
     a = 12
     b = 13
     q = 14
@@ -82,7 +82,7 @@ contains
     m = 0
     n = 64
     o = 16
-    if (l) STOP 6
+    if (l) stop 6
 !$omp target teams distribute parallel do simd if (.not.l) device(a) &
 !$omp & num_teams(b) dist_schedule(static, c) num_threads (h) &
 !$omp & reduction (+: m) safelen (n) schedule(static, o) &
@@ -91,7 +91,7 @@ contains
       m = m + 1
     end do
 !$omp end target teams distribute parallel do simd
-    if (m /= 64) STOP 7
+    if (m /= 64) stop 7
 !$omp end target data
   end subroutine foo
 end subroutine bar
diff --git a/libgomp/testsuite/libgomp.fortran/omp_atomic1.f90 b/libgomp/testsuite/libgomp.fortran/omp_atomic1.f90
index cec05287fc2..57b7c0051f7 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_atomic1.f90
+++ b/libgomp/testsuite/libgomp.fortran/omp_atomic1.f90
@@ -18,22 +18,22 @@
     c = c * 2
 !$omp atomic
     d = 2 / d
-    if (a .ne. 5 .or. b .ne. 2 .or. c .ne. 6 .or. d .ne. 0.5) STOP 1
+    if (a .ne. 5 .or. b .ne. 2 .or. c .ne. 6 .or. d .ne. 0.5) stop 1
     d = 1.2
 !$omp atomic
     a = a + c + d
 !$omp atomic
     b = b - (a + c + d)
-    if (a .ne. 12 .or. b .ne. -17) STOP 2
+    if (a .ne. 12 .or. b .ne. -17) stop 2
 !$omp atomic
     a = c + d + a
 !$omp atomic
     b = a + c + d - b
-    if (a .ne. 19 .or. b .ne. 43) STOP 3
+    if (a .ne. 19 .or. b .ne. 43) stop 3
 !$omp atomic
     b = (a + c + d) - b
     a = 32
 !$omp atomic
     a = a / 3.4
-    if (a .ne. 9 .or. b .ne. -16) STOP 4
+    if (a .ne. 9 .or. b .ne. -16) stop 4
 end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_atomic2.f90 b/libgomp/testsuite/libgomp.fortran/omp_atomic2.f90
index 68df316c85d..3748e30bc26 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_atomic2.f90
+++ b/libgomp/testsuite/libgomp.fortran/omp_atomic2.f90
@@ -13,28 +13,28 @@
   n = 20
   call foo (r, d, n)
 
-  if (n .ne. 22) STOP 1
-  if (any (r .ne. 33)) STOP 2
+  if (n .ne. 22) stop 1
+  if (any (r .ne. 33)) stop 2
 
   i = 1
   j = 18
   k = 23
 !$omp atomic
   i = min (i, j, k, n)
-  if (i .ne. 1) STOP 3
+  if (i .ne. 1) stop 3
 !$omp atomic
   i = max (j, n, k, i)
-  if (i .ne. 23) STOP 4
+  if (i .ne. 23) stop 4
 
   a = 1
   b = 18
   c = 23
 !$omp atomic
   a = min (a, b, c)
-  if (a .ne. 1) STOP 5
+  if (a .ne. 1) stop 5
 !$omp atomic
   a = max (a, b, c)
-  if (a .ne. 23) STOP 6
+  if (a .ne. 23) stop 6
 
 contains
   function bar (i)
diff --git a/libgomp/testsuite/libgomp.fortran/omp_atomic3.f90 b/libgomp/testsuite/libgomp.fortran/omp_atomic3.f90
index e4a1a6e460d..454b167157f 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_atomic3.f90
+++ b/libgomp/testsuite/libgomp.fortran/omp_atomic3.f90
@@ -36,23 +36,23 @@
     c2 = c
 !$omp atomic read
     d2 = d
-    if (a2 .ne. 5 .or. b2 .ne. 2 .or. c2 .ne. 6 .or. d2 .ne. 0.5) STOP 1
+    if (a2 .ne. 5 .or. b2 .ne. 2 .or. c2 .ne. 6 .or. d2 .ne. 0.5) stop 1
 !$omp atomic write
     d = 1.2
 !$omp atomic
     a = a + c + d
 !$omp atomic
     b = b - (a + c + d)
-    if (a .ne. 12 .or. b .ne. -17) STOP 2
+    if (a .ne. 12 .or. b .ne. -17) stop 2
 !$omp atomic
     a = c + d + a
 !$omp atomic
     b = a + c + d - b
-    if (a .ne. 19 .or. b .ne. 43) STOP 3
+    if (a .ne. 19 .or. b .ne. 43) stop 3
 !$omp atomic
     b = (a + c + d) - b
     a = 32
 !$omp atomic
     a = a / 3.4
-    if (a .ne. 9 .or. b .ne. -16) STOP 4
+    if (a .ne. 9 .or. b .ne. -16) stop 4
 end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_atomic4.f90 b/libgomp/testsuite/libgomp.fortran/omp_atomic4.f90
index c4cb5cf9de9..75da9f39400 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_atomic4.f90
+++ b/libgomp/testsuite/libgomp.fortran/omp_atomic4.f90
@@ -28,10 +28,10 @@
     d = d / 2.0
     d2 = d
 !$omp end atomic
-    if (a2 .ne. 1 .or. b2 .ne. -16 .or. c2 .ne. 3 .or. d2 .ne. 2) STOP 1
+    if (a2 .ne. 1 .or. b2 .ne. -16 .or. c2 .ne. 3 .or. d2 .ne. 2) stop 1
 !$omp atomic read
     a2 = a
 !$omp atomic read
     c2 = c
-    if (a2 .ne. 5 .or. b2 .ne. -16 .or. c2 .ne. 6 .or. d2 .ne. 2) STOP 2
+    if (a2 .ne. 5 .or. b2 .ne. -16 .or. c2 .ne. 6 .or. d2 .ne. 2) stop 2
 end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_atomic5.f90 b/libgomp/testsuite/libgomp.fortran/omp_atomic5.f90
index 1303ba4b51c..292a7f62a2f 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_atomic5.f90
+++ b/libgomp/testsuite/libgomp.fortran/omp_atomic5.f90
@@ -30,30 +30,30 @@
     d = d / 2.0
     d2 = d
 !$omp end atomic
-    if (a2 .ne. 1 .or. b2 .ne. -16 .or. c2 .ne. 3 .or. d2 .ne. 2) STOP 1
+    if (a2 .ne. 1 .or. b2 .ne. -16 .or. c2 .ne. 3 .or. d2 .ne. 2) stop 1
 !$omp atomic read seq_cst
     a2 = a
 !$omp atomic seq_cst, read
     c2 = c
-    if (a2 .ne. 5 .or. b2 .ne. -16 .or. c2 .ne. 6 .or. d2 .ne. 2) STOP 2
+    if (a2 .ne. 5 .or. b2 .ne. -16 .or. c2 .ne. 6 .or. d2 .ne. 2) stop 2
     a2 = 10
-    if (a2 .ne. 10) STOP 3
+    if (a2 .ne. 10) stop 3
 !$omp atomic capture
     a2 = a
     a = e(1) + e(6) + e(7) * 2
 !$omp endatomic
-    if (a2 .ne. 5) STOP 4
+    if (a2 .ne. 5) stop 4
 !$omp atomic read
     a2 = a
 !$omp end atomic
-    if (a2 .ne. 28) STOP 5
+    if (a2 .ne. 28) stop 5
 !$omp atomic capture seq_cst
     b2 = b
     b = e(1) + e(7) + e(5) * 2
 !$omp end atomic
-    if (b2 .ne. -16) STOP 6
+    if (b2 .ne. -16) stop 6
 !$omp atomic seq_cst, read
     b2 = b
 !$omp end atomic
-    if (b2 .ne. 24) STOP 7
+    if (b2 .ne. 24) stop 7
 end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_cond1.f b/libgomp/testsuite/libgomp.fortran/omp_cond1.f
index f050f5101be..d98e6cc2848 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_cond1.f
+++ b/libgomp/testsuite/libgomp.fortran/omp_cond1.f
@@ -1,13 +1,13 @@
 C Test conditional compilation in fixed form if -fopenmp
    10 foo = 2
      &56
-      if (foo.ne.256) STOP 1
+      if (foo.ne.256) stop 1
       bar = 26
 !$2 0 ba
 c$   +r = 42
       !$ bar = 62
 !$    bar = bar + 1
-      if (bar.ne.43) STOP 2
+      if (bar.ne.43) stop 2
       baz = bar
 *$   0baz = 5
 C$   +12! Comment
@@ -17,5 +17,5 @@ c$   !4
 !$ X  baz = 0 ! Not valid OpenMP conditional compilation lines
 ! $   baz = 1
 c$ 10&baz = 2
-      if (baz.ne.51242) STOP 3
+      if (baz.ne.51242) stop 3
       end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_cond2.f b/libgomp/testsuite/libgomp.fortran/omp_cond2.f
index 83e79dc36eb..e54edeaf55e 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_cond2.f
+++ b/libgomp/testsuite/libgomp.fortran/omp_cond2.f
@@ -2,13 +2,13 @@ c Test conditional compilation in fixed form if -fno-openmp
 ! { dg-options "-fno-openmp" }
    10 foo = 2
      &56
-      if (foo.ne.256) STOP 1
+      if (foo.ne.256) stop 1
       bar = 26
 !$2 0 ba
 c$   +r = 42
       !$ bar = 62
 !$    bar = bar + 1
-      if (bar.ne.26) STOP 2
+      if (bar.ne.26) stop 2
       baz = bar
 *$   0baz = 5
 C$   +12! Comment
@@ -18,5 +18,5 @@ c$   !4
 !$ X  baz = 0 ! Not valid OpenMP conditional compilation lines
 ! $   baz = 1
 c$ 10&baz = 2
-      if (baz.ne.26) STOP 3
+      if (baz.ne.26) stop 3
       end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_cond3.F90 b/libgomp/testsuite/libgomp.fortran/omp_cond3.F90
index 3db2fd1163e..6a8ce52d326 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_cond3.F90
+++ b/libgomp/testsuite/libgomp.fortran/omp_cond3.F90
@@ -1,7 +1,7 @@
 ! Test conditional compilation in free form if -fopenmp
    10 foo = 2&
   &56
-  if (foo.ne.256) STOP 1
+  if (foo.ne.256) stop 1
   bar = 26
    !$  20 ba&
 !$   &r = 4&
@@ -11,7 +11,7 @@
 #ifdef _OPENMP
 bar = bar - 1
 #endif
-  if (bar.ne.43) STOP 2
+  if (bar.ne.43) stop 2
       baz = bar
 !$ 30 baz = 5&     ! Comment
 !$12  &  
@@ -19,5 +19,5 @@ bar = bar - 1
 !$X baz = 0 ! Not valid OpenMP conditional compilation lines
 ! $   baz = 1
 baz = baz + 1 !$ baz = 2
-      if (baz.ne.515) STOP 3
+      if (baz.ne.515) stop 3
       end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_cond4.F90 b/libgomp/testsuite/libgomp.fortran/omp_cond4.F90
index ae2e93253aa..644f7e302a2 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_cond4.F90
+++ b/libgomp/testsuite/libgomp.fortran/omp_cond4.F90
@@ -2,7 +2,7 @@
 ! { dg-options "-fno-openmp" }
    10 foo = 2&
   &56
-  if (foo.ne.256) STOP 1
+  if (foo.ne.256) stop 1
   bar = 26
    !$  20 ba&
 !$   &r = 4&
@@ -12,7 +12,7 @@
 #ifdef _OPENMP
 bar = bar - 1
 #endif
-  if (bar.ne.26) STOP 2
+  if (bar.ne.26) stop 2
       baz = bar
 !$ 30 baz = 5&     ! Comment
 !$12  &  
@@ -20,5 +20,5 @@ bar = bar - 1
 !$X baz = 0 ! Not valid OpenMP conditional compilation lines
 ! $   baz = 1
 baz = baz + 1 !$ baz = 2
-      if (baz.ne.27) STOP 3
+      if (baz.ne.27) stop 3
       end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_parse1.f90 b/libgomp/testsuite/libgomp.fortran/omp_parse1.f90
index db89401f839..f3b4bc579cf 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_parse1.f90
+++ b/libgomp/testsuite/libgomp.fortran/omp_parse1.f90
@@ -43,16 +43,16 @@ contains
     d(b + 1) = c
     if (f .ne. g .or. f .ne. b) h = .true.
 !$omp endparallel
-    if (h) STOP 1
-    if (a .ne. 6) STOP 2
-    if (j .ne. 24) STOP 3
-    if (d(1) .eq. -1) STOP 4
+    if (h) stop 1
+    if (a .ne. 6) stop 2
+    if (j .ne. 24) stop 3
+    if (d(1) .eq. -1) stop 4
     e = 1
     do g = 1, d(1)
-      if (d(g) .ne. d(1)) STOP 5
+      if (d(g) .ne. d(1)) stop 5
       e = e * 2
     end do
-    if (e .ne. i) STOP 6
+    if (e .ne. i) stop 6
   end subroutine test_parallel
 
   subroutine test_do_orphan
@@ -79,7 +79,7 @@ contains
     call test_do_orphan
 !$omp do schedule (static) firstprivate (n)
     do 200 i = 1, j
-      if (i .eq. 1 .and. n .ne. 24) STOP 7
+      if (i .eq. 1 .and. n .ne. 24) stop 7
       n = i
 200   d(n) = omp_get_thread_num ()
 !$omp enddo nowait
@@ -103,11 +103,11 @@ contains
     end do
     ! Implied omp end do here
 !$omp end parallel
-    if (.not. m) STOP 8
+    if (.not. m) stop 8
 
     j = 0
     do i = 1, 64
-      if (d(i) .lt. j .or. d(i) .ge. j + k) STOP 9
+      if (d(i) .lt. j .or. d(i) .ge. j + k) stop 9
       if (i .eq. 16) j = 1024
       if (i .eq. 32) j = 2048
       if (i .eq. 48) j = 4096
@@ -152,9 +152,9 @@ contains
     n = 7
 !$omp endsections
 !$omp end parallel
-    if (j .ne. 271 .or. l .ne. 0) STOP 10
-    if (m .ne. 4 + 6 + 8 + 10) STOP 11
-    if (n .ne. 7) STOP 12
+    if (j .ne. 271 .or. l .ne. 0) stop 10
+    if (m .ne. 4 + 6 + 8 + 10) stop 11
+    if (n .ne. 7) stop 12
   end subroutine test_sections
 
   subroutine test_single
@@ -182,6 +182,6 @@ contains
 !$omp end single copyprivate (j)
     if (i .ne. omp_get_thread_num () .or. j .ne. -2) m = .true.
 !$omp endparallel
-    if (m) STOP 13
+    if (m) stop 13
   end subroutine test_single
 end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_parse2.f90 b/libgomp/testsuite/libgomp.fortran/omp_parse2.f90
index e63f55f7c31..3de6968bae2 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_parse2.f90
+++ b/libgomp/testsuite/libgomp.fortran/omp_parse2.f90
@@ -16,7 +16,7 @@ contains
     j = omp_get_thread_num () .eq. 0
 !$omp endmaster
 !$omp end parallel
-    if (.not. (i .or. j)) STOP 1
+    if (.not. (i .or. j)) stop 1
   end subroutine test_master
 
   subroutine test_critical_1 (i, j)
@@ -45,7 +45,7 @@ contains
     i = i + 1
 !$omp endcritical (critical_foo)
 !$omp end parallel
-    if (n .lt. 1 .or. i .ne. n * 3 .or. j .ne. n * 3) STOP 2
+    if (n .lt. 1 .or. i .ne. n * 3 .or. j .ne. n * 3) stop 2
   end subroutine test_critical
 
   subroutine test_barrier
@@ -62,7 +62,7 @@ contains
       j = j .or. .true.
     end if
 !$omp end parallel
-    if (i .ne. 5 .or. j) STOP 3
+    if (i .ne. 5 .or. j) stop 3
   end subroutine test_barrier
 
   subroutine test_atomic
@@ -89,14 +89,14 @@ contains
     f = max (omp_get_thread_num (), f)
     if (omp_get_thread_num () .eq. 0) g = omp_get_num_threads ()
 !$omp end parallel
-    if (g .le. 0 .or. g .gt. 8) STOP 4
-    if (a .ne. 6 * g .or. b .ne. 3 ** g) STOP 5
+    if (g .le. 0 .or. g .gt. 8) stop 4
+    if (a .ne. 6 * g .or. b .ne. 3 ** g) stop 5
     if (iand (g, 1) .eq. 1) then
-      if (c .ne. 8) STOP 6
+      if (c .ne. 8) stop 6
     else if (c .ne. 0) then
-      STOP 7
+      stop 7
     end if
-    if (d .ne. 1024 / (2 ** g)) STOP 8
-    if (e .ne. 0 .or. f .ne. g - 1) STOP 9
+    if (d .ne. 1024 / (2 ** g)) stop 8
+    if (e .ne. 0 .or. f .ne. g - 1) stop 9
   end subroutine test_atomic
 end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_parse3.f90 b/libgomp/testsuite/libgomp.fortran/omp_parse3.f90
index a61d54615d2..6076c7aad3c 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_parse3.f90
+++ b/libgomp/testsuite/libgomp.fortran/omp_parse3.f90
@@ -45,10 +45,10 @@ contains
     j = 1
     do 100 i = 1, 100
       if (i .eq. j) then
-	if (d(i) .ne. i) STOP 1
+	if (d(i) .ne. i) stop 1
 	j = i + 5
       else
-	if (d(i) .ne. -1) STOP 2
+	if (d(i) .ne. -1) stop 2
       end if
 100   d(i) = -1
   end subroutine test_ordered
@@ -69,17 +69,17 @@ contains
 !$omp parallel copyin (/tlsblock/, z) reduction (.or.:m) &
 !$omp& num_threads (4)
     if (omp_get_thread_num () .eq. 0) i = omp_get_num_threads ()
-    if (x .ne. 6 .or. y .ne. 7 .or. z .ne. 8) STOP 3
+    if (x .ne. 6 .or. y .ne. 7 .or. z .ne. 8) stop 3
     x = omp_get_thread_num ()
     y = omp_get_thread_num () + 1024
     z = omp_get_thread_num () + 4096
 !$omp end parallel
-    if (x .ne. 0 .or. y .ne. 1024 .or. z .ne. 4096) STOP 4
+    if (x .ne. 0 .or. y .ne. 1024 .or. z .ne. 4096) stop 4
 !$omp parallel num_threads (4), private (j) reduction (.or.:n)
     if (omp_get_num_threads () .eq. i) then
       j = omp_get_thread_num ()
       if (x .ne. j .or. y .ne. j + 1024 .or. z .ne. j + 4096) &
-&       STOP 5
+&       stop 5
     end if
 !$omp end parallel
     m = m .or. n
@@ -89,9 +89,9 @@ contains
     if (z .ne. 4096) n = .true.
     if (omp_get_num_threads () .eq. i) then
       j = omp_get_thread_num ()
-      if (x .ne. j .or. y .ne. j + 1024) STOP 6
+      if (x .ne. j .or. y .ne. j + 1024) stop 6
     end if
 !$omp end parallel
-    if (m .or. n) STOP 7
+    if (m .or. n) stop 7
   end subroutine test_threadprivate
 end
diff --git a/libgomp/testsuite/libgomp.fortran/omp_parse4.f90 b/libgomp/testsuite/libgomp.fortran/omp_parse4.f90
index 273ce53075b..09b0fa24269 100644
--- a/libgomp/testsuite/libgomp.fortran/omp_parse4.f90
+++ b/libgomp/testsuite/libgomp.fortran/omp_parse4.f90
@@ -59,14 +59,14 @@ contains
 !$omp end parallel
 
     if (any (f .ne. (/100, 100, 100, 210, 210, 210, 310, 310, 337, 337/))) &
-&     STOP 1
-    if (any (g .ne. (/-1, -1, -1, 0, 0, 0, 0, 0, 0, 0/))) STOP 2
-    if (i .ne. 20) STOP 3
-!$  if (l .ne. 128 + m) STOP 4
-    if (any (d .ne. 1 .or. e .ne. 1)) STOP 5
-    if (any (b .ne. transpose (a))) STOP 6
-    if (any (c .ne. b)) STOP 7
+&     stop 1
+    if (any (g .ne. (/-1, -1, -1, 0, 0, 0, 0, 0, 0, 0/))) stop 2
+    if (i .ne. 20) stop 3
+!$  if (l .ne. 128 + m) stop 4
+    if (any (d .ne. 1 .or. e .ne. 1)) stop 5
+    if (any (b .ne. transpose (a))) stop 6
+    if (any (c .ne. b)) stop 7
     if (any (n .ne. (/1, 2, 6, 12, 5, 30, 42, 56, 9, 90, &
-&                     110, 132, 13, 182, 210, 240/))) STOP 8
+&                     110, 132, 13, 182, 210, 240/))) stop 8
   end subroutine test_workshare
 end
diff --git a/libgomp/testsuite/libgomp.fortran/openmp_version-1.f b/libgomp/testsuite/libgomp.fortran/openmp_version-1.f
index de16933f9e5..78d4b981f6b 100644
--- a/libgomp/testsuite/libgomp.fortran/openmp_version-1.f
+++ b/libgomp/testsuite/libgomp.fortran/openmp_version-1.f
@@ -4,6 +4,6 @@
       implicit none
       include "omp_lib.h"
 
-      if (openmp_version .ne. 201511) STOP 1;
+      if (openmp_version .ne. 201511) stop 1;
 
       end program main
diff --git a/libgomp/testsuite/libgomp.fortran/openmp_version-2.f90 b/libgomp/testsuite/libgomp.fortran/openmp_version-2.f90
index b2e0d3a7064..693dba0b3f5 100644
--- a/libgomp/testsuite/libgomp.fortran/openmp_version-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/openmp_version-2.f90
@@ -4,6 +4,6 @@ program main
   use omp_lib
   implicit none
 
-  if (openmp_version .ne. 201511) STOP 1;
+  if (openmp_version .ne. 201511) stop 1;
 
 end program main
diff --git a/libgomp/testsuite/libgomp.fortran/optional-map.f90 b/libgomp/testsuite/libgomp.fortran/optional-map.f90
new file mode 100644
index 00000000000..eebe58cc45c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/optional-map.f90
@@ -0,0 +1,121 @@
+! { dg-do run }
+!
+implicit none (type, external)
+call sub()
+call sub2()
+call call_present_1()
+call call_present_2()
+
+contains
+
+subroutine call_present_1()
+  integer :: ii, ival, iarr, iptr, iparr
+  pointer :: iptr, iparr
+  dimension :: iarr(2), iparr(:)
+  allocate(iptr,iparr(2))
+  ii = 101
+  ival = 102
+  iptr = 103
+  iarr = 104
+  iparr = 105
+  call sub_present(ii, ival, iarr, iptr, iparr)
+  deallocate(iptr,iparr)
+end subroutine
+
+subroutine call_present_2()
+  integer :: ii, ival, iarr, iptr, iparr
+  pointer :: iptr, iparr
+  dimension :: iarr(2), iparr(:)
+  allocate(iptr,iparr(2))
+  ii = 201
+  ival = 202
+  iptr = 203
+  iarr = 204
+  iparr = 205
+  call sub2_present(ii, ival, iarr, iptr, iparr)
+  deallocate(iptr,iparr)
+end subroutine
+
+subroutine sub(ii, ival, iarr, iptr, iparr)
+  integer, optional :: ii, ival, iarr, iptr, iparr
+  pointer :: iptr, iparr
+  dimension :: iarr(:), iparr(:)
+  value :: ival
+  integer :: err
+  err = 42
+  !$omp target map(ii, ival, iarr, iptr, iparr, err)
+  if (present(ii)) then
+    ii = iptr + ival
+    iarr = iparr
+  else
+    err = 0
+  end if
+  if (present(ii)) err = 1
+  if (present(ival)) err = 2
+  if (present(iarr)) err = 3
+  if (present(iptr)) err = 4
+  if (present(iparr)) err = 5
+  !$omp end target
+  if (err /= 0) stop 1
+end subroutine sub
+
+subroutine sub2(ii, ival, iarr, iptr, iparr)
+  integer, optional :: ii, ival, iarr, iptr, iparr
+  pointer :: iptr, iparr
+  dimension :: iarr(:), iparr(:)
+  value :: ival
+  integer :: err(1) ! otherwise, implied defaultmap is firstprivate
+  err(1) = 42
+  !$omp target  ! automatic mapping with implied defaultmap(tofrom) 
+  if (present(ii)) then
+    ii = iptr + ival
+    iarr = iparr
+  else
+    err(1) = 0
+  end if
+  if (present(ii)) err(1) = 1
+  if (present(ival)) err(1) = 2
+  if (present(iarr)) err(1) = 3
+  if (present(iptr)) err(1) = 4
+  if (present(iparr)) err(1) = 5
+  !$omp end target
+  if (err(1) /= 0) stop 2
+end subroutine sub2
+
+subroutine sub_present(ii, ival, iarr, iptr, iparr)
+  integer, optional :: ii, ival, iarr, iptr, iparr
+  pointer :: iptr, iparr
+  dimension :: iarr(:), iparr(:)
+  value :: ival
+  integer :: err
+  err = 42
+  !$omp target map(ii, ival, iarr, iptr, iparr, err)
+  if (.not.present(ii)) err = 1
+  if (.not.present(ival)) err = 2
+  if (.not.present(iarr)) err = 3
+  if (.not.present(iptr)) err = 4
+  if (.not.present(iparr)) err = 5
+  err = err - 42 - 101-102-103-104-105 + ii+ival+iarr(2)+iptr+iparr(2)
+  !$omp end target
+  if (err /= 0) stop 3
+end subroutine sub_present
+
+subroutine sub2_present(ii, ival, iarr, iptr, iparr)
+  integer, optional :: ii, ival, iarr, iptr, iparr
+  pointer :: iptr, iparr
+  dimension :: iarr(:), iparr(:)
+  value :: ival
+  integer :: err(1) ! otherwise, implied defaultmap is firstprivate
+  err(1) = 53
+  !$omp target  ! automatic mapping with implied defaultmap(tofrom) 
+  ! Note: OpenMP 4.5's 'defaultmap' is not yet supported, PR 92568
+  if (.not.present(ii)) err = 1
+  if (.not.present(ival)) err = 2
+  if (.not.present(iarr)) err = 3
+  if (.not.present(iptr)) err = 4
+  if (.not.present(iparr)) err = 5
+  err = err - 53 - 201-202-203-204-205 + ii+ival+iarr(2)+iptr+iparr(2)
+  !$omp end target
+  if (err(1) /= 0) stop 4
+end subroutine sub2_present
+end
diff --git a/libgomp/testsuite/libgomp.fortran/parloops-exit-first-loop-alt-2.f95 b/libgomp/testsuite/libgomp.fortran/parloops-exit-first-loop-alt-2.f95
index bb165cdfaca..0f800e64523 100644
--- a/libgomp/testsuite/libgomp.fortran/parloops-exit-first-loop-alt-2.f95
+++ b/libgomp/testsuite/libgomp.fortran/parloops-exit-first-loop-alt-2.f95
@@ -34,7 +34,7 @@ program main
   call foo ()
 
   do i = 0, n - 1
-     if (c(i) .ne. (i + MODULO ((i * 3), 7))) STOP 1
+     if (c(i) .ne. (i + MODULO ((i * 3), 7))) stop 1
   end do
 
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/parloops-exit-first-loop-alt.f95 b/libgomp/testsuite/libgomp.fortran/parloops-exit-first-loop-alt.f95
index 5ed4a382a08..1485683467c 100644
--- a/libgomp/testsuite/libgomp.fortran/parloops-exit-first-loop-alt.f95
+++ b/libgomp/testsuite/libgomp.fortran/parloops-exit-first-loop-alt.f95
@@ -35,7 +35,7 @@ program main
   call foo (n)
 
   do i = 0, n - 1
-     if (c(i) .ne. (i + MODULO ((i * 3), 7))) STOP 1
+     if (c(i) .ne. (i + MODULO ((i * 3), 7))) stop 1
   end do
 
 end program
diff --git a/libgomp/testsuite/libgomp.fortran/pointer1.f90 b/libgomp/testsuite/libgomp.fortran/pointer1.f90
index 817006a2d20..3332000dc61 100644
--- a/libgomp/testsuite/libgomp.fortran/pointer1.f90
+++ b/libgomp/testsuite/libgomp.fortran/pointer1.f90
@@ -21,7 +21,7 @@ contains
         c(1) = c(1) + 1
       r = r + 1
     !$omp end parallel
-    if (a.ne.r.or.c(1).ne.r) STOP 1
+    if (a.ne.r.or.c(1).ne.r) stop 1
     r2 = r
     b => a
     d => c
@@ -33,7 +33,7 @@ contains
         d(1) = d(1) + 1
       r = r + 1
     !$omp end parallel
-    if (b.ne.r+r2.or.d(1).ne.r+r2) STOP 2
+    if (b.ne.r+r2.or.d(1).ne.r+r2) stop 2
   end subroutine foo
   subroutine bar (a, c)
     integer, pointer :: a, c(:), b, d(:)
@@ -55,8 +55,8 @@ contains
 	end if
       end do
     !$omp end parallel do
-    if (b.ne.100.or.any(d.ne.10)) STOP 3
-    if (a.ne.17.or.any(c.ne.21)) STOP 4
+    if (b.ne.100.or.any(d.ne.10)) stop 3
+    if (a.ne.17.or.any(c.ne.21)) stop 4
     a => b
     c => d
     !$omp parallel do firstprivate (b, d) lastprivate (b, d)
@@ -71,7 +71,7 @@ contains
 	end if
       end do
     !$omp end parallel do
-    if (a.ne.200.or.any(c.ne.20)) STOP 5
-    if (b.ne.17.or.any(d.ne.21)) STOP 6
+    if (a.ne.200.or.any(c.ne.20)) stop 5
+    if (b.ne.17.or.any(d.ne.21)) stop 6
   end subroutine bar
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pointer2.f90 b/libgomp/testsuite/libgomp.fortran/pointer2.f90
index 859c0e4c36b..3db052e72aa 100644
--- a/libgomp/testsuite/libgomp.fortran/pointer2.f90
+++ b/libgomp/testsuite/libgomp.fortran/pointer2.f90
@@ -21,8 +21,8 @@
   thr(1) = thr(1) + 1
   i = i + 1
 !$omp end parallel
-  if (l) STOP 1
-  if (thr(1).ne.14) STOP 2
-  if (s(1).ne.1+i) STOP 3
-  if (u(1).ne.14) STOP 4
+  if (l) stop 1
+  if (thr(1).ne.14) stop 2
+  if (s(1).ne.1+i) stop 3
+  if (u(1).ne.14) stop 4
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pr25219.f90 b/libgomp/testsuite/libgomp.fortran/pr25219.f90
index 61dd1bc04e6..6795efa4e85 100644
--- a/libgomp/testsuite/libgomp.fortran/pr25219.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr25219.f90
@@ -1,3 +1,4 @@
+! { dg-do run }
 ! PR fortran/25219
 
   implicit none
@@ -11,5 +12,5 @@
   end do
 !$omp end do
 !$omp end parallel
-  if (k .ne. 100) STOP 1
+  if (k .ne. 100) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pr27395-1.f90 b/libgomp/testsuite/libgomp.fortran/pr27395-1.f90
index 8930c780ff2..855a346c865 100644
--- a/libgomp/testsuite/libgomp.fortran/pr27395-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr27395-1.f90
@@ -8,7 +8,7 @@ program pr27395_1
   integer, dimension(n) :: sumarray
   call foo(n,m,sumarray)
   do i=1,n
-    if (sumarray(i).ne.m*i) STOP 1
+    if (sumarray(i).ne.m*i) stop 1
   end do
 end program pr27395_1
 
diff --git a/libgomp/testsuite/libgomp.fortran/pr27395-2.f90 b/libgomp/testsuite/libgomp.fortran/pr27395-2.f90
index f55b701cdb4..55229cc4b39 100644
--- a/libgomp/testsuite/libgomp.fortran/pr27395-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr27395-2.f90
@@ -25,6 +25,6 @@ subroutine foo(n,m)
 !$OMP END DO
 !$OMP END PARALLEL
   do i=1,n
-    if (sumarray(i).ne.m*i) STOP 1
+    if (sumarray(i).ne.m*i) stop 1
   end do
 end subroutine foo
diff --git a/libgomp/testsuite/libgomp.fortran/pr27416-1.f90 b/libgomp/testsuite/libgomp.fortran/pr27416-1.f90
index 7bc5d3e78c8..e62a784b5a8 100644
--- a/libgomp/testsuite/libgomp.fortran/pr27416-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr27416-1.f90
@@ -6,7 +6,7 @@
 !$omp parallel num_threads (4)
   call foo (j)
 !$omp end parallel
-  if (j.ne.6+16) STOP 1
+  if (j.ne.6+16) stop 1
 end
 
 subroutine foo (j)
diff --git a/libgomp/testsuite/libgomp.fortran/pr27916-1.f90 b/libgomp/testsuite/libgomp.fortran/pr27916-1.f90
index bb75af9c15c..1a1b0c34144 100644
--- a/libgomp/testsuite/libgomp.fortran/pr27916-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr27916-1.f90
@@ -22,5 +22,5 @@ program pr27916
     r = r .or. allocated (a)
   end do
  !$omp end parallel do
-  if (r) STOP 1
+  if (r) stop 1
 end program pr27916
diff --git a/libgomp/testsuite/libgomp.fortran/pr27916-2.f90 b/libgomp/testsuite/libgomp.fortran/pr27916-2.f90
index 7973726cb57..c0bc6668f36 100644
--- a/libgomp/testsuite/libgomp.fortran/pr27916-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr27916-2.f90
@@ -22,5 +22,5 @@ program pr27916
     r = r .or. allocated (a)
   end do
  !$omp end parallel do
-  if (r) STOP 1
+  if (r) stop 1
 end program pr27916
diff --git a/libgomp/testsuite/libgomp.fortran/pr28390.f b/libgomp/testsuite/libgomp.fortran/pr28390.f
index a667e08f73e..9a0832a59bb 100644
--- a/libgomp/testsuite/libgomp.fortran/pr28390.f
+++ b/libgomp/testsuite/libgomp.fortran/pr28390.f
@@ -1,8 +1,9 @@
+! { dg-do run }
 ! PR fortran/28390
       program pr28390
       integer i
 !$omp parallel do lastprivate(i)
       do i=1,100
       end do
-      if (i.ne.101) STOP 1
+      if (i.ne.101) stop 1
       end
diff --git a/libgomp/testsuite/libgomp.fortran/pr29629.f90 b/libgomp/testsuite/libgomp.fortran/pr29629.f90
index 4b802c56310..1920ac0b4a3 100644
--- a/libgomp/testsuite/libgomp.fortran/pr29629.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr29629.f90
@@ -4,7 +4,7 @@
 program pr29629
   integer :: n
   n = 10000
-  if (any (func(n).ne.10000)) STOP 1
+  if (any (func(n).ne.10000)) stop 1
   contains
     function func(n)
       integer, intent(in) :: n
diff --git a/libgomp/testsuite/libgomp.fortran/pr32550.f90 b/libgomp/testsuite/libgomp.fortran/pr32550.f90
index ce496cacd23..99852df3296 100644
--- a/libgomp/testsuite/libgomp.fortran/pr32550.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr32550.f90
@@ -17,5 +17,5 @@
 	e = e + 1
       end if
 !$omp end parallel
-      if (e.ne.0) STOP 1
+      if (e.ne.0) stop 1
       end
diff --git a/libgomp/testsuite/libgomp.fortran/pr33880.f90 b/libgomp/testsuite/libgomp.fortran/pr33880.f90
index e6a26f42d82..ec00dd86d8b 100644
--- a/libgomp/testsuite/libgomp.fortran/pr33880.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr33880.f90
@@ -9,7 +9,7 @@ program pr33880
     !$omp atomic
       j = j + 1
   end do
-  if (j .ne. 1000) STOP 1
+  if (j .ne. 1000) stop 1
 contains
   subroutine something()
     i = 0
diff --git a/libgomp/testsuite/libgomp.fortran/pr34020.f90 b/libgomp/testsuite/libgomp.fortran/pr34020.f90
index 6d2316472d8..31aaecda180 100644
--- a/libgomp/testsuite/libgomp.fortran/pr34020.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr34020.f90
@@ -16,5 +16,5 @@
       do i = 1, 300000
         call atomic_add(lhs, rhs)
       enddo
-      if (lhs .ne. 300000) STOP 1
+      if (lhs .ne. 300000) stop 1
       end
diff --git a/libgomp/testsuite/libgomp.fortran/pr35130.f90 b/libgomp/testsuite/libgomp.fortran/pr35130.f90
index e6be64f15f5..05d00a67ee1 100644
--- a/libgomp/testsuite/libgomp.fortran/pr35130.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr35130.f90
@@ -1,3 +1,4 @@
+! { dg-do run }
 ! PR middle-end/35130
 
 program pr35130
@@ -10,7 +11,7 @@ program pr35130
     call inner(k)
   end do
 !$omp end parallel do
-  if (any (a.ne.42)) STOP 1
+  if (any (a.ne.42)) stop 1
 contains
  subroutine inner(i)
    implicit none
diff --git a/libgomp/testsuite/libgomp.fortran/pr42162.f90 b/libgomp/testsuite/libgomp.fortran/pr42162.f90
index 3792a33fe9f..fd75f554ea4 100644
--- a/libgomp/testsuite/libgomp.fortran/pr42162.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr42162.f90
@@ -49,5 +49,5 @@ program pr42162
   !$omp parallel num_threads(3)
   call sub3 (k, c)
   !$omp end parallel
-  if (k.ne.4.or.any(a.ne.2).or.any(b.ne.3).or.any(c.ne.4)) STOP 1
+  if (k.ne.4.or.any(a.ne.2).or.any(b.ne.3).or.any(c.ne.4)) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pr46753.f90 b/libgomp/testsuite/libgomp.fortran/pr46753.f90
index 0d9debce196..5caa4d7e86b 100644
--- a/libgomp/testsuite/libgomp.fortran/pr46753.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr46753.f90
@@ -7,11 +7,11 @@
   do i = 2147483636, 2147483646
     j = j + 1
   end do
-  if (j.ne.11) STOP 1
+  if (j.ne.11) stop 1
   j = 0
 !$omp parallel do reduction(+:j)
   do i = -2147483637, -2147483647, -1
     j = j + 1
   end do
-  if (j.ne.11) STOP 2
+  if (j.ne.11) stop 2
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pr48894.f90 b/libgomp/testsuite/libgomp.fortran/pr48894.f90
index 0f7bfad4cae..e906f45e27f 100644
--- a/libgomp/testsuite/libgomp.fortran/pr48894.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr48894.f90
@@ -19,5 +19,5 @@
       endif
     !$omp end parallel
   !$omp end parallel
-  if (err .ne. 0) STOP 1
+  if (err .ne. 0) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pr49792-1.f90 b/libgomp/testsuite/libgomp.fortran/pr49792-1.f90
index 18643ac5a50..5a9d470b5e9 100644
--- a/libgomp/testsuite/libgomp.fortran/pr49792-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr49792-1.f90
@@ -14,5 +14,5 @@ program pr49792
   real(kind=8) :: b(16)
   b(:) = a(16:1:-1)
   call reverse (16,a)
-  if (any (a.ne.b)) STOP 1
+  if (any (a.ne.b)) stop 1
 end program pr49792
diff --git a/libgomp/testsuite/libgomp.fortran/pr49792-2.f90 b/libgomp/testsuite/libgomp.fortran/pr49792-2.f90
index 689f7decacb..570901d5559 100644
--- a/libgomp/testsuite/libgomp.fortran/pr49792-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr49792-2.f90
@@ -17,6 +17,6 @@ program pr49792
 !$omp parallel workshare
   a = b
 !$omp end parallel workshare
-  if (size(a).ne.size(b)) STOP 1
-  if (any (a.ne.b)) STOP 2
+  if (size(a).ne.size(b)) stop 1
+  if (any (a.ne.b)) stop 2
 end program pr49792
diff --git a/libgomp/testsuite/libgomp.fortran/pr63938-1.f90 b/libgomp/testsuite/libgomp.fortran/pr63938-1.f90
index eb85500ea4c..4cc8be7ec1e 100644
--- a/libgomp/testsuite/libgomp.fortran/pr63938-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr63938-1.f90
@@ -10,5 +10,5 @@ program pr63938_1
     x(1) = x(1) + 1
   end do
 !$omp end parallel do
-  if (x(1) .ne. 1000) STOP 1
+  if (x(1) .ne. 1000) stop 1
 end program pr63938_1
diff --git a/libgomp/testsuite/libgomp.fortran/pr63938-2.f90 b/libgomp/testsuite/libgomp.fortran/pr63938-2.f90
index 934e800648e..d0a17ac4fea 100644
--- a/libgomp/testsuite/libgomp.fortran/pr63938-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr63938-2.f90
@@ -14,5 +14,5 @@ program pr63938_2
     x%x = x%x + 1
   end do
 !$omp end parallel do
-  if (x%x .ne. 1000) STOP 1
+  if (x%x .ne. 1000) stop 1
 end program pr63938_2
diff --git a/libgomp/testsuite/libgomp.fortran/pr65597.f90 b/libgomp/testsuite/libgomp.fortran/pr65597.f90
index 25754314766..29d1c9e80bc 100644
--- a/libgomp/testsuite/libgomp.fortran/pr65597.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr65597.f90
@@ -13,9 +13,9 @@
     end do
   do i = 1, 151
     if (mod (i, 31) .eq. 1) then
-      if (a(i) .ne. 2) STOP 1
+      if (a(i) .ne. 2) stop 1
     else
-      if (a(i) .ne. 0) STOP 2
+      if (a(i) .ne. 0) stop 2
     end if
   end do
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pr66199-1.f90 b/libgomp/testsuite/libgomp.fortran/pr66199-1.f90
index ecf62458340..6c9e566cf86 100644
--- a/libgomp/testsuite/libgomp.fortran/pr66199-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr66199-1.f90
@@ -1,5 +1,4 @@
 ! PR middle-end/66199
-! { dg-do run }
 ! { dg-options "-O2" }
 
   integer :: u(1024), v(1024), w(1024), a, b, c, d, e, a1, b1, a2, b2, d1, d2
@@ -10,7 +9,7 @@
   do d = a, b
     u(d) = v(d) + w(d)
   end do
-  if (d .ne. 1025) STOP 1
+  if (d .ne. 1025) stop 1
   c = 17
   d = 75
   !$omp parallel do simd default(none) firstprivate (a, b) shared(u, v, w) &
@@ -20,8 +19,8 @@
     c = c + 5
     e = c
   end do
-  if (d .ne. 1025 .or. c .ne. (17 + 5 * 1024)) STOP 2
-  if (e .ne. (17 + 5 * 1024)) STOP 3
+  if (d .ne. 1025 .or. c .ne. (17 + 5 * 1024)) stop 2
+  if (e .ne. (17 + 5 * 1024)) stop 3
   a1 = 0
   a2 = 0
   b1 = 31
@@ -35,7 +34,7 @@
       u(d1 * 32 + d2 + 1) = v(d1 * 32 + d2 + 1) + w(d1 * 32 + d2 + 1)
     end do
   end do
-  if (d1 .ne. 32 .or. d2 .ne. 32) STOP 4
+  if (d1 .ne. 32 .or. d2 .ne. 32) stop 4
   d1 = 7
   d2 = 9
   !$omp parallel do simd default(none) firstprivate (a1, b1, a2, b2) &
@@ -45,5 +44,5 @@
       u(d1 * 32 + d2 + 1) = v(d1 * 32 + d2 + 1) + w(d1 * 32 + d2 + 1)
     end do
   end do
-  if (d1 .ne. 32 .or. d2 .ne. 32) STOP 5
+  if (d1 .ne. 32 .or. d2 .ne. 32) stop 5
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pr66199-2.f90 b/libgomp/testsuite/libgomp.fortran/pr66199-2.f90
index 0cc0fa5097f..fef15b2bb57 100644
--- a/libgomp/testsuite/libgomp.fortran/pr66199-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr66199-2.f90
@@ -1,5 +1,4 @@
 ! PR middle-end/66199
-! { dg-do run }
 ! { dg-options "-O2" }
 
   integer :: u(1024), v(1024), w(1024), a, b, c, d, e, a1, b1, a2, b2, d1, d2
diff --git a/libgomp/testsuite/libgomp.fortran/pr71014.f90 b/libgomp/testsuite/libgomp.fortran/pr71014.f90
index 7fcbf73862d..518df1024aa 100644
--- a/libgomp/testsuite/libgomp.fortran/pr71014.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr71014.f90
@@ -16,5 +16,5 @@ program pr71014
       end do
     end associate
   end do
-  if (any(s /= t)) STOP 1
+  if (any(s /= t)) stop 1
 end program pr71014
diff --git a/libgomp/testsuite/libgomp.fortran/pr81304.f90 b/libgomp/testsuite/libgomp.fortran/pr81304.f90
index c7419342ca6..3f7406aeaf5 100644
--- a/libgomp/testsuite/libgomp.fortran/pr81304.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr81304.f90
@@ -13,5 +13,5 @@ program pr81304
      a = min (a, c)
      b = max (b, c)
    end do
-   if (any (a /= (/ 1, -4, 6 /)) .or. any (b /= (/ 16, 11, 21 /))) STOP 1
+   if (any (a /= (/ 1, -4, 6 /)) .or. any (b /= (/ 16, 11, 21 /))) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pr81841.f90 b/libgomp/testsuite/libgomp.fortran/pr81841.f90
index ed75837c37b..9ddc95af69f 100644
--- a/libgomp/testsuite/libgomp.fortran/pr81841.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr81841.f90
@@ -17,10 +17,10 @@ program pr81841
   common /c/ e, f
   !$omp threadprivate (/c/)
   !$omp parallel num_threads(8)
-  if ((e /= 32) .or. any(f /= 1.)) STOP 1
+  if ((e /= 32) .or. any(f /= 1.)) stop 1
   e = omp_get_thread_num ()
   f = e + 19.
   !$omp barrier
-  if ((e /= omp_get_thread_num ()) .or. any(f /= e + 19.)) STOP 2
+  if ((e /= omp_get_thread_num ()) .or. any(f /= e + 19.)) stop 2
   !$omp end parallel
 end
diff --git a/libgomp/testsuite/libgomp.fortran/pr84418-1.f90 b/libgomp/testsuite/libgomp.fortran/pr84418-1.f90
index 59391211a74..8547fceb79e 100644
--- a/libgomp/testsuite/libgomp.fortran/pr84418-1.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr84418-1.f90
@@ -15,7 +15,7 @@
     c(i) = foo (a(i), b(i))
   end do
   do i = 1, 1024
-    if (c(i).ne.(2 * i)) STOP 1
+    if (c(i).ne.(2 * i)) stop 1
   end do
 contains
   real function foo (x, y)
diff --git a/libgomp/testsuite/libgomp.fortran/pr84418-2.f90 b/libgomp/testsuite/libgomp.fortran/pr84418-2.f90
index f85fbf2ba87..481e24e5d8a 100644
--- a/libgomp/testsuite/libgomp.fortran/pr84418-2.f90
+++ b/libgomp/testsuite/libgomp.fortran/pr84418-2.f90
@@ -23,7 +23,7 @@
     c(i) = foo (a(i), b(:,i))
   end do
   do i = 1, 1024
-    if (c(i).ne.(6 * i)) STOP 1
+    if (c(i).ne.(6 * i)) stop 1
   end do
 contains  
   function foo (x, y)
diff --git a/libgomp/testsuite/libgomp.fortran/pr90779.f90 b/libgomp/testsuite/libgomp.fortran/pr90779.f90
new file mode 100644
index 00000000000..c14dc87dd00
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/pr90779.f90
@@ -0,0 +1,13 @@
+! { dg-do run }
+! PR middle-end/90779
+
+program pr90779
+  implicit none
+  integer :: v(4), i
+
+  !$omp target map(from:v)
+    v(:) = (/ (i, i=1,4) /)
+  !$omp end target
+
+  if (any (v .ne. (/ (i, i=1,4) /))) stop 1
+end program
diff --git a/libgomp/testsuite/libgomp.fortran/procptr1.f90 b/libgomp/testsuite/libgomp.fortran/procptr1.f90
index 560d0da4216..44410d47b53 100644
--- a/libgomp/testsuite/libgomp.fortran/procptr1.f90
+++ b/libgomp/testsuite/libgomp.fortran/procptr1.f90
@@ -11,25 +11,25 @@
   integer :: i
   ptr => foo
 !$omp parallel shared (ptr)
-  if (ptr () /= 1) STOP 1
+  if (ptr () /= 1) stop 1
 !$omp end parallel
   ptr => bar
 !$omp parallel firstprivate (ptr)
-  if (ptr () /= 2) STOP 2
+  if (ptr () /= 2) stop 2
 !$omp end parallel
 !$omp parallel sections lastprivate (ptr)
 !$omp section
   ptr => foo
-  if (ptr () /= 1) STOP 3
+  if (ptr () /= 1) stop 3
 !$omp section
   ptr => bar
-  if (ptr () /= 2) STOP 4
+  if (ptr () /= 2) stop 4
 !$omp section
   ptr => baz
-  if (ptr () /= 3) STOP 5
+  if (ptr () /= 3) stop 5
 !$omp end parallel sections
-  if (ptr () /= 3) STOP 6
-  if (.not.associated (ptr, baz)) STOP 7
+  if (ptr () /= 3) stop 6
+  if (.not.associated (ptr, baz)) stop 7
 end
 integer function foo ()
   foo = 1
diff --git a/libgomp/testsuite/libgomp.fortran/recursion1.f90 b/libgomp/testsuite/libgomp.fortran/recursion1.f90
index c9aec7e4159..2546d09d11e 100644
--- a/libgomp/testsuite/libgomp.fortran/recursion1.f90
+++ b/libgomp/testsuite/libgomp.fortran/recursion1.f90
@@ -14,7 +14,7 @@ do i=1,10
   call sub(i)
 end do
 !$omp end parallel do
-if (s/=55) STOP 1
+if (s/=55) stop 1
 
 contains
 
diff --git a/libgomp/testsuite/libgomp.fortran/reduction1.f90 b/libgomp/testsuite/libgomp.fortran/reduction1.f90
index bc036b057ea..622a7059d6c 100644
--- a/libgomp/testsuite/libgomp.fortran/reduction1.f90
+++ b/libgomp/testsuite/libgomp.fortran/reduction1.f90
@@ -55,14 +55,14 @@
     ca = cmplx (-1, 0)
   end if
 !$omp end parallel
-  if (v) STOP 1
+  if (v) stop 1
   if (cnt .eq. 3) then
-    if (i .ne. 8 .or. any (ia .ne. (/3, 3, 1, 6, 6, 8/))) STOP 2
-    if (r .ne. 8 .or. any (ra .ne. (/9.5, 8.0, 1.5, 1.5/))) STOP 3
-    if (d .ne. 12.5 .or. any (da .ne. (/8.0, 16.5, 16.5, 14.0, 5.5/))) STOP 4
-    if (c .ne. cmplx (11.5, -5)) STOP 5
-    if (ca(1) .ne. cmplx (12, 2)) STOP 6
-    if (ca(2) .ne. cmplx (6.5, 3) .or. ca(2) .ne. ca(3)) STOP 7
+    if (i .ne. 8 .or. any (ia .ne. (/3, 3, 1, 6, 6, 8/))) stop 2
+    if (r .ne. 8 .or. any (ra .ne. (/9.5, 8.0, 1.5, 1.5/))) stop 3
+    if (d .ne. 12.5 .or. any (da .ne. (/8.0, 16.5, 16.5, 14.0, 5.5/))) stop 4
+    if (c .ne. cmplx (11.5, -5)) stop 5
+    if (ca(1) .ne. cmplx (12, 2)) stop 6
+    if (ca(2) .ne. cmplx (6.5, 3) .or. ca(2) .ne. ca(3)) stop 7
   end if
 
   i = 1
@@ -113,14 +113,14 @@
     ca = cmplx (-1, 0)
   end if
 !$omp end parallel
-  if (v) STOP 8
+  if (v) stop 8
   if (cnt .eq. 3) then
-    if (i .ne. 8 .or. any (ia .ne. (/3, 3, 1, 6, 6, 8/))) STOP 9
-    if (r .ne. 8 .or. any (ra .ne. (/9.5, 8.0, 1.5, 1.5/))) STOP 10
-    if (d .ne. 12.5 .or. any (da .ne. (/8.0, 16.5, 16.5, 14.0, 5.5/))) STOP 11
-    if (c .ne. cmplx (11.5, -5)) STOP 12
-    if (ca(1) .ne. cmplx (12, 2)) STOP 13
-    if (ca(2) .ne. cmplx (6.5, 3) .or. ca(2) .ne. ca(3)) STOP 14
+    if (i .ne. 8 .or. any (ia .ne. (/3, 3, 1, 6, 6, 8/))) stop 9
+    if (r .ne. 8 .or. any (ra .ne. (/9.5, 8.0, 1.5, 1.5/))) stop 10
+    if (d .ne. 12.5 .or. any (da .ne. (/8.0, 16.5, 16.5, 14.0, 5.5/))) stop 11
+    if (c .ne. cmplx (11.5, -5)) stop 12
+    if (ca(1) .ne. cmplx (12, 2)) stop 13
+    if (ca(2) .ne. cmplx (6.5, 3) .or. ca(2) .ne. ca(3)) stop 14
   end if
 
   i = 1
@@ -169,13 +169,13 @@
     ca = cmplx (-1, 0)
   end if
 !$omp end parallel
-  if (v) STOP 15
+  if (v) stop 15
   if (cnt .eq. 3) then
-    if (i .ne. 6 .or. any (ia .ne. (/4, 4, 8, -16, -16, -8/))) STOP 16
-    if (r .ne. 8 .or. any (ra .ne. (/4., -2., -1., -1./))) STOP 17
-    if (d .ne. -40 .or. any (da .ne. (/32., -64., -64., 64., -32./))) STOP 18
-    if (c .ne. cmplx (0, 15)) STOP 19
-    if (ca(1) .ne. cmplx (0, 10)) STOP 20
-    if (ca(2) .ne. cmplx (-2, 0) .or. ca(2) .ne. ca(3)) STOP 21
+    if (i .ne. 6 .or. any (ia .ne. (/4, 4, 8, -16, -16, -8/))) stop 16
+    if (r .ne. 8 .or. any (ra .ne. (/4., -2., -1., -1./))) stop 17
+    if (d .ne. -40 .or. any (da .ne. (/32., -64., -64., 64., -32./))) stop 18
+    if (c .ne. cmplx (0, 15)) stop 19
+    if (ca(1) .ne. cmplx (0, 10)) stop 20
+    if (ca(2) .ne. cmplx (-2, 0) .or. ca(2) .ne. ca(3)) stop 21
   end if
 end
diff --git a/libgomp/testsuite/libgomp.fortran/reduction2.f90 b/libgomp/testsuite/libgomp.fortran/reduction2.f90
index 6af173d2397..75c2e0cf239 100644
--- a/libgomp/testsuite/libgomp.fortran/reduction2.f90
+++ b/libgomp/testsuite/libgomp.fortran/reduction2.f90
@@ -31,10 +31,10 @@
     ma(1) = .true.
   end if
 !$omp end parallel
-  if (v) STOP 1
+  if (v) stop 1
   if (cnt .eq. 3) then
-    if (l .or. any (la .neqv. (/.true., .false., .false., .false./))) STOP 2
-    if (.not. m .or. any (ma .neqv. (/.true., .true., .false., .true./))) STOP 3
+    if (l .or. any (la .neqv. (/.true., .false., .false., .false./))) stop 2
+    if (.not. m .or. any (ma .neqv. (/.true., .true., .false., .true./))) stop 3
   end if
 
   l = .true.
@@ -64,10 +64,10 @@
     ma(1) = .true.
   end if
 !$omp end parallel
-  if (v) STOP 4
+  if (v) stop 4
   if (cnt .eq. 3) then
-    if (.not. l .or. any (la .neqv. (/.true., .false., .true., .false./))) STOP 5
-    if (.not. m .or. any (ma .neqv. (/.false., .true., .false., .true./))) STOP 6
+    if (.not. l .or. any (la .neqv. (/.true., .false., .true., .false./))) stop 5
+    if (.not. m .or. any (ma .neqv. (/.false., .true., .false., .true./))) stop 6
   end if
 
 end
diff --git a/libgomp/testsuite/libgomp.fortran/reduction3.f90 b/libgomp/testsuite/libgomp.fortran/reduction3.f90
index b0a858b54f0..e19bac6f57e 100644
--- a/libgomp/testsuite/libgomp.fortran/reduction3.f90
+++ b/libgomp/testsuite/libgomp.fortran/reduction3.f90
@@ -46,11 +46,11 @@
     da = -1
   end if
 !$omp end parallel
-  if (v) STOP 1
+  if (v) stop 1
   if (cnt .eq. 3) then
-    if (i .ne. 4 .or. any (ia .ne. (/7, 2, 2, 5, 5, 5/))) STOP 2
-    if (r .ne. 5 .or. any (ra .ne. (/6.5, 6.5, 4., 4./))) STOP 3
-    if (d .ne. 8.5 .or. any (da .ne. (/6.5, 8.5, 8.5, 8.5, 6.5/))) STOP 4
+    if (i .ne. 4 .or. any (ia .ne. (/7, 2, 2, 5, 5, 5/))) stop 2
+    if (r .ne. 5 .or. any (ra .ne. (/6.5, 6.5, 4., 4./))) stop 3
+    if (d .ne. 8.5 .or. any (da .ne. (/6.5, 8.5, 8.5, 8.5, 6.5/))) stop 4
   end if
 
   i = 1
@@ -94,10 +94,10 @@
     da(1:4) = 6
   end if
 !$omp end parallel
-  if (v) STOP 5
+  if (v) stop 5
   if (cnt .eq. 3) then
-    if (i .ne. 1 .or. any (ia .ne. (/1, 1, -2, -2, -2, 1/))) STOP 6
-    if (r .ne. -1 .or. any (ra .ne. (/4., -1.5, -8.5, -1.5/))) STOP 7
-    if (d .ne. -2.5 .or. any (da .ne. (/2.5, 2.5, 2.5, 6., 6.5/))) STOP 8
+    if (i .ne. 1 .or. any (ia .ne. (/1, 1, -2, -2, -2, 1/))) stop 6
+    if (r .ne. -1 .or. any (ra .ne. (/4., -1.5, -8.5, -1.5/))) stop 7
+    if (d .ne. -2.5 .or. any (da .ne. (/2.5, 2.5, 2.5, 6., 6.5/))) stop 8
   end if
 end
diff --git a/libgomp/testsuite/libgomp.fortran/reduction4.f90 b/libgomp/testsuite/libgomp.fortran/reduction4.f90
index 91c7fc89bf2..2de903c05a1 100644
--- a/libgomp/testsuite/libgomp.fortran/reduction4.f90
+++ b/libgomp/testsuite/libgomp.fortran/reduction4.f90
@@ -4,12 +4,12 @@
   integer (kind = 4) :: i, ia (6), j, ja (6), k, ka (6), ta (6), n, cnt, x
   logical :: v
 
-  i = Z'ffff0f'
-  ia = Z'f0ff0f'
-  j = Z'0f0000'
-  ja = Z'0f5a00'
-  k = Z'055aa0'
-  ka = Z'05a5a5'
+  i = int(Z'ffff0f')
+  ia = int(Z'f0ff0f')
+  j = int(Z'0f0000')
+  ja = int(Z'0f5a00')
+  k = int(Z'055aa0')
+  ka = int(Z'05a5a5')
   v = .false.
   cnt = -1
   x = not(0)
@@ -22,35 +22,35 @@
   n = omp_get_thread_num ()
   if (n .eq. 0) then
     cnt = omp_get_num_threads ()
-    i = Z'ff7fff'
-    ia(3:5) = Z'fffff1'
-    j = Z'078000'
+    i = int(Z'ff7fff')
+    ia(3:5) = int(Z'fffff1')
+    j = int(Z'078000')
     ja(1:3) = 1
-    k = Z'78'
-    ka(3:6) = Z'f0f'
+    k = int(Z'78')
+    ka(3:6) = int(Z'f0f')
   else if (n .eq. 1) then
-    i = Z'ffff77'
-    ia(2:5) = Z'ffafff'
-    j = Z'007800'
+    i = int(Z'ffff77')
+    ia(2:5) = int(Z'ffafff')
+    j = int(Z'007800')
     ja(2:5) = 8
-    k = Z'57'
-    ka(3:4) = Z'f0108'
+    k = int(Z'57')
+    ka(3:4) = int(Z'f0108')
   else
-    i = Z'777fff'
-    ia(1:2) = Z'fffff3'
-    j = Z'000780'
-    ja(5:6) = Z'f00'
-    k = Z'1000'
-    ka(6:6) = Z'777'
+    i = int(Z'777fff')
+    ia(1:2) = int(Z'fffff3')
+    j = int(Z'000780')
+    ja(5:6) = int(Z'f00')
+    k = int(Z'1000')
+    ka(6:6) = int(Z'777')
   end if
 !$omp end parallel
-  if (v) STOP 1
+  if (v) stop 1
   if (cnt .eq. 3) then
-    ta = (/Z'f0ff03', Z'f0af03', Z'f0af01', Z'f0af01', Z'f0af01', Z'f0ff0f'/)
-    if (i .ne. Z'777f07' .or. any (ia .ne. ta)) STOP 2
-    ta = (/Z'f5a01', Z'f5a09', Z'f5a09', Z'f5a08', Z'f5f08', Z'f5f00'/)
-    if (j .ne. Z'fff80' .or. any (ja .ne. ta)) STOP 3
-    ta = (/Z'5a5a5', Z'5a5a5', Z'aaba2', Z'aaba2', Z'5aaaa', Z'5addd'/)
-    if (k .ne. Z'54a8f' .or. any (ka .ne. ta)) STOP 4
+    ta = (/int(Z'f0ff03'), int(Z'f0af03'), int(Z'f0af01'), int(Z'f0af01'), int(Z'f0af01'), int(Z'f0ff0f')/)
+    if (i .ne. int(Z'777f07') .or. any (ia .ne. ta)) stop 2
+    ta = (/int(Z'f5a01'), int(Z'f5a09'), int(Z'f5a09'), int(Z'f5a08'), int(Z'f5f08'), int(Z'f5f00')/)
+    if (j .ne. int(Z'fff80') .or. any (ja .ne. ta)) stop 3
+    ta = (/int(Z'5a5a5'), int(Z'5a5a5'), int(Z'aaba2'), int(Z'aaba2'), int(Z'5aaaa'), int(Z'5addd')/)
+    if (k .ne. int(Z'54a8f') .or. any (ka .ne. ta)) stop 4
   end if
 end
diff --git a/libgomp/testsuite/libgomp.fortran/reduction5.f90 b/libgomp/testsuite/libgomp.fortran/reduction5.f90
index f8fdcb471fe..e2a17a93a1f 100644
--- a/libgomp/testsuite/libgomp.fortran/reduction5.f90
+++ b/libgomp/testsuite/libgomp.fortran/reduction5.f90
@@ -10,15 +10,15 @@ contains
   subroutine test1
     use reduction5, bitwise_or => ior
     integer :: n
-    n = Z'f'
+    n = int(Z'f')
 !$omp parallel sections num_threads (3) reduction (bitwise_or: n)
-    n = ior (n, Z'20')
+    n = ior (n, int(Z'20'))
 !$omp section
-    n = bitwise_or (Z'410', n)
+    n = bitwise_or (int(Z'410'), n)
 !$omp section
-    n = bitwise_or (n, Z'2000')
+    n = bitwise_or (n, int(Z'2000'))
 !$omp end parallel sections
-    if (n .ne. Z'243f') STOP 1
+    if (n .ne. int(Z'243f')) stop 1
   end subroutine
   subroutine test2
     use reduction5, min => max, max => min
@@ -36,7 +36,7 @@ contains
     if (m .gt. 3) m = 3
     if (n .lt. -1) n = -1
 !$omp end parallel sections
-    if (m .ne. 3 .or. n .ne. 15) STOP 2
+    if (m .ne. 3 .or. n .ne. 15) stop 2
   end subroutine test2
 end
 
diff --git a/libgomp/testsuite/libgomp.fortran/reduction6.f90 b/libgomp/testsuite/libgomp.fortran/reduction6.f90
index 99fb8d16bc0..24d849cc60f 100644
--- a/libgomp/testsuite/libgomp.fortran/reduction6.f90
+++ b/libgomp/testsuite/libgomp.fortran/reduction6.f90
@@ -8,7 +8,7 @@
   call foo (a (2:4, 3:5), nthreads)
   if (nthreads .eq. 3) then
     write (c, '(36i1)') a
-    if (c .ne. '999999999999966699966699966699999999') STOP 1
+    if (c .ne. '999999999999966699966699966699999999') stop 1
   end if
 contains
   subroutine foo (b, nthreads)
@@ -27,6 +27,6 @@ contains
 !$omp end master
     b = 2
 !$omp end parallel
-    if (err .gt. 0) STOP 2
+    if (err .gt. 0) stop 2
   end subroutine foo
 end
diff --git a/libgomp/testsuite/libgomp.fortran/reference1.f90 b/libgomp/testsuite/libgomp.fortran/reference1.f90
index 8c9631b49d2..1d52c2fcdaa 100644
--- a/libgomp/testsuite/libgomp.fortran/reference1.f90
+++ b/libgomp/testsuite/libgomp.fortran/reference1.f90
@@ -8,10 +8,10 @@
   k = 0
   d = 24.5
   call test (i, j, k, d)
-  if (i .ne. 38) STOP 1
-  if (iand (k, 255) .ne. 0) STOP 2
+  if (i .ne. 38) stop 1
+  if (iand (k, 255) .ne. 0) stop 2
   if (iand (k, 65280) .eq. 0) then
-    if (k .ne. 65536 * 4) STOP 3
+    if (k .ne. 65536 * 4) stop 3
   end if
 contains
   subroutine test (i, j, k, d)
diff --git a/libgomp/testsuite/libgomp.fortran/reference2.f90 b/libgomp/testsuite/libgomp.fortran/reference2.f90
index 87efab255e1..6fcd05dca4b 100644
--- a/libgomp/testsuite/libgomp.fortran/reference2.f90
+++ b/libgomp/testsuite/libgomp.fortran/reference2.f90
@@ -11,7 +11,7 @@ contains
     a = 15
     l = bar (a)
 !$omp end parallel
-    if (l) STOP 1
+    if (l) stop 1
   end subroutine
   function bar (a)
     real, dimension (5) :: a
diff --git a/libgomp/testsuite/libgomp.fortran/retval1.f90 b/libgomp/testsuite/libgomp.fortran/retval1.f90
index db49a0da8a0..604e14e2e84 100644
--- a/libgomp/testsuite/libgomp.fortran/retval1.f90
+++ b/libgomp/testsuite/libgomp.fortran/retval1.f90
@@ -14,7 +14,7 @@ function f1 ()
   l = l .or. (omp_get_thread_num () .eq. 0 .and. f1 .ne. 8.5)
   l = l .or. (omp_get_thread_num () .eq. 1 .and. f1 .ne. 14.5)
 !$omp end parallel
-  if (l) STOP 1
+  if (l) stop 1
   f1 = -2.5
 end function f1
 function f2 ()
@@ -32,7 +32,7 @@ entry e2 ()
   l = l .or. (omp_get_thread_num () .eq. 0 .and. e2 .ne. 8.5)
   l = l .or. (omp_get_thread_num () .eq. 1 .and. e2 .ne. 14.5)
 !$omp end parallel
-  if (l) STOP 2
+  if (l) stop 2
   e2 = 7.5
 end function f2
 function f3 ()
@@ -53,7 +53,7 @@ entry e3 ()
   l = l .or. (omp_get_thread_num () .eq. 1 .and. e3 .ne. 14.5)
   l = l .or. f3 .ne. e3 - 4.5
 !$omp end parallel
-  if (l) STOP 3
+  if (l) stop 3
   e3 = 0.5
 end function f3
 function f4 () result (r4)
@@ -74,7 +74,7 @@ entry e4 () result (s4)
   l = l .or. (omp_get_thread_num () .eq. 1 .and. s4 .ne. 14.5)
   l = l .or. r4 .ne. s4 - 4.5
 !$omp end parallel
-  if (l) STOP 4
+  if (l) stop 4
   s4 = -0.5
 end function f4
 function f5 (is_f5)
@@ -101,20 +101,20 @@ entry e5 (is_f5)
   l = l .or. (omp_get_thread_num () .eq. 1 .and. e5 .ne. 14)
   l = l .or. f5 .ne. e5 - 4.5
 !$omp end parallel
-  if (l) STOP 5
+  if (l) stop 5
   if (is_f5) f5 = -2.5
   if (.not. is_f5) e5 = 8
 end function f5
 
   real :: f1, f2, e2, f3, e3, f4, e4, f5
   integer :: e5
-  if (f1 () .ne. -2.5) STOP 6
-  if (f2 () .ne. 7.5) STOP 7
-  if (e2 () .ne. 7.5) STOP 8
-  if (f3 () .ne. 0.5) STOP 9
-  if (e3 () .ne. 0.5) STOP 10
-  if (f4 () .ne. -0.5) STOP 11
-  if (e4 () .ne. -0.5) STOP 12
-  if (f5 (.true.) .ne. -2.5) STOP 13
-  if (e5 (.false.) .ne. 8) STOP 14
+  if (f1 () .ne. -2.5) stop 6
+  if (f2 () .ne. 7.5) stop 7
+  if (e2 () .ne. 7.5) stop 8
+  if (f3 () .ne. 0.5) stop 9
+  if (e3 () .ne. 0.5) stop 10
+  if (f4 () .ne. -0.5) stop 11
+  if (e4 () .ne. -0.5) stop 12
+  if (f5 (.true.) .ne. -2.5) stop 13
+  if (e5 (.false.) .ne. 8) stop 14
 end
diff --git a/libgomp/testsuite/libgomp.fortran/retval2.f90 b/libgomp/testsuite/libgomp.fortran/retval2.f90
index a2fd5b99117..2851e056eb8 100644
--- a/libgomp/testsuite/libgomp.fortran/retval2.f90
+++ b/libgomp/testsuite/libgomp.fortran/retval2.f90
@@ -17,11 +17,11 @@ contains
     l = l .or. (omp_get_thread_num () .eq. 0 .and. f1 .ne. 8.5)
     l = l .or. (omp_get_thread_num () .eq. 1 .and. f1 .ne. 14.5)
 !$omp end parallel
-    if (l) STOP 1
+    if (l) stop 1
     f1 = -2.5
   end subroutine sub1
 end function f1
 
   real :: f1
-  if (f1 () .ne. -2.5) STOP 2
+  if (f1 () .ne. -2.5) stop 2
 end
diff --git a/libgomp/testsuite/libgomp.fortran/sharing1.f90 b/libgomp/testsuite/libgomp.fortran/sharing1.f90
index 03633e9a78c..48c21aae429 100644
--- a/libgomp/testsuite/libgomp.fortran/sharing1.f90
+++ b/libgomp/testsuite/libgomp.fortran/sharing1.f90
@@ -25,5 +25,5 @@
 !$omp barrier
   if (j .ne. 25 .or. i .ne. (k * 10 + 14)) l = .true.
 !$omp end parallel
-  if (l .or. j .ne. 25) STOP 1
+  if (l .or. j .ne. 25) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/sharing2.f90 b/libgomp/testsuite/libgomp.fortran/sharing2.f90
index 0b01059ee1d..3f76475f68e 100644
--- a/libgomp/testsuite/libgomp.fortran/sharing2.f90
+++ b/libgomp/testsuite/libgomp.fortran/sharing2.f90
@@ -27,6 +27,6 @@
 !$omp barrier
   if (j .ne. 25 .or. i .ne. (k * 10 + 14)) l = .true.
 !$omp end parallel
-  if (l) STOP 1
-  if (j .ne. 25) STOP 2
+  if (l) stop 1
+  if (j .ne. 25) stop 2
 end
diff --git a/libgomp/testsuite/libgomp.fortran/simd1.f90 b/libgomp/testsuite/libgomp.fortran/simd1.f90
index 558e141e1d1..353f16d04bc 100644
--- a/libgomp/testsuite/libgomp.fortran/simd1.f90
+++ b/libgomp/testsuite/libgomp.fortran/simd1.f90
@@ -30,6 +30,6 @@
     s = s + l
     t%x = t%x + l
   end do
-  if (r.ne.2700.or.j.ne.70.or.k.ne.80.or.s.ne.2700) STOP 1
-  if (t%x.ne.2700) STOP 2
+  if (r.ne.2700.or.j.ne.70.or.k.ne.80.or.s.ne.2700) stop 1
+  if (t%x.ne.2700) stop 2
 end
diff --git a/libgomp/testsuite/libgomp.fortran/simd2.f90 b/libgomp/testsuite/libgomp.fortran/simd2.f90
index 0062d5e6e60..415ad9c965d 100644
--- a/libgomp/testsuite/libgomp.fortran/simd2.f90
+++ b/libgomp/testsuite/libgomp.fortran/simd2.f90
@@ -13,42 +13,42 @@
   end do
   s = foo (b)
   do i = 1, 1024
-    if (a(i).ne.((i - 513) * b(i))) STOP 1
+    if (a(i).ne.((i - 513) * b(i))) stop 1
     if (i.lt.52.and.modulo (i - 52, 39).ne.0) then
-      if (b(i).ne.(modulo (i - 52, 39) - 39)) STOP 2
+      if (b(i).ne.(modulo (i - 52, 39) - 39)) stop 2
     else
-      if (b(i).ne.(modulo (i - 52, 39))) STOP 3
+      if (b(i).ne.(modulo (i - 52, 39))) stop 3
     end if
     a(i) = i - 513
   end do
-  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) STOP 4
+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) stop 4
   k = 4
   m = 2
   t = 1
   s = bar (b)
   do i = 1, 1024
-    if (a(i).ne.((i - 513) * b(i))) STOP 5
+    if (a(i).ne.((i - 513) * b(i))) stop 5
     if (i.lt.52.and.modulo (i - 52, 39).ne.0) then
-      if (b(i).ne.(modulo (i - 52, 39) - 39)) STOP 6
+      if (b(i).ne.(modulo (i - 52, 39) - 39)) stop 6
     else
-      if (b(i).ne.(modulo (i - 52, 39))) STOP 7
+      if (b(i).ne.(modulo (i - 52, 39))) stop 7
     end if
     a(i) = i - 513
   end do
-  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) STOP 8
+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) stop 8
   k = 4
   m = 2
   t = 1
   s = baz (b)
   do i = 1, 1024
-    if (a(i).ne.((i - 513) * b(i))) STOP 9
+    if (a(i).ne.((i - 513) * b(i))) stop 9
     if (i.lt.52.and.modulo (i - 52, 39).ne.0) then
-      if (b(i).ne.(modulo (i - 52, 39) - 39)) STOP 10
+      if (b(i).ne.(modulo (i - 52, 39) - 39)) stop 10
     else
-      if (b(i).ne.(modulo (i - 52, 39))) STOP 11
+      if (b(i).ne.(modulo (i - 52, 39))) stop 11
     end if
   end do
-  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) STOP 12
+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) stop 12
 contains
   function foo (p)
     integer :: p(1024), u, v, i, s, foo
@@ -62,8 +62,8 @@ contains
       s = s + p(i) + k
     end do
     !$omp end simd
-    if (i.ne.1025) STOP 13
-    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) STOP 14
+    if (i.ne.1025) stop 13
+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) stop 14
     foo = s
   end function foo
   function bar (p)
@@ -78,8 +78,8 @@ contains
       s = s + p(i) + k
     end do
     !$omp end simd
-    if (i.ne.1025) STOP 15
-    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) STOP 16
+    if (i.ne.1025) stop 15
+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) stop 16
     bar = s
   end function bar
   function baz (p)
@@ -94,8 +94,8 @@ contains
       v = p(i) + k
       s = s + p(i) + k
     end do
-    if (i.ne.1025) STOP 17
-    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) STOP 18
+    if (i.ne.1025) stop 17
+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) stop 18
     baz = s
   end function baz
 end
diff --git a/libgomp/testsuite/libgomp.fortran/simd3.f90 b/libgomp/testsuite/libgomp.fortran/simd3.f90
index 22ff564bd06..29b98e1895a 100644
--- a/libgomp/testsuite/libgomp.fortran/simd3.f90
+++ b/libgomp/testsuite/libgomp.fortran/simd3.f90
@@ -13,42 +13,42 @@
   end do
   s = foo (b)
   do i = 1, 1024
-    if (a(i).ne.((i - 513) * b(i))) STOP 1
+    if (a(i).ne.((i - 513) * b(i))) stop 1
     if (i.lt.52.and.modulo (i - 52, 39).ne.0) then
-      if (b(i).ne.(modulo (i - 52, 39) - 39)) STOP 2
+      if (b(i).ne.(modulo (i - 52, 39) - 39)) stop 2
     else
-      if (b(i).ne.(modulo (i - 52, 39))) STOP 3
+      if (b(i).ne.(modulo (i - 52, 39))) stop 3
     end if
     a(i) = i - 513
   end do
-  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) STOP 4
+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) stop 4
   k = 4
   m = 2
   t = 1
   s = bar (b)
   do i = 1, 1024
-    if (a(i).ne.((i - 513) * b(i))) STOP 5
+    if (a(i).ne.((i - 513) * b(i))) stop 5
     if (i.lt.52.and.modulo (i - 52, 39).ne.0) then
-      if (b(i).ne.(modulo (i - 52, 39) - 39)) STOP 6
+      if (b(i).ne.(modulo (i - 52, 39) - 39)) stop 6
     else
-      if (b(i).ne.(modulo (i - 52, 39))) STOP 7
+      if (b(i).ne.(modulo (i - 52, 39))) stop 7
     end if
     a(i) = i - 513
   end do
-  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) STOP 8
+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) stop 8
   k = 4
   m = 2
   t = 1
   s = baz (b)
   do i = 1, 1024
-    if (a(i).ne.((i - 513) * b(i))) STOP 9
+    if (a(i).ne.((i - 513) * b(i))) stop 9
     if (i.lt.52.and.modulo (i - 52, 39).ne.0) then
-      if (b(i).ne.(modulo (i - 52, 39) - 39)) STOP 10
+      if (b(i).ne.(modulo (i - 52, 39) - 39)) stop 10
     else
-      if (b(i).ne.(modulo (i - 52, 39))) STOP 11
+      if (b(i).ne.(modulo (i - 52, 39))) stop 11
     end if
   end do
-  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) STOP 12
+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) stop 12
 contains
   function foo (p)
     integer :: p(1024), u, v, i, s, foo
@@ -65,8 +65,8 @@ contains
     end do
     !$omp end do simd
     !$omp end parallel
-    if (i.ne.1025) STOP 13
-    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) STOP 14
+    if (i.ne.1025) stop 13
+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) stop 14
     foo = s
   end function foo
   function bar (p)
@@ -84,8 +84,8 @@ contains
     end do
     !$omp end do simd
     !$omp endparallel
-    if (i.ne.1025) STOP 15
-    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) STOP 16
+    if (i.ne.1025) stop 15
+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) stop 16
     bar = s
   end function bar
   function baz (p)
@@ -102,8 +102,8 @@ contains
       s = s + p(i) + k
     end do
     !$omp end parallel
-    if (i.ne.1025) STOP 17
-    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) STOP 18
+    if (i.ne.1025) stop 17
+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) stop 18
     baz = s
   end function baz
 end
diff --git a/libgomp/testsuite/libgomp.fortran/simd4.f90 b/libgomp/testsuite/libgomp.fortran/simd4.f90
index ceb1611bd38..a81bc5e3472 100644
--- a/libgomp/testsuite/libgomp.fortran/simd4.f90
+++ b/libgomp/testsuite/libgomp.fortran/simd4.f90
@@ -13,42 +13,42 @@
   end do
   s = foo (b)
   do i = 1, 1024
-    if (a(i).ne.((i - 513) * b(i))) STOP 1
+    if (a(i).ne.((i - 513) * b(i))) stop 1
     if (i.lt.52.and.modulo (i - 52, 39).ne.0) then
-      if (b(i).ne.(modulo (i - 52, 39) - 39)) STOP 2
+      if (b(i).ne.(modulo (i - 52, 39) - 39)) stop 2
     else
-      if (b(i).ne.(modulo (i - 52, 39))) STOP 3
+      if (b(i).ne.(modulo (i - 52, 39))) stop 3
     end if
     a(i) = i - 513
   end do
-  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) STOP 4
+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) stop 4
   k = 4
   m = 2
   t = 1
   s = bar (b)
   do i = 1, 1024
-    if (a(i).ne.((i - 513) * b(i))) STOP 5
+    if (a(i).ne.((i - 513) * b(i))) stop 5
     if (i.lt.52.and.modulo (i - 52, 39).ne.0) then
-      if (b(i).ne.(modulo (i - 52, 39) - 39)) STOP 6
+      if (b(i).ne.(modulo (i - 52, 39) - 39)) stop 6
     else
-      if (b(i).ne.(modulo (i - 52, 39))) STOP 7
+      if (b(i).ne.(modulo (i - 52, 39))) stop 7
     end if
     a(i) = i - 513
   end do
-  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) STOP 8
+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) stop 8
   k = 4
   m = 2
   t = 1
   s = baz (b)
   do i = 1, 1024
-    if (a(i).ne.((i - 513) * b(i))) STOP 9
+    if (a(i).ne.((i - 513) * b(i))) stop 9
     if (i.lt.52.and.modulo (i - 52, 39).ne.0) then
-      if (b(i).ne.(modulo (i - 52, 39) - 39)) STOP 10
+      if (b(i).ne.(modulo (i - 52, 39) - 39)) stop 10
     else
-      if (b(i).ne.(modulo (i - 52, 39))) STOP 11
+      if (b(i).ne.(modulo (i - 52, 39))) stop 11
     end if
   end do
-  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) STOP 12
+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) stop 12
 contains
   function foo (p)
     integer :: p(1024), u, v, i, s, foo
@@ -63,8 +63,8 @@ contains
       s = s + p(i) + k
     end do
     !$omp end parallel do simd
-    if (i.ne.1025) STOP 13
-    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) STOP 14
+    if (i.ne.1025) stop 13
+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) stop 14
     foo = s
   end function foo
   function bar (p)
@@ -80,8 +80,8 @@ contains
       s = s + p(i) + k
     end do
     !$omp endparalleldosimd
-    if (i.ne.1025) STOP 15
-    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) STOP 16
+    if (i.ne.1025) stop 15
+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) stop 16
     bar = s
   end function bar
   function baz (p)
@@ -96,8 +96,8 @@ contains
       v = p(i) + k
       s = s + p(i) + k
     end do
-    if (i.ne.1025) STOP 17
-    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) STOP 18
+    if (i.ne.1025) stop 17
+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) stop 18
     baz = s
   end function baz
 end
diff --git a/libgomp/testsuite/libgomp.fortran/simd5.f90 b/libgomp/testsuite/libgomp.fortran/simd5.f90
index e1383d20d30..099fec55cb9 100644
--- a/libgomp/testsuite/libgomp.fortran/simd5.f90
+++ b/libgomp/testsuite/libgomp.fortran/simd5.f90
@@ -12,7 +12,7 @@
     c = c + b - (7 + 2 * i)
     b = b + 2
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) STOP 1
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) stop 1
   i = 4
   j = 4
   b = 7
@@ -21,7 +21,7 @@
     c = c + b - (7 + i / 4 * 3)
     b = b + 3
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) STOP 2
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) stop 2
   i = 4
   j = 4
   b = 7
@@ -30,7 +30,7 @@
     c = c + b - (7 + 2 * i)
     b = b + 2
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) STOP 3
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) stop 3
   i = 4
   j = 4
   b = 7
@@ -39,7 +39,7 @@
     c = c + b - (7 + i / 4 * 3)
     b = b + 3
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) STOP 4
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) stop 4
   i = 4
   j = 4
   b = 7
@@ -50,7 +50,7 @@
       b = b + 2
     end do
   end do
-  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) STOP 5
+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) stop 5
   i = 4
   j = 4
   b = 7
@@ -61,7 +61,7 @@
       b = b + 2
     end do
   end do
-  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) STOP 6
+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) stop 6
   i = 4
   j = 4
   b = 7
@@ -70,7 +70,7 @@
     c = c + b - (7 + 2 * i)
     b = b + 2
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) STOP 7
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) stop 7
   i = 4
   j = 4
   b = 7
@@ -79,7 +79,7 @@
     c = c + b - (7 + i / 4 * 3)
     b = b + 3
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) STOP 8
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) stop 8
   i = 4
   j = 4
   b = 7
@@ -88,7 +88,7 @@
     c = c + b - (7 + 2 * i)
     b = b + 2
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) STOP 9
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) stop 9
   i = 4
   j = 4
   b = 7
@@ -97,7 +97,7 @@
     c = c + b - (7 + i / 4 * 3)
     b = b + 3
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) STOP 10
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) stop 10
   i = 4
   j = 4
   b = 7
@@ -108,7 +108,7 @@
       b = b + 2
     end do
   end do
-  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) STOP 11
+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) stop 11
   i = 4
   j = 4
   b = 7
@@ -120,5 +120,5 @@
       b = b + 2
     end do
   end do
-  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) STOP 12
+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) stop 12
 end
diff --git a/libgomp/testsuite/libgomp.fortran/simd6.f90 b/libgomp/testsuite/libgomp.fortran/simd6.f90
index b78bb4b6886..445ac4de4c4 100644
--- a/libgomp/testsuite/libgomp.fortran/simd6.f90
+++ b/libgomp/testsuite/libgomp.fortran/simd6.f90
@@ -18,7 +18,7 @@
     c = c + b - (7 + 2 * i)
     call foo (b, i, j, 2)
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) STOP 1
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) stop 1
   i = 4
   j = 4
   b = 7
@@ -27,7 +27,7 @@
     c = c + b - (7 + i / 4 * 3)
     call foo (b, i, j, 3)
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) STOP 2
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) stop 2
   i = 4
   j = 4
   b = 7
@@ -36,7 +36,7 @@
     c = c + b - (7 + 2 * i)
     call foo (b, i, j, 2)
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) STOP 3
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) stop 3
   i = 4
   j = 4
   b = 7
@@ -45,7 +45,7 @@
     c = c + b - (7 + i / 4 * 3)
     call foo (b, i, j, 3)
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) STOP 4
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) stop 4
   i = 4
   j = 4
   b = 7
@@ -56,7 +56,7 @@
       call foo (b, i, j, 2)
     end do
   end do
-  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) STOP 5
+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) stop 5
   i = 4
   j = 4
   b = 7
@@ -67,7 +67,7 @@
       call foo (b, i, j, 2)
     end do
   end do
-  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) STOP 6
+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) stop 6
   i = 4
   j = 4
   b = 7
@@ -76,7 +76,7 @@
     c = c + b - (7 + 2 * i)
     call foo (b, i, j, 2)
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) STOP 7
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) stop 7
   i = 4
   j = 4
   b = 7
@@ -85,7 +85,7 @@
     c = c + b - (7 + i / 4 * 3)
     call foo (b, i, j, 3)
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) STOP 8
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) stop 8
   i = 4
   j = 4
   b = 7
@@ -94,7 +94,7 @@
     c = c + b - (7 + 2 * i)
     call foo (b, i, j, 2)
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) STOP 9
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) stop 9
   i = 4
   j = 4
   b = 7
@@ -103,7 +103,7 @@
     c = c + b - (7 + i / 4 * 3)
     call foo (b, i, j, 3)
   end do
-  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) STOP 10
+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) stop 10
   i = 4
   j = 4
   b = 7
@@ -114,7 +114,7 @@
       call foo (b, i, j, 2)
     end do
   end do
-  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) STOP 11
+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) stop 11
   i = 4
   j = 4
   b = 7
@@ -126,7 +126,7 @@
       call foo (b, i, j, 2)
     end do
   end do
-  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) STOP 12
+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) stop 12
 end
 subroutine foo (b, i, j, x)
   integer, intent (inout) :: b
diff --git a/libgomp/testsuite/libgomp.fortran/simd7.f90 b/libgomp/testsuite/libgomp.fortran/simd7.f90
index 4b5633e902b..28b2f251c55 100644
--- a/libgomp/testsuite/libgomp.fortran/simd7.f90
+++ b/libgomp/testsuite/libgomp.fortran/simd7.f90
@@ -30,20 +30,20 @@ subroutine foo (d, e, f, g, m, n)
     b = b + 1; c = c + 2; d = d + 3; e = e + 4; f = f + 5; g = g + 6
     h = h + 7; k = k + 8; m = m + 9
   end do
-  if (l .or. i /= 64) STOP 1
-  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) STOP 2
-  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) STOP 3
-  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) STOP 4
-  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) STOP 5
-  if (m /= 15 + 9 * 64) STOP 6
-  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) STOP 7
-  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) STOP 8
-  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) STOP 9
-  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) STOP 10
-  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) STOP 11
-  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) STOP 12
-  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) STOP 13
-  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) STOP 14
+  if (l .or. i /= 64) stop 1
+  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) stop 2
+  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) stop 3
+  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) stop 4
+  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) stop 5
+  if (m /= 15 + 9 * 64) stop 6
+  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) stop 7
+  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) stop 8
+  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) stop 9
+  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) stop 10
+  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) stop 11
+  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) stop 12
+  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) stop 13
+  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) stop 14
   i = 4; j = 4; b = 7; c = 8; d = 9; e = 10; f = 11; g = 12; h = 13; k = 14; m = 15
 !$omp simd linear(b)linear(c:2)linear(d:3)linear(e:4)linear(f:5)linear(g:6) &
 !$omp & linear(h:7)linear(k:8)linear(m:9) reduction(.or.:l) collapse(2)
@@ -68,20 +68,20 @@ subroutine foo (d, e, f, g, m, n)
       h = h + 7; k = k + 8; m = m + 9
     end do
   end do
-  if (l .or. i /= 8 .or. j /= 8) STOP 15
-  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) STOP 16
-  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) STOP 17
-  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) STOP 18
-  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) STOP 19
-  if (m /= 15 + 9 * 64) STOP 20
-  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) STOP 21
-  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) STOP 22
-  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) STOP 23
-  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) STOP 24
-  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) STOP 25
-  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) STOP 26
-  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) STOP 27
-  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) STOP 28
+  if (l .or. i /= 8 .or. j /= 8) stop 15
+  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) stop 16
+  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) stop 17
+  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) stop 18
+  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) stop 19
+  if (m /= 15 + 9 * 64) stop 20
+  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) stop 21
+  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) stop 22
+  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) stop 23
+  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) stop 24
+  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) stop 25
+  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) stop 26
+  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) stop 27
+  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) stop 28
   i = 4; j = 4; b = 7; c = 8; d = 9; e = 10; f = 11; g = 12; h = 13; k = 14; m = 15
 !$omp parallel do simd linear(b)linear(c:2)linear(d:3)linear(e:4)linear(f:5) &
 !$omp & linear(g:6)linear(h:7)linear(k:8)linear(m:9) reduction(.or.:l)
@@ -104,20 +104,20 @@ subroutine foo (d, e, f, g, m, n)
     b = b + 1; c = c + 2; d = d + 3; e = e + 4; f = f + 5; g = g + 6
     h = h + 7; k = k + 8; m = m + 9
   end do
-  if (l .or. i /= 64) STOP 29
-  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) STOP 30
-  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) STOP 31
-  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) STOP 32
-  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) STOP 33
-  if (m /= 15 + 9 * 64) STOP 34
-  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) STOP 35
-  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) STOP 36
-  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) STOP 37
-  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) STOP 38
-  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) STOP 39
-  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) STOP 40
-  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) STOP 41
-  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) STOP 42
+  if (l .or. i /= 64) stop 29
+  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) stop 30
+  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) stop 31
+  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) stop 32
+  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) stop 33
+  if (m /= 15 + 9 * 64) stop 34
+  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) stop 35
+  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) stop 36
+  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) stop 37
+  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) stop 38
+  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) stop 39
+  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) stop 40
+  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) stop 41
+  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) stop 42
   i = 4; j = 4; b = 7; c = 8; d = 9; e = 10; f = 11; g = 12; h = 13; k = 14; m = 15
 !$omp parallel do simd linear(b)linear(c:2)linear(d:3)linear(e:4)linear(f:5) &
 !$omp & linear(g:6)linear(h:7)linear(k:8)linear(m:9) reduction(.or.:l) collapse(2)
@@ -142,20 +142,20 @@ subroutine foo (d, e, f, g, m, n)
       h = h + 7; k = k + 8; m = m + 9
     end do
   end do
-  if (l .or. i /= 8 .or. j /= 8) STOP 43
-  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) STOP 44
-  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) STOP 45
-  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) STOP 46
-  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) STOP 47
-  if (m /= 15 + 9 * 64) STOP 48
-  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) STOP 49
-  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) STOP 50
-  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) STOP 51
-  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) STOP 52
-  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) STOP 53
-  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) STOP 54
-  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) STOP 55
-  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) STOP 56
+  if (l .or. i /= 8 .or. j /= 8) stop 43
+  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) stop 44
+  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) stop 45
+  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) stop 46
+  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) stop 47
+  if (m /= 15 + 9 * 64) stop 48
+  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) stop 49
+  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) stop 50
+  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) stop 51
+  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) stop 52
+  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) stop 53
+  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) stop 54
+  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) stop 55
+  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) stop 56
 end subroutine
 
   interface
diff --git a/libgomp/testsuite/libgomp.fortran/stack.f90 b/libgomp/testsuite/libgomp.fortran/stack.f90
index f0babdd059a..da0ff744f17 100644
--- a/libgomp/testsuite/libgomp.fortran/stack.f90
+++ b/libgomp/testsuite/libgomp.fortran/stack.f90
@@ -11,7 +11,7 @@ program stack
 !$omp end parallel
   ! Check that the two threads are not sharing a location for
   ! the array x in foo()
-  if (ilocs(1) .eq. ilocs(2)) STOP 1
+  if (ilocs(1) .eq. ilocs(2)) stop 1
 end program stack
 
 integer function foo ()
diff --git a/libgomp/testsuite/libgomp.fortran/strassen.f90 b/libgomp/testsuite/libgomp.fortran/strassen.f90
index 84faced494a..e0dc0c8eef9 100644
--- a/libgomp/testsuite/libgomp.fortran/strassen.f90
+++ b/libgomp/testsuite/libgomp.fortran/strassen.f90
@@ -19,7 +19,7 @@ program strassen_matmul
   call strassen (A, B, D, N)
   end = omp_get_wtime ()
   write(*,'(a, f10.6)') ' Time for Strassen    = ', end - start
-  if (sqrt (sum ((C - D) ** 2)) / N .gt. 0.1) STOP 1
+  if (sqrt (sum ((C - D) ** 2)) / N .gt. 0.1) stop 1
   D = 0
   start = omp_get_wtime ()
 !$omp parallel
@@ -29,7 +29,7 @@ program strassen_matmul
 !$omp end parallel
   end = omp_get_wtime ()
   write(*,'(a, f10.6)') ' Time for Strassen MP = ', end - start
-  if (sqrt (sum ((C - D) ** 2)) / N .gt. 0.1) STOP 2
+  if (sqrt (sum ((C - D) ** 2)) / N .gt. 0.1) stop 2
 
 contains
 
diff --git a/libgomp/testsuite/libgomp.fortran/tabs1.f90 b/libgomp/testsuite/libgomp.fortran/tabs1.f90
index 68dba38c9ad..da334dc419e 100644
--- a/libgomp/testsuite/libgomp.fortran/tabs1.f90
+++ b/libgomp/testsuite/libgomp.fortran/tabs1.f90
@@ -1,4 +1,4 @@
-	if (b().ne.2) STOP 1
+	if (b().ne.2) stop 1
 contains
 subroutine a
 !$omp parallel
diff --git a/libgomp/testsuite/libgomp.fortran/tabs2.f b/libgomp/testsuite/libgomp.fortran/tabs2.f
index 07fca22cac3..a018dd53f60 100644
--- a/libgomp/testsuite/libgomp.fortran/tabs2.f
+++ b/libgomp/testsuite/libgomp.fortran/tabs2.f
@@ -1,5 +1,5 @@
 ! { dg-options "-ffixed-form" }
-      if (b().ne.2) STOP 1
+      if (b().ne.2) stop 1
       contains
       subroutine a
 !$omp parallel
diff --git a/libgomp/testsuite/libgomp.fortran/target-allocatable-1-1.f90 b/libgomp/testsuite/libgomp.fortran/target-allocatable-1-1.f90
new file mode 100644
index 00000000000..429a855a20b
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/target-allocatable-1-1.f90
@@ -0,0 +1,69 @@
+! Test 'allocatable' with OpenMP 'target' 'map' clauses.
+
+! See also '../libgomp.oacc-fortran/allocatable-1-1.f90'.
+
+! { dg-do run }
+! { dg-additional-options "-cpp" }
+! { dg-additional-options "-DMEM_SHARED" { target offload_device_shared_as } }
+
+program main
+  implicit none
+  integer, allocatable :: a, b, c, d, e
+
+  allocate (a)
+  a = 11
+
+  b = 25 ! Implicit allocation.
+
+  c = 52 ! Implicit allocation.
+
+  !No 'allocate (d)' here.
+
+  !No 'allocate (e)' here.
+
+  !$omp target map(to: a) map(tofrom: b, c, d) map(from: e)
+
+  if (.not. allocated (a)) stop 1
+  if (a .ne. 11) stop 2
+  a = 33
+
+  if (.not. allocated (b)) stop 3
+  if (b .ne. 25) stop 4
+
+  if (.not. allocated (c)) stop 5
+  if (c .ne. 52) stop 6
+  c = 10
+
+  if (allocated (d)) stop 7
+  d = 42 ! Implicit allocation, but on device only.
+  if (.not. allocated (d)) stop 8
+  deallocate (d) ! OpenMP requires must be "unallocated upon exit from the region".
+
+  if (allocated (e)) stop 9
+  e = 24 ! Implicit allocation, but on device only.
+  if (.not. allocated (e)) stop 10
+  deallocate (e) ! OpenMP requires must be "unallocated upon exit from the region".
+
+  !$omp end target
+
+  if (.not. allocated (a)) stop 20
+#ifdef MEM_SHARED
+  if (a .ne. 33) stop 21
+#else
+  if (a .ne. 11) stop 22
+#endif
+  deallocate (a)
+
+  if (.not. allocated (b)) stop 23
+  if (b .ne. 25) stop 24
+  deallocate (b)
+
+  if (.not. allocated (c)) stop 25
+  if (c .ne. 10) stop 26
+  deallocate (c)
+
+  if (allocated (d)) stop 27
+
+  if (allocated (e)) stop 28
+
+end program main
diff --git a/libgomp/testsuite/libgomp.fortran/target-allocatable-1-2.f90 b/libgomp/testsuite/libgomp.fortran/target-allocatable-1-2.f90
new file mode 100644
index 00000000000..5301c8eeffb
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/target-allocatable-1-2.f90
@@ -0,0 +1,82 @@
+! Test 'allocatable' with OpenMP 'target' 'map' clauses, subroutine in module,
+! pass by reference.
+
+! See also '../libgomp.oacc-fortran/allocatable-1-2.f90'.
+
+! { dg-do run }
+! { dg-additional-options "-cpp" }
+! { dg-additional-options "-DMEM_SHARED" { target offload_device_shared_as } }
+
+module m
+contains
+  subroutine r (a, b, c, d, e)
+    implicit none
+    integer, allocatable :: a, b, c, d, e
+
+    !$omp target map(to: a) map(tofrom: b, c, d) map(from: e)
+
+    if (.not. allocated (a)) stop 1
+    if (a .ne. 11) stop 2
+    a = 33
+
+    if (.not. allocated (b)) stop 3
+    if (b .ne. 25) stop 4
+
+    if (.not. allocated (c)) stop 5
+    if (c .ne. 52) stop 6
+    c = 10
+
+    if (allocated (d)) stop 7
+    d = 42 ! Implicit allocation, but on device only.
+    if (.not. allocated (d)) stop 8
+    deallocate (d) ! OpenMP requires must be "unallocated upon exit from the region".
+
+    if (allocated (e)) stop 9
+    e = 24 ! Implicit allocation, but on device only.
+    if (.not. allocated (e)) stop 10
+    deallocate (e) ! OpenMP requires must be "unallocated upon exit from the region".
+
+    !$omp end target
+
+  end subroutine r
+end module m
+
+program main
+  use m
+  implicit none
+  integer, allocatable :: a, b, c, d, e
+
+  allocate (a)
+  a = 11
+
+  b = 25 ! Implicit allocation.
+
+  c = 52 ! Implicit allocation.
+
+  !No 'allocate (d)' here.
+
+  !No 'allocate (e)' here.
+
+  call r(a, b, c, d, e)
+
+  if (.not. allocated (a)) stop 20
+#ifdef MEM_SHARED
+  if (a .ne. 33) stop 21
+#else
+  if (a .ne. 11) stop 22
+#endif
+  deallocate (a)
+
+  if (.not. allocated (b)) stop 23
+  if (b .ne. 25) stop 24
+  deallocate (b)
+
+  if (.not. allocated (c)) stop 25
+  if (c .ne. 10) stop 26
+  deallocate (c)
+
+  if (allocated (d)) stop 27
+
+  if (allocated (e)) stop 28
+
+end program main
diff --git a/libgomp/testsuite/libgomp.fortran/target-print-1-nvptx.f90 b/libgomp/testsuite/libgomp.fortran/target-print-1-nvptx.f90
new file mode 100644
index 00000000000..a89c9c33484
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/target-print-1-nvptx.f90
@@ -0,0 +1,11 @@
+! Ensure that write on the offload device works, nvptx offloading variant.
+
+! This doesn't compile: for nvptx offloading we're using a minimal libgfortran
+! configuration.
+! { dg-do link } ! ..., but still apply 'dg-do run' options.
+! { dg-xfail-if "minimal libgfortran" { offload_target_nvptx } }
+
+! Skip duplicated testing.
+! { dg-skip-if "separate file" { ! offload_target_nvptx } }
+
+include 'target-print-1.f90'
diff --git a/libgomp/testsuite/libgomp.fortran/target-print-1.f90 b/libgomp/testsuite/libgomp.fortran/target-print-1.f90
new file mode 100644
index 00000000000..327bb22cb6d
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/target-print-1.f90
@@ -0,0 +1,17 @@
+! Ensure that write on the offload device works.
+
+! { dg-do run }
+! { dg-output "The answer is 42(\n|\r\n|\r)+" }
+
+! Separate file 'target-print-1-nvptx.f90' for nvptx offloading.
+! { dg-skip-if "separate file" { offload_target_nvptx } }
+
+program main
+  implicit none
+  integer :: var = 42
+
+!$omp target 
+  write (0, '("The answer is ", I2)') var
+!$omp end target
+
+end program main
diff --git a/libgomp/testsuite/libgomp.fortran/target-simd.f90 b/libgomp/testsuite/libgomp.fortran/target-simd.f90
new file mode 100644
index 00000000000..158347b59dc
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/target-simd.f90
@@ -0,0 +1,26 @@
+! { dg-do run }
+
+program test
+  implicit none
+  real, allocatable :: a(:), b(:)
+  integer :: i
+
+  a = [(i, i = 1, 100)]
+  allocate(b, mold=a)
+  b = 0
+
+  !$omp target simd map(to:a) map(from:b)
+  do i = 1, size(a)
+    b(i) = 5.0 * a(i)
+  end do
+
+  if (any (b - 5.0 *a > 10.0*epsilon(a))) stop 1
+
+  !$omp target simd map(to:a) map(from:b)
+  do i = 1, size(a)
+    b(i) = 2.0 * a(i)
+  end do
+  !$omp end target simd
+
+  if (any (b - 2.0 *a > 10.0*epsilon(a))) stop 2
+end program test
diff --git a/libgomp/testsuite/libgomp.fortran/target1.f90 b/libgomp/testsuite/libgomp.fortran/target1.f90
index 99c5087ca97..36b12591344 100644
--- a/libgomp/testsuite/libgomp.fortran/target1.f90
+++ b/libgomp/testsuite/libgomp.fortran/target1.f90
@@ -13,9 +13,9 @@ contains
         q(i) = p(i)
       end do
     !$omp end target
-    if (any (p /= q)) STOP 1
+    if (any (p /= q)) stop 1
     do i = 1, n
-      if (p(i) /= i * iand (i, 63)) STOP 2
+      if (p(i) /= i * iand (i, 63)) stop 2
     end do
     !$omp target data if (n > 256) map (to: v(1:n), w) map (from: p, q)
     !$omp target if (n > 256)
@@ -38,7 +38,7 @@ contains
       end do
     !$omp end target
     !$omp end target data
-    if (any (p + 2.0 /= q)) STOP 3
+    if (any (p + 2.0 /= q)) stop 3
   end subroutine
 end module target1
   use target1, only : foo
@@ -52,7 +52,7 @@ end module target1
   end do
   call foo (p, v, w, n)
   do i = 1, n
-    if (p(i) /= i * iand (i, 63) + 3) STOP 4
+    if (p(i) /= i * iand (i, 63) + 3) stop 4
   end do
   deallocate (p, v, w)
 end
diff --git a/libgomp/testsuite/libgomp.fortran/target2.f90 b/libgomp/testsuite/libgomp.fortran/target2.f90
index 0595ed192d5..11b8af737e3 100644
--- a/libgomp/testsuite/libgomp.fortran/target2.f90
+++ b/libgomp/testsuite/libgomp.fortran/target2.f90
@@ -29,7 +29,7 @@ contains
       r = r .or. (j /= 16)
       r = r .or. (any (k /= 17)) .or. (lbound (k, 1) /= 4) .or. (ubound (k, 1) /= n)
     !$omp end target
-    if (r) STOP 1
+    if (r) stop 1
     !$omp target map (to: b(3:n), c(5:n+4), d(2:n+1), e(1:,:2), g(3:n), i(3:n), k(4:n), n) map (from: r)
       r = (any (b /= 8)) .or. (lbound (b, 1) /= 3) .or. (ubound (b, 1) /= n)
       r = r .or. (any (c /= 9)) .or. (lbound (c, 1) /= 5) .or. (ubound (c, 1) /= n + 4)
@@ -40,7 +40,7 @@ contains
       r = r .or. (any (i /= 15)) .or. (lbound (i, 1) /= 3) .or. (ubound (i, 1) /= n)
       r = r .or. (any (k /= 17)) .or. (lbound (k, 1) /= 4) .or. (ubound (k, 1) /= n)
     !$omp end target
-    if (r) STOP 2
+    if (r) stop 2
     !$omp target map (to: b(5:n-2), c(7:n), d(4:n-2), e(1:,2:), g(5:n-3), i(6:n-4), k(5:n-5), n) map (from: r)
       r = (any (b(5:n-2) /= 8)) .or. (lbound (b, 1) /= 3) .or. (ubound (b, 1) /= n)
       r = r .or. (any (c(7:n) /= 9)) .or. (lbound (c, 1) /= 5) .or. (ubound (c, 1) /= n + 4)
@@ -62,7 +62,7 @@ contains
       r = r .or. (any (i(6:n-4) /= 15)) .or. (lbound (i, 1) /= 3) .or. (ubound (i, 1) /= n)
       r = r .or. (any (k(5:n-5) /= 17)) .or. (lbound (k, 1) /= 4) .or. (ubound (k, 1) /= n)
     !$omp end target
-    if (r) STOP 3
+    if (r) stop 3
     !$omp target map (to: d(2:n+1), n)
       r = a /= 7
       r = r .or. (any (b /= 8)) .or. (lbound (b, 1) /= 3) .or. (ubound (b, 1) /= n)
@@ -77,7 +77,7 @@ contains
       r = r .or. (j /= 16)
       r = r .or. (any (k /= 17)) .or. (lbound (k, 1) /= 4) .or. (ubound (k, 1) /= n)
     !$omp end target
-    if (r) STOP 4
+    if (r) stop 4
   end subroutine foo
 end module target2
   use target2, only : foo
diff --git a/libgomp/testsuite/libgomp.fortran/target3.f90 b/libgomp/testsuite/libgomp.fortran/target3.f90
index 6c45d119e6e..d9b9ccf63be 100644
--- a/libgomp/testsuite/libgomp.fortran/target3.f90
+++ b/libgomp/testsuite/libgomp.fortran/target3.f90
@@ -13,12 +13,12 @@ contains
       r = associated (f) .or. associated (g)
       r = r .or. associated (j) .or. associated (k)
     !$omp end target
-    if (r) STOP 1
+    if (r) stop 1
     !$omp target
       r = associated (f) .or. associated (g)
       r = r .or. associated (j) .or. associated (k)
     !$omp end target
-    if (r) STOP 2
+    if (r) stop 2
   end subroutine foo
 end module target3
   use target3, only : foo
diff --git a/libgomp/testsuite/libgomp.fortran/target4.f90 b/libgomp/testsuite/libgomp.fortran/target4.f90
index 52575af07f4..5dac76cffd1 100644
--- a/libgomp/testsuite/libgomp.fortran/target4.f90
+++ b/libgomp/testsuite/libgomp.fortran/target4.f90
@@ -44,5 +44,5 @@ end module target4
 &   30800.0d0, 33000.0d0, 23256.0d0, 25840.0d0, 28424.0d0, 31008.0d0, 33592.0d0, 36176.0d0, &
 &   38760.0d0, 41344.0d0, 30000.0d0, 33000.0d0, 36000.0d0, 39000.0d0, 42000.0d0, 45000.0d0, &
 &   48000.0d0, 51000.0d0 /), (/ 8, 9 /))
-  if (any (a /= res)) STOP 1
+  if (any (a /= res)) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/target5.f90 b/libgomp/testsuite/libgomp.fortran/target5.f90
index b03cb58c544..9d4662a18eb 100644
--- a/libgomp/testsuite/libgomp.fortran/target5.f90
+++ b/libgomp/testsuite/libgomp.fortran/target5.f90
@@ -3,7 +3,7 @@
   integer :: r
   r = 0
   call foo (r)
-  if (r /= 11) STOP 1
+  if (r /= 11) stop 1
 contains
   subroutine foo (r)
     integer :: i, r
diff --git a/libgomp/testsuite/libgomp.fortran/target6.f90 b/libgomp/testsuite/libgomp.fortran/target6.f90
index 82f49e2b9c8..c4105d73082 100644
--- a/libgomp/testsuite/libgomp.fortran/target6.f90
+++ b/libgomp/testsuite/libgomp.fortran/target6.f90
@@ -16,7 +16,7 @@ contains
     !$omp end target
     !$omp target update if (n > 256) from (p)
     do i = 1, n
-      if (p(i) /= i * iand (i, 63)) STOP 1
+      if (p(i) /= i * iand (i, 63)) stop 1
       v(i) = v(i) + 1
     end do
     !$omp target update if (n > 256) to (v(1:n))
@@ -28,8 +28,8 @@ contains
     !$omp end target
     !$omp end target data
     do i = 1, n
-      if (q(i) /= (v(i) - 1) * w(i)) STOP 2
-      if (p(i) /= q(i) + w(i)) STOP 3
+      if (q(i) /= (v(i) - 1) * w(i)) stop 2
+      if (p(i) /= q(i) + w(i)) stop 3
     end do
   end subroutine
 end module target6
@@ -44,7 +44,7 @@ end module target6
   end do
   call foo (p, v, w, n)
   do i = 1, n
-    if (p(i) /= (i + 1) * iand (i, 63)) STOP 4
+    if (p(i) /= (i + 1) * iand (i, 63)) stop 4
   end do
   deallocate (p, v, w)
 end
diff --git a/libgomp/testsuite/libgomp.fortran/target7.f90 b/libgomp/testsuite/libgomp.fortran/target7.f90
index 49ebb97618e..73a7485a638 100644
--- a/libgomp/testsuite/libgomp.fortran/target7.f90
+++ b/libgomp/testsuite/libgomp.fortran/target7.f90
@@ -28,7 +28,7 @@
   !$omp end single
   !$omp end parallel
   do i = 1, n
-    if (a(i) /= i + 1) STOP 1
+    if (a(i) /= i + 1) stop 1
   end do
 end
 real function foo (x)
diff --git a/libgomp/testsuite/libgomp.fortran/target8.f90 b/libgomp/testsuite/libgomp.fortran/target8.f90
index e4874ae275c..5e7b1a4951f 100644
--- a/libgomp/testsuite/libgomp.fortran/target8.f90
+++ b/libgomp/testsuite/libgomp.fortran/target8.f90
@@ -22,7 +22,7 @@
   !$omp end single
   !$omp end parallel
   do i = 1, n
-    if (a(i) /= i + 1) STOP 1
+    if (a(i) /= i + 1) stop 1
   end do
 contains
   real function foo (x)
diff --git a/libgomp/testsuite/libgomp.fortran/target9.f90 b/libgomp/testsuite/libgomp.fortran/target9.f90
new file mode 100644
index 00000000000..30adc1bd70a
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/target9.f90
@@ -0,0 +1,124 @@
+! { dg-do run }
+! { dg-require-effective-target offload_device_nonshared_as } */
+
+module target_test
+  implicit none (type, external)
+  integer, parameter :: N = 40
+  integer :: sum
+  integer :: var1 = 1
+  integer :: var2 = 2
+
+  !$omp declare target to(D)
+  integer :: D(N) = 0
+contains
+  subroutine enter_data (X)
+    integer :: X(:)
+    !$omp target enter data map(to: var1, var2, X) map(alloc: sum)
+  end subroutine enter_data
+
+  subroutine exit_data_0 (D)
+    integer :: D(N)
+    !$omp target exit data map(delete: D)
+  end subroutine exit_data_0
+
+  subroutine exit_data_1 ()
+    !$omp target exit data map(from: var1)
+  end subroutine exit_data_1
+
+  subroutine exit_data_2 (X)
+    integer :: X(N)
+    !$omp target exit data map(from: var2) map(release: X, sum)
+  end subroutine exit_data_2
+
+  subroutine exit_data_3 (p, idx)
+    integer :: p(:)
+    integer, value :: idx
+    !$omp target exit data map(from: p(idx))
+  end subroutine exit_data_3
+
+  subroutine test_nested ()
+    integer :: X, Y, Z
+    X = 0
+    Y = 0
+    Z = 0
+
+    !$omp target data map(from: X, Y, Z)
+      !$omp target data map(from: X, Y, Z)
+        !$omp target map(from: X, Y, Z)
+          X = 1337
+          Y = 1337
+          Z = 1337
+        !$omp end target
+        if (X /= 0) stop 11
+        if (Y /= 0) stop 12
+        if (Z /= 0) stop 13
+
+        !$omp target exit data map(from: X) map(release: Y)
+        if (X /= 0) stop 14
+        if (Y /= 0) stop 15
+
+        !$omp target exit data map(release: Y) map(delete: Z)
+        if (Y /= 0) stop 16
+        if (Z /= 0) stop 17
+      !$omp end target data
+      if (X /= 1337) stop 18
+      if (Y /= 0) stop 19
+      if (Z /= 0) stop 20
+
+      !$omp target map(from: X)
+        X = 2448
+      !$omp end target
+      if (X /= 2448) stop 21
+      if (Y /= 0) stop 22
+      if (Z /= 0) stop 23
+
+      X = 4896
+    !$omp end target data
+    if (X /= 4896) stop 24
+    if (Y /= 0) stop 25
+    if (Z /= 0) stop 26
+  end subroutine test_nested
+end module target_test
+
+program main
+  use target_test
+  implicit none (type, external)
+
+  integer, allocatable :: X(:)
+  integer, pointer, contiguous :: Y(:)
+
+
+  allocate(X(N), Y(N))
+  X(10) = 10
+  Y(20) = 20
+  call enter_data (X)
+
+  call exit_data_0 (D)  ! This should have no effect on D.
+
+  !$omp target map(alloc: var1, var2, X) map(to: Y) map(always, from: sum)
+    var1 = var1 + X(10)
+    var2 = var2 + Y(20)
+    sum = var1 + var2
+    D(sum) = D(sum) + 1
+  !$omp end target
+
+  if (var1 /= 1) stop 1
+  if (var2 /= 2) stop 2
+  if (sum /= 33) stop 3
+
+  call exit_data_1 ()
+  if (var1 /= 11) stop 4
+  if (var2 /= 2) stop 5
+
+  ! Increase refcount of already mapped X(1:N).
+  !$omp target enter data map(alloc: X(16:17))
+
+  call exit_data_2 (X)
+  if (var2 /= 22) stop 6
+
+  call exit_data_3 (X, 5) ! Unmap X(1:N).
+
+  deallocate (X, Y)
+
+  call test_nested ()
+end program main
diff --git a/libgomp/testsuite/libgomp.fortran/task1.f90 b/libgomp/testsuite/libgomp.fortran/task1.f90
index 761226cd854..4eb6c106ea2 100644
--- a/libgomp/testsuite/libgomp.fortran/task1.f90
+++ b/libgomp/testsuite/libgomp.fortran/task1.f90
@@ -13,7 +13,7 @@ program tasktest
       !$omp end task
     end if
   !$omp end parallel
-  if (j.gt.0) STOP 1
+  if (j.gt.0) stop 1
 contains
   subroutine subr (i)
     use omp_lib
diff --git a/libgomp/testsuite/libgomp.fortran/task2.f90 b/libgomp/testsuite/libgomp.fortran/task2.f90
index 27151415043..623c7179293 100644
--- a/libgomp/testsuite/libgomp.fortran/task2.f90
+++ b/libgomp/testsuite/libgomp.fortran/task2.f90
@@ -1,3 +1,4 @@
+! { dg-do run }
 ! { dg-options "-std=legacy" }
 
   integer :: err
@@ -7,7 +8,7 @@
   call test
 !$omp end single
 !$omp end parallel
-  if (err.ne.0) STOP 1
+  if (err.ne.0) stop 1
 contains
   subroutine check (x, y, l)
     integer :: x, y
diff --git a/libgomp/testsuite/libgomp.fortran/task3.f90 b/libgomp/testsuite/libgomp.fortran/task3.f90
index fcff52ad016..a7b90d4c990 100644
--- a/libgomp/testsuite/libgomp.fortran/task3.f90
+++ b/libgomp/testsuite/libgomp.fortran/task3.f90
@@ -21,6 +21,6 @@ program F03_2_7_1d
    !$omp end parallel
    if (sum /= NT) then
       print *, "FAIL - sum == ", sum, " (expected ", NT, ")"
-      STOP 1
+      stop 1
    end if
 end program F03_2_7_1d
diff --git a/libgomp/testsuite/libgomp.fortran/task4.f90 b/libgomp/testsuite/libgomp.fortran/task4.f90
index 6430f2914a4..918bb1f97a7 100644
--- a/libgomp/testsuite/libgomp.fortran/task4.f90
+++ b/libgomp/testsuite/libgomp.fortran/task4.f90
@@ -41,5 +41,5 @@
 !$omp end parallel
 !$omp atomic read
   e = err
-  if (e .ne. 0) STOP 1
+  if (e .ne. 0) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/taskgroup1.f90 b/libgomp/testsuite/libgomp.fortran/taskgroup1.f90
index 3f6b38a35f9..a32d4440c16 100644
--- a/libgomp/testsuite/libgomp.fortran/taskgroup1.f90
+++ b/libgomp/testsuite/libgomp.fortran/taskgroup1.f90
@@ -1,3 +1,4 @@
+! { dg-do run }
   integer :: v(16), i
   do i = 1, 16
     v(i) = i
@@ -18,7 +19,7 @@
 	end do
       !$omp end taskgroup
       do i = 1, 16
-	if (v(i).ne.(i + 1)) STOP 1
+	if (v(i).ne.(i + 1)) stop 1
       end do
       !$omp taskgroup
 	do i = 1, 16, 2
@@ -34,7 +35,7 @@
 	end do
       !$omp endtaskgroup
       do i = 1, 16
-	if (v(i).ne.(i + 2)) STOP 2
+	if (v(i).ne.(i + 2)) stop 2
       end do
       !$omp taskgroup
 	do i = 1, 16, 2
@@ -53,8 +54,8 @@
 	end do
       !$omp end taskgroup
       do i = 1, 16, 2
-	if (v(i).ne.(i + 3)) STOP 3
-	if (v(i + 1).ne.(i + 5)) STOP 4
+	if (v(i).ne.(i + 3)) stop 3
+	if (v(i + 1).ne.(i + 5)) stop 4
       end do
       !$omp taskgroup
 	do i = 1, 16, 2
@@ -66,14 +67,14 @@
 	      v(i + 1) = v(i + 1) + 1
 	    !$omp end task
 	  !$omp end taskgroup
-	  if (v(i).ne.(i + 4).or.v(i + 1).ne.(i + 6)) STOP 5
+	  if (v(i).ne.(i + 4).or.v(i + 1).ne.(i + 6)) stop 5
 	  !$omp task
 	    v(i) = v(i) + 1
 	  !$omp end task
 	end do
       !$omp end taskgroup
       do i = 1, 16
-	if (v(i).ne.(i + 5)) STOP 6
+	if (v(i).ne.(i + 5)) stop 6
       end do
     !$omp end single
   !$omp end parallel
diff --git a/libgomp/testsuite/libgomp.fortran/taskloop1.f90 b/libgomp/testsuite/libgomp.fortran/taskloop1.f90
index 48904b145bd..616d16a6a26 100644
--- a/libgomp/testsuite/libgomp.fortran/taskloop1.f90
+++ b/libgomp/testsuite/libgomp.fortran/taskloop1.f90
@@ -1,3 +1,4 @@
+! { dg-do run }
   common /blk/ q, e
   integer :: q, r
   logical :: e
@@ -7,7 +8,7 @@
   r = bar (12, 18)
 !$omp end single
 !$omp end parallel
-  if (q .ne. 6 .or. r .ne. 17 .or. e) STOP 1
+  if (q .ne. 6 .or. r .ne. 17 .or. e) stop 1
 contains
   subroutine foo (a, b)
     integer, intent (in) :: a, b
diff --git a/libgomp/testsuite/libgomp.fortran/taskloop2.f90 b/libgomp/testsuite/libgomp.fortran/taskloop2.f90
index 0e92fcb6f89..a20242f9774 100644
--- a/libgomp/testsuite/libgomp.fortran/taskloop2.f90
+++ b/libgomp/testsuite/libgomp.fortran/taskloop2.f90
@@ -1,4 +1,3 @@
-! { dg-do run }
 ! { dg-options "-O2" }
 ! { dg-additional-options "-msse2" { target sse2_runtime } }
 ! { dg-additional-options "-mavx" { target avx_runtime } }
@@ -13,7 +12,7 @@
   !$omp end single
   !$omp end parallel
   do i = 1, 1024
-    if (u(i) .ne. 2 * i + 1) STOP 1
+    if (u(i) .ne. 2 * i + 1) stop 1
     v(i) = 1024 - i
     w(i) = 512 - i
   end do
@@ -24,45 +23,45 @@
   !$omp end parallel
   do i = 1, 1024
     if (i .lt. 2 .or. i .gt. 1022) then
-      if (u(i) .ne. 2 * i + 1) STOP 2
+      if (u(i) .ne. 2 * i + 1) stop 2
     else
-      if (u(i) .ne. 1536 - 2 * i) STOP 3
+      if (u(i) .ne. 1536 - 2 * i) stop 3
     end if
     v(i) = i
     w(i) = i + 1
   end do
-  if (m .ne. (1023 + 2 * (1021 * 5 + 17) + 9)) STOP 4
+  if (m .ne. (1023 + 2 * (1021 * 5 + 17) + 9)) stop 4
   !$omp parallel
   !$omp single
     call f3 (1, 1024)
   !$omp end single
   !$omp end parallel 
   do i = 1, 1024
-    if (u(i) .ne. 2 * i + 1) STOP 5
+    if (u(i) .ne. 2 * i + 1) stop 5
     v(i) = 1024 - i
     w(i) = 512 - i
   end do
-  if (m .ne. 1025) STOP 6
+  if (m .ne. 1025) stop 6
   !$omp parallel
   !$omp single
     call f4 (0, 31, 1, 32)
   !$omp end single
   !$omp end parallel 
   do i = 1, 1024
-    if (u(i) .ne. 1536 - 2 * i) STOP 7
+    if (u(i) .ne. 1536 - 2 * i) stop 7
     v(i) = i
     w(i) = i + 1
   end do
-  if (m .ne. 32 + 33 + 1024) STOP 8
+  if (m .ne. 32 + 33 + 1024) stop 8
   !$omp parallel
   !$omp single
     call f5 (0, 31, 1, 32)
   !$omp end single
   !$omp end parallel 
   do i = 1, 1024
-    if (u(i) .ne. 2 * i + 1) STOP 9
+    if (u(i) .ne. 2 * i + 1) stop 9
   end do
-  if (m .ne. 32 + 33) STOP 10
+  if (m .ne. 32 + 33) stop 10
 contains
   subroutine f1 (a, b)
     integer, intent(in) :: a, b
diff --git a/libgomp/testsuite/libgomp.fortran/taskloop3.f90 b/libgomp/testsuite/libgomp.fortran/taskloop3.f90
index 75f48229211..c4e57ddd451 100644
--- a/libgomp/testsuite/libgomp.fortran/taskloop3.f90
+++ b/libgomp/testsuite/libgomp.fortran/taskloop3.f90
@@ -1,18 +1,17 @@
-! { dg-do run }
 ! { dg-options "-O2" }
 
   integer, save :: g
   integer :: i
   !$omp parallel
   !$omp single
-    if (f1 (74) .ne. 63 + 4) STOP 1
+    if (f1 (74) .ne. 63 + 4) stop 1
     g = 77
     call f2
     !$omp taskwait
-    if (g .ne. 63 + 9) STOP 2
-    if (f3 (7_8, 11_8, 2_8) .ne. 11 * 7 + 13) STOP 3
+    if (g .ne. 63 + 9) stop 2
+    if (f3 (7_8, 11_8, 2_8) .ne. 11 * 7 + 13) stop 3
     if (f4 (0_8, 31_8, 16_8, 46_8, 1_8, 2_8, 73) .ne. 32 + 5 * 48 &
-&       + 11 * 31 + 17 * 46) STOP 4
+&       + 11 * 31 + 17 * 46) stop 4
   !$omp end single
   !$omp end parallel
 contains
@@ -22,7 +21,7 @@ contains
     x = y
     !$omp taskloop firstprivate(x)lastprivate(x)
     do i = 0, 63
-      if (x .ne. 74) STOP 5
+      if (x .ne. 74) stop 5
       if (i .eq. 63) then
         x = i + 4
       end if
@@ -33,7 +32,7 @@ contains
     integer :: i
     !$omp taskloop firstprivate(g)lastprivate(g)nogroup
     do i = 0, 63
-      if (g .ne. 77) STOP 6
+      if (g .ne. 77) stop 6
       if (i .eq. 63) then
         g = i + 9
       end if
@@ -60,7 +59,7 @@ contains
     !$omp & lastprivate (i, j, k, l)
     do i = a, b, e
       do j = c, d, f
-        if (k .ne. 73) STOP 7
+        if (k .ne. 73) stop 7
         if (i .eq. 31 .and. j .eq. 46) then
           k = i
         end if
diff --git a/libgomp/testsuite/libgomp.fortran/taskloop4.f90 b/libgomp/testsuite/libgomp.fortran/taskloop4.f90
index 23067a3e48d..4f7a25b88ca 100644
--- a/libgomp/testsuite/libgomp.fortran/taskloop4.f90
+++ b/libgomp/testsuite/libgomp.fortran/taskloop4.f90
@@ -1,4 +1,3 @@
-! { dg-do run }
 ! { dg-options "-O2" }
 
   integer, save :: u(64), v
@@ -11,22 +10,22 @@
     ! >= grainsize && < 2 * grainsize,
     ! unless # of loop iterations is smaller than grainsize.
     call test (0, 79, 1, 17, fn, ntasks, min_iters, max_iters, cnt)
-    if (cnt .ne. 79) STOP 1
-    if (min_iters .lt. 17 .or. max_iters .ge. 17 * 2) STOP 2
+    if (cnt .ne. 79) stop 1
+    if (min_iters .lt. 17 .or. max_iters .ge. 17 * 2) stop 2
     call test (-49, 2541, 7, 28, fn, ntasks, min_iters, max_iters, cnt)
-    if (cnt .ne. 370) STOP 3
-    if (min_iters .lt. 28 .or. max_iters .ge. 28 * 2) STOP 4
+    if (cnt .ne. 370) stop 3
+    if (min_iters .lt. 28 .or. max_iters .ge. 28 * 2) stop 4
     call test (7, 21, 2, 15, fn, ntasks, min_iters, max_iters, cnt)
-    if (cnt .ne. 7) STOP 5
-    if (min_iters .ne. 7 .or. max_iters .ne. 7) STOP 6
-    if (ntasks .ne. 1) STOP 7
+    if (cnt .ne. 7) stop 5
+    if (min_iters .ne. 7 .or. max_iters .ne. 7) stop 6
+    if (ntasks .ne. 1) stop 7
     fn => num_tasks
     ! If num_tasks is present, # of task loop iters is
     ! min (# of loop iters, num_tasks).
     call test (-51, 2500, 48, 9, fn, ntasks, min_iters, max_iters, cnt)
-    if (cnt .ne. 54 .or. ntasks .ne. 9) STOP 8
+    if (cnt .ne. 54 .or. ntasks .ne. 9) stop 8
     call test (0, 25, 2, 17, fn, ntasks, min_iters, max_iters, cnt)
-    if (cnt .ne. 13 .or. ntasks .ne. 13) STOP 9
+    if (cnt .ne. 13 .or. ntasks .ne. 13) stop 9
   !$omp end single
   !$omp end parallel
 contains
@@ -42,7 +41,7 @@ contains
           k = v
           v = v + 1
         !$omp end atomic
-        if (k .ge. 64) STOP 10
+        if (k .ge. 64) stop 10
       end if
       j = j + 1
       u(k + 1) = j
@@ -60,7 +59,7 @@ contains
           k = v
           v = v + 1
         !$omp end atomic
-        if (k .ge. 64) STOP 11
+        if (k .ge. 64) stop 11
       end if
       j = j + 1
       u(k + 1) = j
diff --git a/libgomp/testsuite/libgomp.fortran/teams1.f90 b/libgomp/testsuite/libgomp.fortran/teams1.f90
new file mode 100644
index 00000000000..4f146074d3d
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/teams1.f90
@@ -0,0 +1,19 @@
+program teams1
+  use omp_lib
+!$omp teams thread_limit (2)
+  if (omp_in_parallel ()) stop 1
+  if (omp_get_level () .ne. 0) stop 2
+  if (omp_get_ancestor_thread_num (0) .ne. 0) stop 3
+  if (omp_get_ancestor_thread_num (1) .ne. -1) stop 4
+  call omp_set_dynamic (.false.)
+  call omp_set_nested (.true.)
+!$omp parallel num_threads (2)
+  if (.not. omp_in_parallel ()) stop 5
+  if (omp_get_level () .ne. 1) stop 6
+  if (omp_get_ancestor_thread_num (0) .ne. 0) stop 7
+  if (omp_get_ancestor_thread_num (1) &
+&     .ne. omp_get_thread_num ()) stop 8
+  if (omp_get_ancestor_thread_num (2) .ne. -1) stop 9
+!$omp end parallel
+!$omp end teams
+end program
diff --git a/libgomp/testsuite/libgomp.fortran/teams2.f90 b/libgomp/testsuite/libgomp.fortran/teams2.f90
new file mode 100644
index 00000000000..f6b58f7c077
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/teams2.f90
@@ -0,0 +1,140 @@
+program teams2
+  use omp_lib
+  integer :: i, j, err
+  err = 0
+!$omp teams reduction(+:err)
+  err = err + bar (0, 0, 0)
+!$omp end teams
+  if (err .ne. 0) stop 1
+!$omp teams reduction(+:err)
+  err = err + bar (1, 0, 0)
+!$omp end teams
+  if (err .ne. 0) stop 2
+!$omp teams reduction(+:err)
+!$omp distribute
+  do i = 0, 63
+    err = err + bar (2, i, 0)
+  end do
+!$omp end teams
+  if (err .ne. 0) stop 3
+!$omp teams reduction(+:err)
+!$omp distribute
+  do i = 0, 63
+!$omp parallel do reduction(+:err)
+    do j = 0, 31
+      err = err + bar (3, i, j)
+    end do
+  end do
+!$omp end teams
+  if (err .ne. 0) stop 4
+contains
+  subroutine foo (x, y, z, a, b)
+    integer :: x, y, z, a, b(64), i, j
+    if (x .eq. 0) then
+      do i = 0, 63
+!$omp parallel do shared (a, b)
+        do j = 0, 31
+	  call foo (3, i, j, a, b)
+	end do
+      end do
+    else if (x .eq. 1) then
+!$omp distribute dist_schedule (static, 1)
+      do i = 0, 63
+!$omp parallel do shared (a, b)
+	do j = 0, 31
+	  call foo (3, i, j, a, b)
+	end do
+      end do
+    else if (x .eq. 2) then
+!$omp parallel do shared (a, b)
+      do j = 0, 31
+	call foo (3, y, j, a, b)
+      end do
+    else
+!$omp atomic
+      b(y + 1) = b(y + 1) + z
+!$omp end atomic
+!$omp atomic
+      a = a + 1
+!$omp end atomic
+    end if
+  end subroutine
+
+  integer function bar (x, y, z)
+    use omp_lib
+    integer :: x, y, z, a, b(64), i, c, d, e, f
+    a = 8
+    do i = 0, 63
+      b(i + 1) = i
+    end do
+    call foo (x, y, z, a, b)
+    if (x .eq. 0) then
+      if (a .ne. 8 + 64 * 32) then
+        bar = 1
+        return
+      end if
+      do i = 0, 63
+	if (b(i + 1) .ne. i + 31 * 32 / 2) then
+	  bar = 1
+	  return
+	end if
+      end do
+    else if (x .eq. 1) then
+      c = omp_get_num_teams ()
+      d = omp_get_team_num ()
+      e = d
+      f = 0
+      do i = 0, 63
+	if (i .eq. e) then
+          if (b(i + 1) .ne. i + 31 * 32 / 2) then
+            bar = 1
+            return
+          end if
+          f = f + 1
+          e = e + c
+	else if (b(i + 1) .ne. i) then
+	  bar = 1
+	  return
+	end if
+      end do
+      if (a .lt. 8 .or. a > 8 + f * 32) then
+        bar = 1
+        return
+      end if
+    else if (x .eq. 2) then
+      if (a .ne. 8 + 32) then
+        bar = 1
+        return
+      end if
+      do i = 0, 63
+        if (i .eq. y) then
+          c = 31 * 32 / 2
+        else
+          c = 0
+        end if
+	if (b(i + 1) .ne. i + c) then
+	  bar = 1
+	  return
+	end if
+      end do
+    else if (x .eq. 3) then
+      if (a .ne. 8 + 1) then
+        bar = 1
+        return
+      end if
+      do i = 0, 63
+        if (i .eq. y) then
+          c = z
+        else
+          c = 0
+        end if
+        if (b (i + 1) .ne. i + c) then
+          bar = 1
+          return
+        end if
+      end do
+    end if
+    bar = 0
+    return
+  end function
+end program
diff --git a/libgomp/testsuite/libgomp.fortran/threadprivate1.f90 b/libgomp/testsuite/libgomp.fortran/threadprivate1.f90
index 4867cc2cdbc..4ee56448aa0 100644
--- a/libgomp/testsuite/libgomp.fortran/threadprivate1.f90
+++ b/libgomp/testsuite/libgomp.fortran/threadprivate1.f90
@@ -15,7 +15,7 @@ end module threadprivate1
 !$omp barrier
   if (d .ne. omp_get_thread_num () + 6.5) l = .true.
 !$omp end parallel
-  if (l) STOP 1
+  if (l) stop 1
 end
 
 ! { dg-final { cleanup-modules "threadprivate1" } }
diff --git a/libgomp/testsuite/libgomp.fortran/threadprivate2.f90 b/libgomp/testsuite/libgomp.fortran/threadprivate2.f90
index c0aa5be8a94..f1428d8bef9 100644
--- a/libgomp/testsuite/libgomp.fortran/threadprivate2.f90
+++ b/libgomp/testsuite/libgomp.fortran/threadprivate2.f90
@@ -53,16 +53,16 @@ end module threadprivate2
   baz%b = omp_get_thread_num () * 2 + 1
 !$omp end parallel
 
-  if (l) STOP 1
-  if (.not.allocated (foo)) STOP 2
-  if (size (foo).ne.18) STOP 3
-  if (any (foo.ne.1)) STOP 4
-
-  if (associated (bar1)) STOP 5
-  if (.not.associated (bar3)) STOP 6
-  if (any (bar3 .ne. -2)) STOP 7
+  if (l) stop 1
+  if (.not.allocated (foo)) stop 2
+  if (size (foo).ne.18) stop 3
+  if (any (foo.ne.1)) stop 4
+
+  if (associated (bar1)) stop 5
+  if (.not.associated (bar3)) stop 6
+  if (any (bar3 .ne. -2)) stop 7
   deallocate (bar3)
-  if (associated (bar3)) STOP 8
+  if (associated (bar3)) stop 8
 
 !$omp parallel num_threads (4) reduction (.or.:l)
   l = l.or..not.allocated (foo)
@@ -85,12 +85,12 @@ end module threadprivate2
   l = l.or.(baz%b.ne.(omp_get_thread_num () * 2 + 1))
 !$omp end parallel
 
-  if (l) STOP 9
-  if (.not.allocated (foo)) STOP 10
-  if (size (foo).ne.18) STOP 11
-  if (any (foo.ne.1)) STOP 12
+  if (l) stop 9
+  if (.not.allocated (foo)) stop 10
+  if (size (foo).ne.18) stop 11
+  if (any (foo.ne.1)) stop 12
   deallocate (foo)
-  if (allocated (foo)) STOP 13
+  if (allocated (foo)) stop 13
 end
 
 ! { dg-final { cleanup-modules "threadprivate2" } }
diff --git a/libgomp/testsuite/libgomp.fortran/threadprivate3.f90 b/libgomp/testsuite/libgomp.fortran/threadprivate3.f90
index 5bb6b290e48..e82cc8a5ce4 100644
--- a/libgomp/testsuite/libgomp.fortran/threadprivate3.f90
+++ b/libgomp/testsuite/libgomp.fortran/threadprivate3.f90
@@ -44,7 +44,7 @@ end module threadprivate3
   bar3 = omp_get_thread_num () - 2
   if (omp_get_thread_num () .ne. 0) then
     deallocate (bar3)
-    if (associated (bar3)) STOP 1
+    if (associated (bar3)) stop 1
   else
     bar1 => var
   end if
@@ -55,13 +55,13 @@ end module threadprivate3
   baz%b = omp_get_thread_num () * 2 + 1
 !$omp end parallel
 
-  if (l) STOP 2
-  if (.not.associated (bar1)) STOP 3
-  if (any (bar1.ne.6)) STOP 4
-  if (.not.associated (bar3)) STOP 5
-  if (any (bar3 .ne. -2)) STOP 6
+  if (l) stop 2
+  if (.not.associated (bar1)) stop 3
+  if (any (bar1.ne.6)) stop 4
+  if (.not.associated (bar3)) stop 5
+  if (any (bar3 .ne. -2)) stop 6
   deallocate (bar3)
-  if (associated (bar3)) STOP 7
+  if (associated (bar3)) stop 7
 
   allocate (bar3 (10))
   bar3 = 17
@@ -102,7 +102,7 @@ end module threadprivate3
   l = l.or.(baz%b .ne. omp_get_thread_num () * 3 + 5)
 !$omp end parallel
 
-  if (l) STOP 8
+  if (l) stop 8
 end
 
 ! { dg-final { cleanup-modules "threadprivate3" } }
diff --git a/libgomp/testsuite/libgomp.fortran/threadprivate4.f90 b/libgomp/testsuite/libgomp.fortran/threadprivate4.f90
index 2e7a438dd7b..a428ed94b15 100644
--- a/libgomp/testsuite/libgomp.fortran/threadprivate4.f90
+++ b/libgomp/testsuite/libgomp.fortran/threadprivate4.f90
@@ -72,7 +72,7 @@ end module threadprivate4
   vi = -1
 !$omp end parallel
 
-  if (l) STOP 1
+  if (l) stop 1
 
 end
 
diff --git a/libgomp/testsuite/libgomp.fortran/udr1.f90 b/libgomp/testsuite/libgomp.fortran/udr1.f90
index 138bd587232..a12016d8864 100644
--- a/libgomp/testsuite/libgomp.fortran/udr1.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr1.f90
@@ -28,24 +28,24 @@ end module udr1
   do i = 1, 100
     j = j + i
   end do
-  if (j .ne. 5050) STOP 1
+  if (j .ne. 5050) stop 1
   j = 3
 !$omp parallel do reduction (bar : j)
   do i = 1, 100
     j = j + 4 * i
   end do
-  if (j .ne. (5050 * 4 + 3)) STOP 2
+  if (j .ne. (5050 * 4 + 3)) stop 2
 !$omp parallel do reduction (+ : d)
   do i = 1, 100
-    if (d%y .ne. 9) STOP 3
+    if (d%y .ne. 9) stop 3
     d%x = d%x + 8 * i
   end do
-  if (d%x .ne. (5050 * 8 + 7) .or. d%y .ne. 9) STOP 4
+  if (d%x .ne. (5050 * 8 + 7) .or. d%y .ne. 9) stop 4
   d = dt (5, 21)
 !$omp parallel do reduction (foo : d)
   do i = 1, 100
-    if (d%y .ne. 21) STOP 5
+    if (d%y .ne. 21) stop 5
     d%x = d%x + 8 * i
   end do
-  if (d%x .ne. (5050 * 8 + 5) .or. d%y .ne. 21) STOP 6
+  if (d%x .ne. (5050 * 8 + 5) .or. d%y .ne. 21) stop 6
 end
diff --git a/libgomp/testsuite/libgomp.fortran/udr10.f90 b/libgomp/testsuite/libgomp.fortran/udr10.f90
index a855c0b15c9..15e0f869bee 100644
--- a/libgomp/testsuite/libgomp.fortran/udr10.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr10.f90
@@ -28,5 +28,5 @@ program udr10
     j = j .localadd. dl(i)
     k = k + dl(i * 2)
   end do
-  if (j%x /= 5050 .or. k%x /= 10100) STOP 1
+  if (j%x /= 5050 .or. k%x /= 10100) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/udr11.f90 b/libgomp/testsuite/libgomp.fortran/udr11.f90
index d69dd72bac3..57989be4a01 100644
--- a/libgomp/testsuite/libgomp.fortran/udr11.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr11.f90
@@ -88,8 +88,8 @@ end module udr11
     t%x = t%x + 2 * i
     u%x = u%x + 3 * i
   end do
-  if (j%x /= 5050 .or. k%x /= 30300 .or. l%x /= 15150) STOP 1
-  if (m%x /= 5050 .or. n%x /= 10100 .or. o%x /= 15150) STOP 2
-  if (p%x /= 5050 .or. q%x /= 10100 .or. r%x /= 15150) STOP 3
-  if (s%x /= 5050 .or. t%x /= 10100 .or. u%x /= 15150) STOP 4
+  if (j%x /= 5050 .or. k%x /= 30300 .or. l%x /= 15150) stop 1
+  if (m%x /= 5050 .or. n%x /= 10100 .or. o%x /= 15150) stop 2
+  if (p%x /= 5050 .or. q%x /= 10100 .or. r%x /= 15150) stop 3
+  if (s%x /= 5050 .or. t%x /= 10100 .or. u%x /= 15150) stop 4
 end
diff --git a/libgomp/testsuite/libgomp.fortran/udr12.f90 b/libgomp/testsuite/libgomp.fortran/udr12.f90
index c39f0ebc90a..d1ae1aad909 100644
--- a/libgomp/testsuite/libgomp.fortran/udr12.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr12.f90
@@ -34,7 +34,7 @@
   b = b + 3
   r = r + 1
 !$omp end parallel
-  if (any (a /= 2 * r) .or. b /= 3 * r) STOP 1
+  if (any (a /= 2 * r) .or. b /= 3 * r) stop 1
   a(:) = 0
   b = 0
   r = 0
@@ -43,7 +43,7 @@
   b = b + 3
   r = r + 1
 !$omp end parallel
-  if (any (a /= 4 * r) .or. b /= 6 * r) STOP 2
+  if (any (a /= 4 * r) .or. b /= 6 * r) stop 2
   a(:) = 0
   b = 0
   r = 0
@@ -52,7 +52,7 @@
   b = b + 3
   r = r + 1
 !$omp end parallel
-  if (any (a /= 2 * r) .or. b /= 3 * r) STOP 3
+  if (any (a /= 2 * r) .or. b /= 3 * r) stop 3
 end
 elemental function fn1 (x, y)
   integer, intent(in) :: x, y
diff --git a/libgomp/testsuite/libgomp.fortran/udr13.f90 b/libgomp/testsuite/libgomp.fortran/udr13.f90
index 0ff53adf0ca..d29e498e6bb 100644
--- a/libgomp/testsuite/libgomp.fortran/udr13.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr13.f90
@@ -41,38 +41,38 @@
   a(:) = 0
   r = 0
 !$omp parallel reduction (bar : a) reduction (+: r)
-  if (lbound (a, 1) /= 1 .or. ubound (a, 1) /= 10) STOP 1
+  if (lbound (a, 1) /= 1 .or. ubound (a, 1) /= 10) stop 1
   a = a + 2
   r = r + 1
 !$omp end parallel
-  if (any (a /= 4 * r) ) STOP 2
+  if (any (a /= 4 * r) ) stop 2
   b(:,:) = 0
   allocate (c (4:6,8:10))
   c(:,:) = 0
   r = 0
 !$omp parallel reduction (baz : b, c) reduction (+: r)
-  if (lbound (b, 1) /= 3 .or. ubound (b, 1) /= 5) STOP 3
-  if (lbound (b, 2) /= 7 .or. ubound (b, 2) /= 9) STOP 4
-  if (.not. allocated (c)) STOP 5
-  if (lbound (c, 1) /= 4 .or. ubound (c, 1) /= 6) STOP 6
-  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 10) STOP 7
+  if (lbound (b, 1) /= 3 .or. ubound (b, 1) /= 5) stop 3
+  if (lbound (b, 2) /= 7 .or. ubound (b, 2) /= 9) stop 4
+  if (.not. allocated (c)) stop 5
+  if (lbound (c, 1) /= 4 .or. ubound (c, 1) /= 6) stop 6
+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 10) stop 7
   b = b + 3
   c = c + 4
   r = r + 1
 !$omp end parallel
-  if (any (b /= 3 * r) .or. any (c /= 4 * r)) STOP 8
+  if (any (b /= 3 * r) .or. any (c /= 4 * r)) stop 8
   deallocate (c)
   allocate (c (0:1,7:11))
   c(:,:) = 0
   r = 0
 !$omp parallel reduction (foo : c) reduction (+: r)
-  if (.not. allocated (c)) STOP 9
-  if (lbound (c, 1) /= 0 .or. ubound (c, 1) /= 1) STOP 10
-  if (lbound (c, 2) /= 7 .or. ubound (c, 2) /= 11) STOP 11
+  if (.not. allocated (c)) stop 9
+  if (lbound (c, 1) /= 0 .or. ubound (c, 1) /= 1) stop 10
+  if (lbound (c, 2) /= 7 .or. ubound (c, 2) /= 11) stop 11
   c = c + 5
   r = r + 1
 !$omp end parallel
-  if (any (c /= 10 * r)) STOP 12
+  if (any (c /= 10 * r)) stop 12
 end
 function fn1 (x, y, m1, m2)
   integer, intent(in) :: x(:), y(:), m1, m2
diff --git a/libgomp/testsuite/libgomp.fortran/udr14.f90 b/libgomp/testsuite/libgomp.fortran/udr14.f90
index cb54f4350b9..eed57e9afaf 100644
--- a/libgomp/testsuite/libgomp.fortran/udr14.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr14.f90
@@ -13,31 +13,31 @@
   a(7)%h = (/ 0, 0, 0 /)
   r = 0
 !$omp parallel reduction(+:r) reduction (baz:a)
-  if (.not.allocated (a)) STOP 1
-  if (lbound (a, 1) /= 7 .or. ubound (a, 1) /= 8) STOP 2
-  if (.not.allocated (a(7)%h)) STOP 3
-  if (allocated (a(8)%h)) STOP 4
-  if (lbound (a(7)%h, 1) /= 1 .or. ubound (a(7)%h, 1) /= 3) STOP 5
+  if (.not.allocated (a)) stop 1
+  if (lbound (a, 1) /= 7 .or. ubound (a, 1) /= 8) stop 2
+  if (.not.allocated (a(7)%h)) stop 3
+  if (allocated (a(8)%h)) stop 4
+  if (lbound (a(7)%h, 1) /= 1 .or. ubound (a(7)%h, 1) /= 3) stop 5
   a(:)%g = a(:)%g + 2
   a(7)%h = a(7)%h + 3
   r = r + 1
 !$omp end parallel
-  if (.not.allocated (a)) STOP 6
-  if (lbound (a, 1) /= 7 .or. ubound (a, 1) /= 8) STOP 7
-  if (.not.allocated (a(7)%h)) STOP 8
-  if (allocated (a(8)%h)) STOP 9
-  if (lbound (a(7)%h, 1) /= 1 .or. ubound (a(7)%h, 1) /= 3) STOP 10
-  if (any (a(:)%g /= 2 * r) .or. any (a(7)%h(:) /= 3 * r)) STOP 11
+  if (.not.allocated (a)) stop 6
+  if (lbound (a, 1) /= 7 .or. ubound (a, 1) /= 8) stop 7
+  if (.not.allocated (a(7)%h)) stop 8
+  if (allocated (a(8)%h)) stop 9
+  if (lbound (a(7)%h, 1) /= 1 .or. ubound (a(7)%h, 1) /= 3) stop 10
+  if (any (a(:)%g /= 2 * r) .or. any (a(7)%h(:) /= 3 * r)) stop 11
 contains
   subroutine foo (x, y)
     type (dt), allocatable :: x(:), y(:)
-    if (allocated (x) .neqv. allocated (y)) STOP 12
-    if (lbound (x, 1) /= lbound (y, 1)) STOP 13
-    if (ubound (x, 1) /= ubound (y, 1)) STOP 14
-    if (allocated (x(7)%h) .neqv. allocated (y(7)%h)) STOP 15
-    if (allocated (x(8)%h) .neqv. allocated (y(8)%h)) STOP 16
-    if (lbound (x(7)%h, 1) /= lbound (y(7)%h, 1)) STOP 17
-    if (ubound (x(7)%h, 1) /= ubound (y(7)%h, 1)) STOP 18
+    if (allocated (x) .neqv. allocated (y)) stop 12
+    if (lbound (x, 1) /= lbound (y, 1)) stop 13
+    if (ubound (x, 1) /= ubound (y, 1)) stop 14
+    if (allocated (x(7)%h) .neqv. allocated (y(7)%h)) stop 15
+    if (allocated (x(8)%h) .neqv. allocated (y(8)%h)) stop 16
+    if (lbound (x(7)%h, 1) /= lbound (y(7)%h, 1)) stop 17
+    if (ubound (x(7)%h, 1) /= ubound (y(7)%h, 1)) stop 18
     x(7)%g = 0
     x(7)%h = 0
     x(8)%g = 0
diff --git a/libgomp/testsuite/libgomp.fortran/udr15.f90 b/libgomp/testsuite/libgomp.fortran/udr15.f90
index ffdb9a783bc..f5f3139d084 100644
--- a/libgomp/testsuite/libgomp.fortran/udr15.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr15.f90
@@ -60,5 +60,5 @@ end module udr15m2
     j = j.addthree.iand (i, -4)
     d = d + dt(i)
   end do
-  if (d%x /= 5050 .or. j /= 4903) STOP 1
+  if (d%x /= 5050 .or. j /= 4903) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/udr2.f90 b/libgomp/testsuite/libgomp.fortran/udr2.f90
index 5b7d87b33eb..81fc6519257 100644
--- a/libgomp/testsuite/libgomp.fortran/udr2.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr2.f90
@@ -28,24 +28,24 @@ end module udr2
   do i = 1, 100
     j = j + i
   end do
-  if (any(j .ne. 5050)) STOP 1
+  if (any(j .ne. 5050)) stop 1
   j = 3
 !$omp parallel do reduction (bar : j)
   do i = 1, 100
     j = j + 4 * i
   end do
-  if (any(j .ne. (5050 * 4 + 3))) STOP 2
+  if (any(j .ne. (5050 * 4 + 3))) stop 2
 !$omp parallel do reduction (+ : d)
   do i = 1, 100
-    if (any(d%y .ne. 9)) STOP 3
+    if (any(d%y .ne. 9)) stop 3
     d%x = d%x + 8 * i
   end do
-  if (any(d%x .ne. (5050 * 8 + 7)) .or. any(d%y .ne. 9)) STOP 4
+  if (any(d%x .ne. (5050 * 8 + 7)) .or. any(d%y .ne. 9)) stop 4
   d = dt (5, 21)
 !$omp parallel do reduction (foo : d)
   do i = 1, 100
-    if (any(d%y .ne. 21)) STOP 5
+    if (any(d%y .ne. 21)) stop 5
     d%x = d%x + 8 * i
   end do
-  if (any(d%x .ne. (5050 * 8 + 5)) .or. any(d%y .ne. 21)) STOP 6
+  if (any(d%x .ne. (5050 * 8 + 5)) .or. any(d%y .ne. 21)) stop 6
 end
diff --git a/libgomp/testsuite/libgomp.fortran/udr3.f90 b/libgomp/testsuite/libgomp.fortran/udr3.f90
index 50cecec1f5a..a54f8ba2b2f 100644
--- a/libgomp/testsuite/libgomp.fortran/udr3.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr3.f90
@@ -29,10 +29,10 @@
 &	// char (ichar (f(2:2)) + mod (i, 3))
   end do
   do i = 1, 64
-    if (index (c, char (ichar ('0') + i)) .eq. 0) STOP 1
-    if (index (d, char (ichar ('0') + i)) .eq. 0) STOP 2
+    if (index (c, char (ichar ('0') + i)) .eq. 0) stop 1
+    if (index (d, char (ichar ('0') + i)) .eq. 0) stop 2
   end do
-  if (e.ne.char (ichar ('0') + 64)) STOP 3
-  if (f(1:1).ne.char (ichar ('0') + 32)) STOP 4
-  if (f(2:2).ne.char (ichar ('0') + 64)) STOP 5
+  if (e.ne.char (ichar ('0') + 64)) stop 3
+  if (f(1:1).ne.char (ichar ('0') + 32)) stop 4
+  if (f(2:2).ne.char (ichar ('0') + 64)) stop 5
 end
diff --git a/libgomp/testsuite/libgomp.fortran/udr4.f90 b/libgomp/testsuite/libgomp.fortran/udr4.f90
index 86d9515c70a..5d70b6b2830 100644
--- a/libgomp/testsuite/libgomp.fortran/udr4.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr4.f90
@@ -36,12 +36,12 @@
 &	// char (ichar (f(:,:)(2:2)) + mod (i, 3))
   end do
   do i = 1, 64
-    if (any (index (c, char (ichar ('0') + i)) .eq. 0)) STOP 1
-    if (any (index (d, char (ichar ('0') + i)) .eq. 0)) STOP 2
+    if (any (index (c, char (ichar ('0') + i)) .eq. 0)) stop 1
+    if (any (index (d, char (ichar ('0') + i)) .eq. 0)) stop 2
   end do
-  if (any (e.ne.char (ichar ('0') + 64))) STOP 3
-  if (any (f(:,:)(1:1).ne.char (ichar ('0') + 32))) STOP 4
-  if (any (f(:,:)(2:2).ne.char (ichar ('0') + 64))) STOP 5
+  if (any (e.ne.char (ichar ('0') + 64))) stop 3
+  if (any (f(:,:)(1:1).ne.char (ichar ('0') + 32))) stop 4
+  if (any (f(:,:)(2:2).ne.char (ichar ('0') + 64))) stop 5
 end
 elemental function fn (x, y)
   character (len=64), intent (in) :: x, y
diff --git a/libgomp/testsuite/libgomp.fortran/udr5.f90 b/libgomp/testsuite/libgomp.fortran/udr5.f90
index 8c6c525742a..725d0bfc905 100644
--- a/libgomp/testsuite/libgomp.fortran/udr5.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr5.f90
@@ -52,6 +52,6 @@ program udr5
   r4 = r4 + 1.0
   call dp_add (dp, 1.0d0)
 !$omp end parallel
-  if (xdt%r .ne. r) STOP 1
-  if (i4.ne.r.or.i8.ne.r.or.r4.ne.r.or.dp.ne.r) STOP 2
+  if (xdt%r .ne. r) stop 1
+  if (i4.ne.r.or.i8.ne.r.or.r4.ne.r.or.dp.ne.r) stop 2
 end program udr5
diff --git a/libgomp/testsuite/libgomp.fortran/udr6.f90 b/libgomp/testsuite/libgomp.fortran/udr6.f90
index 159f6a40ffb..7c7556b5f24 100644
--- a/libgomp/testsuite/libgomp.fortran/udr6.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr6.f90
@@ -62,8 +62,8 @@ program udr6
     call dp_add (dp(i), 1.0d0)
   end do
 !$omp end parallel
-  if (any (xdt%r .ne. r)) STOP 1
-  if (any (i4.ne.r).or.any(i8.ne.r)) STOP 2
-  if (any(r4.ne.r).or.any(dp.ne.r)) STOP 3
+  if (any (xdt%r .ne. r)) stop 1
+  if (any (i4.ne.r).or.any(i8.ne.r)) stop 2
+  if (any(r4.ne.r).or.any(dp.ne.r)) stop 3
   deallocate (xdt, i4, i8, r4, dp)
 end program udr6
diff --git a/libgomp/testsuite/libgomp.fortran/udr7.f90 b/libgomp/testsuite/libgomp.fortran/udr7.f90
index 92b24a196f4..9e60ac1eb0d 100644
--- a/libgomp/testsuite/libgomp.fortran/udr7.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr7.f90
@@ -22,7 +22,7 @@ program udr7
   do i = 1, 64
     x = x + i
   end do
-  if (any (x /= 2080.0)) STOP 1
+  if (any (x /= 2080.0)) stop 1
 contains
   elemental subroutine omp_out (x, y)
     real, intent (out) :: x
diff --git a/libgomp/testsuite/libgomp.fortran/udr8.f90 b/libgomp/testsuite/libgomp.fortran/udr8.f90
index 6b8eac22a7f..fb1fc2e9373 100644
--- a/libgomp/testsuite/libgomp.fortran/udr8.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr8.f90
@@ -42,5 +42,5 @@ end module udr8m2
     j = j.add.iand (i, -4)
     d = d + dt(i)
   end do
-  if (d%x /= 5050 .or. j /= 4903) STOP 1
+  if (d%x /= 5050 .or. j /= 4903) stop 1
 end
diff --git a/libgomp/testsuite/libgomp.fortran/udr9.f90 b/libgomp/testsuite/libgomp.fortran/udr9.f90
index a8ba78d924d..7b96f88fcbb 100644
--- a/libgomp/testsuite/libgomp.fortran/udr9.f90
+++ b/libgomp/testsuite/libgomp.fortran/udr9.f90
@@ -23,7 +23,7 @@ contains
   end subroutine
   subroutine initializer1 (x, y)
     integer :: x, y
-    if (y .ne. 3) STOP 1
+    if (y .ne. 3) stop 1
     x = y
   end subroutine
 end module udr9m1
@@ -61,5 +61,5 @@ end module udr9m2
     j = j.add.iand (i, -4)
     d = d + dt(i)
   end do
-  if (d%x /= 5050 .or. j /= 4903) STOP 2
+  if (d%x /= 5050 .or. j /= 4903) stop 2
 end
diff --git a/libgomp/testsuite/libgomp.fortran/use_device_addr-1.f90 b/libgomp/testsuite/libgomp.fortran/use_device_addr-1.f90
new file mode 100644
index 00000000000..0254f2dc196
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/use_device_addr-1.f90
@@ -0,0 +1,1269 @@
+! { dg-do run }
+! Comprehensive run-time test for use_device_addr
+!
+! Differs from use_device_addr-2.f90 by using a 8-byte variable (c_double)
+!
+! This test case assumes that a 'var' appearing in 'use_device_addr' is
+! only used as 'c_loc(var)' - such that only the actual data is used/usable
+! on the device - and not meta data ((dynamic) type information, 'present()'
+! status, array shape).
+!
+! Untested in this test case are:
+! - arrays with array descriptor
+! - polymorphic variables
+! - absent optional arguments
+!
+module target_procs
+  use iso_c_binding
+  implicit none (type, external)
+  private
+  public :: copy3_array, copy3_scalar
+contains
+  subroutine copy3_array_int(from_ptr, to_ptr, N)
+    !$omp declare target
+    real(c_double) :: from_ptr(:)
+    real(c_double) :: to_ptr(:)
+    integer, value :: N
+    integer :: i
+
+    !$omp parallel do
+    do i = 1, N
+      to_ptr(i) = 3 * from_ptr(i)
+    end do
+    !$omp end parallel do
+  end subroutine copy3_array_int
+
+  subroutine copy3_scalar_int(from, to)
+    !$omp declare target
+    real(c_double) :: from, to
+
+    to = 3 * from
+  end subroutine copy3_scalar_int
+
+
+  subroutine copy3_array(from, to, N)
+    type(c_ptr), value :: from, to
+    integer, value :: N
+    real(c_double), pointer :: from_ptr(:), to_ptr(:)
+
+    call c_f_pointer(from, from_ptr, shape=[N])
+    call c_f_pointer(to, to_ptr, shape=[N])
+
+    call do_offload_scalar(from_ptr,to_ptr)
+  contains
+    subroutine do_offload_scalar(from_r, to_r)
+      real(c_double), target :: from_r(:), to_r(:)
+      ! The extra function is needed as is_device_ptr
+      ! requires non-value, non-pointer dummy arguments
+
+      !$omp target is_device_ptr(from_r, to_r)
+      call copy3_array_int(from_r, to_r, N)
+      !$omp end target
+    end subroutine do_offload_scalar
+  end subroutine copy3_array
+
+  subroutine copy3_scalar(from, to)
+    type(c_ptr), value, target :: from, to
+    real(c_double), pointer :: from_ptr(:), to_ptr(:)
+
+    ! Standard-conform detour of using an array as at time of writing
+    ! is_device_ptr below does not handle scalars
+    call c_f_pointer(from, from_ptr, shape=[1])
+    call c_f_pointer(to, to_ptr, shape=[1])
+
+    call do_offload_scalar(from_ptr,to_ptr)
+  contains
+    subroutine do_offload_scalar(from_r, to_r)
+      real(c_double), target :: from_r(:), to_r(:)
+      ! The extra function is needed as is_device_ptr
+      ! requires non-value, non-pointer dummy arguments
+
+      !$omp target is_device_ptr(from_r, to_r)
+      call copy3_scalar_int(from_r(1), to_r(1))
+      !$omp end target
+    end subroutine do_offload_scalar
+  end subroutine copy3_scalar
+end module target_procs
+
+
+
+! Test local dummy arguments (w/o optional)
+module test_dummies
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_call_1, test_dummy_call_2
+contains
+  subroutine test_dummy_call_1()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_double), target :: aa, bb
+     real(c_double), target, allocatable :: cc, dd
+     real(c_double), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), target :: gg(N), hh(N)
+
+     allocate(cc, dd, ee, ff)
+
+     aa = 11.0_c_double
+     bb = 22.0_c_double
+     cc = 33.0_c_double
+     dd = 44.0_c_double
+     ee = 55.0_c_double
+     ff = 66.0_c_double
+     gg = 77.0_c_double
+     hh = 88.0_c_double
+
+     call test_dummy_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     deallocate(ee, ff) ! pointers, only
+  end subroutine test_dummy_call_1
+
+  subroutine test_dummy_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     ! scalars
+     real(c_double), target :: aa, bb
+     real(c_double), target, allocatable :: cc, dd
+     real(c_double), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), target :: gg(N), hh(N)
+     integer, value :: N
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 2
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     call copy3_scalar(c_loc(cc), c_loc(dd))
+     !$omp end target data
+     if (abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc)) stop 3
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 4
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     call copy3_scalar(c_loc(ee), c_loc(ff))
+     !$omp end target data
+     if (abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee)) stop 5
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 6
+
+
+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)
+     call copy3_array(c_loc(gg), c_loc(hh), N)
+     !$omp end target data
+     if (any(abs(gg - 77.0_c_double) > 10.0_c_double * epsilon(gg))) stop 7
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 8
+  end subroutine test_dummy_callee_1
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_call_2()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_double), target :: aa, bb
+     real(c_double), target, allocatable :: cc, dd
+     real(c_double), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), target :: gg(N), hh(N)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_double), pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_double), pointer :: gptr(:), hptr(:)
+
+     allocate(cc, dd, ee, ff)
+     call test_dummy_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &
+                               c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &
+                               aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &
+                               N)
+     deallocate(ee, ff)
+  end subroutine test_dummy_call_2
+
+  subroutine test_dummy_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &
+                                  c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &
+                                  aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &
+                                  N)
+     ! scalars
+     real(c_double), target :: aa, bb
+     real(c_double), target, allocatable :: cc, dd
+     real(c_double), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), target :: gg(N), hh(N)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_double), pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_double), pointer :: gptr(:), hptr(:)
+
+     integer, value :: N
+
+     real(c_double) :: dummy
+
+     aa = 111.0_c_double
+     bb = 222.0_c_double
+     cc = 333.0_c_double
+     dd = 444.0_c_double
+     ee = 555.0_c_double
+     ff = 666.0_c_double
+     gg = 777.0_c_double
+     hh = 888.0_c_double
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 9
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 10
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 11
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 12
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 13
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 14
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 15
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 16
+
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 17
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 18
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_double
+     !$omp target update to(cc)
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 19
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 20
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_double
+     !$omp target update to(cc)
+     call copy3_scalar(c_loc(cptr), c_loc(dptr))
+     !$omp target update from(dd)
+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 21
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 22
+     !$omp end target data
+
+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd)) stop 23
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd)) stop 24
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 25
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 26
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_double
+     !$omp target update to(ee)
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 27
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 28
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_double
+     !$omp target update to(ee)
+     call copy3_scalar(c_loc(eptr), c_loc(fptr))
+     !$omp target update from(ff)
+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 29
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff)) stop 30
+     !$omp end target data
+
+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 31
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 32
+
+
+     !$omp target data map(to:gg) map(from:hh)
+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)
+     c_gptr = c_loc(gg)
+     c_hptr = c_loc(hh)
+     gptr => gg
+     hptr => hh
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 33
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(hh))) stop 34
+
+     ! check c_loc ptr again after target-value modification
+     gg = 7777.0_c_double
+     !$omp target update to(gg)
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 7777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 35
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 36
+
+     ! check Fortran pointer after target-value modification
+     gg = 77777.0_c_double
+     !$omp target update to(gg)
+     call copy3_array(c_loc(gptr), c_loc(hptr), N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 37
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 38
+     !$omp end target data
+
+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 39
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 40
+  end subroutine test_dummy_callee_2
+end module test_dummies
+
+
+
+! Test local dummy arguments + VALUE (w/o optional)
+module test_dummies_value
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_val_call_1, test_dummy_val_call_2
+contains
+  subroutine test_dummy_val_call_1()
+     ! scalars - with value, neither allocatable nor pointer no dimension permitted
+     real(c_double), target :: aa, bb
+
+     aa = 11.0_c_double
+     bb = 22.0_c_double
+
+     call test_dummy_val_callee_1(aa, bb)
+  end subroutine test_dummy_val_call_1
+
+  subroutine test_dummy_val_callee_1(aa, bb)
+     ! scalars
+     real(c_double), value, target :: aa, bb
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 41
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 42
+  end subroutine test_dummy_val_callee_1
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_val_call_2()
+     ! scalars - with value, neither allocatable nor pointer no dimension permitted
+     real(c_double), target :: aa, bb
+     type(c_ptr) :: c_aptr, c_bptr
+     real(c_double), pointer :: aptr, bptr
+
+     call test_dummy_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)
+  end subroutine test_dummy_val_call_2
+
+  subroutine test_dummy_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)
+     real(c_double), value, target :: aa, bb
+     type(c_ptr), value :: c_aptr, c_bptr
+     real(c_double), pointer :: aptr, bptr
+
+     real(c_double) :: dummy
+
+     aa = 111.0_c_double
+     bb = 222.0_c_double
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 43
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 44
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 45
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 46
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 47
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 48
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 49
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 50
+  end subroutine test_dummy_val_callee_2
+end module test_dummies_value
+
+
+
+! Test local dummy arguments + OPTIONAL
+! Values present and ptr associated to nonzero
+module test_dummies_opt
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_opt_call_1, test_dummy_opt_call_2
+contains
+  subroutine test_dummy_opt_call_1()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_double), target :: aa, bb
+     real(c_double), target, allocatable :: cc, dd
+     real(c_double), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), target :: gg(N), hh(N)
+
+     allocate(cc, dd, ee, ff)
+
+     aa = 11.0_c_double
+     bb = 22.0_c_double
+     cc = 33.0_c_double
+     dd = 44.0_c_double
+     ee = 55.0_c_double
+     ff = 66.0_c_double
+     gg = 77.0_c_double
+     hh = 88.0_c_double
+
+     call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     call test_dummy_opt_callee_1_absent(N=N)
+     deallocate(ee, ff) ! pointers, only
+  end subroutine test_dummy_opt_call_1
+
+  subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     ! scalars
+     real(c_double), optional, target :: aa, bb
+     real(c_double), optional, target, allocatable :: cc, dd
+     real(c_double), optional, pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), optional, target :: gg(N), hh(N)
+     integer, value :: N
+
+     ! All shall be present - and pointing to non-NULL
+     if (.not.present(aa) .or. .not.present(bb)) stop 51
+     if (.not.present(cc) .or. .not.present(dd)) stop 52
+     if (.not.present(ee) .or. .not.present(ff)) stop 53
+     if (.not.present(gg) .or. .not.present(hh)) stop 54
+
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 55
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 56
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 57
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 58
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 59
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     if (.not.present(cc) .or. .not.present(dd)) stop 60
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 61
+     call copy3_scalar(c_loc(cc), c_loc(dd))
+     !$omp end target data
+     if (abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc)) stop 62
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 63
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 64
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 65
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 66
+     call copy3_scalar(c_loc(ee), c_loc(ff))
+     !$omp end target data
+     if (abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee)) stop 67
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 68
+
+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)
+     if (.not.present(gg) .or. .not.present(hh)) stop 69
+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 70
+     call copy3_array(c_loc(gg), c_loc(hh), N)
+     !$omp end target data
+     if (any(abs(gg - 77.0_c_double) > 10.0_c_double * epsilon(gg))) stop 71
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 72
+  end subroutine test_dummy_opt_callee_1
+
+  subroutine test_dummy_opt_callee_1_absent(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     ! scalars
+     real(c_double), optional, target :: aa, bb
+     real(c_double), optional, target, allocatable :: cc, dd
+     real(c_double), optional, pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), optional, target :: gg(N), hh(N)
+     integer, value :: N
+
+     integer :: err
+
+     ! All shall be absent
+     if (present(aa) .or. present(bb)) stop 243
+     if (present(cc) .or. present(dd)) stop 244
+     if (present(ee) .or. present(ff)) stop 245
+     if (present(gg) .or. present(hh)) stop 246
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (present(aa) .or. present(bb)) stop 247
+     !$omp end target data
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     if (present(cc) .or. present(dd)) stop 248
+     !$omp end target data
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (present(ee) .or. present(ff)) stop 249
+     !$omp end target data
+
+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)
+     if (present(gg) .or. present(hh)) stop 250
+     !$omp end target data
+  end subroutine test_dummy_opt_callee_1_absent
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_opt_call_2()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_double), target :: aa, bb
+     real(c_double), target, allocatable :: cc, dd
+     real(c_double), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), target :: gg(N), hh(N)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_double), pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_double), pointer :: gptr(:), hptr(:)
+
+     allocate(cc, dd, ee, ff)
+     call test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &
+                                   c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &
+                                   aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &
+                                   N)
+     deallocate(ee, ff)
+  end subroutine test_dummy_opt_call_2
+
+  subroutine test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &
+                                      c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &
+                                      aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &
+                                      N)
+     ! scalars
+     real(c_double), optional, target :: aa, bb
+     real(c_double), optional, target, allocatable :: cc, dd
+     real(c_double), optional, pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), optional, target :: gg(N), hh(N)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_double), optional, pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_double), optional, pointer :: gptr(:), hptr(:)
+
+     integer, value :: N
+
+     real(c_double) :: dummy
+
+     ! All shall be present - and pointing to non-NULL
+     if (.not.present(aa) .or. .not.present(bb)) stop 73
+     if (.not.present(cc) .or. .not.present(dd)) stop 74
+     if (.not.present(ee) .or. .not.present(ff)) stop 75
+     if (.not.present(gg) .or. .not.present(hh)) stop 76
+
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 77
+
+     aa = 111.0_c_double
+     bb = 222.0_c_double
+     cc = 333.0_c_double
+     dd = 444.0_c_double
+     ee = 555.0_c_double
+     ff = 666.0_c_double
+     gg = 777.0_c_double
+     hh = 888.0_c_double
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 78
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 79
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 80
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 81
+     !$omp end target data
+
+     if (.not.present(aa) .or. .not.present(bb)) stop 82
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 83
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 84
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 85
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 86
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 87
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 88
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 89
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 90
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 91
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 92
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 93
+
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     if (.not.present(cc) .or. .not.present(dd)) stop 94
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 95
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 96
+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 97
+     !$omp end target data
+     if (.not.present(cc) .or. .not.present(dd)) stop 98
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 99
+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 100
+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 101
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 102
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 103
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_double
+     !$omp target update to(cc)
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 104
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 105
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_double
+     !$omp target update to(cc)
+     call copy3_scalar(c_loc(cptr), c_loc(dptr))
+     !$omp target update from(dd)
+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 106
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 107
+     !$omp end target data
+
+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd)) stop 108
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd)) stop 109
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 110
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 111
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 112
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 113
+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 114
+     !$omp end target data
+     if (.not.present(ee) .or. .not.present(ff)) stop 115
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 116
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 117
+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 118
+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 119
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 120
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 121
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_double
+     !$omp target update to(ee)
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 122
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 123
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_double
+     !$omp target update to(ee)
+     call copy3_scalar(c_loc(eptr), c_loc(fptr))
+     !$omp target update from(ff)
+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 124
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff)) stop 125
+     !$omp end target data
+
+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 126
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 127
+
+
+     !$omp target data map(to:gg) map(from:hh)
+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)
+     if (.not.present(gg) .or. .not.present(hh)) stop 128
+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 129
+     c_gptr = c_loc(gg)
+     c_hptr = c_loc(hh)
+     gptr => gg
+     hptr => hh
+     if (.not.c_associated(c_gptr) .or. .not.c_associated(c_hptr)) stop 130
+     if (.not.associated(gptr) .or. .not.associated(hptr)) stop 131
+     !$omp end target data
+     if (.not.present(gg) .or. .not.present(hh)) stop 132
+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 133
+     if (.not.c_associated(c_gptr) .or. .not.c_associated(c_hptr)) stop 134
+     if (.not.associated(gptr) .or. .not.associated(hptr)) stop 135
+
+     ! check c_loc ptr once
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 136
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(hh))) stop 137
+
+     ! check c_loc ptr again after target-value modification
+     gg = 7777.0_c_double
+     !$omp target update to(gg)
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 7777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 138
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 139
+
+     ! check Fortran pointer after target-value modification
+     gg = 77777.0_c_double
+     !$omp target update to(gg)
+     call copy3_array(c_loc(gptr), c_loc(hptr), N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 140
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 141
+     !$omp end target data
+
+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 142
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 143
+  end subroutine test_dummy_opt_callee_2
+end module test_dummies_opt
+
+
+
+! Test local dummy arguments + OPTIONAL + VALUE
+! Values present
+module test_dummies_opt_value
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_opt_val_call_1, test_dummy_opt_val_call_2
+contains
+  subroutine test_dummy_opt_val_call_1()
+     ! scalars - with value, neither allocatable nor pointer no dimension permitted
+     real(c_double), target :: aa, bb
+
+     aa = 11.0_c_double
+     bb = 22.0_c_double
+
+     call test_dummy_opt_val_callee_1(aa, bb)
+  end subroutine test_dummy_opt_val_call_1
+
+  subroutine test_dummy_opt_val_callee_1(aa, bb)
+     ! scalars
+     real(c_double), optional, value, target :: aa, bb
+
+     if (.not.present(aa) .or. .not.present(bb)) stop 144
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 145
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 146
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 147
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 148
+  end subroutine test_dummy_opt_val_callee_1
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_opt_val_call_2()
+     ! scalars - with value, neither allocatable nor pointer no dimension permitted
+     real(c_double), target :: aa, bb
+     type(c_ptr) :: c_aptr, c_bptr
+     real(c_double), pointer :: aptr, bptr
+
+     call test_dummy_opt_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)
+  end subroutine test_dummy_opt_val_call_2
+
+  subroutine test_dummy_opt_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)
+     real(c_double), optional, value, target :: aa, bb
+     type(c_ptr), optional, value :: c_aptr, c_bptr
+     real(c_double), optional, pointer :: aptr, bptr
+
+     real(c_double) :: dummy
+
+     if (.not.present(aa) .or. .not.present(bb)) stop 149
+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 150
+     if (.not.present(aptr) .or. .not.present(bptr)) stop 151
+
+     aa = 111.0_c_double
+     bb = 222.0_c_double
+
+     !$omp target data map(to:aa) map(from:bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 152
+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 153
+     if (.not.present(aptr) .or. .not.present(bptr)) stop 154
+
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 155
+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 156
+     if (.not.present(aptr) .or. .not.present(bptr)) stop 157
+
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 158
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 159
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 160
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 161
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 162
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 163
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 164
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 165
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 166
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 167
+  end subroutine test_dummy_opt_val_callee_2
+end module test_dummies_opt_value
+
+
+
+! Test nullptr
+module test_nullptr
+  use iso_c_binding
+  implicit none (type, external)
+  private
+  public :: test_nullptr_1
+contains
+  subroutine test_nullptr_1()
+     ! scalars
+     real(c_double), pointer :: aa, bb
+     real(c_double), pointer :: ee, ff
+
+     real(c_double), allocatable, target :: gg, hh
+
+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_double), pointer :: aptr, bptr, eptr, fptr, gptr, hptr
+
+     aa => null()
+     bb => null()
+     ee => null()
+     ff => null()
+
+     if (associated(aa) .or. associated(bb)) stop 168
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (c_associated(c_loc(aa)) .or. c_associated(c_loc(bb))) stop 169
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 170
+     if (associated(aptr) .or. associated(bptr, bb)) stop 171
+     !$omp end target data
+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 172
+     if (associated(aptr) .or. associated(bptr, bb)) stop 173
+
+     if (allocated(gg)) stop 174
+     !$omp target data map(tofrom:gg) use_device_addr(gg)
+     if (c_associated(c_loc(gg))) stop 175
+     c_gptr = c_loc(gg)
+     gptr => gg
+     if (c_associated(c_gptr)) stop 176
+     if (associated(gptr)) stop 177
+     if (allocated(gg)) stop 178
+     !$omp end target data
+     if (c_associated(c_gptr)) stop 179
+     if (associated(gptr)) stop 180
+     if (allocated(gg)) stop 181
+
+     call test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)
+  end subroutine test_nullptr_1
+
+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)
+     ! scalars
+     real(c_double), optional, pointer :: ee, ff
+     real(c_double), optional, allocatable, target :: hh
+
+     type(c_ptr), optional :: c_eptr, c_fptr, c_hptr
+     real(c_double), optional, pointer :: eptr, fptr, hptr
+
+     if (.not.present(ee) .or. .not.present(ff)) stop 182
+     if (associated(ee) .or. associated(ff)) stop 183
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 184
+     if (associated(ee) .or. associated(ff)) stop 185
+     if (c_associated(c_loc(ee)) .or. c_associated(c_loc(ff))) stop 186
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 187
+     if (associated(eptr) .or. associated(fptr)) stop 188
+     !$omp end target data
+
+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 189
+     if (associated(eptr) .or. associated(fptr)) stop 190
+     if (associated(ee) .or. associated(ff)) stop 191
+
+
+     if (.not.present(hh)) stop 192
+     if (allocated(hh)) stop 193
+
+     !$omp target data map(tofrom:hh) use_device_addr(hh)
+     if (.not.present(hh)) stop 194
+     if (allocated(hh)) stop 195
+     if (c_associated(c_loc(hh))) stop 196
+     c_hptr = c_loc(hh)
+     hptr => hh
+     if (c_associated(c_hptr)) stop 197
+     if (associated(hptr)) stop 198
+     if (allocated(hh)) stop 199
+     !$omp end target data
+
+     if (c_associated(c_hptr)) stop 200
+     if (associated(hptr)) stop 201
+     if (allocated(hh)) stop 202
+  end subroutine test_dummy_opt_nullptr_callee_1
+end module test_nullptr
+
+
+
+! Test local variables
+module tests
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_main_1, test_main_2
+contains
+   ! map + use_device_addr + c_loc
+   subroutine test_main_1()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_double), target :: aa, bb
+     real(c_double), target, allocatable :: cc, dd
+     real(c_double), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), target :: gg(N), hh(N)
+
+     allocate(cc, dd, ee, ff)
+
+
+     aa = 11.0_c_double
+     bb = 22.0_c_double
+     cc = 33.0_c_double
+     dd = 44.0_c_double
+     ee = 55.0_c_double
+     ff = 66.0_c_double
+     gg = 77.0_c_double
+     hh = 88.0_c_double
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 203
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 204
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     call copy3_scalar(c_loc(cc), c_loc(dd))
+     !$omp end target data
+     if (abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc)) stop 205
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 206
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     call copy3_scalar(c_loc(ee), c_loc(ff))
+     !$omp end target data
+     if (abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee)) stop 207
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 208
+
+
+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)
+     call copy3_array(c_loc(gg), c_loc(hh), N)
+     !$omp end target data
+     if (any(abs(gg - 77.0_c_double) > 10.0_c_double * epsilon(gg))) stop 209
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 210
+
+     deallocate(ee, ff) ! pointers, only
+   end subroutine test_main_1
+
+   ! Save device ptr - and recall pointer
+   subroutine test_main_2
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_double), target :: aa, bb
+     real(c_double), target, allocatable :: cc, dd
+     real(c_double), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_double), target :: gg(N), hh(N)
+
+     real(c_double) :: dummy
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_double), pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_double), pointer :: gptr(:), hptr(:)
+
+     allocate(cc, dd, ee, ff)
+
+     aa = 111.0_c_double
+     bb = 222.0_c_double
+     cc = 333.0_c_double
+     dd = 444.0_c_double
+     ee = 555.0_c_double
+     ff = 666.0_c_double
+     gg = 777.0_c_double
+     hh = 888.0_c_double
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 211
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 212
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 213
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 214
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_double
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 215
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 216
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 217
+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 218
+
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 219
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 220
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_double
+     !$omp target update to(cc)
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 221
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 222
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_double
+     !$omp target update to(cc)
+     call copy3_scalar(c_loc(cptr), c_loc(dptr))
+     !$omp target update from(dd)
+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 223
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 224
+     !$omp end target data
+
+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd)) stop 225
+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd)) stop 226
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 227
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 228
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_double
+     !$omp target update to(ee)
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 229
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 230
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_double
+     !$omp target update to(ee)
+     call copy3_scalar(c_loc(eptr), c_loc(fptr))
+     !$omp target update from(ff)
+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 231
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff)) stop 232
+     !$omp end target data
+
+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 233
+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 234
+
+
+     !$omp target data map(to:gg) map(from:hh)
+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)
+     c_gptr = c_loc(gg)
+     c_hptr = c_loc(hh)
+     gptr => gg
+     hptr => hh
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 235
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(hh))) stop 236
+
+     ! check c_loc ptr again after target-value modification
+     gg = 7777.0_c_double
+     !$omp target update to(gg)
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 7777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 237
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 238
+
+     ! check Fortran pointer after target-value modification
+     gg = 77777.0_c_double
+     !$omp target update to(gg)
+     call copy3_array(c_loc(gptr), c_loc(hptr), N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 239
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 240
+     !$omp end target data
+
+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 241
+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 242
+
+     deallocate(ee, ff)
+   end subroutine test_main_2
+end module tests
+
+
+program omp_device_addr
+  use tests
+  use test_dummies
+  use test_dummies_value
+  use test_dummies_opt
+  use test_dummies_opt_value
+  use test_nullptr
+  implicit none (type, external)
+
+  call test_main_1()
+  call test_main_2()
+
+  call test_dummy_call_1()
+  call test_dummy_call_2()
+
+  call test_dummy_val_call_1()
+  call test_dummy_val_call_2()
+
+  call test_dummy_opt_call_1()
+  call test_dummy_opt_call_2()
+
+  call test_dummy_opt_val_call_1()
+  call test_dummy_opt_val_call_2()
+
+  call test_nullptr_1()
+end program omp_device_addr
diff --git a/libgomp/testsuite/libgomp.fortran/use_device_addr-2.f90 b/libgomp/testsuite/libgomp.fortran/use_device_addr-2.f90
new file mode 100644
index 00000000000..3dd1f90f04c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/use_device_addr-2.f90
@@ -0,0 +1,1269 @@
+! { dg-do run }
+! Comprehensive run-time test for use_device_addr
+!
+! Differs from use_device_addr-1.f90 by using a 4-byte variable (c_float)
+!
+! This test case assumes that a 'var' appearing in 'use_device_addr' is
+! only used as 'c_loc(var)' - such that only the actual data is used/usable
+! on the device - and not meta data ((dynamic) type information, 'present()'
+! status, array shape).
+!
+! Untested in this test case are:
+! - arrays with array descriptor
+! - polymorphic variables
+! - absent optional arguments
+!
+module target_procs
+  use iso_c_binding
+  implicit none (type, external)
+  private
+  public :: copy3_array, copy3_scalar
+contains
+  subroutine copy3_array_int(from_ptr, to_ptr, N)
+    !$omp declare target
+    real(c_float) :: from_ptr(:)
+    real(c_float) :: to_ptr(:)
+    integer, value :: N
+    integer :: i
+
+    !$omp parallel do
+    do i = 1, N
+      to_ptr(i) = 3 * from_ptr(i)
+    end do
+    !$omp end parallel do
+  end subroutine copy3_array_int
+
+  subroutine copy3_scalar_int(from, to)
+    !$omp declare target
+    real(c_float) :: from, to
+
+    to = 3 * from
+  end subroutine copy3_scalar_int
+
+
+  subroutine copy3_array(from, to, N)
+    type(c_ptr), value :: from, to
+    integer, value :: N
+    real(c_float), pointer :: from_ptr(:), to_ptr(:)
+
+    call c_f_pointer(from, from_ptr, shape=[N])
+    call c_f_pointer(to, to_ptr, shape=[N])
+
+    call do_offload_scalar(from_ptr,to_ptr)
+  contains
+    subroutine do_offload_scalar(from_r, to_r)
+      real(c_float), target :: from_r(:), to_r(:)
+      ! The extra function is needed as is_device_ptr
+      ! requires non-value, non-pointer dummy arguments
+
+      !$omp target is_device_ptr(from_r, to_r)
+      call copy3_array_int(from_r, to_r, N)
+      !$omp end target
+    end subroutine do_offload_scalar
+  end subroutine copy3_array
+
+  subroutine copy3_scalar(from, to)
+    type(c_ptr), value, target :: from, to
+    real(c_float), pointer :: from_ptr(:), to_ptr(:)
+
+    ! Standard-conform detour of using an array as at time of writing
+    ! is_device_ptr below does not handle scalars
+    call c_f_pointer(from, from_ptr, shape=[1])
+    call c_f_pointer(to, to_ptr, shape=[1])
+
+    call do_offload_scalar(from_ptr,to_ptr)
+  contains
+    subroutine do_offload_scalar(from_r, to_r)
+      real(c_float), target :: from_r(:), to_r(:)
+      ! The extra function is needed as is_device_ptr
+      ! requires non-value, non-pointer dummy arguments
+
+      !$omp target is_device_ptr(from_r, to_r)
+      call copy3_scalar_int(from_r(1), to_r(1))
+      !$omp end target
+    end subroutine do_offload_scalar
+  end subroutine copy3_scalar
+end module target_procs
+
+
+
+! Test local dummy arguments (w/o optional)
+module test_dummies
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_call_1, test_dummy_call_2
+contains
+  subroutine test_dummy_call_1()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_float), target :: aa, bb
+     real(c_float), target, allocatable :: cc, dd
+     real(c_float), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), target :: gg(N), hh(N)
+
+     allocate(cc, dd, ee, ff)
+
+     aa = 11.0_c_float
+     bb = 22.0_c_float
+     cc = 33.0_c_float
+     dd = 44.0_c_float
+     ee = 55.0_c_float
+     ff = 66.0_c_float
+     gg = 77.0_c_float
+     hh = 88.0_c_float
+
+     call test_dummy_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     deallocate(ee, ff) ! pointers, only
+  end subroutine test_dummy_call_1
+
+  subroutine test_dummy_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     ! scalars
+     real(c_float), target :: aa, bb
+     real(c_float), target, allocatable :: cc, dd
+     real(c_float), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), target :: gg(N), hh(N)
+     integer, value :: N
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 2
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     call copy3_scalar(c_loc(cc), c_loc(dd))
+     !$omp end target data
+     if (abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc)) stop 3
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 4
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     call copy3_scalar(c_loc(ee), c_loc(ff))
+     !$omp end target data
+     if (abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee)) stop 5
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 6
+
+
+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)
+     call copy3_array(c_loc(gg), c_loc(hh), N)
+     !$omp end target data
+     if (any(abs(gg - 77.0_c_float) > 10.0_c_float * epsilon(gg))) stop 7
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 8
+  end subroutine test_dummy_callee_1
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_call_2()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_float), target :: aa, bb
+     real(c_float), target, allocatable :: cc, dd
+     real(c_float), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), target :: gg(N), hh(N)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_float), pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_float), pointer :: gptr(:), hptr(:)
+
+     allocate(cc, dd, ee, ff)
+     call test_dummy_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &
+                               c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &
+                               aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &
+                               N)
+     deallocate(ee, ff)
+  end subroutine test_dummy_call_2
+
+  subroutine test_dummy_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &
+                                  c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &
+                                  aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &
+                                  N)
+     ! scalars
+     real(c_float), target :: aa, bb
+     real(c_float), target, allocatable :: cc, dd
+     real(c_float), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), target :: gg(N), hh(N)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_float), pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_float), pointer :: gptr(:), hptr(:)
+
+     integer, value :: N
+
+     real(c_float) :: dummy
+
+     aa = 111.0_c_float
+     bb = 222.0_c_float
+     cc = 333.0_c_float
+     dd = 444.0_c_float
+     ee = 555.0_c_float
+     ff = 666.0_c_float
+     gg = 777.0_c_float
+     hh = 888.0_c_float
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 9
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 10
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 11
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 12
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 13
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 14
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 15
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 16
+
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 17
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 18
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_float
+     !$omp target update to(cc)
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 19
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 20
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_float
+     !$omp target update to(cc)
+     call copy3_scalar(c_loc(cptr), c_loc(dptr))
+     !$omp target update from(dd)
+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 21
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 22
+     !$omp end target data
+
+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd)) stop 23
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd)) stop 24
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 25
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 26
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_float
+     !$omp target update to(ee)
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 27
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 28
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_float
+     !$omp target update to(ee)
+     call copy3_scalar(c_loc(eptr), c_loc(fptr))
+     !$omp target update from(ff)
+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 29
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff)) stop 30
+     !$omp end target data
+
+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 31
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 32
+
+
+     !$omp target data map(to:gg) map(from:hh)
+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)
+     c_gptr = c_loc(gg)
+     c_hptr = c_loc(hh)
+     gptr => gg
+     hptr => hh
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 33
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(hh))) stop 34
+
+     ! check c_loc ptr again after target-value modification
+     gg = 7777.0_c_float
+     !$omp target update to(gg)
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 7777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 35
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 36
+
+     ! check Fortran pointer after target-value modification
+     gg = 77777.0_c_float
+     !$omp target update to(gg)
+     call copy3_array(c_loc(gptr), c_loc(hptr), N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 37
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 38
+     !$omp end target data
+
+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 39
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 40
+  end subroutine test_dummy_callee_2
+end module test_dummies
+
+
+
+! Test local dummy arguments + VALUE (w/o optional)
+module test_dummies_value
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_val_call_1, test_dummy_val_call_2
+contains
+  subroutine test_dummy_val_call_1()
+     ! scalars - with value, neither allocatable nor pointer no dimension permitted
+     real(c_float), target :: aa, bb
+
+     aa = 11.0_c_float
+     bb = 22.0_c_float
+
+     call test_dummy_val_callee_1(aa, bb)
+  end subroutine test_dummy_val_call_1
+
+  subroutine test_dummy_val_callee_1(aa, bb)
+     ! scalars
+     real(c_float), value, target :: aa, bb
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 41
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 42
+  end subroutine test_dummy_val_callee_1
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_val_call_2()
+     ! scalars - with value, neither allocatable nor pointer no dimension permitted
+     real(c_float), target :: aa, bb
+     type(c_ptr) :: c_aptr, c_bptr
+     real(c_float), pointer :: aptr, bptr
+
+     call test_dummy_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)
+  end subroutine test_dummy_val_call_2
+
+  subroutine test_dummy_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)
+     real(c_float), value, target :: aa, bb
+     type(c_ptr), value :: c_aptr, c_bptr
+     real(c_float), pointer :: aptr, bptr
+
+     real(c_float) :: dummy
+
+     aa = 111.0_c_float
+     bb = 222.0_c_float
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 43
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 44
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 45
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 46
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 47
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 48
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 49
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 50
+  end subroutine test_dummy_val_callee_2
+end module test_dummies_value
+
+
+
+! Test local dummy arguments + OPTIONAL
+! Values present and ptr associated to nonzero
+module test_dummies_opt
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_opt_call_1, test_dummy_opt_call_2
+contains
+  subroutine test_dummy_opt_call_1()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_float), target :: aa, bb
+     real(c_float), target, allocatable :: cc, dd
+     real(c_float), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), target :: gg(N), hh(N)
+
+     allocate(cc, dd, ee, ff)
+
+     aa = 11.0_c_float
+     bb = 22.0_c_float
+     cc = 33.0_c_float
+     dd = 44.0_c_float
+     ee = 55.0_c_float
+     ff = 66.0_c_float
+     gg = 77.0_c_float
+     hh = 88.0_c_float
+
+     call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     call test_dummy_opt_callee_1_absent(N=N)
+     deallocate(ee, ff) ! pointers, only
+  end subroutine test_dummy_opt_call_1
+
+  subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     ! scalars
+     real(c_float), optional, target :: aa, bb
+     real(c_float), optional, target, allocatable :: cc, dd
+     real(c_float), optional, pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), optional, target :: gg(N), hh(N)
+     integer, value :: N
+
+     ! All shall be present - and pointing to non-NULL
+     if (.not.present(aa) .or. .not.present(bb)) stop 51
+     if (.not.present(cc) .or. .not.present(dd)) stop 52
+     if (.not.present(ee) .or. .not.present(ff)) stop 53
+     if (.not.present(gg) .or. .not.present(hh)) stop 54
+
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 55
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 56
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 57
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 58
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 59
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     if (.not.present(cc) .or. .not.present(dd)) stop 60
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 61
+     call copy3_scalar(c_loc(cc), c_loc(dd))
+     !$omp end target data
+     if (abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc)) stop 62
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 63
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 64
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 65
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 66
+     call copy3_scalar(c_loc(ee), c_loc(ff))
+     !$omp end target data
+     if (abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee)) stop 67
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 68
+
+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)
+     if (.not.present(gg) .or. .not.present(hh)) stop 69
+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 70
+     call copy3_array(c_loc(gg), c_loc(hh), N)
+     !$omp end target data
+     if (any(abs(gg - 77.0_c_float) > 10.0_c_float * epsilon(gg))) stop 71
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 72
+  end subroutine test_dummy_opt_callee_1
+
+  subroutine test_dummy_opt_callee_1_absent(aa, bb, cc, dd, ee, ff, gg, hh, N)
+     ! scalars
+     real(c_float), optional, target :: aa, bb
+     real(c_float), optional, target, allocatable :: cc, dd
+     real(c_float), optional, pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), optional, target :: gg(N), hh(N)
+     integer, value :: N
+
+     integer :: err
+
+     ! All shall be absent
+     if (present(aa) .or. present(bb)) stop 243
+     if (present(cc) .or. present(dd)) stop 244
+     if (present(ee) .or. present(ff)) stop 245
+     if (present(gg) .or. present(hh)) stop 246
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (present(aa) .or. present(bb)) stop 247
+     !$omp end target data
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     if (present(cc) .or. present(dd)) stop 248
+     !$omp end target data
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (present(ee) .or. present(ff)) stop 249
+     !$omp end target data
+
+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)
+     if (present(gg) .or. present(hh)) stop 250
+     !$omp end target data
+  end subroutine test_dummy_opt_callee_1_absent
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_opt_call_2()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_float), target :: aa, bb
+     real(c_float), target, allocatable :: cc, dd
+     real(c_float), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), target :: gg(N), hh(N)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_float), pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_float), pointer :: gptr(:), hptr(:)
+
+     allocate(cc, dd, ee, ff)
+     call test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &
+                                   c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &
+                                   aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &
+                                   N)
+     deallocate(ee, ff)
+  end subroutine test_dummy_opt_call_2
+
+  subroutine test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &
+                                      c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &
+                                      aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &
+                                      N)
+     ! scalars
+     real(c_float), optional, target :: aa, bb
+     real(c_float), optional, target, allocatable :: cc, dd
+     real(c_float), optional, pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), optional, target :: gg(N), hh(N)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_float), optional, pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_float), optional, pointer :: gptr(:), hptr(:)
+
+     integer, value :: N
+
+     real(c_float) :: dummy
+
+     ! All shall be present - and pointing to non-NULL
+     if (.not.present(aa) .or. .not.present(bb)) stop 73
+     if (.not.present(cc) .or. .not.present(dd)) stop 74
+     if (.not.present(ee) .or. .not.present(ff)) stop 75
+     if (.not.present(gg) .or. .not.present(hh)) stop 76
+
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 77
+
+     aa = 111.0_c_float
+     bb = 222.0_c_float
+     cc = 333.0_c_float
+     dd = 444.0_c_float
+     ee = 555.0_c_float
+     ff = 666.0_c_float
+     gg = 777.0_c_float
+     hh = 888.0_c_float
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 78
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 79
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 80
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 81
+     !$omp end target data
+
+     if (.not.present(aa) .or. .not.present(bb)) stop 82
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 83
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 84
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 85
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 86
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 87
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 88
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 89
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 90
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 91
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 92
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 93
+
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     if (.not.present(cc) .or. .not.present(dd)) stop 94
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 95
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 96
+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 97
+     !$omp end target data
+     if (.not.present(cc) .or. .not.present(dd)) stop 98
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 99
+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 100
+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 101
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 102
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 103
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_float
+     !$omp target update to(cc)
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 104
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 105
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_float
+     !$omp target update to(cc)
+     call copy3_scalar(c_loc(cptr), c_loc(dptr))
+     !$omp target update from(dd)
+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 106
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 107
+     !$omp end target data
+
+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd)) stop 108
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd)) stop 109
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 110
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 111
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 112
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 113
+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 114
+     !$omp end target data
+     if (.not.present(ee) .or. .not.present(ff)) stop 115
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 116
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 117
+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 118
+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 119
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 120
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 121
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_float
+     !$omp target update to(ee)
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 122
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 123
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_float
+     !$omp target update to(ee)
+     call copy3_scalar(c_loc(eptr), c_loc(fptr))
+     !$omp target update from(ff)
+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 124
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff)) stop 125
+     !$omp end target data
+
+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 126
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 127
+
+
+     !$omp target data map(to:gg) map(from:hh)
+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)
+     if (.not.present(gg) .or. .not.present(hh)) stop 128
+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 129
+     c_gptr = c_loc(gg)
+     c_hptr = c_loc(hh)
+     gptr => gg
+     hptr => hh
+     if (.not.c_associated(c_gptr) .or. .not.c_associated(c_hptr)) stop 130
+     if (.not.associated(gptr) .or. .not.associated(hptr)) stop 131
+     !$omp end target data
+     if (.not.present(gg) .or. .not.present(hh)) stop 132
+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 133
+     if (.not.c_associated(c_gptr) .or. .not.c_associated(c_hptr)) stop 134
+     if (.not.associated(gptr) .or. .not.associated(hptr)) stop 135
+
+     ! check c_loc ptr once
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 136
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(hh))) stop 137
+
+     ! check c_loc ptr again after target-value modification
+     gg = 7777.0_c_float
+     !$omp target update to(gg)
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 7777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 138
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 139
+
+     ! check Fortran pointer after target-value modification
+     gg = 77777.0_c_float
+     !$omp target update to(gg)
+     call copy3_array(c_loc(gptr), c_loc(hptr), N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 140
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 141
+     !$omp end target data
+
+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 142
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 143
+  end subroutine test_dummy_opt_callee_2
+end module test_dummies_opt
+
+
+
+! Test local dummy arguments + OPTIONAL + VALUE
+! Values present
+module test_dummies_opt_value
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_opt_val_call_1, test_dummy_opt_val_call_2
+contains
+  subroutine test_dummy_opt_val_call_1()
+     ! scalars - with value, neither allocatable nor pointer no dimension permitted
+     real(c_float), target :: aa, bb
+
+     aa = 11.0_c_float
+     bb = 22.0_c_float
+
+     call test_dummy_opt_val_callee_1(aa, bb)
+  end subroutine test_dummy_opt_val_call_1
+
+  subroutine test_dummy_opt_val_callee_1(aa, bb)
+     ! scalars
+     real(c_float), optional, value, target :: aa, bb
+
+     if (.not.present(aa) .or. .not.present(bb)) stop 144
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 145
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 146
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 147
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 148
+  end subroutine test_dummy_opt_val_callee_1
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_opt_val_call_2()
+     ! scalars - with value, neither allocatable nor pointer no dimension permitted
+     real(c_float), target :: aa, bb
+     type(c_ptr) :: c_aptr, c_bptr
+     real(c_float), pointer :: aptr, bptr
+
+     call test_dummy_opt_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)
+  end subroutine test_dummy_opt_val_call_2
+
+  subroutine test_dummy_opt_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)
+     real(c_float), optional, value, target :: aa, bb
+     type(c_ptr), optional, value :: c_aptr, c_bptr
+     real(c_float), optional, pointer :: aptr, bptr
+
+     real(c_float) :: dummy
+
+     if (.not.present(aa) .or. .not.present(bb)) stop 149
+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 150
+     if (.not.present(aptr) .or. .not.present(bptr)) stop 151
+
+     aa = 111.0_c_float
+     bb = 222.0_c_float
+
+     !$omp target data map(to:aa) map(from:bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 152
+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 153
+     if (.not.present(aptr) .or. .not.present(bptr)) stop 154
+
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 155
+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 156
+     if (.not.present(aptr) .or. .not.present(bptr)) stop 157
+
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 158
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 159
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 160
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 161
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 162
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 163
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 164
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 165
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 166
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 167
+  end subroutine test_dummy_opt_val_callee_2
+end module test_dummies_opt_value
+
+
+
+! Test nullptr
+module test_nullptr
+  use iso_c_binding
+  implicit none (type, external)
+  private
+  public :: test_nullptr_1
+contains
+  subroutine test_nullptr_1()
+     ! scalars
+     real(c_float), pointer :: aa, bb
+     real(c_float), pointer :: ee, ff
+
+     real(c_float), allocatable, target :: gg, hh
+
+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_float), pointer :: aptr, bptr, eptr, fptr, gptr, hptr
+
+     aa => null()
+     bb => null()
+     ee => null()
+     ff => null()
+
+     if (associated(aa) .or. associated(bb)) stop 168
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (c_associated(c_loc(aa)) .or. c_associated(c_loc(bb))) stop 169
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 170
+     if (associated(aptr) .or. associated(bptr, bb)) stop 171
+     !$omp end target data
+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 172
+     if (associated(aptr) .or. associated(bptr, bb)) stop 173
+
+     if (allocated(gg)) stop 174
+     !$omp target data map(tofrom:gg) use_device_addr(gg)
+     if (c_associated(c_loc(gg))) stop 175
+     c_gptr = c_loc(gg)
+     gptr => gg
+     if (c_associated(c_gptr)) stop 176
+     if (associated(gptr)) stop 177
+     if (allocated(gg)) stop 178
+     !$omp end target data
+     if (c_associated(c_gptr)) stop 179
+     if (associated(gptr)) stop 180
+     if (allocated(gg)) stop 181
+
+     call test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)
+  end subroutine test_nullptr_1
+
+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)
+     ! scalars
+     real(c_float), optional, pointer :: ee, ff
+     real(c_float), optional, allocatable, target :: hh
+
+     type(c_ptr), optional :: c_eptr, c_fptr, c_hptr
+     real(c_float), optional, pointer :: eptr, fptr, hptr
+
+     if (.not.present(ee) .or. .not.present(ff)) stop 182
+     if (associated(ee) .or. associated(ff)) stop 183
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 184
+     if (associated(ee) .or. associated(ff)) stop 185
+     if (c_associated(c_loc(ee)) .or. c_associated(c_loc(ff))) stop 186
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 187
+     if (associated(eptr) .or. associated(fptr)) stop 188
+     !$omp end target data
+
+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 189
+     if (associated(eptr) .or. associated(fptr)) stop 190
+     if (associated(ee) .or. associated(ff)) stop 191
+
+
+     if (.not.present(hh)) stop 192
+     if (allocated(hh)) stop 193
+
+     !$omp target data map(tofrom:hh) use_device_addr(hh)
+     if (.not.present(hh)) stop 194
+     if (allocated(hh)) stop 195
+     if (c_associated(c_loc(hh))) stop 196
+     c_hptr = c_loc(hh)
+     hptr => hh
+     if (c_associated(c_hptr)) stop 197
+     if (associated(hptr)) stop 198
+     if (allocated(hh)) stop 199
+     !$omp end target data
+
+     if (c_associated(c_hptr)) stop 200
+     if (associated(hptr)) stop 201
+     if (allocated(hh)) stop 202
+  end subroutine test_dummy_opt_nullptr_callee_1
+end module test_nullptr
+
+
+
+! Test local variables
+module tests
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_main_1, test_main_2
+contains
+   ! map + use_device_addr + c_loc
+   subroutine test_main_1()
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_float), target :: aa, bb
+     real(c_float), target, allocatable :: cc, dd
+     real(c_float), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), target :: gg(N), hh(N)
+
+     allocate(cc, dd, ee, ff)
+
+
+     aa = 11.0_c_float
+     bb = 22.0_c_float
+     cc = 33.0_c_float
+     dd = 44.0_c_float
+     ee = 55.0_c_float
+     ff = 66.0_c_float
+     gg = 77.0_c_float
+     hh = 88.0_c_float
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     call copy3_scalar(c_loc(aa), c_loc(bb))
+     !$omp end target data
+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 203
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 204
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     call copy3_scalar(c_loc(cc), c_loc(dd))
+     !$omp end target data
+     if (abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc)) stop 205
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 206
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     call copy3_scalar(c_loc(ee), c_loc(ff))
+     !$omp end target data
+     if (abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee)) stop 207
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 208
+
+
+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)
+     call copy3_array(c_loc(gg), c_loc(hh), N)
+     !$omp end target data
+     if (any(abs(gg - 77.0_c_float) > 10.0_c_float * epsilon(gg))) stop 209
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 210
+
+     deallocate(ee, ff) ! pointers, only
+   end subroutine test_main_1
+
+   ! Save device ptr - and recall pointer
+   subroutine test_main_2
+     integer, parameter :: N = 1000
+
+     ! scalars
+     real(c_float), target :: aa, bb
+     real(c_float), target, allocatable :: cc, dd
+     real(c_float), pointer :: ee, ff
+
+     ! non-descriptor arrays
+     real(c_float), target :: gg(N), hh(N)
+
+     real(c_float) :: dummy
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_float), pointer :: aptr, bptr, cptr, dptr, eptr, fptr
+     real(c_float), pointer :: gptr(:), hptr(:)
+
+     allocate(cc, dd, ee, ff)
+
+     aa = 111.0_c_float
+     bb = 222.0_c_float
+     cc = 333.0_c_float
+     dd = 444.0_c_float
+     ee = 555.0_c_float
+     ff = 666.0_c_float
+     gg = 777.0_c_float
+     hh = 888.0_c_float
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 211
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 212
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_aptr, c_bptr)
+     !$omp target update from(bb)
+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 213
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 214
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_float
+     !$omp target update to(aa)
+     call copy3_scalar(c_loc(aptr), c_loc(bptr))
+     !$omp target update from(bb)
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 215
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 216
+     !$omp end target data
+
+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 217
+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 218
+
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 219
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 220
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_float
+     !$omp target update to(cc)
+     call copy3_scalar(c_cptr, c_dptr)
+     !$omp target update from(dd)
+     if (abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 221
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 222
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_float
+     !$omp target update to(cc)
+     call copy3_scalar(c_loc(cptr), c_loc(dptr))
+     !$omp target update from(dd)
+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 223
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 224
+     !$omp end target data
+
+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd)) stop 225
+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd)) stop 226
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 227
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 228
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_float
+     !$omp target update to(ee)
+     call copy3_scalar(c_eptr, c_fptr)
+     !$omp target update from(ff)
+     if (abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 229
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 230
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_float
+     !$omp target update to(ee)
+     call copy3_scalar(c_loc(eptr), c_loc(fptr))
+     !$omp target update from(ff)
+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 231
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff)) stop 232
+     !$omp end target data
+
+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 233
+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 234
+
+
+     !$omp target data map(to:gg) map(from:hh)
+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)
+     c_gptr = c_loc(gg)
+     c_hptr = c_loc(hh)
+     gptr => gg
+     hptr => hh
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 235
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(hh))) stop 236
+
+     ! check c_loc ptr again after target-value modification
+     gg = 7777.0_c_float
+     !$omp target update to(gg)
+     call copy3_array(c_gptr, c_hptr, N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 7777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 237
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 238
+
+     ! check Fortran pointer after target-value modification
+     gg = 77777.0_c_float
+     !$omp target update to(gg)
+     call copy3_array(c_loc(gptr), c_loc(hptr), N)
+     !$omp target update from(hh)
+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 239
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 240
+     !$omp end target data
+
+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 241
+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 242
+
+     deallocate(ee, ff)
+   end subroutine test_main_2
+end module tests
+
+
+program omp_device_addr
+  use tests
+  use test_dummies
+  use test_dummies_value
+  use test_dummies_opt
+  use test_dummies_opt_value
+  use test_nullptr
+  implicit none (type, external)
+
+  call test_main_1()
+  call test_main_2()
+
+  call test_dummy_call_1()
+  call test_dummy_call_2()
+
+  call test_dummy_val_call_1()
+  call test_dummy_val_call_2()
+
+  call test_dummy_opt_call_1()
+  call test_dummy_opt_call_2()
+
+  call test_dummy_opt_val_call_1()
+  call test_dummy_opt_val_call_2()
+
+  call test_nullptr_1()
+end program omp_device_addr
diff --git a/libgomp/testsuite/libgomp.fortran/use_device_addr-3.f90 b/libgomp/testsuite/libgomp.fortran/use_device_addr-3.f90
new file mode 100644
index 00000000000..a917d289fe8
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/use_device_addr-3.f90
@@ -0,0 +1,792 @@
+! { dg-do run }
+
+! Comprehensive run-time test for use_device_addr
+!
+! Tests array with array descriptor
+!
+! Differs from use_device_addr-4.f90 by using a 8-byte variable (c_double)
+!
+! This test case assumes that a 'var' appearing in 'use_device_addr' is
+! only used as 'c_loc(var)' - such that only the actual data is used/usable
+! on the device - and not meta data ((dynamic) type information, 'present()'
+! status, array shape).
+!
+! Untested in this test case are:
+! - scalars
+! - polymorphic variables
+! - absent optional arguments
+!
+module target_procs
+  use iso_c_binding
+  implicit none (type, external)
+  private
+  public :: copy3_array
+contains
+  subroutine copy3_array_int(from_ptr, to_ptr, N)
+    !$omp declare target
+    real(c_double) :: from_ptr(:)
+    real(c_double) :: to_ptr(:)
+    integer, value :: N
+    integer :: i
+
+    !$omp parallel do
+    do i = 1, N
+      to_ptr(i) = 3 * from_ptr(i)
+    end do
+    !$omp end parallel do
+  end subroutine copy3_array_int
+
+  subroutine copy3_array(from, to, N)
+    type(c_ptr), value :: from, to
+    integer, value :: N
+    real(c_double), pointer :: from_ptr(:), to_ptr(:)
+
+    call c_f_pointer(from, from_ptr, shape=[N])
+    call c_f_pointer(to, to_ptr, shape=[N])
+
+    call do_offload_scalar(from_ptr,to_ptr)
+  contains
+    subroutine do_offload_scalar(from_r, to_r)
+      real(c_double), target :: from_r(:), to_r(:)
+      ! The extra function is needed as is_device_ptr
+      ! requires non-value, non-pointer dummy arguments
+
+      !$omp target is_device_ptr(from_r, to_r)
+      call copy3_array_int(from_r, to_r, N)
+      !$omp end target
+    end subroutine do_offload_scalar
+  end subroutine copy3_array
+end module target_procs
+
+
+
+! Test local dummy arguments (w/o optional)
+module test_dummies
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_call_1, test_dummy_call_2
+contains
+  subroutine test_dummy_call_1()
+     integer, parameter :: N = 1000
+
+     real(c_double), target :: aa(N), bb(N)
+     real(c_double), target, allocatable :: cc(:), dd(:)
+     real(c_double), pointer :: ee(:), ff(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     aa = 11.0_c_double
+     bb = 22.0_c_double
+     cc = 33.0_c_double
+     dd = 44.0_c_double
+     ee = 55.0_c_double
+     ff = 66.0_c_double
+
+     call test_dummy_callee_1(aa, bb, cc, dd, ee, ff, N)
+     deallocate(ee, ff) ! pointers, only
+  end subroutine test_dummy_call_1
+
+  subroutine test_dummy_callee_1(aa, bb, cc, dd, ee, ff, N)
+     real(c_double), target :: aa(:), bb(:)
+     real(c_double), target, allocatable :: cc(:), dd(:)
+     real(c_double), pointer :: ee(:), ff(:)
+
+     integer, value :: N
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     call copy3_array(c_loc(aa), c_loc(bb), N)
+     !$omp end target data
+     if (any(abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa))) stop 2
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 3
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     call copy3_array(c_loc(cc), c_loc(dd), N)
+     !$omp end target data
+     if (any(abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc))) stop 4
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 5
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     call copy3_array(c_loc(ee), c_loc(ff), N)
+     !$omp end target data
+     if (any(abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee))) stop 6
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 7
+  end subroutine test_dummy_callee_1
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_call_2()
+     integer, parameter :: N = 1000
+
+     real(c_double), target :: aa(N), bb(N)
+     real(c_double), target, allocatable :: cc(:), dd(:)
+     real(c_double), pointer :: ee(:), ff(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_double), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     call test_dummy_callee_2(aa, bb, cc, dd, ee, ff, &
+                               c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &
+                               aptr, bptr, cptr, dptr, eptr, fptr, &
+                               N)
+     deallocate(ee, ff)
+  end subroutine test_dummy_call_2
+
+  subroutine test_dummy_callee_2(aa, bb, cc, dd, ee, ff, &
+                                  c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &
+                                  aptr, bptr, cptr, dptr, eptr, fptr, &
+                                  N)
+     real(c_double), target :: aa(:), bb(:)
+     real(c_double), target, allocatable :: cc(:), dd(:)
+     real(c_double), pointer :: ee(:), ff(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_double), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)
+
+     integer, value :: N
+
+     real(c_double) :: dummy
+
+     aa = 111.0_c_double
+     bb = 222.0_c_double
+     cc = 333.0_c_double
+     dd = 444.0_c_double
+     ee = 555.0_c_double
+     ff = 666.0_c_double
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_aptr, c_bptr, N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 8
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 9
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_double
+     !$omp target update to(aa)
+     call copy3_array(c_aptr, c_bptr, N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 10
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 11
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_double
+     !$omp target update to(aa)
+     call copy3_array(c_loc(aptr), c_loc(bptr), N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 12
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 13
+     !$omp end target data
+
+     if (any(abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 14
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 15
+
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 16
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 17
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_double
+     !$omp target update to(cc)
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 18
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 19
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_double
+     !$omp target update to(cc)
+     call copy3_array(c_loc(cptr), c_loc(dptr), N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 20
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 21
+     !$omp end target data
+
+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd))) stop 22
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd))) stop 23
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 24
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 25
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_double
+     !$omp target update to(ee)
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 26
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 27
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_double
+     !$omp target update to(ee)
+     call copy3_array(c_loc(eptr), c_loc(fptr), N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 28
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff))) stop 29
+     !$omp end target data
+
+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 30
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 31
+  end subroutine test_dummy_callee_2
+end module test_dummies
+
+
+
+! Test local dummy arguments + OPTIONAL
+! Values present and ptr associated to nonzero
+module test_dummies_opt
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_opt_call_1, test_dummy_opt_call_2
+contains
+  subroutine test_dummy_opt_call_1()
+     integer, parameter :: N = 1000
+
+     real(c_double), target :: aa(N), bb(N)
+     real(c_double), target, allocatable :: cc(:), dd(:)
+     real(c_double), pointer :: ee(:), ff(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     aa = 11.0_c_double
+     bb = 22.0_c_double
+     cc = 33.0_c_double
+     dd = 44.0_c_double
+     ee = 55.0_c_double
+     ff = 66.0_c_double
+
+     call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)
+     call test_dummy_opt_callee_1_absent(N=N)
+     deallocate(ee, ff) ! pointers, only
+  end subroutine test_dummy_opt_call_1
+
+  subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)
+     ! scalars
+     real(c_double), optional, target :: aa(:), bb(:)
+     real(c_double), optional, target, allocatable :: cc(:), dd(:)
+     real(c_double), optional, pointer :: ee(:), ff(:)
+
+     integer, value :: N
+
+     ! All shall be present - and pointing to non-NULL
+     if (.not.present(aa) .or. .not.present(bb)) stop 32
+     if (.not.present(cc) .or. .not.present(dd)) stop 33
+     if (.not.present(ee) .or. .not.present(ff)) stop 34
+
+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 35
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 36
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 37
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 38
+     call copy3_array(c_loc(aa), c_loc(bb), N)
+     !$omp end target data
+     if (any(abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa))) stop 39
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 40
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     if (.not.present(cc) .or. .not.present(dd)) stop 41
+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 42
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 43
+     call copy3_array(c_loc(cc), c_loc(dd), N)
+     !$omp end target data
+     if (any(abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc))) stop 44
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 45
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 46
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 47
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 48
+     call copy3_array(c_loc(ee), c_loc(ff), N)
+     !$omp end target data
+     if (any(abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee))) stop 49
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 50
+  end subroutine test_dummy_opt_callee_1
+
+  subroutine test_dummy_opt_callee_1_absent(aa, bb, cc, dd, ee, ff, N)
+     ! scalars
+     real(c_double), optional, target :: aa(:), bb(:)
+     real(c_double), optional, target, allocatable :: cc(:), dd(:)
+     real(c_double), optional, pointer :: ee(:), ff(:)
+
+     integer, value :: N
+
+     ! All shall be absent
+     if (present(aa) .or. present(bb)) stop 51
+     if (present(cc) .or. present(dd)) stop 52
+     if (present(ee) .or. present(ff)) stop 53
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (present(aa) .or. present(bb)) stop 54
+     !$omp end target data
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     if (present(cc) .or. present(dd)) stop 55
+     !$omp end target data
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (present(ee) .or. present(ff)) stop 56
+     !$omp end target data
+  end subroutine test_dummy_opt_callee_1_absent
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_opt_call_2()
+     integer, parameter :: N = 1000
+
+     real(c_double), target :: aa(N), bb(N)
+     real(c_double), target, allocatable :: cc(:), dd(:)
+     real(c_double), pointer :: ee(:), ff(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_double), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+     call test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, &
+                                   c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &
+                                   aptr, bptr, cptr, dptr, eptr, fptr, &
+                                   N)
+     deallocate(ee, ff)
+  end subroutine test_dummy_opt_call_2
+
+  subroutine test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, &
+                                      c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &
+                                      aptr, bptr, cptr, dptr, eptr, fptr,  &
+                                      N)
+     ! scalars
+     real(c_double), optional, target :: aa(:), bb(:)
+     real(c_double), optional, target, allocatable :: cc(:), dd(:)
+     real(c_double), optional, pointer :: ee(:), ff(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_double), optional, pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)
+
+     integer, value :: N
+
+     real(c_double) :: dummy
+
+     ! All shall be present - and pointing to non-NULL
+     if (.not.present(aa) .or. .not.present(bb)) stop 57
+     if (.not.present(cc) .or. .not.present(dd)) stop 58
+     if (.not.present(ee) .or. .not.present(ff)) stop 59
+
+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 60
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 61
+
+     aa = 111.0_c_double
+     bb = 222.0_c_double
+     cc = 333.0_c_double
+     dd = 444.0_c_double
+     ee = 555.0_c_double
+     ff = 666.0_c_double
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 62
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 63
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 64
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 65
+     !$omp end target data
+
+     if (.not.present(aa) .or. .not.present(bb)) stop 66
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 67
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 68
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 69
+
+     ! check c_loc ptr once
+     call copy3_array(c_aptr, c_bptr, N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 70
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 71
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_double
+     !$omp target update to(aa)
+     call copy3_array(c_aptr, c_bptr, N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 72
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 73
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_double
+     !$omp target update to(aa)
+     call copy3_array(c_loc(aptr), c_loc(bptr), N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 74
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 75
+     !$omp end target data
+
+     if (any(abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 76
+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 77
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     if (.not.present(cc) .or. .not.present(dd)) stop 78
+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 79
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 80
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 81
+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 82
+     !$omp end target data
+     if (.not.present(cc) .or. .not.present(dd)) stop 83
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 84
+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 85
+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 86
+
+     ! check c_loc ptr once
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 87
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 88
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_double
+     !$omp target update to(cc)
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 89
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 90
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_double
+     !$omp target update to(cc)
+     call copy3_array(c_loc(cptr), c_loc(dptr), N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 91
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 92
+     !$omp end target data
+
+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd))) stop 93
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd))) stop 94
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 95
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 96
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 97
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 98
+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 99
+     !$omp end target data
+     if (.not.present(ee) .or. .not.present(ff)) stop 100
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 101
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 102
+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 103
+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 104
+
+     ! check c_loc ptr once
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 105
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 106
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_double
+     !$omp target update to(ee)
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 107
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 108
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_double
+     !$omp target update to(ee)
+     call copy3_array(c_loc(eptr), c_loc(fptr), N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 109
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff))) stop 110
+     !$omp end target data
+
+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 111
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 112
+  end subroutine test_dummy_opt_callee_2
+end module test_dummies_opt
+
+
+
+! Test nullptr
+module test_nullptr
+  use iso_c_binding
+  implicit none (type, external)
+  private
+  public :: test_nullptr_1
+contains
+  subroutine test_nullptr_1()
+     real(c_double), pointer :: aa(:), bb(:)
+     real(c_double), pointer :: ee(:), ff(:)
+
+     real(c_double), allocatable, target :: gg(:), hh(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_double), pointer :: aptr(:), bptr(:), eptr(:), fptr(:), gptr(:), hptr(:)
+
+     aa => null()
+     bb => null()
+     ee => null()
+     ff => null()
+
+     if (associated(aa) .or. associated(bb)) stop 113
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (c_associated(c_loc(aa)) .or. c_associated(c_loc(bb))) stop 114
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 115
+     if (associated(aptr) .or. associated(bptr, bb)) stop 116
+     if (associated(aa) .or. associated(bb)) stop 117
+     !$omp end target data
+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 118
+     if (associated(aptr) .or. associated(bptr, bb)) stop 119
+     if (associated(aa) .or. associated(bb)) stop 120
+
+     if (allocated(gg)) stop 121
+     !$omp target data map(tofrom:gg) use_device_addr(gg)
+     if (c_associated(c_loc(gg))) stop 122
+     c_gptr = c_loc(gg)
+     gptr => gg
+     if (c_associated(c_gptr)) stop 123
+     if (associated(gptr)) stop 124
+     if (allocated(gg)) stop 125
+     !$omp end target data
+     if (c_associated(c_gptr)) stop 126
+     if (associated(gptr)) stop 127
+     if (allocated(gg)) stop 128
+
+     call test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)
+  end subroutine test_nullptr_1
+
+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)
+     ! scalars
+     real(c_double), optional, pointer :: ee(:), ff(:)
+     real(c_double), optional, allocatable, target :: hh(:)
+
+     type(c_ptr), optional :: c_eptr, c_fptr, c_hptr
+     real(c_double), optional, pointer :: eptr(:), fptr(:), hptr(:)
+
+     if (.not.present(ee) .or. .not.present(ff)) stop 129
+     if (associated(ee) .or. associated(ff)) stop 130
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 131
+     if (associated(ee) .or. associated(ff)) stop 132
+     if (c_associated(c_loc(ee)) .or. c_associated(c_loc(ff))) stop 133
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 134
+     if (associated(eptr) .or. associated(fptr)) stop 135
+     !$omp end target data
+
+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 136
+     if (associated(eptr) .or. associated(fptr)) stop 137
+
+     if (allocated(hh)) stop 138
+     !$omp target data map(tofrom:hh) use_device_addr(hh)
+     if (c_associated(c_loc(hh))) stop 139
+     c_hptr = c_loc(hh)
+     hptr => hh
+     if (c_associated(c_hptr)) stop 140
+     if (associated(hptr)) stop 141
+     if (allocated(hh)) stop 142
+     !$omp end target data
+     if (c_associated(c_hptr)) stop 143
+     if (associated(hptr)) stop 144
+     if (allocated(hh)) stop 145
+  end subroutine test_dummy_opt_nullptr_callee_1
+end module test_nullptr
+
+
+
+! Test local variables
+module tests
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_main_1, test_main_2
+contains
+   ! map + use_device_addr + c_loc
+   subroutine test_main_1()
+     integer, parameter :: N = 1000
+
+     real(c_double), target, allocatable :: cc(:), dd(:)
+     real(c_double), pointer :: ee(:), ff(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     cc = 33.0_c_double
+     dd = 44.0_c_double
+     ee = 55.0_c_double
+     ff = 66.0_c_double
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     call copy3_array(c_loc(cc), c_loc(dd), N)
+     !$omp end target data
+     if (any(abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc))) stop 146
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 147
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     call copy3_array(c_loc(ee), c_loc(ff), N)
+     !$omp end target data
+     if (any(abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee))) stop 148
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 149
+
+     deallocate(ee, ff) ! pointers, only
+   end subroutine test_main_1
+
+   ! Save device ptr - and recall pointer
+   subroutine test_main_2
+     integer, parameter :: N = 1000
+
+     real(c_double), target, allocatable :: cc(:), dd(:)
+     real(c_double), pointer :: ee(:), ff(:)
+
+     real(c_double) :: dummy
+     type(c_ptr) :: c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_double), pointer :: cptr(:), dptr(:), eptr(:), fptr(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     cc = 333.0_c_double
+     dd = 444.0_c_double
+     ee = 555.0_c_double
+     ff = 666.0_c_double
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 150
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 151
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_double
+     !$omp target update to(cc)
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 152
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 153
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_double
+     !$omp target update to(cc)
+     call copy3_array(c_loc(cptr), c_loc(dptr), N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 154
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 155
+     !$omp end target data
+
+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd))) stop 156
+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd))) stop 157
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 158
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 159
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_double
+     !$omp target update to(ee)
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 160
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 161
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_double
+     !$omp target update to(ee)
+     call copy3_array(c_loc(eptr), c_loc(fptr), N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 162
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff))) stop 163
+     !$omp end target data
+
+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 164
+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 165
+
+     deallocate(ee, ff)
+   end subroutine test_main_2
+end module tests
+
+
+program omp_device_addr
+  use tests
+  use test_dummies
+  use test_dummies_opt
+  use test_nullptr
+  implicit none (type, external)
+
+  call test_main_1()
+  call test_main_2()
+
+  call test_dummy_call_1()
+  call test_dummy_call_2()
+
+  call test_dummy_opt_call_1()
+  call test_dummy_opt_call_2()
+
+  call test_nullptr_1()
+end program omp_device_addr
diff --git a/libgomp/testsuite/libgomp.fortran/use_device_addr-4.f90 b/libgomp/testsuite/libgomp.fortran/use_device_addr-4.f90
new file mode 100644
index 00000000000..e7b6c624f4e
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/use_device_addr-4.f90
@@ -0,0 +1,792 @@
+! { dg-do run }
+
+! Comprehensive run-time test for use_device_addr
+!
+! Tests array with array descriptor
+!
+! Differs from use_device_addr-3.f90 by using a 4-byte variable (c_float)
+!
+! This test case assumes that a 'var' appearing in 'use_device_addr' is
+! only used as 'c_loc(var)' - such that only the actual data is used/usable
+! on the device - and not meta data ((dynamic) type information, 'present()'
+! status, array shape).
+!
+! Untested in this test case are:
+! - scalars
+! - polymorphic variables
+! - absent optional arguments
+!
+module target_procs
+  use iso_c_binding
+  implicit none (type, external)
+  private
+  public :: copy3_array
+contains
+  subroutine copy3_array_int(from_ptr, to_ptr, N)
+    !$omp declare target
+    real(c_float) :: from_ptr(:)
+    real(c_float) :: to_ptr(:)
+    integer, value :: N
+    integer :: i
+
+    !$omp parallel do
+    do i = 1, N
+      to_ptr(i) = 3 * from_ptr(i)
+    end do
+    !$omp end parallel do
+  end subroutine copy3_array_int
+
+  subroutine copy3_array(from, to, N)
+    type(c_ptr), value :: from, to
+    integer, value :: N
+    real(c_float), pointer :: from_ptr(:), to_ptr(:)
+
+    call c_f_pointer(from, from_ptr, shape=[N])
+    call c_f_pointer(to, to_ptr, shape=[N])
+
+    call do_offload_scalar(from_ptr,to_ptr)
+  contains
+    subroutine do_offload_scalar(from_r, to_r)
+      real(c_float), target :: from_r(:), to_r(:)
+      ! The extra function is needed as is_device_ptr
+      ! requires non-value, non-pointer dummy arguments
+
+      !$omp target is_device_ptr(from_r, to_r)
+      call copy3_array_int(from_r, to_r, N)
+      !$omp end target
+    end subroutine do_offload_scalar
+  end subroutine copy3_array
+end module target_procs
+
+
+
+! Test local dummy arguments (w/o optional)
+module test_dummies
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_call_1, test_dummy_call_2
+contains
+  subroutine test_dummy_call_1()
+     integer, parameter :: N = 1000
+
+     real(c_float), target :: aa(N), bb(N)
+     real(c_float), target, allocatable :: cc(:), dd(:)
+     real(c_float), pointer :: ee(:), ff(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     aa = 11.0_c_float
+     bb = 22.0_c_float
+     cc = 33.0_c_float
+     dd = 44.0_c_float
+     ee = 55.0_c_float
+     ff = 66.0_c_float
+
+     call test_dummy_callee_1(aa, bb, cc, dd, ee, ff, N)
+     deallocate(ee, ff) ! pointers, only
+  end subroutine test_dummy_call_1
+
+  subroutine test_dummy_callee_1(aa, bb, cc, dd, ee, ff, N)
+     real(c_float), target :: aa(:), bb(:)
+     real(c_float), target, allocatable :: cc(:), dd(:)
+     real(c_float), pointer :: ee(:), ff(:)
+
+     integer, value :: N
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     call copy3_array(c_loc(aa), c_loc(bb), N)
+     !$omp end target data
+     if (any(abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa))) stop 2
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 3
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     call copy3_array(c_loc(cc), c_loc(dd), N)
+     !$omp end target data
+     if (any(abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc))) stop 4
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 5
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     call copy3_array(c_loc(ee), c_loc(ff), N)
+     !$omp end target data
+     if (any(abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee))) stop 6
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 7
+  end subroutine test_dummy_callee_1
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_call_2()
+     integer, parameter :: N = 1000
+
+     real(c_float), target :: aa(N), bb(N)
+     real(c_float), target, allocatable :: cc(:), dd(:)
+     real(c_float), pointer :: ee(:), ff(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_float), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     call test_dummy_callee_2(aa, bb, cc, dd, ee, ff, &
+                               c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &
+                               aptr, bptr, cptr, dptr, eptr, fptr, &
+                               N)
+     deallocate(ee, ff)
+  end subroutine test_dummy_call_2
+
+  subroutine test_dummy_callee_2(aa, bb, cc, dd, ee, ff, &
+                                  c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &
+                                  aptr, bptr, cptr, dptr, eptr, fptr, &
+                                  N)
+     real(c_float), target :: aa(:), bb(:)
+     real(c_float), target, allocatable :: cc(:), dd(:)
+     real(c_float), pointer :: ee(:), ff(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_float), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)
+
+     integer, value :: N
+
+     real(c_float) :: dummy
+
+     aa = 111.0_c_float
+     bb = 222.0_c_float
+     cc = 333.0_c_float
+     dd = 444.0_c_float
+     ee = 555.0_c_float
+     ff = 666.0_c_float
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_aptr, c_bptr, N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 8
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 9
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_float
+     !$omp target update to(aa)
+     call copy3_array(c_aptr, c_bptr, N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 10
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 11
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_float
+     !$omp target update to(aa)
+     call copy3_array(c_loc(aptr), c_loc(bptr), N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 12
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 13
+     !$omp end target data
+
+     if (any(abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 14
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 15
+
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 16
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 17
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_float
+     !$omp target update to(cc)
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 18
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 19
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_float
+     !$omp target update to(cc)
+     call copy3_array(c_loc(cptr), c_loc(dptr), N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 20
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 21
+     !$omp end target data
+
+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd))) stop 22
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd))) stop 23
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 24
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 25
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_float
+     !$omp target update to(ee)
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 26
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 27
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_float
+     !$omp target update to(ee)
+     call copy3_array(c_loc(eptr), c_loc(fptr), N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 28
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff))) stop 29
+     !$omp end target data
+
+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 30
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 31
+  end subroutine test_dummy_callee_2
+end module test_dummies
+
+
+
+! Test local dummy arguments + OPTIONAL
+! Values present and ptr associated to nonzero
+module test_dummies_opt
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_dummy_opt_call_1, test_dummy_opt_call_2
+contains
+  subroutine test_dummy_opt_call_1()
+     integer, parameter :: N = 1000
+
+     real(c_float), target :: aa(N), bb(N)
+     real(c_float), target, allocatable :: cc(:), dd(:)
+     real(c_float), pointer :: ee(:), ff(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     aa = 11.0_c_float
+     bb = 22.0_c_float
+     cc = 33.0_c_float
+     dd = 44.0_c_float
+     ee = 55.0_c_float
+     ff = 66.0_c_float
+
+     call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)
+     call test_dummy_opt_callee_1_absent(N=N)
+     deallocate(ee, ff) ! pointers, only
+  end subroutine test_dummy_opt_call_1
+
+  subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)
+     ! scalars
+     real(c_float), optional, target :: aa(:), bb(:)
+     real(c_float), optional, target, allocatable :: cc(:), dd(:)
+     real(c_float), optional, pointer :: ee(:), ff(:)
+
+     integer, value :: N
+
+     ! All shall be present - and pointing to non-NULL
+     if (.not.present(aa) .or. .not.present(bb)) stop 32
+     if (.not.present(cc) .or. .not.present(dd)) stop 33
+     if (.not.present(ee) .or. .not.present(ff)) stop 34
+
+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 35
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 36
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 37
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 38
+     call copy3_array(c_loc(aa), c_loc(bb), N)
+     !$omp end target data
+     if (any(abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa))) stop 39
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 40
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     if (.not.present(cc) .or. .not.present(dd)) stop 41
+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 42
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 43
+     call copy3_array(c_loc(cc), c_loc(dd), N)
+     !$omp end target data
+     if (any(abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc))) stop 44
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 45
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 46
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 47
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 48
+     call copy3_array(c_loc(ee), c_loc(ff), N)
+     !$omp end target data
+     if (any(abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee))) stop 49
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 50
+  end subroutine test_dummy_opt_callee_1
+
+  subroutine test_dummy_opt_callee_1_absent(aa, bb, cc, dd, ee, ff, N)
+     ! scalars
+     real(c_float), optional, target :: aa(:), bb(:)
+     real(c_float), optional, target, allocatable :: cc(:), dd(:)
+     real(c_float), optional, pointer :: ee(:), ff(:)
+
+     integer, value :: N
+
+     ! All shall be absent
+     if (present(aa) .or. present(bb)) stop 51
+     if (present(cc) .or. present(dd)) stop 52
+     if (present(ee) .or. present(ff)) stop 53
+
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (present(aa) .or. present(bb)) stop 54
+     !$omp end target data
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     if (present(cc) .or. present(dd)) stop 55
+     !$omp end target data
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (present(ee) .or. present(ff)) stop 56
+     !$omp end target data
+  end subroutine test_dummy_opt_callee_1_absent
+
+  ! Save device ptr - and recall pointer
+  subroutine test_dummy_opt_call_2()
+     integer, parameter :: N = 1000
+
+     real(c_float), target :: aa(N), bb(N)
+     real(c_float), target, allocatable :: cc(:), dd(:)
+     real(c_float), pointer :: ee(:), ff(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_float), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+     call test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, &
+                                   c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &
+                                   aptr, bptr, cptr, dptr, eptr, fptr, &
+                                   N)
+     deallocate(ee, ff)
+  end subroutine test_dummy_opt_call_2
+
+  subroutine test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, &
+                                      c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &
+                                      aptr, bptr, cptr, dptr, eptr, fptr,  &
+                                      N)
+     ! scalars
+     real(c_float), optional, target :: aa(:), bb(:)
+     real(c_float), optional, target, allocatable :: cc(:), dd(:)
+     real(c_float), optional, pointer :: ee(:), ff(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_float), optional, pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)
+
+     integer, value :: N
+
+     real(c_float) :: dummy
+
+     ! All shall be present - and pointing to non-NULL
+     if (.not.present(aa) .or. .not.present(bb)) stop 57
+     if (.not.present(cc) .or. .not.present(dd)) stop 58
+     if (.not.present(ee) .or. .not.present(ff)) stop 59
+
+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 60
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 61
+
+     aa = 111.0_c_float
+     bb = 222.0_c_float
+     cc = 333.0_c_float
+     dd = 444.0_c_float
+     ee = 555.0_c_float
+     ff = 666.0_c_float
+
+     !$omp target data map(to:aa) map(from:bb)
+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)
+     if (.not.present(aa) .or. .not.present(bb)) stop 62
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 63
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 64
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 65
+     !$omp end target data
+
+     if (.not.present(aa) .or. .not.present(bb)) stop 66
+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 67
+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 68
+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 69
+
+     ! check c_loc ptr once
+     call copy3_array(c_aptr, c_bptr, N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 70
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 71
+
+     ! check c_loc ptr again after target-value modification
+     aa = 1111.0_c_float
+     !$omp target update to(aa)
+     call copy3_array(c_aptr, c_bptr, N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 72
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 73
+
+     ! check Fortran pointer after target-value modification
+     aa = 11111.0_c_float
+     !$omp target update to(aa)
+     call copy3_array(c_loc(aptr), c_loc(bptr), N)
+     !$omp target update from(bb)
+     if (any(abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 74
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 75
+     !$omp end target data
+
+     if (any(abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 76
+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 77
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     if (.not.present(cc) .or. .not.present(dd)) stop 78
+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 79
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 80
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 81
+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 82
+     !$omp end target data
+     if (.not.present(cc) .or. .not.present(dd)) stop 83
+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 84
+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 85
+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 86
+
+     ! check c_loc ptr once
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 87
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 88
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_float
+     !$omp target update to(cc)
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 89
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 90
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_float
+     !$omp target update to(cc)
+     call copy3_array(c_loc(cptr), c_loc(dptr), N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 91
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 92
+     !$omp end target data
+
+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd))) stop 93
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd))) stop 94
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 95
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 96
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 97
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 98
+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 99
+     !$omp end target data
+     if (.not.present(ee) .or. .not.present(ff)) stop 100
+     if (.not.associated(ee) .or. .not.associated(ff)) stop 101
+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 102
+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 103
+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 104
+
+     ! check c_loc ptr once
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 105
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 106
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_float
+     !$omp target update to(ee)
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 107
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 108
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_float
+     !$omp target update to(ee)
+     call copy3_array(c_loc(eptr), c_loc(fptr), N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 109
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff))) stop 110
+     !$omp end target data
+
+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 111
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 112
+  end subroutine test_dummy_opt_callee_2
+end module test_dummies_opt
+
+
+
+! Test nullptr
+module test_nullptr
+  use iso_c_binding
+  implicit none (type, external)
+  private
+  public :: test_nullptr_1
+contains
+  subroutine test_nullptr_1()
+     real(c_float), pointer :: aa(:), bb(:)
+     real(c_float), pointer :: ee(:), ff(:)
+
+     real(c_float), allocatable, target :: gg(:), hh(:)
+
+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr, c_gptr, c_hptr
+     real(c_float), pointer :: aptr(:), bptr(:), eptr(:), fptr(:), gptr(:), hptr(:)
+
+     aa => null()
+     bb => null()
+     ee => null()
+     ff => null()
+
+     if (associated(aa) .or. associated(bb)) stop 113
+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)
+     if (c_associated(c_loc(aa)) .or. c_associated(c_loc(bb))) stop 114
+     c_aptr = c_loc(aa)
+     c_bptr = c_loc(bb)
+     aptr => aa
+     bptr => bb
+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 115
+     if (associated(aptr) .or. associated(bptr, bb)) stop 116
+     if (associated(aa) .or. associated(bb)) stop 117
+     !$omp end target data
+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 118
+     if (associated(aptr) .or. associated(bptr, bb)) stop 119
+     if (associated(aa) .or. associated(bb)) stop 120
+
+     if (allocated(gg)) stop 121
+     !$omp target data map(tofrom:gg) use_device_addr(gg)
+     if (c_associated(c_loc(gg))) stop 122
+     c_gptr = c_loc(gg)
+     gptr => gg
+     if (c_associated(c_gptr)) stop 123
+     if (associated(gptr)) stop 124
+     if (allocated(gg)) stop 125
+     !$omp end target data
+     if (c_associated(c_gptr)) stop 126
+     if (associated(gptr)) stop 127
+     if (allocated(gg)) stop 128
+
+     call test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)
+  end subroutine test_nullptr_1
+
+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)
+     ! scalars
+     real(c_float), optional, pointer :: ee(:), ff(:)
+     real(c_float), optional, allocatable, target :: hh(:)
+
+     type(c_ptr), optional :: c_eptr, c_fptr, c_hptr
+     real(c_float), optional, pointer :: eptr(:), fptr(:), hptr(:)
+
+     if (.not.present(ee) .or. .not.present(ff)) stop 129
+     if (associated(ee) .or. associated(ff)) stop 130
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     if (.not.present(ee) .or. .not.present(ff)) stop 131
+     if (associated(ee) .or. associated(ff)) stop 132
+     if (c_associated(c_loc(ee)) .or. c_associated(c_loc(ff))) stop 133
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 134
+     if (associated(eptr) .or. associated(fptr)) stop 135
+     !$omp end target data
+
+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 136
+     if (associated(eptr) .or. associated(fptr)) stop 137
+
+     if (allocated(hh)) stop 138
+     !$omp target data map(tofrom:hh) use_device_addr(hh)
+     if (c_associated(c_loc(hh))) stop 139
+     c_hptr = c_loc(hh)
+     hptr => hh
+     if (c_associated(c_hptr)) stop 140
+     if (associated(hptr)) stop 141
+     if (allocated(hh)) stop 142
+     !$omp end target data
+     if (c_associated(c_hptr)) stop 143
+     if (associated(hptr)) stop 144
+     if (allocated(hh)) stop 145
+  end subroutine test_dummy_opt_nullptr_callee_1
+end module test_nullptr
+
+
+
+! Test local variables
+module tests
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+  private
+  public :: test_main_1, test_main_2
+contains
+   ! map + use_device_addr + c_loc
+   subroutine test_main_1()
+     integer, parameter :: N = 1000
+
+     real(c_float), target, allocatable :: cc(:), dd(:)
+     real(c_float), pointer :: ee(:), ff(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     cc = 33.0_c_float
+     dd = 44.0_c_float
+     ee = 55.0_c_float
+     ff = 66.0_c_float
+
+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)
+     call copy3_array(c_loc(cc), c_loc(dd), N)
+     !$omp end target data
+     if (any(abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc))) stop 146
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 147
+
+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)
+     call copy3_array(c_loc(ee), c_loc(ff), N)
+     !$omp end target data
+     if (any(abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee))) stop 148
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 149
+
+     deallocate(ee, ff) ! pointers, only
+   end subroutine test_main_1
+
+   ! Save device ptr - and recall pointer
+   subroutine test_main_2
+     integer, parameter :: N = 1000
+
+     real(c_float), target, allocatable :: cc(:), dd(:)
+     real(c_float), pointer :: ee(:), ff(:)
+
+     real(c_float) :: dummy
+     type(c_ptr) :: c_cptr, c_dptr, c_eptr, c_fptr
+     real(c_float), pointer :: cptr(:), dptr(:), eptr(:), fptr(:)
+
+     allocate(cc(N), dd(N), ee(N), ff(N))
+
+     cc = 333.0_c_float
+     dd = 444.0_c_float
+     ee = 555.0_c_float
+     ff = 666.0_c_float
+
+     !$omp target data map(to:cc) map(from:dd)
+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)
+     c_cptr = c_loc(cc)
+     c_dptr = c_loc(dd)
+     cptr => cc
+     dptr => dd
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 150
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 151
+
+     ! check c_loc ptr again after target-value modification
+     cc = 3333.0_c_float
+     !$omp target update to(cc)
+     call copy3_array(c_cptr, c_dptr, N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 152
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 153
+
+     ! check Fortran pointer after target-value modification
+     cc = 33333.0_c_float
+     !$omp target update to(cc)
+     call copy3_array(c_loc(cptr), c_loc(dptr), N)
+     !$omp target update from(dd)
+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 154
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 155
+     !$omp end target data
+
+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd))) stop 156
+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd))) stop 157
+
+
+     !$omp target data map(to:ee) map(from:ff)
+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)
+     c_eptr = c_loc(ee)
+     c_fptr = c_loc(ff)
+     eptr => ee
+     fptr => ff
+     !$omp end target data
+
+     ! check c_loc ptr once
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 158
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 159
+
+     ! check c_loc ptr again after target-value modification
+     ee = 5555.0_c_float
+     !$omp target update to(ee)
+     call copy3_array(c_eptr, c_fptr, N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 160
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 161
+
+     ! check Fortran pointer after target-value modification
+     ee = 55555.0_c_float
+     !$omp target update to(ee)
+     call copy3_array(c_loc(eptr), c_loc(fptr), N)
+     !$omp target update from(ff)
+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 162
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff))) stop 163
+     !$omp end target data
+
+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 164
+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 165
+
+     deallocate(ee, ff)
+   end subroutine test_main_2
+end module tests
+
+
+program omp_device_addr
+  use tests
+  use test_dummies
+  use test_dummies_opt
+  use test_nullptr
+  implicit none (type, external)
+
+  call test_main_1()
+  call test_main_2()
+
+  call test_dummy_call_1()
+  call test_dummy_call_2()
+
+  call test_dummy_opt_call_1()
+  call test_dummy_opt_call_2()
+
+  call test_nullptr_1()
+end program omp_device_addr
diff --git a/libgomp/testsuite/libgomp.fortran/use_device_ptr-1.f90 b/libgomp/testsuite/libgomp.fortran/use_device_ptr-1.f90
new file mode 100644
index 00000000000..e5390e27a51
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/use_device_ptr-1.f90
@@ -0,0 +1,597 @@
+! { dg-do run }
+
+module target_procs
+  use iso_c_binding
+  implicit none (type, external)
+  private
+  public :: copy3_array, copy3_scalar, copy3_array1, copy3_array3
+contains
+  subroutine copy3_array_int(from_ptr, to_ptr, N)
+    !$omp declare target
+    real(c_double) :: from_ptr(:)
+    real(c_double) :: to_ptr(:)
+    integer, value :: N
+    integer :: i
+
+    !$omp parallel do
+    do i = 1, N
+      to_ptr(i) = 3 * from_ptr(i)
+    end do
+    !$omp end parallel do
+  end subroutine copy3_array_int
+
+  subroutine copy3_scalar_int(from, to)
+    !$omp declare target
+    real(c_double) :: from, to
+
+    to = 3 * from
+  end subroutine copy3_scalar_int
+
+
+  subroutine copy3_array(from, to, N)
+    type(c_ptr), value :: from, to
+    integer, value :: N
+    real(c_double), pointer :: from_ptr(:), to_ptr(:)
+
+    call c_f_pointer(from, from_ptr, shape=[N])
+    call c_f_pointer(to, to_ptr, shape=[N])
+
+    call do_offload_scalar(from_ptr,to_ptr)
+  contains
+    subroutine do_offload_scalar(from_r, to_r)
+      real(c_double), target :: from_r(:), to_r(:)
+      ! The extra function is needed as is_device_ptr
+      ! requires non-value, non-pointer dummy arguments
+
+      !$omp target is_device_ptr(from_r, to_r)
+      call copy3_array_int(from_r, to_r, N)
+      !$omp end target
+    end subroutine do_offload_scalar
+  end subroutine copy3_array
+
+  subroutine copy3_scalar(from, to)
+    type(c_ptr), value, target :: from, to
+    real(c_double), pointer :: from_ptr(:), to_ptr(:)
+
+    ! Standard-conform detour of using an array as at time of writing
+    ! is_device_ptr below does not handle scalars
+    call c_f_pointer(from, from_ptr, shape=[1])
+    call c_f_pointer(to, to_ptr, shape=[1])
+
+    call do_offload_scalar(from_ptr,to_ptr)
+  contains
+    subroutine do_offload_scalar(from_r, to_r)
+      real(c_double), target :: from_r(:), to_r(:)
+      ! The extra function is needed as is_device_ptr
+      ! requires non-value, non-pointer dummy arguments
+
+      !$omp target is_device_ptr(from_r, to_r)
+      call copy3_scalar_int(from_r(1), to_r(1))
+      !$omp end target
+    end subroutine do_offload_scalar
+  end subroutine copy3_scalar
+
+  subroutine copy3_array1(from, to)
+    real(c_double), target :: from(:), to(:)
+    integer :: N
+    N = size(from)
+
+    !!$omp target is_device_ptr(from, to)
+    call copy3_array(c_loc(from), c_loc(to), N)
+    !!$omp end target
+  end subroutine copy3_array1
+
+  subroutine copy3_array3(from, to)
+    real(c_double), optional, target :: from(:), to(:)
+    integer :: N
+    N = size(from)
+
+!    !$omp target is_device_ptr(from, to)
+    call copy3_array(c_loc(from), c_loc(to), N)
+!    !$omp end target
+  end subroutine copy3_array3
+end module target_procs
+
+
+
+module offloading2
+  use iso_c_binding
+  use target_procs
+  implicit none (type, external)
+contains
+  ! Same as main program but uses dummy *nonoptional* arguments
+  subroutine use_device_ptr_sub(AA, BB, CC, DD, EE, FF, AptrA, BptrB, N)
+    real(c_double), pointer :: AA(:), BB(:)
+    real(c_double), allocatable, target :: CC(:), DD(:)
+    real(c_double), target :: EE(N), FF(N), dummy(1)
+    real(c_double), pointer :: AptrA(:), BptrB(:)
+    intent(inout) :: AA, BB, CC, DD, EE, FF
+    integer, value :: N
+
+    type(c_ptr) :: tgt_aptr, tgt_bptr, tgt_cptr, tgt_dptr, tgt_eptr, tgt_fptr
+
+    AA = 11.0_c_double
+    BB = 22.0_c_double
+    CC = 33.0_c_double
+    DD = 44.0_c_double
+    EE = 55.0_c_double
+    FF = 66.0_c_double
+
+    ! pointer-type array to use_device_ptr
+    !$omp target data map(to:AA) map(from:BB) use_device_ptr(AA,BB)
+    call copy3_array(c_loc(AA), c_loc(BB), N)
+    !$omp end target data
+
+    if (any(abs(AA - 11.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 2
+
+    ! allocatable array to use_device_ptr
+    !$omp target data map(to:CC) map(from:DD) use_device_ptr(CC,DD)
+    call copy3_array(c_loc(CC), c_loc(DD), N)
+    !$omp end target data
+
+    if (any(abs(CC - 33.0_c_double) > 10.0_c_double * epsilon(CC))) stop 3
+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 4
+
+    ! fixed-size decriptorless array to use_device_ptr
+    !$omp target data map(to:EE) map(from:FF) use_device_ptr(EE,FF)
+    call copy3_array(c_loc(EE), c_loc(FF), N)
+    !$omp end target data
+
+    if (any(abs(EE - 55.0_c_double) > 10.0_c_double * epsilon(EE))) stop 5
+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 6
+
+
+
+    AA = 111.0_c_double
+    BB = 222.0_c_double
+    CC = 333.0_c_double
+    DD = 444.0_c_double
+    EE = 555.0_c_double
+    FF = 666.0_c_double
+
+    ! pointer-type array to use_device_ptr
+    !$omp target data map(to:AA) map(from:BB)
+    !$omp target data map(alloc:dummy) use_device_ptr(AA,BB)
+    tgt_aptr = c_loc(AA)
+    tgt_bptr = c_loc(BB)
+    AptrA => AA
+    BptrB => BB
+    !$omp end target data
+
+    call copy3_array(tgt_aptr, tgt_bptr, N)
+    !$omp target update from(BB)
+    if (any(abs(AA - 111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 7
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 8
+
+    AA = 1111.0_c_double
+    !$omp target update to(AA)
+    call copy3_array(tgt_aptr, tgt_bptr, N)
+    !$omp target update from(BB)
+    if (any(abs(AA - 1111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 9
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 10
+
+    ! AprtA tests
+    AA = 7.0_c_double
+    !$omp target update to(AA)
+    call copy3_array(c_loc(AptrA), c_loc(BptrB), N)
+    !$omp target update from(BB)
+    if (any(abs(AA - 7.0_c_double) > 10.0_c_double * epsilon(AA))) stop 11
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 12
+
+    AA = 77.0_c_double
+    !$omp target update to(AA)
+    call copy3_array1(AptrA, BptrB)
+    !$omp target update from(BB)
+    if (any(abs(AA - 77.0_c_double) > 10.0_c_double * epsilon(AA))) stop 13
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 14
+
+!    AA = 777.0_c_double
+!    !$omp target update to(AA)
+!    call copy3_array2(AptrA, BptrB)
+!    !$omp target update from(BB)
+!    if (any(abs(AA - 777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 15
+!    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 16
+
+    AA = 7777.0_c_double
+    !$omp target update to(AA)
+    call copy3_array3(AptrA, BptrB)
+    !$omp target update from(BB)
+    if (any(abs(AA - 7777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 17
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 18
+
+!    AA = 77777.0_c_double
+!    !$omp target update to(AA)
+!    call copy3_array4(AptrA, BptrB)
+!    !$omp target update from(BB)
+    !$omp end target data
+!
+!    if (any(abs(AA - 77777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 19
+!    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 20
+
+
+
+    ! allocatable array to use_device_ptr
+    !$omp target data map(to:CC) map(from:DD)
+    !$omp target data map(alloc:dummy) use_device_ptr(CC,DD)
+    tgt_cptr = c_loc(CC)
+    tgt_dptr = c_loc(DD)
+    !$omp end target data
+
+    call copy3_array(tgt_cptr, tgt_dptr, N)
+    !$omp target update from(DD)
+    if (any(abs(CC - 333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 21
+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 22
+
+    CC = 3333.0_c_double
+    !$omp target update to(CC)
+    call copy3_array(tgt_cptr, tgt_dptr, N)
+    !$omp target update from(DD)
+    !$omp end target data
+
+    if (any(abs(CC - 3333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 23
+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 24
+
+
+
+    ! fixed-size decriptorless array to use_device_ptr
+    !$omp target data map(to:EE) map(from:FF)
+    !$omp target data map(alloc:dummy) use_device_ptr(EE,FF)
+    tgt_eptr = c_loc(EE)
+    tgt_fptr = c_loc(FF)
+    !$omp end target data
+
+    call copy3_array(tgt_eptr, tgt_fptr, N)
+    !$omp target update from(FF)
+    if (any(abs(EE - 555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 25
+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 26
+
+    EE = 5555.0_c_double
+    !$omp target update to(EE)
+    call copy3_array(tgt_eptr, tgt_fptr, N)
+    !$omp target update from(FF)
+    !$omp end target data
+
+    if (any(abs(EE - 5555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 27
+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 28
+  end subroutine use_device_ptr_sub
+
+
+
+  ! Same as main program but uses dummy *optional* arguments
+  subroutine use_device_ptr_sub2(AA, BB, CC, DD, EE, FF, AptrA, BptrB, N)
+    real(c_double), optional, pointer :: AA(:), BB(:)
+    real(c_double), optional, allocatable, target :: CC(:), DD(:)
+    real(c_double), optional, target :: EE(N), FF(N)
+    real(c_double), pointer :: AptrA(:), BptrB(:)
+    intent(inout) :: AA, BB, CC, DD, EE, FF
+    real(c_double), target :: dummy(1)
+    integer, value :: N
+
+    type(c_ptr) :: tgt_aptr, tgt_bptr, tgt_cptr, tgt_dptr, tgt_eptr, tgt_fptr
+
+    AA = 11.0_c_double
+    BB = 22.0_c_double
+    CC = 33.0_c_double
+    DD = 44.0_c_double
+    EE = 55.0_c_double
+    FF = 66.0_c_double
+
+    ! pointer-type array to use_device_ptr
+    !$omp target data map(to:AA) map(from:BB) use_device_ptr(AA,BB)
+    call copy3_array(c_loc(AA), c_loc(BB), N)
+    !$omp end target data
+
+    if (any(abs(AA - 11.0_c_double) > 10.0_c_double * epsilon(AA))) stop 29
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 30
+
+    ! allocatable array to use_device_ptr
+    !$omp target data map(to:CC) map(from:DD) use_device_ptr(CC,DD)
+    call copy3_array(c_loc(CC), c_loc(DD), N)
+    !$omp end target data
+
+    if (any(abs(CC - 33.0_c_double) > 10.0_c_double * epsilon(CC))) stop 31
+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 32
+
+    ! fixed-size decriptorless array to use_device_ptr
+    !$omp target data map(to:EE) map(from:FF) use_device_ptr(EE,FF)
+    call copy3_array(c_loc(EE), c_loc(FF), N)
+    !$omp end target data
+
+    if (any(abs(EE - 55.0_c_double) > 10.0_c_double * epsilon(EE))) stop 33
+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 34
+
+
+
+    AA = 111.0_c_double
+    BB = 222.0_c_double
+    CC = 333.0_c_double
+    DD = 444.0_c_double
+    EE = 555.0_c_double
+    FF = 666.0_c_double
+
+    ! pointer-type array to use_device_ptr
+    !$omp target data map(to:AA) map(from:BB)
+    !$omp target data map(alloc:dummy) use_device_ptr(AA,BB)
+    tgt_aptr = c_loc(AA)
+    tgt_bptr = c_loc(BB)
+    AptrA => AA
+    BptrB => BB
+    !$omp end target data
+
+    call copy3_array(tgt_aptr, tgt_bptr, N)
+    !$omp target update from(BB)
+    if (any(abs(AA - 111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 35
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 36
+
+    AA = 1111.0_c_double
+    !$omp target update to(AA)
+    call copy3_array(tgt_aptr, tgt_bptr, N)
+    !$omp target update from(BB)
+    if (any(abs(AA - 1111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 37
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 38
+
+    ! AprtA tests
+    AA = 7.0_c_double
+    !$omp target update to(AA)
+    call copy3_array(c_loc(AptrA), c_loc(BptrB), N)
+    !$omp target update from(BB)
+    if (any(abs(AA - 7.0_c_double) > 10.0_c_double * epsilon(AA))) stop 39
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 40
+
+    AA = 77.0_c_double
+    !$omp target update to(AA)
+    call copy3_array1(AptrA, BptrB)
+    !$omp target update from(BB)
+    if (any(abs(AA - 77.0_c_double) > 10.0_c_double * epsilon(AA))) stop 41
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 42
+
+!    AA = 777.0_c_double
+!    !$omp target update to(AA)
+!    call copy3_array2(AptrA, BptrB)
+!    !$omp target update from(BB)
+!    if (any(abs(AA - 777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 43
+!    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 44
+
+    AA = 7777.0_c_double
+    !$omp target update to(AA)
+    call copy3_array3(AptrA, BptrB)
+    !$omp target update from(BB)
+    if (any(abs(AA - 7777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 45
+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 46
+
+!    AA = 77777.0_c_double
+!    !$omp target update to(AA)
+!    call copy3_array4(AptrA, BptrB)
+!    !$omp target update from(BB)
+    !$omp end target data
+!
+!    if (any(abs(AA - 77777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 47
+!    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 48
+
+
+
+    ! allocatable array to use_device_ptr
+    !$omp target data map(to:CC) map(from:DD)
+    !$omp target data map(alloc:dummy) use_device_ptr(CC,DD)
+    tgt_cptr = c_loc(CC)
+    tgt_dptr = c_loc(DD)
+    !$omp end target data
+
+    call copy3_array(tgt_cptr, tgt_dptr, N)
+    !$omp target update from(DD)
+    if (any(abs(CC - 333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 49
+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 50
+
+    CC = 3333.0_c_double
+    !$omp target update to(CC)
+    call copy3_array(tgt_cptr, tgt_dptr, N)
+    !$omp target update from(DD)
+    !$omp end target data
+
+    if (any(abs(CC - 3333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 51
+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 52
+
+
+
+    ! fixed-size decriptorless array to use_device_ptr
+    !$omp target data map(to:EE) map(from:FF)
+    !$omp target data map(alloc:dummy) use_device_ptr(EE,FF)
+    tgt_eptr = c_loc(EE)
+    tgt_fptr = c_loc(FF)
+    !$omp end target data
+
+    call copy3_array(tgt_eptr, tgt_fptr, N)
+    !$omp target update from(FF)
+    if (any(abs(EE - 555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 53
+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 54
+
+    EE = 5555.0_c_double
+    !$omp target update to(EE)
+    call copy3_array(tgt_eptr, tgt_fptr, N)
+    !$omp end target data
+
+    if (any(abs(EE - 5555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 55
+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 56
+  end subroutine use_device_ptr_sub2
+end module offloading2
+
+
+
+program omp_device_ptr
+  use iso_c_binding
+  use target_procs
+  use offloading2
+  implicit none (type, external)
+
+  integer, parameter :: N = 1000
+  real(c_double), pointer :: AA(:), BB(:), arg_AA(:), arg_BB(:), arg2_AA(:), arg2_BB(:)
+  real(c_double), allocatable, target :: CC(:), DD(:), arg_CC(:), arg_DD(:), arg2_CC(:), arg2_DD(:)
+  real(c_double), target :: EE(N), FF(N), dummy(1), arg_EE(N), arg_FF(N), arg2_EE(N), arg2_FF(N)
+
+  real(c_double), pointer :: AptrA(:), BptrB(:)
+  type(c_ptr) :: tgt_aptr, tgt_bptr, tgt_cptr, tgt_dptr, tgt_eptr, tgt_fptr
+
+  allocate(AA(N), BB(N), CC(N), DD(N))
+
+  AA = 11.0_c_double
+  BB = 22.0_c_double
+  CC = 33.0_c_double
+  DD = 44.0_c_double
+  EE = 55.0_c_double
+  FF = 66.0_c_double
+
+  ! pointer-type array to use_device_ptr
+  !$omp target data map(to:AA) map(from:BB) use_device_ptr(AA,BB)
+  call copy3_array(c_loc(AA), c_loc(BB), N)
+  !$omp end target data
+
+  if (any(abs(AA - 11.0_c_double) > 10.0_c_double * epsilon(AA))) stop 57
+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 58
+
+  ! allocatable array to use_device_ptr
+  !$omp target data map(to:CC) map(from:DD) use_device_ptr(CC,DD)
+  call copy3_array(c_loc(CC), c_loc(DD), N)
+  !$omp end target data
+
+  if (any(abs(CC - 33.0_c_double) > 10.0_c_double * epsilon(CC))) stop 59
+  if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 60
+
+  ! fixed-size decriptorless array to use_device_ptr
+  !$omp target data map(to:EE) map(from:FF) use_device_ptr(EE,FF)
+  call copy3_array(c_loc(EE), c_loc(FF), N)
+  !$omp end target data
+
+  if (any(abs(EE - 55.0_c_double) > 10.0_c_double * epsilon(EE))) stop 61
+  if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 62
+
+
+
+  AA = 111.0_c_double
+  BB = 222.0_c_double
+  CC = 333.0_c_double
+  DD = 444.0_c_double
+  EE = 555.0_c_double
+  FF = 666.0_c_double
+
+  ! pointer-type array to use_device_ptr
+  !$omp target data map(to:AA) map(from:BB)
+  !$omp target data map(alloc:dummy) use_device_ptr(AA,BB)
+  tgt_aptr = c_loc(AA)
+  tgt_bptr = c_loc(BB)
+  AptrA => AA
+  BptrB => BB
+  !$omp end target data
+
+  call copy3_array(tgt_aptr, tgt_bptr, N)
+  !$omp target update from(BB)
+  if (any(abs(AA - 111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 63
+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 64
+
+  AA = 1111.0_c_double
+  !$omp target update to(AA)
+  call copy3_array(tgt_aptr, tgt_bptr, N)
+  !$omp target update from(BB)
+  if (any(abs(AA - 1111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 65
+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 66
+
+  ! AprtA tests
+  AA = 7.0_c_double
+  !$omp target update to(AA)
+  call copy3_array(c_loc(AptrA), c_loc(BptrB), N)
+  !$omp target update from(BB)
+  if (any(abs(AA - 7.0_c_double) > 10.0_c_double * epsilon(AA))) stop 67
+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 68
+
+  AA = 77.0_c_double
+  !$omp target update to(AA)
+  call copy3_array1(AptrA, BptrB)
+  !$omp target update from(BB)
+  if (any(abs(AA - 77.0_c_double) > 10.0_c_double * epsilon(AA))) stop 69
+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 70
+
+!  AA = 777.0_c_double
+!  !$omp target update to(AA)
+!  call copy3_array2(AptrA, BptrB)
+!  !$omp target update from(BB)
+!  if (any(abs(AA - 777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 71
+!  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 72
+
+  AA = 7777.0_c_double
+  !$omp target update to(AA)
+  call copy3_array3(AptrA, BptrB)
+  !$omp target update from(BB)
+  if (any(abs(AA - 7777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 73
+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 74
+
+!  AA = 77777.0_c_double
+!  !$omp target update to(AA)
+!  call copy3_array4(AptrA, BptrB)
+!  !$omp target update from(BB)
+  !$omp end target data
+!
+!  if (any(abs(AA - 77777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 75
+!  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 76
+
+
+
+  ! allocatable array to use_device_ptr
+  !$omp target data map(to:CC) map(from:DD)
+  !$omp target data map(alloc:dummy) use_device_ptr(CC,DD)
+  tgt_cptr = c_loc(CC)
+  tgt_dptr = c_loc(DD)
+  !$omp end target data
+
+  call copy3_array(tgt_cptr, tgt_dptr, N)
+  !$omp target update from(DD)
+  if (any(abs(CC - 333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 77
+  if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 78
+
+  CC = 3333.0_c_double
+  !$omp target update to(CC)
+  call copy3_array(tgt_cptr, tgt_dptr, N)
+  !$omp target update from(DD)
+  !$omp end target data
+
+  if (any(abs(CC - 3333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 79
+  if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 80
+
+
+
+  ! fixed-size decriptorless array to use_device_ptr
+  !$omp target data map(to:EE) map(from:FF)
+  !$omp target data map(alloc:dummy) use_device_ptr(EE,FF)
+  tgt_eptr = c_loc(EE)
+  tgt_fptr = c_loc(FF)
+  !$omp end target data
+
+  call copy3_array(tgt_eptr, tgt_fptr, N)
+  !$omp target update from(FF)
+  if (any(abs(EE - 555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 81
+  if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 82
+
+  EE = 5555.0_c_double
+  !$omp target update to(EE)
+  call copy3_array(tgt_eptr, tgt_fptr, N)
+  !$omp target update from(FF)
+  !$omp end target data
+
+  if (any(abs(EE - 5555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 83
+  if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 84
+
+
+
+  deallocate(AA, BB)  ! Free pointers only
+
+  AptrA => null()
+  BptrB => null()
+  allocate(arg_AA(N), arg_BB(N), arg_CC(N), arg_DD(N))
+  call use_device_ptr_sub(arg_AA, arg_BB, arg_CC, arg_DD, arg_EE, arg_FF, AptrA, BptrB, N)
+  deallocate(arg_AA, arg_BB)
+
+  AptrA => null()
+  BptrB => null()
+  allocate(arg2_AA(N), arg2_BB(N), arg2_CC(N), arg2_DD(N))
+  call use_device_ptr_sub2(arg2_AA, arg2_BB, arg2_CC, arg2_DD, arg2_EE, arg2_FF, AptrA, BptrB, N)
+  deallocate(arg2_AA, arg2_BB)
+end program omp_device_ptr
diff --git a/libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-1.f90 b/libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-1.f90
new file mode 100644
index 00000000000..e92ee8bf573
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-1.f90
@@ -0,0 +1,59 @@
+! { dg-do run }
+! Test whether use_device_ptr properly handles OPTIONAL arguments
+! (Only case of present arguments is tested)
+program test_it
+  implicit none
+  integer, target :: ixx
+  integer, pointer :: ptr_i, ptr_null
+
+  ptr_i => ixx
+  call foo(ptr_i)
+
+  ptr_null => null()
+  call bar(ptr_null)
+
+  call foo_absent()
+  call bar_absent()
+contains
+  subroutine foo(ii)
+    integer, pointer, optional :: ii
+
+    if (.not.present(ii)) stop 1
+    if (.not.associated(ii, ixx)) stop 2
+    !$omp target data map(to:ixx) use_device_ptr(ii)
+    if (.not.present(ii)) stop 3
+    if (.not.associated(ii)) stop 4
+    !$omp end target data
+  end subroutine foo
+
+  ! For bar, it is assumed that a NULL ptr on the host maps to NULL on the device
+  subroutine bar(jj)
+    integer, pointer, optional :: jj
+
+    if (.not.present(jj)) stop 5
+    if (associated(jj)) stop 6
+    !$omp target data map(to:ixx) use_device_ptr(jj)
+    if (.not.present(jj)) stop 7
+   if (associated(jj)) stop 8
+    !$omp end target data
+  end subroutine bar
+
+  subroutine foo_absent(ii)
+    integer, pointer, optional :: ii
+
+    if (present(ii)) STOP 31
+    !$omp target data map(to:ixx) use_device_ptr(ii)
+    if (present(ii)) STOP 32
+    !$omp end target data
+  end subroutine foo_absent
+
+  ! For bar, it is assumed that a NULL ptr on the host maps to NULL on the device
+  subroutine bar_absent(jj)
+    integer, pointer, optional :: jj
+
+    if (present(jj)) STOP 41
+    !$omp target data map(to:ixx) use_device_ptr(jj)
+    if (present(jj)) STOP 42
+    !$omp end target data
+  end subroutine bar_absent
+end program test_it
diff --git a/libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-2.f90 b/libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-2.f90
new file mode 100644
index 00000000000..d33b7d1cce0
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-2.f90
@@ -0,0 +1,60 @@
+! Check whether absent optional arguments are properly
+! handled with use_device_{addr,ptr}.
+program main
+ use iso_c_binding, only: c_ptr, c_loc, c_associated
+ implicit none (type, external)
+ call foo()
+contains
+  subroutine foo(v, w, x, y, z, cptr, cptr_in)
+    integer, target, optional, value :: v
+    integer, target, optional :: w
+    integer, target, optional :: x(:)
+    integer, target, optional, allocatable :: y
+    integer, target, optional, allocatable :: z(:)
+    type(c_ptr), target, optional, value :: cptr
+    type(c_ptr), target, optional, value, intent(in) :: cptr_in
+    integer :: d
+
+    ! Need to map per-VALUE arguments, if present
+    if (present(v)) then
+      !$omp target enter data map(to:v)
+      stop 1  ! â€“ but it shall not be present in this test case.
+    end if
+    if (present(cptr)) then
+      !$omp target enter data map(to:cptr)
+      stop 2  ! â€“ but it shall not be present in this test case.
+    end if
+    if (present(cptr_in)) then
+      !$omp target enter data map(to:cptr_in)
+      stop 3  ! â€“ but it shall not be present in this test case.
+    end if
+
+    !$omp target data map(d) use_device_addr(v, w, x, y, z, cptr, cptr_in)
+      if (present(v)) then; v    = 5; stop 11; endif
+      if (present(w)) then; w    = 5; stop 12; endif
+      if (present(x)) then; x(1) = 5; stop 13; endif
+      if (present(y)) then; y    = 5; stop 14; endif
+      if (present(z)) then; z(1) = 5; stop 15; endif
+      if (present(cptr)) then; cptr = c_loc(v); stop 16; endif
+      if (present(cptr_in)) then
+        if (c_associated(cptr_in, c_loc(x))) stop 17
+        stop 18
+      endif
+    !$omp end target data
+
+! Using 'v' in use_device_ptr gives an ICE
+! TODO: Find out what the OpenMP spec permits for use_device_ptr
+
+    !$omp target data map(d) use_device_ptr(w, x, y, z, cptr, cptr_in)
+      if (present(w)) then; w    = 5; stop 21; endif
+      if (present(x)) then; x(1) = 5; stop 22; endif
+      if (present(y)) then; y    = 5; stop 23; endif
+      if (present(z)) then; z(1) = 5; stop 24; endif
+      if (present(cptr)) then; cptr = c_loc(x); stop 25; endif
+      if (present(cptr_in)) then
+        if (c_associated(cptr_in, c_loc(x))) stop 26
+        stop 27
+      endif
+    !$omp end target data
+  end subroutine foo
+end program main
diff --git a/libgomp/testsuite/libgomp.fortran/vla1.f90 b/libgomp/testsuite/libgomp.fortran/vla1.f90
index bf25e89a54a..63d17e7d47b 100644
--- a/libgomp/testsuite/libgomp.fortran/vla1.f90
+++ b/libgomp/testsuite/libgomp.fortran/vla1.f90
@@ -156,7 +156,7 @@ contains
     call check (size (k, 3), 3, l)
     call check (size (k), 15, l)
 !$omp end parallel
-    if (l) STOP 1
+    if (l) stop 1
   end subroutine foo
 
   subroutine test
diff --git a/libgomp/testsuite/libgomp.fortran/vla2.f90 b/libgomp/testsuite/libgomp.fortran/vla2.f90
index 1bda078a8f1..ef337d4753e 100644
--- a/libgomp/testsuite/libgomp.fortran/vla2.f90
+++ b/libgomp/testsuite/libgomp.fortran/vla2.f90
@@ -124,7 +124,7 @@ contains
     call check (size (k, 3), 3, l)
     call check (size (k), 15, l)
 !$omp end parallel
-    if (l) STOP 1
+    if (l) stop 1
   end subroutine foo
 
   subroutine test
diff --git a/libgomp/testsuite/libgomp.fortran/vla3.f90 b/libgomp/testsuite/libgomp.fortran/vla3.f90
index e31aaaf6b15..c21048370bc 100644
--- a/libgomp/testsuite/libgomp.fortran/vla3.f90
+++ b/libgomp/testsuite/libgomp.fortran/vla3.f90
@@ -162,7 +162,7 @@ contains
     call check (size (k, 3), 3, l)
     call check (size (k), 15, l)
 !$omp end parallel
-    if (l) STOP 1
+    if (l) stop 1
   end subroutine foo
 
   subroutine test
diff --git a/libgomp/testsuite/libgomp.fortran/vla4.f90 b/libgomp/testsuite/libgomp.fortran/vla4.f90
index 3388e872288..2d1a940778f 100644
--- a/libgomp/testsuite/libgomp.fortran/vla4.f90
+++ b/libgomp/testsuite/libgomp.fortran/vla4.f90
@@ -166,7 +166,7 @@ contains
     call check (size (k), 15, l)
 110 continue
 !$omp end parallel do
-    if (l) STOP 1
+    if (l) stop 1
     if (z2 == 6) then
       x = 5
       w = 'thread5thr_number_5THREAD5THR_NUMBER_5'
@@ -202,7 +202,7 @@ contains
 	do 115, q = 4, 6
 	  l = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q
 115   continue
-      if (l) STOP 2
+      if (l) stop 2
     end if
   end subroutine foo
 
diff --git a/libgomp/testsuite/libgomp.fortran/vla5.f90 b/libgomp/testsuite/libgomp.fortran/vla5.f90
index 3b040c737ff..3b28c5108fe 100644
--- a/libgomp/testsuite/libgomp.fortran/vla5.f90
+++ b/libgomp/testsuite/libgomp.fortran/vla5.f90
@@ -138,7 +138,7 @@ contains
     call check (size (k), 15, l)
 110 continue
 !$omp end parallel do
-    if (l) STOP 1
+    if (l) stop 1
     if (z2 == 6) then
       x = 5
       w = 'thread5thr_number_5THREAD5THR_NUMBER_5'
@@ -174,7 +174,7 @@ contains
 	do 115, q = 4, 6
 	  l = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q
 115   continue
-      if (l) STOP 2
+      if (l) stop 2
     end if
   end subroutine foo
 
diff --git a/libgomp/testsuite/libgomp.fortran/vla6.f90 b/libgomp/testsuite/libgomp.fortran/vla6.f90
index ccc91ec85d3..c2ea7f38ac4 100644
--- a/libgomp/testsuite/libgomp.fortran/vla6.f90
+++ b/libgomp/testsuite/libgomp.fortran/vla6.f90
@@ -173,7 +173,7 @@ contains
 	l = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q
 115 continue
 !$omp end parallel
-    if (l) STOP 1
+    if (l) stop 1
   end subroutine foo
 
   subroutine test
diff --git a/libgomp/testsuite/libgomp.fortran/vla7.f90 b/libgomp/testsuite/libgomp.fortran/vla7.f90
index a97132dc0a4..1e27a2e3f4a 100644
--- a/libgomp/testsuite/libgomp.fortran/vla7.f90
+++ b/libgomp/testsuite/libgomp.fortran/vla7.f90
@@ -4,13 +4,13 @@
   character (6) :: c, f2
   character (6) :: d(2)
   c = f1 (6)
-  if (c .ne. 'opqrst') STOP 1
+  if (c .ne. 'opqrst') stop 1
   c = f2 (6)
-  if (c .ne. '_/!!/_') STOP 2
+  if (c .ne. '_/!!/_') stop 2
   d = f3 (6)
-  if (d(1) .ne. 'opqrst' .or. d(2) .ne. 'a') STOP 3
+  if (d(1) .ne. 'opqrst' .or. d(2) .ne. 'a') stop 3
   d = f4 (6)
-  if (d(1) .ne. 'Opqrst' .or. d(2) .ne. 'A') STOP 4
+  if (d(1) .ne. 'Opqrst' .or. d(2) .ne. 'A') stop 4
 contains
   function f1 (n)
     use omp_lib
@@ -40,7 +40,7 @@ contains
 !$omp barrier
     l = l .or. f1 .ne. 'def'
 !$omp end parallel
-    if (l) STOP 5
+    if (l) stop 5
     f1 = 'opqrst'
   end function f1
   function f3 (n)
@@ -71,7 +71,7 @@ contains
 !$omp barrier
     l = l .or. any (f3 .ne. 'def')
 !$omp end parallel
-    if (l) STOP 6
+    if (l) stop 6
     f3(1) = 'opqrst'
     f3(2) = 'a'
   end function f3
@@ -105,7 +105,7 @@ contains
     l = l .or. any (f4 .ne. 'def')
     l = l .or. size (f4) .ne. 2
 !$omp end parallel
-    if (l) STOP 7
+    if (l) stop 7
     f4(1) = 'Opqrst'
     f4(2) = 'A'
   end function f4
@@ -138,6 +138,6 @@ function f2 (n)
 !$omp barrier
   l = l .or. f2 .ne. 'def'
 !$omp end parallel
-  if (l) STOP 8
+  if (l) stop 8
   f2 = '_/!!/_'
 end function f2
diff --git a/libgomp/testsuite/libgomp.fortran/vla8.f90 b/libgomp/testsuite/libgomp.fortran/vla8.f90
index ee756d4fe6e..fbf3308d747 100644
--- a/libgomp/testsuite/libgomp.fortran/vla8.f90
+++ b/libgomp/testsuite/libgomp.fortran/vla8.f90
@@ -237,7 +237,7 @@ contains
 	l = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q
 125 continue
 !$omp end parallel
-    if (l) STOP 1
+    if (l) stop 1
   end subroutine foo
 
   subroutine test
diff --git a/libgomp/testsuite/libgomp.fortran/workshare1.f90 b/libgomp/testsuite/libgomp.fortran/workshare1.f90
index 1d2ba7d3ee2..a9baef40979 100644
--- a/libgomp/testsuite/libgomp.fortran/workshare1.f90
+++ b/libgomp/testsuite/libgomp.fortran/workshare1.f90
@@ -1,3 +1,4 @@
+! { dg-do run }
 function foo ()
   integer :: foo
   logical :: foo_seen
@@ -24,7 +25,7 @@ end
   b = 20
   a(1:5) = max (a(1:5), b(1:5))
 !$omp end parallel workshare
-  if (any (a(1:5) .ne. 20)) STOP 1
-  if (any (a(6:10) .ne. 10)) STOP 2
-  if (.not. foo_seen .or. .not. bar_seen) STOP 3
+  if (any (a(1:5) .ne. 20)) stop 1
+  if (any (a(6:10) .ne. 10)) stop 2
+  if (.not. foo_seen .or. .not. bar_seen) stop 3
 end
diff --git a/libgomp/testsuite/libgomp.fortran/workshare2.f90 b/libgomp/testsuite/libgomp.fortran/workshare2.f90
index 655a450885e..299e577732b 100644
--- a/libgomp/testsuite/libgomp.fortran/workshare2.f90
+++ b/libgomp/testsuite/libgomp.fortran/workshare2.f90
@@ -1,9 +1,10 @@
+! { dg-do run }
 subroutine f1
   integer a(20:50,70:90)
 !$omp parallel workshare
   a(:,:) = 17
 !$omp end parallel workshare
-  if (any (a.ne.17)) STOP 1
+  if (any (a.ne.17)) stop 1
 end subroutine f1
 subroutine f2
   integer a(20:50,70:90),d(15),e(15),f(15)
@@ -20,14 +21,14 @@ subroutine f2
   f = 7
   where (e.ge.5) f = f + 1
 !$omp end parallel workshare
-  if (any (a.ne.17)) STOP 2
-  if (c.ne.5.or.b.ne.4) STOP 3
-  if (any(d.ne.0)) STOP 4
+  if (any (a.ne.17)) stop 2
+  if (c.ne.5.or.b.ne.4) stop 3
+  if (any(d.ne.0)) stop 4
   do i = 1, 15
     if (e(i).ge.5) then
-      if (f(i).ne.8) STOP 5
+      if (f(i).ne.8) stop 5
     else
-      if (f(i).ne.7) STOP 6
+      if (f(i).ne.7) stop 6
     end if
   end do
 end subroutine f2
diff --git a/libgomp/testsuite/libgomp.hsa.c/tiling-2.c b/libgomp/testsuite/libgomp.hsa.c/tiling-2.c
index 6e543045559..2756d14ca82 100644
--- a/libgomp/testsuite/libgomp.hsa.c/tiling-2.c
+++ b/libgomp/testsuite/libgomp.hsa.c/tiling-2.c
@@ -167,7 +167,7 @@ void tiled_sgemm_tt(const int M, const int N, const int K, const float alpha, co
 
 // -------------------------------------------------------------------
 //      The rest of this code forms the HSAIL kernel with the
-//      pairs of "paralell for collapse(2)" loops repalced with a barrier.
+//      pairs of "parallel for collapse(2)" loops replaced with a barrier.
 //      The kernel initializes these values
 //      C_row_start = get_group_id(0) * BLOCK_SIZE
 //      C_col_start = get_group_id(1) * BLOCK_SIZE
diff --git a/libgomp/testsuite/libgomp.oacc-c++/c++.exp b/libgomp/testsuite/libgomp.oacc-c++/c++.exp
index dcefa792ca4..c06c2a097e3 100644
--- a/libgomp/testsuite/libgomp.oacc-c++/c++.exp
+++ b/libgomp/testsuite/libgomp.oacc-c++/c++.exp
@@ -88,6 +88,15 @@ if { $lang_test_file_found } {
 		unsupported "$subdir $offload_target offloading"
 		continue
 	    }
+	    gcn {
+		if { ![check_effective_target_openacc_amdgcn_accel_present] } {
+		    # Don't bother; execution testing is going to FAIL.
+		    untested "$subdir $offload_target offloading: supported, but hardware not accessible"
+		    continue
+		}
+
+		set acc_mem_shared 0
+	    }
 	    host {
 		set acc_mem_shared 1
 	    }
diff --git a/libgomp/testsuite/libgomp.oacc-c++/firstprivate-mappings-1.C b/libgomp/testsuite/libgomp.oacc-c++/firstprivate-mappings-1.C
new file mode 100644
index 00000000000..c8dba9e5d1c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c++/firstprivate-mappings-1.C
@@ -0,0 +1,3 @@
+/* Verify OpenACC 'firstprivate' mappings for C++ reference types.  */
+
+#include "../../../gcc/testsuite/g++.dg/goacc/firstprivate-mappings-1.C"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-1.c
new file mode 100644
index 00000000000..4fc6068ba98
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-1.c
@@ -0,0 +1,28 @@
+/* Verify that we refuse 'acc_free', after 'acc_map_data'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 108;
+
+  char *h = (char *) malloc (N);
+  void *d = acc_malloc (N - 10);
+  if (!d)
+    abort ();
+  acc_map_data (h, d, N - 19);
+
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_free (d);
+
+  return 0;
+}
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" }
+   { dg-output "refusing to free device memory space at \[0-9a-fA-FxX\]+ that is still mapped at \\\[\[0-9a-fA-FxX\]+,\\\+89\\\]" }
+   { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-2.c
new file mode 100644
index 00000000000..3f6a8e57174
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-2.c
@@ -0,0 +1,27 @@
+/* Verify that we refuse 'acc_free', after 'acc_create'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 108;
+
+  char *h = (char *) malloc (N);
+  void *d = acc_create (h, N - 1);
+  if (!d)
+    abort ();
+
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_free (d);
+
+  return 0;
+}
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" }
+   { dg-output "refusing to free device memory space at \[0-9a-fA-FxX\]+ that is still mapped at \\\[\[0-9a-fA-FxX\]+,\\\+107\\\]" }
+   { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-3-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-3-2.c
new file mode 100644
index 00000000000..9f4504809eb
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-3-2.c
@@ -0,0 +1,28 @@
+/* Verify that we refuse 'acc_free', inside 'host_data', after '#pragma acc enter data create'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 108;
+
+  char *h = (char *) malloc (N);
+#pragma acc enter data create (h[0:N - 2])
+
+#pragma acc host_data use_device (h)
+  {
+    fprintf (stderr, "CheCKpOInT\n");
+    acc_free (h);
+  }
+
+  return 0;
+}
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" }
+   { dg-output "refusing to free device memory space at \[0-9a-fA-FxX\]+ that is still mapped at \\\[\[0-9a-fA-FxX\]+,\\\+106\\\]" }
+   { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-3.c
new file mode 100644
index 00000000000..162083051cf
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-3.c
@@ -0,0 +1,28 @@
+/* Verify that we refuse 'acc_free', after '#pragma acc enter data create'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 108;
+
+  char *h = (char *) malloc (N);
+#pragma acc enter data create (h[0:N - 3])
+  void *d = acc_deviceptr (h);
+  if (!d)
+    abort ();
+
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_free (d);
+
+  return 0;
+}
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" }
+   { dg-output "refusing to free device memory space at \[0-9a-fA-FxX\]+ that is still mapped at \\\[\[0-9a-fA-FxX\]+,\\\+105\\\]" }
+   { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4-2.c
new file mode 100644
index 00000000000..48226cf64c7
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4-2.c
@@ -0,0 +1,29 @@
+/* Verify that we refuse 'acc_free', inside 'host_data', inside 'data'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 108;
+
+  char *h = (char *) malloc (N);
+#pragma acc data create (h[0:N - 44])
+  {
+#pragma acc host_data use_device (h)
+    {
+      fprintf (stderr, "CheCKpOInT\n");
+      acc_free (h);
+    }
+  }
+
+  return 0;
+}
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" }
+   { dg-output "refusing to free device memory space at \[0-9a-fA-FxX\]+ that is still mapped at \\\[\[0-9a-fA-FxX\]+,\\\+64\\\]" }
+   { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4.c
new file mode 100644
index 00000000000..7638d528575
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_free-pr92503-4.c
@@ -0,0 +1,30 @@
+/* Verify that we refuse 'acc_free', inside 'data'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 108;
+
+  char *h = (char *) malloc (N);
+#pragma acc data create (h[0:N - 21])
+  {
+    void *d = acc_deviceptr (h);
+    if (!d)
+      abort ();
+
+    fprintf (stderr, "CheCKpOInT\n");
+    acc_free (d);
+  }
+
+  return 0;
+}
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" }
+   { dg-output "refusing to free device memory space at \[0-9a-fA-FxX\]+ that is still mapped at \\\[\[0-9a-fA-FxX\]+,\\\+87\\\]" }
+   { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-1.c
new file mode 100644
index 00000000000..b48a1adbbb6
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-1.c
@@ -0,0 +1,36 @@
+/* Verify that we refuse 'acc_map_data' when the "device address [...] is
+   already mapped".  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 131;
+
+  char *h1 = (char *) malloc (N);
+  assert (h1);
+  void *d = acc_malloc (N);
+  assert (d);
+  acc_map_data (h1, d, N);
+
+  char *h2 = (char *) malloc (N);
+  assert (h2);
+  /* Try to arrange a setting such that a later 'acc_unmap_data' would find the
+     device memory object still referenced elsewhere.  This is not possible,
+     given the semantics of 'acc_map_data'.  */
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_map_data (h2, d, N);
+
+  return 0;
+}
+
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
+/* { dg-output "device address \\\[\[0-9a-fA-FxX\]+, \\\+131\\\] is already mapped" } */
+/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-2.c
new file mode 100644
index 00000000000..4fe0662cabb
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-2.c
@@ -0,0 +1,35 @@
+/* Verify that we refuse 'acc_map_data' when the "device address [...] is
+   already mapped".  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 132;
+
+  char *h1 = (char *) malloc (N);
+  assert (h1);
+  void *d = acc_create (h1, N);
+  assert (d);
+
+  char *h2 = (char *) malloc (N);
+  assert (h2);
+  /* Try to arrange a setting such that a later 'acc_unmap_data' would find the
+     device memory object still referenced elsewhere.  This is not possible,
+     given the semantics of 'acc_map_data'.  */
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_map_data (h2, d, N);
+
+  return 0;
+}
+
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
+/* { dg-output "device address \\\[\[0-9a-fA-FxX\]+, \\\+132\\\] is already mapped" } */
+/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-3.c
new file mode 100644
index 00000000000..44ebaa0eb3f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-device_already-3.c
@@ -0,0 +1,31 @@
+/* Verify that we refuse 'acc_map_data' when the "device address [...] is
+   already mapped".  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <assert.h>
+#include <stdio.h>
+#include <openacc.h>
+
+double global_var;
+#pragma acc declare create (global_var)
+
+int
+main ()
+{
+  double var;
+  void *d = acc_deviceptr (&global_var);
+  assert (d);
+  /* Try to arrange a setting such that a later 'acc_unmap_data' would find the
+     device memory object still referenced elsewhere.  This is not possible,
+     given the semantics of 'acc_map_data'.  */
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_map_data (&var, d, sizeof var);
+
+  return 0;
+}
+
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
+/* { dg-output "device address \\\[\[0-9a-fA-FxX\]+, \\\+8\\\] is already mapped" { xfail *-*-* } } TODO PR92888 */
+/* { dg-shouldfail "TODO PR92888" { this-really-should-fail } } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-1.c
new file mode 100644
index 00000000000..1fff806613c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-1.c
@@ -0,0 +1,33 @@
+/* Verify that we refuse 'acc_map_data' when the "host address [...] is already
+   mapped".  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 101;
+
+  char *h = (char *) malloc (N);
+  assert (h);
+  void *d1 = acc_malloc (N);
+  assert (d1);
+  acc_map_data (h, d1, N);
+
+  void *d2 = acc_malloc (N);
+  assert (d2);
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_map_data (h, d2, N);
+
+  return 0;
+}
+
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
+/* { dg-output "host address \\\[\[0-9a-fA-FxX\]+, \\\+101\\\] is already mapped" } */
+/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-2.c
new file mode 100644
index 00000000000..fc804692d1b
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-2.c
@@ -0,0 +1,32 @@
+/* Verify that we refuse 'acc_map_data' when the "host address [...] is already
+   mapped".  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 102;
+
+  char *h = (char *) malloc (N);
+  assert (h);
+  void *d1 = acc_create (h, N);
+  assert (d1);
+
+  void *d2 = acc_malloc (N);
+  assert (d2);
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_map_data (h, d2, N);
+
+  return 0;
+}
+
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
+/* { dg-output "host address \\\[\[0-9a-fA-FxX\]+, \\\+102\\\] is already mapped" } */
+/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-3.c
new file mode 100644
index 00000000000..6a80ebfef46
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_map_data-host_already-3.c
@@ -0,0 +1,27 @@
+/* Verify that we refuse 'acc_map_data' when the "host address [...] is already
+   mapped".  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <assert.h>
+#include <stdio.h>
+#include <openacc.h>
+
+float global_var;
+#pragma acc declare create (global_var)
+
+int
+main ()
+{
+  void *d = acc_malloc (sizeof global_var);
+  assert (d);
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_map_data (&global_var, d, sizeof global_var);
+
+  return 0;
+}
+
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
+/* { dg-output "host address \\\[\[0-9a-fA-FxX\]+, \\\+4\\\] is already mapped" } */
+/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-dispatch-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-dispatch-1.c
new file mode 100644
index 00000000000..d929bfd80a4
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-dispatch-1.c
@@ -0,0 +1,353 @@
+/* Test dispatch of events to callbacks.  */
+
+#undef NDEBUG
+#include <assert.h>
+
+#include <acc_prof.h>
+
+
+/* Use explicit 'copyin' clauses, to work around "'firstprivate'
+   optimizations", which will cause the value at the point of call to be used
+   (*before* any potential modifications done in callbacks), as opposed to its
+   address being taken, which then later gets dereferenced (*after* any
+   modifications done in callbacks).  */
+#define COPYIN(...) copyin(__VA_ARGS__)
+
+
+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)
+
+
+static int state = -1;
+
+#define STATE_OP(state, op) \
+  do \
+    { \
+      typeof (state) state_o = (state); \
+      (void) state_o; \
+      (state)op; \
+      DEBUG_printf("state: %d -> %d\n", state_o, (state)); \
+    } \
+  while (0)
+
+
+static void cb_compute_construct_start_1 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 0
+	  || state == 10
+	  || state == 30
+	  || state == 41
+	  || state == 51
+	  || state == 91
+	  || state == 101
+	  || state == 151);
+  STATE_OP (state, ++);
+}
+
+static void cb_compute_construct_start_2 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 1
+	  || state == 11
+	  || state == 40
+	  || state == 50
+	  || state == 90
+	  || state == 100
+	  || state == 150);
+  STATE_OP (state, ++);
+}
+
+static void cb_compute_construct_end_1 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 14
+	  || state == 21
+	  || state == 32
+	  || state == 42
+	  || state == 80
+	  || state == 103
+	  || state == 152);
+  STATE_OP (state, ++);
+}
+
+static void cb_compute_construct_end_2 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 13
+	  || state == 43
+	  || state == 102
+	  || state == 154);
+  STATE_OP (state, ++);
+}
+
+static void cb_compute_construct_end_3 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 12
+	  || state == 20
+	  || state == 31
+	  || state == 44
+	  || state == 81
+	  || state == 104
+	  || state == 153);
+  STATE_OP (state, ++);
+}
+
+
+static acc_prof_reg reg;
+static acc_prof_reg unreg;
+static acc_prof_lookup_func lookup;
+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  reg = reg_;
+  unreg = unreg_;
+  lookup = lookup_;
+}
+
+
+int main()
+{
+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);
+
+  STATE_OP (state, = 0);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_reg);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 2);
+  }
+  assert (state == 2);
+
+  STATE_OP (state, = 10);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 12);
+  }
+  assert (state == 15);
+
+  STATE_OP (state, = 20);
+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_toggle);
+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_toggle);
+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);
+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_reg);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_toggle);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_toggle);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_toggle);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_toggle);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_toggle);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 20);
+  }
+  assert (state == 20);
+
+  STATE_OP (state, = 30);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_toggle);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_toggle);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_toggle);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_toggle);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_toggle);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 31);
+  }
+  assert (state == 33);
+
+  STATE_OP (state, = 40);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_reg);
+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 42);
+  }
+  assert (state == 45);
+
+  STATE_OP (state, = 50);
+  unreg (acc_ev_compute_construct_end, NULL, acc_toggle);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 52);
+  }
+  assert (state == 52);
+
+  STATE_OP (state, = 60);
+  unreg (acc_ev_compute_construct_end, NULL, acc_toggle);
+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);
+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 60);
+  }
+  assert (state == 60);
+
+  STATE_OP (state, = 70);
+  unreg (acc_ev_compute_construct_start, NULL, acc_toggle);
+  reg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 70);
+  }
+  assert (state == 70);
+
+  STATE_OP (state, = 80);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);
+  reg (acc_ev_compute_construct_end, NULL, acc_toggle);
+  reg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 80);
+  }
+  assert (state == 82);
+
+  STATE_OP (state, = 90);
+  reg (acc_ev_compute_construct_start, NULL, acc_toggle);
+  unreg (acc_ev_compute_construct_end, NULL, acc_toggle);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 92);
+  }
+  assert (state == 92);
+
+  STATE_OP (state, = 100);
+  reg (acc_ev_compute_construct_end, NULL, acc_toggle);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 102);
+  }
+  assert (state == 105);
+
+  STATE_OP (state, = 110);
+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle);
+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 110);
+  }
+  assert (state == 110);
+
+  STATE_OP (state, = 120);
+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 120);
+  }
+  assert (state == 120);
+
+  STATE_OP (state, = 130);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);
+  reg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 130);
+  }
+  assert (state == 130);
+
+  STATE_OP (state, = 140);
+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);
+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 140);
+  }
+  assert (state == 140);
+
+  STATE_OP (state, = 150);
+  reg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+    assert (state_init == 152);
+  }
+  assert (state == 155);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-init-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-init-1.c
new file mode 100644
index 00000000000..e82a03e8f3c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-init-1.c
@@ -0,0 +1,318 @@
+/* Test dispatch of events to callbacks.  */
+
+#undef NDEBUG
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <acc_prof.h>
+
+
+/* Use explicit 'copyin' clauses, to work around "'firstprivate'
+   optimizations", which will cause the value at the point of call to be used
+   (*before* any potential modifications done in callbacks), as opposed to its
+   address being taken, which then later gets dereferenced (*after* any
+   modifications done in callbacks).  */
+#define COPYIN(...) copyin(__VA_ARGS__)
+
+
+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)
+
+
+static int state = -1;
+
+#define STATE_OP(state, op) \
+  do \
+    { \
+      typeof (state) state_o = (state); \
+      (void) state_o; \
+      (state)op; \
+      DEBUG_printf("state: %d -> %d\n", state_o, (state)); \
+    } \
+  while (0)
+
+
+static acc_device_t acc_device_type;
+static int acc_device_num;
+static int acc_async;
+
+
+struct tool_info
+{
+  acc_event_info event_info;
+  struct tool_info *nested;
+};
+struct tool_info *tool_info;
+
+static void cb_device_init_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 0
+	  || state == 100);
+  STATE_OP (state, ++);
+
+  assert (tool_info == NULL);
+  tool_info = (struct tool_info *) malloc(sizeof *tool_info);
+  assert (tool_info != NULL);
+  tool_info->nested = NULL;
+
+  assert (prof_info->event_type == acc_ev_device_init_start);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  if (state == 1)
+    assert (prof_info->device_type == acc_device_host);
+  else
+    assert (prof_info->device_type == acc_device_default);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async_sync);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_runtime_api);
+  assert (event_info->other_event.implicit == 0);
+  assert (event_info->other_event.tool_info == NULL);
+
+  assert (api_info->device_api == acc_device_api_none);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  tool_info->event_info.other_event.event_type = event_info->other_event.event_type;
+  event_info->other_event.tool_info = tool_info;
+}
+
+static void cb_device_init_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 1
+	  || state == 101);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_device_init_start);
+
+  assert (prof_info->event_type == acc_ev_device_init_end);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  if (state == 2)
+    assert (prof_info->device_type == acc_device_host);
+  else
+    assert (prof_info->device_type == acc_device_default);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async_sync);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_runtime_api);
+  assert (event_info->other_event.implicit == 0);
+  assert (event_info->other_event.tool_info == tool_info);
+
+  assert (api_info->device_api == acc_device_api_none);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  free (tool_info);
+  tool_info = NULL;
+}
+
+static void cb_compute_construct_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 10
+	  || state == 110);
+  STATE_OP (state, ++);
+
+  assert (tool_info == NULL);
+  tool_info = (struct tool_info *) malloc(sizeof *tool_info);
+  assert (tool_info != NULL);
+  tool_info->nested = NULL;
+
+  assert (prof_info->event_type == acc_ev_compute_construct_start);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == /* TODO acc_async */ acc_async_sync);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 0);
+  assert (event_info->other_event.tool_info == NULL);
+
+  assert (api_info->device_api == acc_device_api_none);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  tool_info->event_info.other_event.event_type = event_info->other_event.event_type;
+  event_info->other_event.tool_info = tool_info;
+}
+
+static void cb_compute_construct_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 11
+	  || state == 111);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested == NULL);
+
+  assert (prof_info->event_type == acc_ev_compute_construct_end);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  if (acc_device_type == acc_device_host)
+    assert (prof_info->async == acc_async_sync);
+  else
+    assert (prof_info->async == acc_async);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 0);
+  assert (event_info->other_event.tool_info == tool_info);
+
+  if (acc_device_type == acc_device_host)
+    assert (api_info->device_api == acc_device_api_none);
+  else if (acc_device_type == acc_device_gcn)
+    assert (api_info->device_api == acc_device_api_other);
+  else
+    assert (api_info->device_api == acc_device_api_cuda);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  free (tool_info);
+  tool_info = NULL;
+}
+
+
+static acc_prof_reg reg;
+static acc_prof_reg unreg;
+static acc_prof_lookup_func lookup;
+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  reg = reg_;
+  unreg = unreg_;
+  lookup = lookup_;
+}
+
+
+int main()
+{
+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);
+
+  STATE_OP (state, = 0);
+  reg (acc_ev_device_init_start, cb_device_init_start, acc_reg);
+  reg (acc_ev_device_init_end, cb_device_init_end, acc_reg);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end, acc_reg);
+  assert (state == 0);
+
+  acc_init (acc_device_host);
+  assert (state == 2);
+
+  STATE_OP (state, = 10);
+
+  acc_device_type = acc_get_device_type ();
+  acc_device_num = acc_get_device_num (acc_device_type);
+  acc_async = 12;
+
+  {
+    int state_init;
+#pragma acc parallel async(acc_async) COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+#pragma acc wait
+    assert (state_init == 11);
+  }
+  assert (state == 12);
+
+  STATE_OP (state, = 90);
+  acc_shutdown (acc_device_host);
+  assert (state == 90);
+
+
+  STATE_OP (state, = 100);
+  acc_init (acc_device_default);
+  assert (state == 102);
+
+  STATE_OP (state, = 110);
+
+  acc_device_type = acc_get_device_type ();
+  acc_device_num = acc_get_device_num (acc_device_type);
+  acc_async = 12;
+
+  {
+    int state_init;
+#pragma acc parallel async(acc_async) COPYIN(state) copyout(state_init)
+    {
+      state_init = state;
+    }
+#pragma acc wait
+    assert (state_init == 111);
+  }
+  assert (state == 112);
+
+  STATE_OP (state, = 190);
+  acc_shutdown (acc_device_default);
+  assert (state == 190);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-kernels-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-kernels-1.c
new file mode 100644
index 00000000000..ddf647cda9b
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-kernels-1.c
@@ -0,0 +1,233 @@
+/* Test dispatch of events to callbacks.  */
+
+#undef NDEBUG
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <acc_prof.h>
+
+
+/* Use explicit 'copyin' clauses, to work around "'firstprivate'
+   optimizations", which will cause the value at the point of call to be used
+   (*before* any potential modifications done in callbacks), as opposed to its
+   address being taken, which then later gets dereferenced (*after* any
+   modifications done in callbacks).  */
+#define COPYIN(...) copyin(__VA_ARGS__)
+
+
+/* See the 'DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT' reference in
+   'libgomp.texi'.  */
+#define DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT 0
+
+
+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)
+
+
+volatile // TODO PR90488
+static int state = -1;
+
+#define STATE_OP(state, op) \
+  do \
+    { \
+      typeof (state) state_o = (state); \
+      (void) state_o; \
+      (state)op; \
+      DEBUG_printf("state: %d -> %d\n", state_o, (state)); \
+    } \
+  while (0)
+
+
+static acc_device_t acc_device_type;
+static int acc_device_num;
+static int num_gangs, num_workers, vector_length;
+
+
+static void cb_enqueue_launch_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (acc_device_type != acc_device_host);
+
+  assert (state == 0);
+  STATE_OP (state, = 1);
+
+  assert (prof_info->event_type == acc_ev_enqueue_launch_start);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async_sync);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->launch_event.event_type == prof_info->event_type);
+  assert (event_info->launch_event.valid_bytes == _ACC_LAUNCH_EVENT_INFO_VALID_BYTES);
+  assert (event_info->launch_event.parent_construct == acc_construct_parallel);
+  assert (event_info->launch_event.implicit == 1);
+  assert (event_info->launch_event.tool_info == NULL);
+  assert (event_info->launch_event.kernel_name != NULL);
+  {
+    const char *s = strstr (event_info->launch_event.kernel_name, "main");
+    assert (s != NULL);
+    s = strstr (s, "omp_fn");
+    assert (s != NULL);
+  }
+  if (num_gangs < 1)
+    assert (event_info->launch_event.num_gangs >= 1);
+  else
+    {
+#ifdef __OPTIMIZE__
+      assert (event_info->launch_event.num_gangs == num_gangs);
+#else
+      /* No parallelized OpenACC 'kernels' constructs.  Unparallelized OpenACC
+	 'kernels' constructs must get launched as 1 x 1 x 1 GPU kernels.  */
+      assert (event_info->launch_event.num_gangs == 1);
+#endif
+    }
+  if (num_workers < 1)
+    assert (event_info->launch_event.num_workers >= 1);
+  else
+    {
+#ifdef __OPTIMIZE__
+      assert (event_info->launch_event.num_workers == num_workers);
+#else
+      /* See 'num_gangs' above.  */
+      assert (event_info->launch_event.num_workers == 1);
+#endif
+    }
+  if (vector_length < 1)
+    assert (event_info->launch_event.vector_length >= 1);
+  else if (acc_device_type == acc_device_nvidia) /* ... is special.  */
+    assert (event_info->launch_event.vector_length == 32);
+  else if (acc_device_type == acc_device_gcn) /* ...and so is this.  */
+    assert (event_info->launch_event.vector_length == 64);
+  else
+    {
+#ifdef __OPTIMIZE__
+      assert (event_info->launch_event.vector_length == vector_length);
+#else
+      /* See 'num_gangs' above.  */
+      assert (event_info->launch_event.vector_length == 1);
+#endif
+    }
+
+  if (acc_device_type == acc_device_host)
+    assert (api_info->device_api == acc_device_api_none);
+  else if (acc_device_type == acc_device_gcn)
+    assert (api_info->device_api == acc_device_api_other);
+  else
+    assert (api_info->device_api == acc_device_api_cuda);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+}
+
+
+static acc_prof_reg reg;
+static acc_prof_reg unreg;
+static acc_prof_lookup_func lookup;
+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  reg = reg_;
+  unreg = unreg_;
+  lookup = lookup_;
+}
+
+
+int main()
+{
+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);
+
+  STATE_OP (state, = 0);
+  reg (acc_ev_enqueue_launch_start, cb_enqueue_launch_start, acc_reg);
+  assert (state == 0);
+
+  acc_device_type = acc_get_device_type ();
+  acc_device_num = acc_get_device_num (acc_device_type);
+  assert (state == 0);
+
+  /* Parallelism dimensions: compiler/runtime decides.  */
+  STATE_OP (state, = 0);
+  num_gangs = num_workers = vector_length = 0;
+  {
+#define N 100
+    int x[N];
+#pragma acc kernels
+    {
+      for (int i = 0; i < N; ++i)
+	x[i] = i * i;
+    }
+    if (acc_device_type == acc_device_host)
+      assert (state == 0); /* No 'acc_ev_enqueue_launch_start'.  */
+    else
+      assert (state == 1);
+    for (int i = 0; i < N; ++i)
+      if (x[i] != i * i)
+	__builtin_abort ();
+#undef N
+  }
+
+  /* Parallelism dimensions: literal.  */
+  STATE_OP (state, = 0);
+  num_gangs = 30;
+  num_workers = 3;
+  vector_length = 5;
+  {
+#define N 100
+    int x[N];
+#pragma acc kernels \
+  num_gangs (30) num_workers (3) vector_length (5)
+    /* { dg-prune-output "using vector_length \\(32\\), ignoring 5" } */
+    {
+      for (int i = 0; i < N; ++i)
+	x[i] = i * i;
+    }
+    if (acc_device_type == acc_device_host)
+      assert (state == 0); /* No 'acc_ev_enqueue_launch_start'.  */
+    else
+      assert (state == 1);
+    for (int i = 0; i < N; ++i)
+      if (x[i] != i * i)
+	__builtin_abort ();
+#undef N
+  }
+
+  /* Parallelism dimensions: variable.  */
+  STATE_OP (state, = 0);
+  num_gangs = 22;
+  num_workers = 5;
+  vector_length = 7;
+  {
+#define N 100
+    int x[N];
+#pragma acc kernels \
+  num_gangs (num_gangs) num_workers (num_workers) vector_length (vector_length)
+    /* { dg-prune-output "using vector_length \\(32\\), ignoring runtime setting" } */
+    {
+      for (int i = 0; i < N; ++i)
+	x[i] = i * i;
+    }
+    if (acc_device_type == acc_device_host)
+      assert (state == 0); /* No 'acc_ev_enqueue_launch_start'.  */
+    else
+      assert (state == 1);
+    for (int i = 0; i < N; ++i)
+      if (x[i] != i * i)
+	__builtin_abort ();
+#undef N
+  }
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c
new file mode 100644
index 00000000000..dc7c7582ce2
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c
@@ -0,0 +1,731 @@
+/* Test dispatch of events to callbacks.  */
+
+#undef NDEBUG
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <acc_prof.h>
+
+
+/* Use explicit 'copyin' clauses, to work around "'firstprivate'
+   optimizations", which will cause the value at the point of call to be used
+   (*before* any potential modifications done in callbacks), as opposed to its
+   address being taken, which then later gets dereferenced (*after* any
+   modifications done in callbacks).  */
+#define COPYIN(...) copyin(__VA_ARGS__)
+
+
+/* See the 'DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT' reference in
+   libgomp.texi.  */
+#define DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT 0
+
+
+/* Do we expect to see 'acc_ev_exit_data_start' and 'acc_ev_exit_data_end'
+   after a compute construct with an 'async' clause?  */
+#define ASYNC_EXIT_DATA 1
+
+
+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)
+
+
+static int state = -1;
+
+#define STATE_OP(state, op) \
+  do \
+    { \
+      typeof (state) state_o = (state); \
+      (void) state_o; \
+      (state)op; \
+      DEBUG_printf("state: %d -> %d\n", state_o, (state)); \
+    } \
+  while (0)
+
+
+static acc_device_t acc_device_type;
+static int acc_device_num;
+static int acc_async;
+
+
+struct tool_info
+{
+  acc_event_info event_info;
+  struct tool_info *nested;
+};
+struct tool_info *tool_info;
+
+static void cb_device_init_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT
+  assert (state == 1
+	  || state == 101);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested == NULL);
+  tool_info->nested = (struct tool_info *) malloc(sizeof *tool_info);
+  assert (tool_info->nested != NULL);
+  tool_info->nested->nested = NULL;
+#else
+  assert (state == 0
+	  || state == 100);
+  STATE_OP (state, ++);
+
+  assert (tool_info == NULL);
+  tool_info = (struct tool_info *) malloc(sizeof *tool_info);
+  assert (tool_info != NULL);
+  tool_info->nested = NULL;
+#endif
+
+  assert (prof_info->event_type == acc_ev_device_init_start);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_default);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async_sync);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 1);
+  assert (event_info->other_event.tool_info == NULL);
+
+  assert (api_info->device_api == acc_device_api_none);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT
+  tool_info->nested->event_info.other_event.event_type = event_info->other_event.event_type;
+  event_info->other_event.tool_info = tool_info->nested;
+#else
+  tool_info->event_info.other_event.event_type = event_info->other_event.event_type;
+  event_info->other_event.tool_info = tool_info;
+#endif
+}
+
+static void cb_device_init_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT
+  assert (state == 2
+	  || state == 102);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested != NULL);
+  assert (tool_info->nested->event_info.other_event.event_type == acc_ev_device_init_start);
+#else
+  assert (state == 1
+	  || state == 101);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_device_init_start);
+#endif
+
+  assert (prof_info->event_type == acc_ev_device_init_end);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_default);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async_sync);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 1);
+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT
+  assert (event_info->other_event.tool_info == tool_info->nested);
+#else
+  assert (event_info->other_event.tool_info == tool_info);
+#endif
+
+  assert (api_info->device_api == acc_device_api_none);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT
+  free (tool_info->nested);
+  tool_info->nested = NULL;
+#else
+  free (tool_info);
+  tool_info = NULL;
+#endif
+}
+
+static void cb_enter_data_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 3
+	  || state == 103);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested == NULL);
+  tool_info->nested = (struct tool_info *) malloc(sizeof *tool_info);
+  assert (tool_info->nested != NULL);
+  tool_info->nested->nested = NULL;
+
+  assert (prof_info->event_type == acc_ev_enter_data_start);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 1);
+  assert (event_info->other_event.tool_info == NULL);
+
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  tool_info->nested->event_info.other_event.event_type = event_info->other_event.event_type;
+  event_info->other_event.tool_info = tool_info->nested;
+}
+
+static void cb_enter_data_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 4
+	  || state == 104);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested != NULL);
+  assert (tool_info->nested->event_info.other_event.event_type == acc_ev_enter_data_start);
+
+  assert (prof_info->event_type == acc_ev_enter_data_end);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 1);
+  assert (event_info->other_event.tool_info == tool_info->nested);
+
+  if (acc_device_type == acc_device_host)
+    assert (api_info->device_api == acc_device_api_none);
+  else if (acc_device_type == acc_device_gcn)
+    assert (api_info->device_api == acc_device_api_other);
+  else
+    assert (api_info->device_api == acc_device_api_cuda);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  free (tool_info->nested);
+  tool_info->nested = NULL;
+}
+
+static void cb_exit_data_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 7
+#if ASYNC_EXIT_DATA
+	  || state == 107
+#endif
+	  );
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested == NULL);
+  tool_info->nested = (struct tool_info *) malloc(sizeof *tool_info);
+  assert (tool_info->nested != NULL);
+  tool_info->nested->nested = NULL;
+
+  assert (prof_info->event_type == acc_ev_exit_data_start);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 1);
+  assert (event_info->other_event.tool_info == NULL);
+
+  if (acc_device_type == acc_device_host)
+    assert (api_info->device_api == acc_device_api_none);
+  else if (acc_device_type == acc_device_gcn)
+    assert (api_info->device_api == acc_device_api_other);
+  else
+    assert (api_info->device_api == acc_device_api_cuda);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  tool_info->nested->event_info.other_event.event_type = event_info->other_event.event_type;
+  event_info->other_event.tool_info = tool_info->nested;
+}
+
+static void cb_exit_data_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (state == 8
+#if ASYNC_EXIT_DATA
+	  || state == 108
+#endif
+	  );
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested != NULL);
+  assert (tool_info->nested->event_info.other_event.event_type == acc_ev_exit_data_start);
+
+  assert (prof_info->event_type == acc_ev_exit_data_end);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 1);
+  assert (event_info->other_event.tool_info == tool_info->nested);
+
+  if (acc_device_type == acc_device_host)
+    assert (api_info->device_api == acc_device_api_none);
+  else if (acc_device_type == acc_device_gcn)
+    assert (api_info->device_api == acc_device_api_other);
+  else
+    assert (api_info->device_api == acc_device_api_cuda);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  free (tool_info->nested);
+  tool_info->nested = NULL;
+}
+
+static void cb_compute_construct_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT
+  assert (state == 0
+	  || state == 100);
+  if (state == 100)
+    {
+      /* Compensate for the missing 'acc_ev_device_init_start' and
+	 'acc_ev_device_init_end'.  */
+      state += 2;
+    }
+#else
+  if (state == 100)
+    {
+      /* Compensate for the missing 'acc_ev_device_init_start' and
+	 'acc_ev_device_init_end'.  */
+      state += 2;
+    }
+  assert (state == 2
+	  || state == 102);
+#endif
+  STATE_OP (state, ++);
+
+  assert (tool_info == NULL);
+  tool_info = (struct tool_info *) malloc(sizeof *tool_info);
+  assert (tool_info != NULL);
+  tool_info->nested = NULL;
+
+  assert (prof_info->event_type == acc_ev_compute_construct_start);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == /* TODO acc_async */ acc_async_sync);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 0);
+  assert (event_info->other_event.tool_info == NULL);
+
+  assert (api_info->device_api == acc_device_api_none);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  tool_info->event_info.other_event.event_type = event_info->other_event.event_type;
+  event_info->other_event.tool_info = tool_info;
+
+  if (acc_device_type == acc_device_host)
+    {
+      /* Compensate for the missing 'acc_ev_enter_data_start'.  */
+      state += 1;
+    }
+}
+
+static void cb_compute_construct_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  if (acc_device_type == acc_device_host)
+    {
+      /* Compensate for the missing 'acc_ev_enter_data_end'.  */
+      state += 1;
+      /* Compensate for the missing 'acc_ev_enqueue_launch_start' and
+	 'acc_ev_enqueue_launch_end'.  */
+      state += 2;
+      /* Compensate for the missing 'acc_ev_exit_data_start' and
+	 'acc_ev_exit_data_end'.  */
+      state += 2;
+    }
+#if !ASYNC_EXIT_DATA
+  else if (acc_async != acc_async_sync)
+    {
+      /* Compensate for the missing 'acc_ev_exit_data_start' and
+	 'acc_ev_exit_data_end'.  */
+      state += 2;
+    }
+#endif
+  assert (state == 9
+	  || state == 109);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested == NULL);
+
+  assert (prof_info->event_type == acc_ev_compute_construct_end);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  if (acc_device_type == acc_device_host)
+    assert (prof_info->async == acc_async_sync);
+  else
+    assert (prof_info->async == acc_async);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->other_event.event_type == prof_info->event_type);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (event_info->other_event.parent_construct == acc_construct_parallel);
+  assert (event_info->other_event.implicit == 0);
+  assert (event_info->other_event.tool_info == tool_info);
+
+  if (acc_device_type == acc_device_host)
+    assert (api_info->device_api == acc_device_api_none);
+  else if (acc_device_type == acc_device_gcn)
+    assert (api_info->device_api == acc_device_api_other);
+  else
+    assert (api_info->device_api == acc_device_api_cuda);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  free (tool_info);
+  tool_info = NULL;
+}
+
+static void cb_enqueue_launch_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (acc_device_type != acc_device_host);
+
+  assert (state == 5
+	  || state == 105);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested == NULL);
+  tool_info->nested = (struct tool_info *) malloc(sizeof *tool_info);
+  assert (tool_info->nested != NULL);
+  tool_info->nested->nested = NULL;
+
+  assert (prof_info->event_type == acc_ev_enqueue_launch_start);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->launch_event.event_type == prof_info->event_type);
+  assert (event_info->launch_event.valid_bytes == _ACC_LAUNCH_EVENT_INFO_VALID_BYTES);
+  assert (event_info->launch_event.parent_construct == acc_construct_parallel);
+  assert (event_info->launch_event.implicit == 1);
+  assert (event_info->launch_event.tool_info == NULL);
+  assert (event_info->launch_event.kernel_name != NULL);
+  {
+    const char *s = strstr (event_info->launch_event.kernel_name, "main");
+    assert (s != NULL);
+    s = strstr (s, "omp_fn");
+    assert (s != NULL);
+  }
+  assert (event_info->launch_event.num_gangs >= 1);
+  assert (event_info->launch_event.num_workers >= 1);
+  assert (event_info->launch_event.vector_length >= 1);
+
+  if (acc_device_type == acc_device_host)
+    assert (api_info->device_api == acc_device_api_none);
+  else if (acc_device_type == acc_device_gcn)
+    assert (api_info->device_api == acc_device_api_other);
+  else
+    assert (api_info->device_api == acc_device_api_cuda);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  tool_info->nested->event_info.launch_event.event_type = event_info->launch_event.event_type;
+  tool_info->nested->event_info.launch_event.kernel_name = strdup (event_info->launch_event.kernel_name);
+  tool_info->nested->event_info.launch_event.num_gangs = event_info->launch_event.num_gangs;
+  tool_info->nested->event_info.launch_event.num_workers = event_info->launch_event.num_workers;
+  tool_info->nested->event_info.launch_event.vector_length = event_info->launch_event.vector_length;
+  event_info->other_event.tool_info = tool_info->nested;
+}
+
+static void cb_enqueue_launch_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  assert (acc_device_type != acc_device_host);
+
+  assert (state == 6
+	  || state == 106);
+  STATE_OP (state, ++);
+
+  assert (tool_info != NULL);
+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);
+  assert (tool_info->nested != NULL);
+  assert (tool_info->nested->event_info.launch_event.event_type == acc_ev_enqueue_launch_start);
+  assert (tool_info->nested->event_info.launch_event.kernel_name != NULL);
+  assert (tool_info->nested->event_info.launch_event.num_gangs >= 1);
+  assert (tool_info->nested->event_info.launch_event.num_workers >= 1);
+  assert (tool_info->nested->event_info.launch_event.vector_length >= 1);
+
+  assert (prof_info->event_type == acc_ev_enqueue_launch_end);
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);
+  assert (prof_info->device_type == acc_device_type);
+  assert (prof_info->device_number == acc_device_num);
+  assert (prof_info->thread_id == -1);
+  assert (prof_info->async == acc_async);
+  assert (prof_info->async_queue == prof_info->async);
+  assert (prof_info->src_file == NULL);
+  assert (prof_info->func_name == NULL);
+  assert (prof_info->line_no == -1);
+  assert (prof_info->end_line_no == -1);
+  assert (prof_info->func_line_no == -1);
+  assert (prof_info->func_end_line_no == -1);
+
+  assert (event_info->launch_event.event_type == prof_info->event_type);
+  assert (event_info->launch_event.valid_bytes == _ACC_LAUNCH_EVENT_INFO_VALID_BYTES);
+  assert (event_info->launch_event.parent_construct == acc_construct_parallel);
+  assert (event_info->launch_event.implicit == 1);
+  assert (event_info->launch_event.tool_info == tool_info->nested);
+  assert (event_info->launch_event.kernel_name != NULL);
+  assert (strcmp (event_info->launch_event.kernel_name, tool_info->nested->event_info.launch_event.kernel_name) == 0);
+  assert (event_info->launch_event.num_gangs == tool_info->nested->event_info.launch_event.num_gangs);
+  assert (event_info->launch_event.num_workers == tool_info->nested->event_info.launch_event.num_workers);
+  assert (event_info->launch_event.vector_length == tool_info->nested->event_info.launch_event.vector_length);
+
+  if (acc_device_type == acc_device_host)
+    assert (api_info->device_api == acc_device_api_none);
+  else if (acc_device_type == acc_device_gcn)
+    assert (api_info->device_api == acc_device_api_other);
+  else
+    assert (api_info->device_api == acc_device_api_cuda);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+  assert (api_info->device_type == prof_info->device_type);
+  assert (api_info->vendor == -1);
+  assert (api_info->device_handle == NULL);
+  assert (api_info->context_handle == NULL);
+  assert (api_info->async_handle == NULL);
+
+  free ((void *) tool_info->nested->event_info.launch_event.kernel_name);
+  free (tool_info->nested);
+  tool_info->nested = NULL;
+}
+
+
+static acc_prof_reg reg;
+static acc_prof_reg unreg;
+static acc_prof_lookup_func lookup;
+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  reg = reg_;
+  unreg = unreg_;
+  lookup = lookup_;
+}
+
+
+int main()
+{
+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);
+
+  STATE_OP (state, = 0);
+  reg (acc_ev_device_init_start, cb_device_init_start, acc_reg);
+  reg (acc_ev_device_init_end, cb_device_init_end, acc_reg);
+  reg (acc_ev_enter_data_start, cb_enter_data_start, acc_reg);
+  reg (acc_ev_enter_data_end, cb_enter_data_end, acc_reg);
+  reg (acc_ev_exit_data_start, cb_exit_data_start, acc_reg);
+  reg (acc_ev_exit_data_end, cb_exit_data_end, acc_reg);
+  reg (acc_ev_compute_construct_start, cb_compute_construct_start, acc_reg);
+  reg (acc_ev_compute_construct_end, cb_compute_construct_end, acc_reg);
+  reg (acc_ev_enqueue_launch_start, cb_enqueue_launch_start, acc_reg);
+  reg (acc_ev_enqueue_launch_end, cb_enqueue_launch_end, acc_reg);
+  assert (state == 0);
+
+  acc_device_type = acc_get_device_type ();
+  acc_device_num = acc_get_device_num (acc_device_type);
+  acc_async = acc_async_sync;
+  assert (state == 0);
+
+  {
+    int state_init;
+#pragma acc parallel COPYIN(state) copyout(state_init)
+    {
+      asm volatile ("" : : : "memory"); // TODO PR90488
+
+      state_init = state;
+    }
+    assert (state_init == 4);
+  }
+  assert (state == 10);
+
+  STATE_OP (state, = 100);
+
+  acc_async = 12;
+  {
+    int state_init;
+#pragma acc parallel async(acc_async) COPYIN(state) copyout(state_init)
+    {
+      asm volatile ("" : : : "memory"); // TODO PR90488
+
+      state_init = state;
+    }
+#pragma acc wait
+    assert (state_init == 104);
+  }
+  assert (state == 110);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-valid_bytes-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-valid_bytes-1.c
new file mode 100644
index 00000000000..5b58c51d4c4
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-valid_bytes-1.c
@@ -0,0 +1,226 @@
+/* Test the 'valid_bytes' magic.  */
+
+#undef NDEBUG
+#include <assert.h>
+
+#include <acc_prof.h>
+
+
+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)
+
+
+static int ev_count_data;
+
+static void cb_data_event (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s %d\n", __FUNCTION__, prof_info->event_type);
+
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (event_info->data_event.valid_bytes == _ACC_DATA_EVENT_INFO_VALID_BYTES);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+
+  ++ev_count_data;
+}
+
+static int ev_count_launch;
+
+static void cb_launch_event (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s %d\n", __FUNCTION__, prof_info->event_type);
+
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (event_info->launch_event.valid_bytes == _ACC_LAUNCH_EVENT_INFO_VALID_BYTES);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+
+  ++ev_count_launch;
+}
+
+static int ev_count_other;
+
+static void cb_other_event (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s %d\n", __FUNCTION__, prof_info->event_type);
+
+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);
+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);
+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);
+
+  ++ev_count_other;
+}
+
+
+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  reg_ (acc_ev_device_init_start, cb_other_event, acc_reg);
+  reg_ (acc_ev_device_init_end, cb_other_event, acc_reg);
+  reg_ (acc_ev_device_shutdown_start, cb_other_event, acc_reg);
+  reg_ (acc_ev_device_shutdown_end, cb_other_event, acc_reg);
+  reg_ (acc_ev_runtime_shutdown, cb_other_event, acc_reg);
+  reg_ (acc_ev_create, cb_data_event, acc_reg);
+  reg_ (acc_ev_delete, cb_data_event, acc_reg);
+  reg_ (acc_ev_alloc, cb_data_event, acc_reg);
+  reg_ (acc_ev_free, cb_data_event, acc_reg);
+  reg_ (acc_ev_enter_data_start, cb_other_event, acc_reg);
+  reg_ (acc_ev_enter_data_end, cb_other_event, acc_reg);
+  reg_ (acc_ev_exit_data_start, cb_other_event, acc_reg);
+  reg_ (acc_ev_exit_data_end, cb_other_event, acc_reg);
+  reg_ (acc_ev_update_start, cb_other_event, acc_reg);
+  reg_ (acc_ev_update_end, cb_other_event, acc_reg);
+  reg_ (acc_ev_compute_construct_start, cb_other_event, acc_reg);
+  reg_ (acc_ev_compute_construct_end, cb_other_event, acc_reg);
+  reg_ (acc_ev_enqueue_launch_start, cb_launch_event, acc_reg);
+  reg_ (acc_ev_enqueue_launch_end, cb_launch_event, acc_reg);
+  reg_ (acc_ev_enqueue_upload_start, cb_data_event, acc_reg);
+  reg_ (acc_ev_enqueue_upload_end, cb_data_event, acc_reg);
+  reg_ (acc_ev_enqueue_download_start, cb_data_event, acc_reg);
+  reg_ (acc_ev_enqueue_download_end, cb_data_event, acc_reg);
+  reg_ (acc_ev_wait_start, cb_other_event, acc_reg);
+  reg_ (acc_ev_wait_end, cb_other_event, acc_reg);
+}
+
+
+/* Basic struct.  */
+typedef struct A
+{
+  int a;
+  int b;
+#define VALID_BYTES_A \
+  _ACC_PROF_VALID_BYTES_STRUCT (A, b, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (int))
+} A;
+
+/* Add a 'char' field.  */
+typedef struct B
+{
+  int a;
+  int b;
+  char c;
+#define VALID_BYTES_B \
+  _ACC_PROF_VALID_BYTES_STRUCT (B, c, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (char))
+} B;
+
+/* Add another 'char' field.  */
+typedef struct C
+{
+  int a;
+  int b;
+  char c, d;
+#define VALID_BYTES_C \
+  _ACC_PROF_VALID_BYTES_STRUCT (C, d, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (char))
+} C;
+
+/* Add two 'void *' fields.  */
+typedef struct D
+{
+  int a;
+  int b;
+  char c, d;
+  void *e;
+  void *f;
+#define VALID_BYTES_D \
+  _ACC_PROF_VALID_BYTES_STRUCT (D, f, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (void *))
+} D;
+
+/* Add another three 'char' fields.  */
+typedef struct E
+{
+  int a;
+  int b;
+  char c, d;
+  void *e;
+  void *f;
+  char g, h, i;
+#define VALID_BYTES_E \
+  _ACC_PROF_VALID_BYTES_STRUCT (E, i, \
+				_ACC_PROF_VALID_BYTES_BASICTYPE (char))
+} E;
+
+
+int main()
+{
+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);
+
+  A A1;
+  DEBUG_printf ("s=%zd, vb=%zd\n", sizeof A1, VALID_BYTES_A);
+  assert (VALID_BYTES_A <= sizeof A1);
+  DEBUG_printf ("&A1=%p, &A1.b=%p\n", &A1, &A1.b);
+  assert (((char *) &A1) + VALID_BYTES_A == (char *) (&A1.b + 1));
+
+  B B1;
+  DEBUG_printf ("s=%zd, vb=%zd\n", sizeof B1, VALID_BYTES_B);
+  assert (VALID_BYTES_B <= sizeof B1);
+  DEBUG_printf ("&B1=%p, &B1.c=%p\n", &B1, &B1.c);
+  assert (((char *) &B1) + VALID_BYTES_B == (char *) (&B1.c + 1));
+
+  assert (VALID_BYTES_B == VALID_BYTES_A + 1 * sizeof (char));
+
+  C C1;
+  DEBUG_printf ("s=%zd, vb=%zd\n", sizeof C1, VALID_BYTES_C);
+  assert (VALID_BYTES_C <= sizeof C1);
+  DEBUG_printf ("&C1=%p, &C1.d=%p\n", &C1, &C1.d);
+  assert (((char *) &C1) + VALID_BYTES_C == (char *) (&C1.d + 1));
+
+  assert (VALID_BYTES_C == VALID_BYTES_B + 1 * sizeof (char));
+
+  D D1;
+  DEBUG_printf ("s=%zd, vb=%zd\n", sizeof D1, VALID_BYTES_D);
+  assert (VALID_BYTES_D <= sizeof D1);
+  DEBUG_printf ("&D1=%p, &D1.f=%p\n", &D1, &D1.f);
+  assert (((char *) &D1) + VALID_BYTES_D == (char *) (&D1.f + 1));
+
+  assert (VALID_BYTES_D > VALID_BYTES_C);
+
+  E E1;
+  DEBUG_printf ("s=%zd, vb=%zd\n", sizeof E1, VALID_BYTES_E);
+  assert (VALID_BYTES_E <= sizeof E1);
+  DEBUG_printf ("&E1=%p, &E1.i=%p\n", &E1, &E1.i);
+  assert (((char *) &E1) + VALID_BYTES_E == (char *) (&E1.i + 1));
+
+  assert (VALID_BYTES_E == VALID_BYTES_D + 3 * sizeof (char));
+
+  ev_count_data = 0;
+  ev_count_launch = 0;
+  ev_count_other = 0;
+
+  /* Trigger tests done in 'cb_*' functions.  */
+  int host;
+#pragma acc parallel copyout (host)
+  {
+    asm volatile ("" : : : "memory"); // TODO PR90488
+
+    host = acc_on_device (acc_device_host);
+  }
+
+  DEBUG_printf ("ev_count_data = %d\n", ev_count_data);
+  if (host)
+    assert (ev_count_data == 0);
+  else
+    {
+      /* We don't know exactly how many data events to expect, but we at least
+	 expect some.  */
+      assert (ev_count_data > 0);
+    }
+
+  DEBUG_printf ("ev_count_launch = %d\n", ev_count_launch);
+  if (host)
+    assert (ev_count_data == 0);
+  else
+    {
+      /* We expect two launch events, 'acc_ev_enqueue_launch_start',
+	 'acc_ev_enqueue_launch_end'.  */
+      assert (ev_count_launch == 2);
+    }
+
+  DEBUG_printf ("ev_count_other = %d\n", ev_count_other);
+  /* We don't know exactly how many other events to expect, but we at least
+     expect 'acc_ev_device_init_start', 'acc_ev_device_init_end',
+     'acc_ev_compute_construct_start', 'acc_ev_compute_construct_end'.  */
+  assert (ev_count_other >= 4);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-version-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-version-1.c
new file mode 100644
index 00000000000..f5378687167
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-version-1.c
@@ -0,0 +1,76 @@
+/* Test the 'version' field of 'acc_prof_info'.  */
+
+#undef NDEBUG
+#include <assert.h>
+
+#include <acc_prof.h>
+
+
+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)
+
+
+static int ev_count;
+
+
+static void cb_any_event (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  DEBUG_printf ("%s %d\n", __FUNCTION__, prof_info->event_type);
+
+  assert (prof_info->version == 201711);
+
+  ++ev_count;
+}
+
+
+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)
+{
+  DEBUG_printf ("%s\n", __FUNCTION__);
+
+  reg_ (acc_ev_device_init_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_device_init_end, cb_any_event, acc_reg);
+  reg_ (acc_ev_device_shutdown_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_device_shutdown_end, cb_any_event, acc_reg);
+  reg_ (acc_ev_runtime_shutdown, cb_any_event, acc_reg);
+  reg_ (acc_ev_create, cb_any_event, acc_reg);
+  reg_ (acc_ev_delete, cb_any_event, acc_reg);
+  reg_ (acc_ev_alloc, cb_any_event, acc_reg);
+  reg_ (acc_ev_free, cb_any_event, acc_reg);
+  reg_ (acc_ev_enter_data_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_enter_data_end, cb_any_event, acc_reg);
+  reg_ (acc_ev_exit_data_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_exit_data_end, cb_any_event, acc_reg);
+  reg_ (acc_ev_update_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_update_end, cb_any_event, acc_reg);
+  reg_ (acc_ev_compute_construct_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_compute_construct_end, cb_any_event, acc_reg);
+  reg_ (acc_ev_enqueue_launch_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_enqueue_launch_end, cb_any_event, acc_reg);
+  reg_ (acc_ev_enqueue_upload_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_enqueue_upload_end, cb_any_event, acc_reg);
+  reg_ (acc_ev_enqueue_download_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_enqueue_download_end, cb_any_event, acc_reg);
+  reg_ (acc_ev_wait_start, cb_any_event, acc_reg);
+  reg_ (acc_ev_wait_end, cb_any_event, acc_reg);
+}
+
+
+int main()
+{
+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);
+
+  ev_count = 0;
+
+  /* Trigger tests done in 'cb_*' functions.  */
+#pragma acc parallel
+  {
+    asm volatile ("" : : : "memory"); // TODO PR90488
+  }
+
+  DEBUG_printf ("ev_count = %d\n", ev_count);
+  /* We don't know exactly how many events to expect, but we at least expect
+     'acc_ev_device_init_start', 'acc_ev_device_init_end',
+     'acc_ev_compute_construct_start', 'acc_ev_compute_construct_end'.  */
+  assert (ev_count >= 4);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-1.c
new file mode 100644
index 00000000000..d7ae59dd548
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-1.c
@@ -0,0 +1,27 @@
+/* Verify that we refuse 'acc_unmap_data', after 'acc_create'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 101;
+
+  char *h = (char *) malloc (N);
+  void *d = acc_create (h, N - 3);
+  if (!d)
+    abort ();
+
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_unmap_data (h);
+
+  return 0;
+}
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
+/* { dg-output "refusing to unmap block \\\[\[0-9a-fA-FxX\]+,\\\+98\\\] that has not been mapped by 'acc_map_data'" } */
+/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-2.c
new file mode 100644
index 00000000000..751e6ebc33f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-2.c
@@ -0,0 +1,25 @@
+/* Verify that we refuse 'acc_unmap_data', after '#pragma acc enter data create'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 101;
+
+  char *h = (char *) malloc (N);
+#pragma acc enter data create (h[0:N - 77])
+
+  fprintf (stderr, "CheCKpOInT\n");
+  acc_unmap_data (h);
+
+  return 0;
+}
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
+/* { dg-output "refusing to unmap block \\\[\[0-9a-fA-FxX\]+,\\\+24\\\] that has not been mapped by 'acc_map_data'" } */
+/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-3.c
new file mode 100644
index 00000000000..915a2705ea9
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/acc_unmap_data-pr92840-3.c
@@ -0,0 +1,26 @@
+/* Verify that we refuse 'acc_unmap_data', inside 'data'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 101;
+
+  char *h = (char *) malloc (N);
+#pragma acc data create (h[0:N - 55])
+  {
+    fprintf (stderr, "CheCKpOInT\n");
+    acc_unmap_data (h);
+  }
+
+  return 0;
+}
+
+/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
+/* { dg-output "refusing to unmap block \\\[\[0-9a-fA-FxX\]+,\\\+46\\\] that has not been mapped by 'acc_map_data'" } */
+/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/async_queue-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/async_queue-1.c
index 544b19fe663..4f9e53da85d 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/async_queue-1.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/async_queue-1.c
@@ -1,3 +1,5 @@
+/* { dg-do run { target openacc_nvidia_accel_selected } } */
+
 /* Test mapping of async values to specific underlying queues.  */
 
 #undef NDEBUG
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/asyncwait-nop-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/asyncwait-nop-1.c
index 4ab67363ba6..840052fec12 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/asyncwait-nop-1.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/asyncwait-nop-1.c
@@ -26,6 +26,8 @@ main ()
   acc_device_t d;
 #if defined ACC_DEVICE_TYPE_nvidia
   d = acc_device_nvidia;
+#elif defined ACC_DEVICE_TYPE_gcn
+  d = acc_device_gcn;
 #elif defined ACC_DEVICE_TYPE_host
   d = acc_device_host;
 #else
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-1.c
index 410c46cc651..8f01d5f32f8 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-1.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-1.c
@@ -103,7 +103,10 @@ main (int argc, char **argv)
     if (acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
 
-    acc_free (d);
+    acc_delete (&a[0], N * sizeof (float));
+
+    if (acc_is_present (&a[0], N * sizeof (float)))
+      abort ();
 
     for (i = 0; i < N; i++)
     {
@@ -162,7 +165,7 @@ main (int argc, char **argv)
     if (!acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
 
-    acc_free (d);
+    acc_delete (&b[0], N * sizeof (float));
 
     if (acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
@@ -266,13 +269,15 @@ main (int argc, char **argv)
     if (!acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
 
-    d = (float *) acc_deviceptr (&a[0]);
-    acc_unmap_data (&a[0]);
-    acc_free (d);
+    acc_delete (&a[0], N * sizeof (float));
 
-    d = (float *) acc_deviceptr (&b[0]);
-    acc_unmap_data (&b[0]);
-    acc_free (d);
+    if (acc_is_present (&a[0], N * sizeof (float)))
+      abort ();
+
+    acc_delete (&b[0], N * sizeof (float));
+
+    if (acc_is_present (&b[0], N * sizeof (float)))
+      abort ();
 
     for (i = 0; i < N; i++)
     {
@@ -464,7 +469,9 @@ main (int argc, char **argv)
     if (!acc_is_present (c, (N * sizeof (float))))
       abort ();
 
-    acc_copyout (b, N * sizeof (float));
+    d = (float *) acc_deviceptr (b);
+
+    acc_memcpy_from_device (b, d, N * sizeof (float));
 
     for (i = 0; i < N; i++)
     {
@@ -475,9 +482,17 @@ main (int argc, char **argv)
             abort ();
     }
 
-    d = (float *) acc_deviceptr (a);
+    acc_delete (a, N * sizeof (float));
 
-    acc_unmap_data (a);
+    if (acc_is_present (a, N * sizeof (float)))
+      abort ();
+
+    d = (float *) acc_deviceptr (b);
+
+    acc_unmap_data (b);
+
+    if (acc_is_present (b, N * sizeof (float)))
+      abort ();
 
     acc_free (d);
 
@@ -485,6 +500,9 @@ main (int argc, char **argv)
 
     acc_unmap_data (c);
 
+    if (acc_is_present (c, N * sizeof (float)))
+      abort ();
+
     acc_free (d);
 
     for (i = 0; i < N; i++)
@@ -556,7 +574,10 @@ main (int argc, char **argv)
     if (acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
 
-    acc_free (d);
+    acc_delete (&a[0], N * sizeof (float));
+
+    if (acc_is_present (&a[0], N * sizeof (float)))
+      abort ();
 
     for (i = 0; i < N; i++)
     {
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/context-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/context-1.c
index dabc7063c68..2e3b62ebbd2 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/context-1.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/context-1.c
@@ -172,13 +172,13 @@ main (int argc, char **argv)
         exit (EXIT_FAILURE);
     }
 
+    acc_delete (&h_X[0], N * sizeof (float));
+    acc_delete (&h_Y1[0], N * sizeof (float));
+
     free (h_X);
     free (h_Y1);
     free (h_Y2);
 
-    acc_free (d_X);
-    acc_free (d_Y);
-
     context_check (pctx);
 
     s = cublasDestroy (h);
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/context-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/context-2.c
index 6a52f746dcb..6bdcfe7d429 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/context-2.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/context-2.c
@@ -182,13 +182,13 @@ main (int argc, char **argv)
         exit (EXIT_FAILURE);
     }
 
+    acc_delete (&h_X[0], N * sizeof (float));
+    acc_delete (&h_Y1[0], N * sizeof (float));
+
     free (h_X);
     free (h_Y1);
     free (h_Y2);
 
-    acc_free (d_X);
-    acc_free (d_Y);
-
     context_check (pctx);
 
     s = cublasDestroy (h);
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/context-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/context-3.c
index ccd276cd98f..8f14560ea8b 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/context-3.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/context-3.c
@@ -163,13 +163,13 @@ main (int argc, char **argv)
         exit (EXIT_FAILURE);
     }
 
+    acc_delete (&h_X[0], N * sizeof (float));
+    acc_delete (&h_Y1[0], N * sizeof (float));
+
     free (h_X);
     free (h_Y1);
     free (h_Y2);
 
-    acc_free (d_X);
-    acc_free (d_Y);
-
     context_check (pctx);
 
     s = cublasDestroy (h);
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/context-4.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/context-4.c
index 71365e8ed32..b403a5cf5cb 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/context-4.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/context-4.c
@@ -176,13 +176,13 @@ main (int argc, char **argv)
         exit (EXIT_FAILURE);
     }
 
+    acc_delete (&h_X[0], N * sizeof (float));
+    acc_delete (&h_Y1[0], N * sizeof (float));
+
     free (h_X);
     free (h_Y1);
     free (h_Y2);
 
-    acc_free (d_X);
-    acc_free (d_Y);
-
     context_check (pctx);
 
     s = cublasDestroy (h);
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/data-firstprivate-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/data-firstprivate-1.c
new file mode 100644
index 00000000000..8900a4e070d
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/data-firstprivate-1.c
@@ -0,0 +1,165 @@
+/* Test behavior of 'firstprivate' lexically vs. dynamically nested inside a
+   'data' region.  */
+
+#include <stdlib.h>
+
+
+#define VERIFY(x) \
+  do { \
+    if (!(x)) \
+      abort (); \
+  } while (0);
+
+
+/* This is basically and extended version of 't2' from 'firstprivate-1.c'.  */
+
+int lexically_nested_val = 2;
+
+static void
+lexically_nested ()
+{
+#pragma acc data \
+  copy (lexically_nested_val)
+  {
+    VERIFY (lexically_nested_val == 2);
+
+#pragma acc parallel \
+  present (lexically_nested_val)
+    {
+      VERIFY (lexically_nested_val == 2);
+
+      /* This updates the device copy, or shared variable.  */
+      lexically_nested_val = 7;
+    }
+
+#if ACC_MEM_SHARED
+    VERIFY (lexically_nested_val == 7);
+#else
+    VERIFY (lexically_nested_val == 2);
+#endif
+
+    /* This only updates the local/shared variable, but not the device
+       copy.  */
+    lexically_nested_val = 5;
+
+#pragma acc parallel \
+    firstprivate (lexically_nested_val)
+      {
+#if 1 /* Current behavior.  */
+	/* The 'firstprivate' copy is initialized from the device copy, or
+	   shared variable.  */
+# if ACC_MEM_SHARED
+	VERIFY (lexically_nested_val == 5);
+# else
+	VERIFY (lexically_nested_val == 7);
+# endif
+#else /* Expected behavior per PR92036.  */
+	/* The 'firstprivate' copy is initialized from the local thread.  */
+	VERIFY (lexically_nested_val == 5);
+#endif
+
+	/* This updates the 'firstprivate' copy only, but not the shared
+	   variable.  */
+	lexically_nested_val = 9;
+      }
+
+    VERIFY (lexically_nested_val == 5);
+  }
+  /* If not shared, the device copy has now been copied back.  */
+
+#if ACC_MEM_SHARED
+  VERIFY (lexically_nested_val == 5);
+#else
+  VERIFY (lexically_nested_val == 7);
+#endif
+}
+
+
+int dynamically_nested_val = 2;
+
+/* Same as above, but compute construct 1 broken out, so no longer lexically
+   nested inside 'data' region.  */
+
+static void
+dynamically_nested_compute_1 ()
+{
+#pragma acc parallel \
+  present (dynamically_nested_val)
+  {
+    VERIFY (dynamically_nested_val == 2);
+
+    /* This updates the device copy, or shared variable.  */
+    dynamically_nested_val = 7;
+  }
+}
+
+/* Same as above, but compute construct 2 broken out, so no longer lexically
+   nested inside 'data' region.  */
+
+static void
+dynamically_nested_compute_2 ()
+{
+#pragma acc parallel \
+  firstprivate (dynamically_nested_val)
+    {
+#if 1 /* Current behavior.  */
+      /* The 'firstprivate' copy is initialized from the device copy, or shared
+	 variable.  */
+# if ACC_MEM_SHARED
+      VERIFY (dynamically_nested_val == 5);
+# else
+      VERIFY (dynamically_nested_val == 7);
+# endif
+#else /* Expected behavior per PR92036.  */
+      /* The 'firstprivate' copy is initialized from the local thread.  */
+      VERIFY (dynamically_nested_val == 5);
+#endif
+
+      /* This updates the 'firstprivate' copy only, but not the shared
+	 variable.  */
+      dynamically_nested_val = 9;
+    }
+}
+
+static void
+dynamically_nested ()
+{
+#pragma acc data \
+  copy (dynamically_nested_val)
+  {
+    VERIFY (dynamically_nested_val == 2);
+
+    dynamically_nested_compute_1 ();
+
+#if ACC_MEM_SHARED
+    VERIFY (dynamically_nested_val == 7);
+#else
+    VERIFY (dynamically_nested_val == 2);
+#endif
+
+    /* This only updates the local/shared variable, but not the device
+       copy.  */
+    dynamically_nested_val = 5;
+
+    dynamically_nested_compute_2 ();
+
+    VERIFY (dynamically_nested_val == 5);
+  }
+  /* If not shared, the device copy has now been copied back.  */
+
+#if ACC_MEM_SHARED
+  VERIFY (dynamically_nested_val == 5);
+#else
+  VERIFY (dynamically_nested_val == 7);
+#endif
+}
+
+
+int
+main()
+{
+  lexically_nested ();
+  dynamically_nested ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/declare-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/declare-1.c
index bc726174252..087b9545692 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/declare-1.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/declare-1.c
@@ -1,6 +1,5 @@
 #include <openacc.h>
 #include <stdlib.h>
-#include <stdio.h>
 
 #define N 8
 
@@ -39,14 +38,14 @@ subr1 (int *a)
   }
 }
 
-int b[8];
+int b[N];
 #pragma acc declare create (b)
 
-int d[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
+int d[N] = { 1, 2, 3, 4, 5, 6, 7, 8 };
 #pragma acc declare copyin (d)
 
-int
-main (int argc, char **argv)
+static void
+f (void)
 {
   int a[N];
   int e[N];
@@ -110,11 +109,98 @@ main (int argc, char **argv)
 
   subr2 (&a[0]);
 
-  for (i = 0; i < 1; i++)
+  for (i = 0; i < N; i++)
     {
       if (a[i] != 1234 * 6)
 	abort ();
     }
+}
+
+
+/* The same as 'f' but everything contained in an OpenACC 'data' construct.  */
+
+static void
+f_data (void)
+{
+#pragma acc data
+  {
+    int a[N];
+    int e[N];
+# pragma acc declare create (e)
+    int i;
+
+    for (i = 0; i < N; i++)
+      a[i] = i + 1;
+
+    if (!acc_is_present (&b, sizeof (b)))
+      abort ();
+
+    if (!acc_is_present (&d, sizeof (d)))
+      abort ();
+
+    if (!acc_is_present (&e, sizeof (e)))
+      abort ();
+
+# pragma acc parallel copyin (a[0:N])
+    {
+      for (i = 0; i < N; i++)
+	{
+	  b[i] = a[i];
+	  a[i] = b[i];
+	}
+    }
+
+    for (i = 0; i < N; i++)
+      {
+	if (a[i] != i + 1)
+	  abort ();
+      }
+
+# pragma acc parallel copy (a[0:N])
+    {
+      for (i = 0; i < N; i++)
+	{
+	  e[i] = a[i] + d[i];
+	  a[i] = e[i];
+	}
+    }
+
+    for (i = 0; i < N; i++)
+      {
+	if (a[i] != (i + 1) * 2)
+	  abort ();
+      }
+
+    for (i = 0; i < N; i++)
+      {
+	a[i] = 1234;
+      }
+
+    subr1 (&a[0]);
+
+    for (i = 0; i < N; i++)
+      {
+	if (a[i] != 1234 * 2)
+	  abort ();
+      }
+
+    subr2 (&a[0]);
+
+    for (i = 0; i < N; i++)
+      {
+	if (a[i] != 1234 * 6)
+	  abort ();
+      }
+  }
+}
+
+
+int
+main (int argc, char **argv)
+{
+  f ();
+
+  f_data ();
 
   return 0;
 }
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla.c
index 3ea148ed40d..0f51badca42 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla.c
@@ -1,9 +1,10 @@
-/* Verify that acc declare accept VLA variables.  */
+/* Verify OpenACC 'declare' with VLAs.  */
 
 #include <assert.h>
 
-int
-main ()
+
+void
+f (void)
 {
   int N = 1000;
   int i, A[N];
@@ -20,6 +21,46 @@ main ()
 
   for (i = 0; i < N; i++)
     assert (A[i] == i);
+}
+
+
+/* The same as 'f' but everything contained in an OpenACC 'data' construct.  */
+
+void
+f_data (void)
+{
+#pragma acc data
+  {
+    int N = 1000;
+    int i, A[N];
+# pragma acc declare copy(A)
+
+    for (i = 0; i < N; i++)
+      A[i] = -i;
+
+# pragma acc kernels
+    for (i = 0; i < N; i++)
+      A[i] = i;
+
+# pragma acc update host(A)
+
+    for (i = 0; i < N; i++)
+      assert (A[i] == i);
+  }
+}
+
+
+int
+main ()
+{
+  f ();
+
+  f_data ();
 
   return 0;
 }
+
+
+/* { dg-xfail-run-if "TODO PR90861" { *-*-* } { "-DACC_MEM_SHARED=0" } }
+   This might XPASS if the compiler happens to put the two 'A' VLAs at the same
+   address.  */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/enter_exit-lib.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/enter_exit-lib.c
index b5b37b2893f..f86af75beaa 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/enter_exit-lib.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/enter_exit-lib.c
@@ -1,4 +1,4 @@
-/* Verify enter/exit data interoperablilty between pragmas and
+/* Verify enter/exit data interoperability between pragmas and
    acc library calls.  */
 
 /* { dg-do run } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/firstprivate-mappings-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/firstprivate-mappings-1.c
new file mode 100644
index 00000000000..4a8b310414c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/firstprivate-mappings-1.c
@@ -0,0 +1,6 @@
+/* Verify OpenACC 'firstprivate' mappings.  */
+
+/* { dg-additional-options "-Wno-psabi" } as apparently we're doing funny
+   things with vector arguments.  */
+
+#include "../../../gcc/testsuite/c-c++-common/goacc/firstprivate-mappings-1.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/function-not-offloaded.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/function-not-offloaded.c
index fdf4eb08f8a..517004a562d 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/function-not-offloaded.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/function-not-offloaded.c
@@ -1,11 +1,11 @@
 /* { dg-do link } */
-/* { dg-excess-errors "lto1, mkoffload and lto-wrapper fatal errors" { target openacc_nvidia_accel_selected } } */
+/* { dg-excess-errors "lto1, mkoffload and lto-wrapper fatal errors" { target { openacc_nvidia_accel_selected || openacc_amdgcn_accel_selected } } } */
 
 int var;
 #pragma acc declare create (var)
 
 void __attribute__((noinline, noclone))
-foo () /* { dg-error "function 'foo' has been referenced in offloaded code but hasn't been marked to be included in the offloaded code" "" { target openacc_nvidia_accel_selected } } */
+foo () /* { dg-error "function 'foo' has been referenced in offloaded code but hasn't been marked to be included in the offloaded code" "" { target { openacc_nvidia_accel_selected || openacc_amdgcn_accel_selected } } } */
 {
   var++;
 }
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/host_data-6.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/host_data-6.c
new file mode 100644
index 00000000000..1cda442b001
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/host_data-6.c
@@ -0,0 +1,47 @@
+/* Call 'acc_memcpy_from_device' inside '#pragma acc host_data'.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int SIZE = 318;
+  const int c0 = 22;
+  const int c1 = 112;
+
+  char *h = (char *) malloc (SIZE);
+
+  memset (h, c0, SIZE);
+
+#pragma acc data create (h[0:SIZE - 44])
+  {
+#pragma acc update device (h[0:SIZE - 44])
+
+    memset (h, c1, 67);
+
+    void *d = h;
+#pragma acc host_data use_device (d)
+    {
+      acc_memcpy_from_device (h, d, 12);
+    }
+  }
+
+  for (int i = 0; i < SIZE; ++i)
+    {
+      if (i < 12)
+	assert (h[i] == c0);
+      else if (i < 67)
+	assert (h[i] == c1);
+      else
+	assert (h[i] == c0);
+    }
+
+  free (h);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-13.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-13.c
index d6655335e21..aca4c252091 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-13.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-13.c
@@ -51,7 +51,7 @@ main (int argc, char **argv)
   if (acc_is_present (h, 0) != 0)
     abort ();
 
-  acc_free (d);
+  acc_delete (h, N);
 
   if (acc_is_present (h, 1) != 0)
     abort ();
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-14.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-14.c
index ee21257c9a5..de6d38b060c 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-14.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-14.c
@@ -48,7 +48,7 @@ main (int argc, char **argv)
 	abort ();
     }
 
-  acc_free (d);
+  acc_delete (h, N);
 
   for (i = 0; i < N; i++)
     {
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-18.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-18.c
index b686cc94815..93bfb99f415 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-18.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-18.c
@@ -23,7 +23,7 @@ main (int argc, char **argv)
 
   d = acc_copyin (h, N);
 
-  acc_free (d);
+  acc_delete (h, N);
 
   fprintf (stderr, "CheCKpOInT\n");
   acc_copyout (h, N);
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-20.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-20.c
index 25ceb3a26af..10d3cbc5cc6 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-20.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-20.c
@@ -31,5 +31,5 @@ main (int argc, char **argv)
 }
 
 /* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
-/* { dg-output "\\\[\[0-9a-fA-FxX\]+,256\\\] surrounds2 \\\[\[0-9a-fA-FxX\]+,\\\+257\\\]" } */
+/* { dg-output "\\\[\[0-9a-fA-FxX\]+,\\\+257\\\] outside mapped block \\\[\[0-9a-fA-FxX\]+,\\\+256\\\]" } */
 /* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-22.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-22.c
deleted file mode 100644
index 65ff440a528..00000000000
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-22.c
+++ /dev/null
@@ -1,35 +0,0 @@
-/* Exercise acc_copyin and acc_copyout on nvidia targets.  */
-
-/* { dg-do run { target openacc_nvidia_accel_selected } } */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <openacc.h>
-
-int
-main (int argc, char **argv)
-{
-  const int N = 256;
-  int i;
-  unsigned char *h;
-
-  h = (unsigned char *) malloc (N);
-
-  for (i = 0; i < N; i++)
-    {
-      h[i] = i;
-    }
-
-  (void) acc_copyin (h, N);
-
-  fprintf (stderr, "CheCKpOInT\n");
-  acc_copyout (h + 1, N - 1);
-
-  free (h);
-
-  return 0;
-}
-
-/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
-/* { dg-output "\\\[\[0-9a-fA-FxX\]+,256\\\] surrounds2 \\\[\[0-9a-fA-FxX\]+,\\\+255\\\]" } */
-/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-23.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-23.c
index fd4dc5971a1..b1f3e71f278 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-23.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-23.c
@@ -41,5 +41,5 @@ main (int argc, char **argv)
 }
 
 /* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
-/* { dg-output "\\\[\[0-9a-fA-FxX\]+,256\\\] surrounds2 \\\[\[0-9a-fA-FxX\]+,\\\+512\\\]" } */
+/* { dg-output "\\\[\[0-9a-fA-FxX\]+,\\\+512\\\] outside mapped block \\\[\[0-9a-fA-FxX\]+,\\\+256\\\]" } */
 /* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-30.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-30.c
deleted file mode 100644
index 9bc9ecc1068..00000000000
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-30.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Exercise an invalid partial acc_delete on nvidia targets.  */
-
-/* { dg-do run { target openacc_nvidia_accel_selected } } */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <openacc.h>
-
-int
-main (int argc, char **argv)
-{
-  const int N = 256;
-  unsigned char *h;
-  void *d;
-
-  h = (unsigned char *) malloc (N);
-
-  d = acc_create (h, N);
-  if (!d)
-    abort ();
-
-  fprintf (stderr, "CheCKpOInT\n");
-  acc_delete (h, N - 2);
-
-  free (h);
-
-  return 0;
-}
-
-/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
-/* { dg-output "\\\[\[0-9a-fA-FxX\]+,256\\\] surrounds2 \\\[\[0-9a-fA-FxX\]+,\\\+254\\\]" } */
-/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-43.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-43.c
deleted file mode 100644
index 5db29124e9e..00000000000
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-43.c
+++ /dev/null
@@ -1,51 +0,0 @@
-/* Exercise acc_update_device with a NULL data address on nvidia targets.  */
-
-/* { dg-do run { target openacc_nvidia_accel_selected } } */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <openacc.h>
-
-int
-main (int argc, char **argv)
-{
-  const int N = 256;
-  int i;
-  unsigned char *h;
-  void *d;
-
-  h = (unsigned char *) malloc (N);
-
-  for (i = 0; i < N; i++)
-    {
-      h[i] = i;
-    }
-
-  d = acc_copyin (h, N);
-  if (!d)
-    abort ();
-
-  for (i = 0; i < N; i++)
-    {
-      h[i] = 0xab;
-    }
-
-  fprintf (stderr, "CheCKpOInT\n");
-  acc_update_device (0, N);
-
-  acc_copyout (h, N);
-
-  for (i = 0; i < N; i++)
-    {
-      if (h[i] != 0xab)
-	abort ();
-    }
-
-  free (h);
-
-  return 0;
-}
-
-/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
-/* { dg-output "\\\[\[^\n\r]*,256\\\] is not mapped" } */
-/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-47.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-47.c
deleted file mode 100644
index c2140429cb1..00000000000
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-47.c
+++ /dev/null
@@ -1,49 +0,0 @@
-/* Exercise acc_update_self with a NULL data mapping on nvidia targets.  */
-
-/* { dg-do run { target openacc_nvidia_accel_selected } } */
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <openacc.h>
-
-int
-main (int argc, char **argv)
-{
-  const int N = 256;
-  int i;
-  unsigned char *h;
-  void *d;
-
-  h = (unsigned char *) malloc (N);
-
-  for (i = 0; i < N; i++)
-    {
-      h[i] = i;
-    }
-
-  d = acc_copyin (h, N);
-  if (!d)
-    abort ();
-
-  memset (&h[0], 0, N);
-
-  fprintf (stderr, "CheCKpOInT\n");
-  acc_update_self (0, N);
-
-  for (i = 0; i < N; i++)
-    {
-      if (h[i] != i)
-	abort ();
-    }
-
-  acc_delete (h, N);
-
-  free (h);
-
-  return 0;
-}
-
-/* { dg-output "CheCKpOInT(\n|\r\n|\r).*" } */
-/* { dg-output "\\\[\[^\n\r]*,256\\\] is not mapped" } */
-/* { dg-shouldfail "" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-82.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-82.c
index be30a7f28ac..9cf73b31964 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-82.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-82.c
@@ -120,9 +120,13 @@ main (int argc, char **argv)
 
   for (i = 0; i < N; i++)
     {
-      acc_copyout (a[i], nbytes);
+      acc_memcpy_from_device (a[i], d_a[i], nbytes);
       if (*a[i] != i)
 	abort ();
+
+      acc_unmap_data (a[i]);
+
+      acc_free (d_a[i]);
     }
 
   free (streams);
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-91.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-91.c
index e00ef4f7206..36fff089b83 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-91.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/lib-91.c
@@ -72,6 +72,8 @@ main (int argc, char **argv)
   if (async > (sync * 1.5))
     abort ();
 
+  acc_unmap_data (h);
+
   acc_free (d);
 
   free (h);
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/loop-default.h b/libgomp/testsuite/libgomp.oacc-c-c++-common/loop-default.h
index a9e26939cf2..8c71249687c 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/loop-default.h
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/loop-default.h
@@ -1,5 +1,4 @@
 #include <openacc.h>
-#include <alloca.h>
 #include <string.h>
 #include <stdio.h>
 #include <gomp-constants.h>
@@ -28,9 +27,9 @@ check (const int *ary, int size, int gp, int wp, int vp)
 {
   int exit = 0;
   int ix;
-  int *gangs = (int *)alloca (gp * sizeof (int));
-  int *workers = (int *)alloca (wp * sizeof (int));
-  int *vectors = (int *)alloca (vp * sizeof (int));
+  int *gangs = (int *)__builtin_alloca (gp * sizeof (int));
+  int *workers = (int *)__builtin_alloca (wp * sizeof (int));
+  int *vectors = (int *)__builtin_alloca (vp * sizeof (int));
   int offloaded = 0;
 
   memset (gangs, 0, gp * sizeof (int));
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/loop-dim-default.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/loop-dim-default.c
index dd8107c1acc..04387d36174 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/loop-dim-default.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/loop-dim-default.c
@@ -1,7 +1,6 @@
 /* { dg-additional-options "-fopenacc-dim=16:16" } */
 
 #include <openacc.h>
-#include <alloca.h>
 #include <string.h>
 #include <stdio.h>
 #include <gomp-constants.h>
@@ -28,9 +27,9 @@ int check (const int *ary, int size, int gp, int wp, int vp)
 {
   int exit = 0;
   int ix;
-  int *gangs = (int *)alloca (gp * sizeof (int));
-  int *workers = (int *)alloca (wp * sizeof (int));
-  int *vectors = (int *)alloca (vp * sizeof (int));
+  int *gangs = (int *)__builtin_alloca (gp * sizeof (int));
+  int *workers = (int *)__builtin_alloca (wp * sizeof (int));
+  int *vectors = (int *)__builtin_alloca (vp * sizeof (int));
   int offloaded = 0;
   
   memset (gangs, 0, gp * sizeof (int));
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/map-data-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/map-data-1.c
new file mode 100644
index 00000000000..d0781dd7f56
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/map-data-1.c
@@ -0,0 +1,53 @@
+/* Verify that 'acc_map_data' does not copy data to, and 'acc_unmap_data' does
+   not copy data from the device.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <stdlib.h>
+#include <string.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int c0 = 9;
+  const int c1 = 40;
+  const int c2 = 47;
+
+  const size_t N = 256;
+
+  unsigned char *h = (unsigned char *) malloc (N);
+
+  void *d = acc_malloc (N);
+
+  memset (h, c0, N); // H <- c0
+  acc_memcpy_to_device (d, h, N); // D <- H = c0
+
+  memset (h, c1, N); // H <- c1
+  acc_map_data (h, d, N);
+  for (size_t i = 0; i < N; ++i)
+    if (h[i] != c1)
+      abort ();
+
+  acc_memcpy_from_device (h, d, N); // H <- D = c0
+  for (size_t i = 0; i < N; ++i)
+    if (h[i] != c0)
+      abort ();
+
+  memset (h, c2, N); // H <- c2
+  acc_unmap_data (h);
+  for (size_t i = 0; i < N; ++i)
+    if (h[i] != c2)
+      abort ();
+
+  acc_memcpy_from_device (h, d, N); // H <- D = c0
+  for (size_t i = 0; i < N; ++i)
+    if (h[i] != c0)
+      abort ();
+
+  acc_free (d);
+
+  free (h);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/nested-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/nested-1.c
index ededf2ba5b7..3e8b42527cf 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/nested-1.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/nested-1.c
@@ -112,7 +112,10 @@ main (int argc, char **argv)
     if (acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
 
-    acc_free (d);
+    acc_delete (&a[0], N * sizeof (float));
+
+    if (acc_is_present (&a[0], N * sizeof (float)))
+      abort ();
 
     for (i = 0; i < N; i++)
     {
@@ -177,7 +180,7 @@ main (int argc, char **argv)
     if (!acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
 
-    acc_free (d);
+    acc_delete (&b[0], N * sizeof (float));
 
     if (acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
@@ -290,13 +293,15 @@ main (int argc, char **argv)
     if (!acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
 
-    d = (float *) acc_deviceptr (&a[0]);
-    acc_unmap_data (&a[0]);
-    acc_free (d);
+    acc_delete (&a[0], N * sizeof (float));
 
-    d = (float *) acc_deviceptr (&b[0]);
-    acc_unmap_data (&b[0]);
-    acc_free (d);
+    if (acc_is_present (&a[0], N * sizeof (float)))
+      abort ();
+
+    acc_delete (&b[0], N * sizeof (float));
+
+    if (acc_is_present (&b[0], N * sizeof (float)))
+      abort ();
 
 
     for (i = 0; i < N; i++)
@@ -512,7 +517,9 @@ main (int argc, char **argv)
     if (!acc_is_present (c, (N * sizeof (float))))
       abort ();
 
-    acc_copyout (b, N * sizeof (float));
+    d = (float *) acc_deviceptr (b);
+
+    acc_memcpy_from_device (b, d, N * sizeof (float));
 
     for (i = 0; i < N; i++)
     {
@@ -529,6 +536,12 @@ main (int argc, char **argv)
 
     acc_free (d);
 
+    d = (float *) acc_deviceptr (b);
+
+    acc_unmap_data (b);
+
+    acc_free (d);
+
     d = (float *) acc_deviceptr (c);
 
     acc_unmap_data (c);
@@ -607,7 +620,10 @@ main (int argc, char **argv)
     if (acc_is_present (&b[0], (N * sizeof (float))))
       abort ();
 
-    acc_free (d);
+    acc_delete (&a[0], N * sizeof (float));
+
+    if (acc_is_present (&a[0], N * sizeof (float)))
+      abort ();
 
     for (i = 0; i < N; i++)
     {
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-1.c
index 5e82e1d350c..8c08717fdf2 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-1.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-1.c
@@ -15,7 +15,7 @@ main (int argc, char *argv[])
   #pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \
     reduction(+:res) copy(res)
   {
-    #pragma acc loop gang
+    #pragma acc loop gang /* { dg-warning "nested loop in reduction needs reduction clause for 'res'" "TODO" } */
     for (j = 0; j < 32; j++)
       {
 	#pragma acc loop worker reduction(+:res)
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-2.c
index a339f327956..41042accbde 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-2.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-2.c
@@ -14,7 +14,7 @@ main (int argc, char *argv[])
   #pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \
 		       reduction(^:res)
   {
-    #pragma acc loop gang
+    #pragma acc loop gang /* { dg-warning "nested loop in reduction needs reduction clause for 'res'" "TODO" } */
     for (j = 0; j < 32; j++)
       {
 	#pragma acc loop worker vector reduction(^:res)
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-3.c
index 6369d7fbb33..ace1e005e2e 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-3.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-3.c
@@ -16,7 +16,7 @@ main (int argc, char *argv[])
   #pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \
     reduction(+:res) copy(res)
   {
-    #pragma acc loop gang
+    #pragma acc loop gang /* { dg-warning "nested loop in reduction needs reduction clause for 'res'" "TODO" } */
     for (j = 0; j < 32; j++)
       {
 	#pragma acc loop worker vector reduction(+:res)
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-4.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-4.c
index 140c3226327..c3cc12fa953 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-4.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/par-loop-comb-reduction-4.c
@@ -16,7 +16,7 @@ main (int argc, char *argv[])
   #pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \
     reduction(+:res) reduction(max:mres) copy(res, mres)
   {
-    #pragma acc loop gang
+    #pragma acc loop gang /* { dg-warning "nested loop in reduction needs reduction clause for 'm\?res'" "TODO" } */
     for (j = 0; j < 32; j++)
       {
 	#pragma acc loop worker vector reduction(+:res) reduction(max:mres)
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/parallel-dims.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/parallel-dims.c
index 7e699f476b2..a5edfc6ca16 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/parallel-dims.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/parallel-dims.c
@@ -1,6 +1,8 @@
 /* OpenACC parallelism dimensions clauses: num_gangs, num_workers,
    vector_length.  */
 
+/* See also '../libgomp.oacc-fortran/parallel-dims.f90'.  */
+
 #include <limits.h>
 #include <openacc.h>
 #include <gomp-constants.h>
@@ -45,6 +47,8 @@ int main ()
 {
   acc_init (acc_device_default);
 
+  /* OpenACC parallel construct.  */
+
   /* Non-positive value.  */
 
   /* GR, WS, VS.  */
@@ -478,6 +482,8 @@ int main ()
   }
 
 
+  /* OpenACC kernels construct.  */
+
   /* We can't test parallelized OpenACC kernels constructs in this way: use of
      the acc_gang, acc_worker, acc_vector functions will make the construct
      unparallelizable.  */
@@ -544,5 +550,72 @@ int main ()
   }
 
 
+  /* OpenACC serial construct.  */
+
+  /* GR, WS, VS.  */
+  {
+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;
+    gangs_min = workers_min = vectors_min = INT_MAX;
+    gangs_max = workers_max = vectors_max = INT_MIN;
+#pragma acc serial /* { dg-warning "using vector_length \\(32\\), ignoring 1" "" { target openacc_nvidia_accel_selected } } */ \
+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)
+    {
+      for (int i = 100; i > -100; i--)
+	{
+	  gangs_min = gangs_max = acc_gang ();
+	  workers_min = workers_max = acc_worker ();
+	  vectors_min = vectors_max = acc_vector ();
+	}
+    }
+    if (gangs_min != 0 || gangs_max != 1 - 1
+	|| workers_min != 0 || workers_max != 1 - 1
+	|| vectors_min != 0 || vectors_max != 1 - 1)
+      __builtin_abort ();
+  }
+
+  /* Composition of GP, WP, VP.  */
+  {
+    int vectors_actual = 1;  /* Implicit 'vector_length (1)' clause.  */
+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;
+    gangs_min = workers_min = vectors_min = INT_MAX;
+    gangs_max = workers_max = vectors_max = INT_MIN;
+#pragma acc serial copy (vectors_actual) /* { dg-warning "using vector_length \\(32\\), ignoring 1" "" { target openacc_nvidia_accel_selected } } */ \
+  copy (gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max)
+    {
+      if (acc_on_device (acc_device_nvidia))
+	{
+	  /* The GCC nvptx back end enforces vector_length (32).  */
+	  /* It's unclear if that's actually permissible here;
+	     <https://github.com/OpenACC/openacc-spec/issues/238> "OpenACC
+	     'serial' construct might not actually be serial".  */
+	  vectors_actual = 32;
+	}
+#pragma acc loop gang reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)
+      for (int i = 100; i > -100; i--)
+#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)
+	for (int j = 100; j > -100; j--)
+#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)
+	  for (int k = 100 * vectors_actual; k > -100 * vectors_actual; k--)
+	    {
+	      gangs_min = gangs_max = acc_gang ();
+	      workers_min = workers_max = acc_worker ();
+	      vectors_min = vectors_max = acc_vector ();
+	    }
+    }
+    if (acc_get_device_type () == acc_device_nvidia)
+      {
+	if (vectors_actual != 32)
+	  __builtin_abort ();
+      }
+    else
+      if (vectors_actual != 1)
+	__builtin_abort ();
+    if (gangs_min != 0 || gangs_max != 1 - 1
+	|| workers_min != 0 || workers_max != 1 - 1
+	|| vectors_min != 0 || vectors_max != vectors_actual - 1)
+      __builtin_abort ();
+  }
+
+
   return 0;
 }
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955-1.c
new file mode 100644
index 00000000000..44767cd27c3
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955-1.c
@@ -0,0 +1,31 @@
+/* { dg-do compile }  */
+/* { dg-options "-O2 -fdump-tree-cddce2 -ffinite-loops" } */
+
+int
+f1 (void)
+{
+  int i, j;
+
+#pragma acc parallel loop tile(2,3)
+  for (i = 1; i < 10; i++)
+    for (j = 1; j < 10; j++)
+      for (;;)
+	;
+
+  return i + j;
+}
+
+int
+f2 (void)
+{
+  int i, j, k;
+
+#pragma acc parallel loop tile(2,3)
+  for (i = 1; i < 10; i++)
+    for (j = 1; j < 10; j++)
+      for (k = 1; k < 10; k++)
+	;
+
+  return i + j;
+}
+/* { dg-final { scan-tree-dump-not "if" "cddce2"} } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85381-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85381-2.c
index 6570c64afff..2cb5b95949d 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85381-2.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85381-2.c
@@ -15,22 +15,4 @@ main (void)
   return 0;
 }
 
-/* Todo: Boths bar.syncs can be removed.
-   Atm we generate this dead code inbetween forked and joining:
-
-                     mov.u32 %r28, %ntid.y;
-                     mov.u32 %r29, %tid.y;
-                     add.u32 %r30, %r29, %r29;
-                     setp.gt.s32     %r31, %r30, 19;
-             @%r31   bra     $L2;
-                     add.u32 %r25, %r28, %r28;
-                     mov.u32 %r24, %r30;
-     $L3:
-                     add.u32 %r24, %r24, %r25;
-                     setp.le.s32     %r33, %r24, 19;
-             @%r33   bra     $L3;
-     $L2:
-
-   so the loop is not recognized as empty loop (which we detect by seeing if
-   joining immediately follows forked).  */
-/* { dg-final { scan-assembler-times "bar.sync" 2 } } */
+/* { dg-final { scan-assembler-times "bar.sync" 0 } } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85381-4.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85381-4.c
index d955d79718d..e8a433ffc0a 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85381-4.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85381-4.c
@@ -21,7 +21,4 @@ main (void)
   return 0;
 }
 
-/* Atm, %ntid.y is broadcast from one loop to the next, so there are 2 bar.syncs
-   for that (the other two are there for the same reason as in pr85381-2.c).
-   Todo: Recompute %ntid.y instead of broadcasting it. */
-/* { dg-final { scan-assembler-times "bar.sync" 4 } } */
+/* { dg-final { scan-assembler-times "bar.sync" 0 } } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr89376.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr89376.c
new file mode 100644
index 00000000000..7f6c83254d5
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr89376.c
@@ -0,0 +1,15 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fno-tree-ch -fno-tree-dce -fno-tree-vrp" } */
+
+int
+main (void)
+{
+  int fa;
+
+  #pragma acc kernels
+  for (int rw = 0; rw < 1; ++rw)
+    fa = 0;
+
+  return 0;
+}
+
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr90009.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr90009.c
new file mode 100644
index 00000000000..58d1039dd8d
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr90009.c
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+
+#include <stdlib.h>
+
+#define N 100
+
+int data[N];
+
+int
+main (void)
+{
+  int n = N, b = 3;
+#pragma acc parallel num_workers(2)
+  {
+    int c;
+    if (n)
+      c = 0;
+    else
+      c = b;
+
+#pragma acc loop worker
+    for (int i = 0; i < n; i++)
+      data[i] = 1;
+
+    if (c)
+      data[0] = 2;
+  }
+
+  for (int i = 0; i < n; i++)
+    if (data[i] != 1)
+      abort ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr92843-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr92843-1.c
new file mode 100644
index 00000000000..db5b35b08d9
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr92843-1.c
@@ -0,0 +1,179 @@
+/* Verify that 'acc_copyout' etc. is a no-op if there's still a structured
+   reference count.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+
+const int c0 = 58;
+const int c1 = 81;
+
+static void
+assign_array (char *array, size_t size, char value)
+{
+  for (size_t i = 0; i < size; ++i)
+    array[i] = value;
+}
+
+static void
+verify_array (const char *array, size_t size, char value)
+{
+  for (size_t i = 0; i < size; ++i)
+    assert (array[i] == value);
+}
+
+
+float global_var;
+#pragma acc declare create (global_var)
+
+static void
+test_acc_declare ()
+{
+  assert (acc_is_present (&global_var, sizeof global_var));
+
+  global_var = c0;
+#pragma acc update device (global_var)
+
+  global_var = c1;
+  acc_copyout (&global_var, sizeof global_var);
+  assert (acc_is_present (&global_var, sizeof global_var));
+  assert (global_var == c1);
+
+  global_var = c1;
+  acc_copyout_finalize (&global_var, sizeof global_var);
+  assert (acc_is_present (&global_var, sizeof global_var));
+  assert (global_var == c1);
+
+  void *global_var_d_p = acc_deviceptr (&global_var);
+  assert (global_var_d_p);
+
+  void *d_p = acc_copyin (&global_var, sizeof global_var);
+  assert (d_p == global_var_d_p);
+
+  acc_copyout (&global_var, sizeof global_var);
+  assert (acc_is_present (&global_var, sizeof global_var));
+
+  d_p = acc_copyin (&global_var, sizeof global_var);
+  assert (d_p == global_var_d_p);
+
+  d_p = acc_copyin (&global_var, sizeof global_var);
+  assert (d_p == global_var_d_p);
+
+  global_var = c1;
+  acc_copyout_finalize (&global_var, sizeof global_var);
+  assert (acc_is_present (&global_var, sizeof global_var));
+  assert (global_var == c1);
+
+  global_var = c1;
+  acc_copyout (&global_var, sizeof global_var);
+  assert (acc_is_present (&global_var, sizeof global_var));
+  assert (global_var == c1);
+}
+
+
+static void
+test_acc_map_data ()
+{
+  const int N = 801;
+
+  char *h = (char *) malloc (N);
+  assert (h);
+  void *d = acc_malloc (N);
+  assert (d);
+  acc_map_data (h, d, N);
+  assert (acc_is_present (h, N));
+
+  assign_array (h, N, c0);
+#pragma acc update device (h[0:N])
+
+  assign_array (h, N, c1);
+#pragma acc exit data copyout (h[0:N])
+  assert (acc_is_present (h, N));
+  verify_array (h, N, c1);
+
+  assign_array (h, N, c1);
+#pragma acc exit data copyout (h[0:N]) finalize
+  assert (acc_is_present (h, N));
+  verify_array (h, N, c1);
+
+#pragma acc enter data copyin (h[0:N])
+
+  assign_array (h, N, c1);
+#pragma acc exit data copyout (h[0:N])
+  assert (acc_is_present (h, N));
+  verify_array (h, N, c1);
+
+#pragma acc enter data copyin (h[0:N])
+
+#pragma acc enter data copyin (h[0:N])
+
+  assign_array (h, N, c1);
+#pragma acc exit data copyout (h[0:N]) finalize
+  assert (acc_is_present (h, N));
+  verify_array (h, N, c1);
+
+  assign_array (h, N, c1);
+#pragma acc exit data copyout (h[0:N])
+  assert (acc_is_present (h, N));
+  verify_array (h, N, c1);
+}
+
+
+static void
+test_acc_data ()
+{
+#define N 23
+  char h[N];
+
+  assign_array (h, N, c0);
+#pragma acc data copyin (h)
+  {
+    assert (acc_is_present (h, sizeof h));
+
+    assign_array (h, N, c1);
+    acc_copyout_finalize (h, sizeof h);
+    assert (acc_is_present (h, sizeof h));
+    verify_array (h, N, c1);
+
+    assign_array (h, N, c1);
+    acc_copyout (h, sizeof h);
+    assert (acc_is_present (h, sizeof h));
+    verify_array (h, N, c1);
+
+    acc_copyin (h, sizeof h);
+
+    assign_array (h, N, c1);
+    acc_copyout (h, sizeof h);
+    assert (acc_is_present (h, sizeof h));
+    verify_array (h, N, c1);
+
+    acc_copyin (h, sizeof h);
+
+    acc_copyin (h, sizeof h);
+
+    assign_array (h, N, c1);
+    acc_copyout_finalize (h, sizeof h);
+    assert (acc_is_present (h, sizeof h));
+    verify_array (h, N, c1);
+
+    assign_array (h, N, c1);
+    acc_copyout (h, sizeof h);
+    assert (acc_is_present (h, sizeof h));
+    verify_array (h, N, c1);
+  }
+#undef N
+}
+
+
+int
+main ()
+{
+  test_acc_declare ();
+  test_acc_map_data ();
+  test_acc_data ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr92854-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr92854-1.c
new file mode 100644
index 00000000000..6ba96b6bf8f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr92854-1.c
@@ -0,0 +1,31 @@
+/* Verify that 'acc_unmap_data' unmaps even in presence of dynamic reference
+   counts.  */
+
+/* { dg-skip-if "" { *-*-* } { "*" } { "-DACC_MEM_SHARED=0" } } */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  const int N = 180;
+
+  char *h = (char *) malloc (N);
+  char *d = (char *) acc_malloc (N);
+  if (!d)
+    abort ();
+  acc_map_data (h, d, N);
+
+  char *d_ = (char *) acc_create (h + 3, N - 77);
+  assert (d_ == d + 3);
+
+  d_ = (char *) acc_create (h, N);
+  assert (d_ == d);
+
+  acc_unmap_data (h);
+  assert (!acc_is_present (h, N));
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr92877-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr92877-1.c
new file mode 100644
index 00000000000..02595a9c0e5
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr92877-1.c
@@ -0,0 +1,19 @@
+/* Make sure that we can resolve back via 'acc_hostptr' an 'acc_deviceptr'
+   retrieved for a structured mapping.  */
+
+#include <assert.h>
+#include <openacc.h>
+
+int
+main ()
+{
+  int var;
+
+#pragma acc data create (var)
+  {
+    void *var_p_d = acc_deviceptr (&var);
+    assert (acc_hostptr (var_p_d) == &var);
+  }
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-a.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-a.c
new file mode 100644
index 00000000000..1d168c2e585
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-a.c
@@ -0,0 +1,7 @@
+/* Test "subset" subarray mappings
+   { dg-additional-options "-DOPENACC_DIRECTIVES" } using OpenACC directives,
+   { dg-additional-options "-DARRAYS" } using arrays.  */
+
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include "subset-subarray-mappings-1-r-p.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-p.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-p.c
new file mode 100644
index 00000000000..68ed0ce3eca
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-p.c
@@ -0,0 +1,7 @@
+/* Test "subset" subarray mappings
+   { dg-additional-options "-DOPENACC_DIRECTIVES" } using OpenACC directives,
+   { dg-additional-options "-DPOINTERS" } using pointers.  */
+
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include "subset-subarray-mappings-1-r-p.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-a.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-a.c
new file mode 100644
index 00000000000..5c0fd040d87
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-a.c
@@ -0,0 +1,7 @@
+/* Test "subset" subarray mappings
+   { dg-additional-options "-DOPENACC_RUNTIME" } using OpenACC Runtime Library routines,
+   { dg-additional-options "-DARRAYS" } using arrays.  */
+
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include "subset-subarray-mappings-1-r-p.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c
new file mode 100644
index 00000000000..9b5d83c66dd
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c
@@ -0,0 +1,514 @@
+/* Test "subset" subarray mappings
+   { dg-additional-options "-DOPENACC_RUNTIME" } using OpenACC Runtime Library routines,
+   { dg-additional-options "-DPOINTERS" } using pointers.  */
+
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#if OPENACC_RUNTIME
+#elif OPENACC_DIRECTIVES
+#else
+# error
+#endif
+
+#if POINTERS
+#elif ARRAYS
+#else
+# error
+#endif
+
+
+#include <openacc.h>
+#include <acc_prof.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+
+static bool cb_ev_alloc_expected;
+static size_t cb_ev_alloc_bytes;
+static const void *cb_ev_alloc_device_ptr;
+static void
+cb_ev_alloc (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  assert (cb_ev_alloc_expected);
+  cb_ev_alloc_expected = false;
+
+  cb_ev_alloc_bytes = event_info->data_event.bytes;
+  cb_ev_alloc_device_ptr = event_info->data_event.device_ptr;
+}
+
+static bool cb_ev_free_expected;
+static const void *cb_ev_free_device_ptr;
+static void
+cb_ev_free (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  assert (cb_ev_free_expected);
+  cb_ev_free_expected = false;
+
+  cb_ev_free_device_ptr = event_info->data_event.device_ptr;
+}
+
+
+/* Match the alignment processing that
+   'libgomp/target.c:gomp_map_vars_internal' is doing; simplified, not
+   considering special alignment requirements of certain data types.  */
+
+static size_t
+aligned_size (size_t tgt_size)
+{
+  size_t tgt_align = sizeof (void *);
+  return tgt_size + tgt_align - 1;
+}
+
+static const void *
+aligned_address (const void *tgt_start)
+{
+  size_t tgt_align = sizeof (void *);
+  return (void *) (((uintptr_t) tgt_start + tgt_align - 1) & ~(tgt_align - 1));
+}
+
+
+#define SIZE 1024
+#define SUBSET 32
+
+
+static void
+f1 (void)
+{
+  cb_ev_alloc_expected = false;
+  cb_ev_free_expected = false;
+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);
+
+#if POINTERS
+  char* myblock = (char *) malloc (SIZE);
+#else
+  char myblock[SIZE];
+#endif
+  int i;
+  void *dst;
+  for (i = 0; i < SIZE; i++)
+    myblock[i] = i;
+
+  cb_ev_alloc_expected = true;
+#if OPENACC_RUNTIME
+  dst = acc_copyin (myblock, SIZE);
+#else
+# if POINTERS
+#  pragma acc enter data copyin (myblock[0:SIZE])
+# else
+#  pragma acc enter data copyin (myblock)
+# endif
+  dst = acc_deviceptr (myblock);
+#endif
+  assert (dst);
+  assert (!cb_ev_alloc_expected);
+  assert (cb_ev_alloc_bytes == aligned_size (SIZE));
+  assert (aligned_address (cb_ev_alloc_device_ptr) == dst);
+  for (i = 0; i < SIZE; i += SUBSET)
+    {
+      void *partdst = acc_deviceptr (&myblock[i]);
+      assert ((uintptr_t) partdst == (uintptr_t) dst + i);
+      assert (acc_hostptr (partdst) == &myblock[i]);
+    }
+  for (i = 0; i < SIZE; i += SUBSET)
+    {
+      void *partdst;
+#if OPENACC_RUNTIME
+      partdst = acc_pcopyin (&myblock[i], SUBSET);
+#else
+# pragma acc enter data pcopyin (myblock[i:SUBSET])
+      partdst = acc_deviceptr (&myblock[i]);
+#endif
+      assert ((uintptr_t) partdst == (uintptr_t) dst + i);
+    }
+  /* Dereference first half.  */
+  for (i = 0; i < 512; i += SUBSET)
+    {
+      assert (acc_is_present (&myblock[i], SUBSET));
+      assert (acc_is_present (myblock, SIZE));
+#if OPENACC_RUNTIME
+      acc_delete (&myblock[i], SUBSET);
+#else
+# pragma acc exit data delete (myblock[i:SUBSET])
+#endif
+      assert (acc_is_present (&myblock[i], SUBSET));
+      assert (acc_is_present (myblock, SIZE));
+    }
+  /* Dereference all.  */
+#if OPENACC_RUNTIME
+  acc_delete (myblock, SIZE);
+#else
+# if POINTERS
+#  pragma acc exit data delete (myblock[0:SIZE])
+# else
+#  pragma acc exit data delete (myblock)
+# endif
+#endif
+  /* Expect it's still present.  */
+  assert (acc_is_present (myblock, SIZE));
+  /* Dereference second half.  */
+  for (i = 512; i < SIZE; i += SUBSET)
+    {
+      bool last = i >= SIZE - SUBSET;
+
+      assert (acc_is_present (&myblock[i], SUBSET));
+      assert (acc_is_present (myblock, SIZE));
+#if 0 //TODO PR92848
+      if (last)
+	cb_ev_free_expected = true;
+#endif
+#if OPENACC_RUNTIME
+      acc_delete (&myblock[i], SUBSET);
+#else
+# pragma acc exit data delete (myblock[i:SUBSET])
+#endif
+#if 0 //TODO PR92848
+      assert (!cb_ev_free_expected);
+      if (last)
+	assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);
+#endif
+      assert (acc_is_present (&myblock[i], SUBSET) != last);
+      assert (acc_is_present (myblock, SIZE) != last);
+    }
+  /* Expect it's all gone now.  */
+  for (i = 512; i < SIZE; i += SUBSET)
+    assert (!acc_is_present (&myblock[i], SUBSET));
+  assert (!acc_is_present (myblock, SIZE));
+  assert (!acc_is_present (myblock, 1));
+
+#if POINTERS
+  free (myblock);
+#endif
+
+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);
+}
+
+
+static void
+f2 (void)
+{
+  cb_ev_alloc_expected = false;
+  cb_ev_free_expected = false;
+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);
+
+#if POINTERS
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+  char *block3 = (char *) malloc (SIZE);
+#else
+  char block1[SIZE];
+  char block2[SIZE];
+  char block3[SIZE];
+#endif
+  int i;
+  for (i = 0; i < SIZE; i++)
+    block1[i] = block2[i] = block3[i] = i;
+
+  cb_ev_alloc_expected = true;
+#if POINTERS
+# pragma acc data copyin(block1[0:SIZE], block2[0:SIZE], block3[0:SIZE])
+#else
+# pragma acc data copyin(block1, block2, block3)
+#endif
+  {
+    void *block1_d = acc_deviceptr (block1);
+    void *block2_d = acc_deviceptr (block2);
+    void *block3_d = acc_deviceptr (block3);
+    assert (!cb_ev_alloc_expected);
+    /* 'block1', 'block2', 'block3' get mapped in one device memory object, in
+       reverse order.  */
+    assert (cb_ev_alloc_bytes == aligned_size (3 * SIZE));
+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 2 * SIZE) == block1_d);
+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 1 * SIZE) == block2_d);
+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 0 * SIZE) == block3_d);
+
+    for (i = 0; i < SIZE; i += SUBSET)
+      {
+	void *block2_part_d;
+#if OPENACC_RUNTIME
+	block2_part_d = acc_pcopyin (&block2[i], SUBSET);
+#else
+# pragma acc enter data pcopyin (block2[i:SUBSET])
+	block2_part_d = acc_deviceptr (&block2[i]);
+#endif
+	assert ((uintptr_t) block2_part_d == (uintptr_t) block2_d + i);
+      }
+  }
+  /* The mappings have been removed, but the device memory object has not yet
+     been 'free'd.  */
+  assert (!acc_is_present (block1, SIZE));
+  assert (acc_is_present (block2, SIZE));
+  assert (!acc_is_present (block3, SIZE));
+  for (i = 0; i < SIZE; i += SUBSET)
+    {
+      bool last = i >= SIZE - SUBSET;
+
+      assert (acc_is_present (block2, SIZE));
+      if (last)
+	cb_ev_free_expected = true;
+#if OPENACC_RUNTIME
+      acc_delete (&block2[i], SUBSET);
+#else
+# pragma acc exit data delete (block2[i:SUBSET])
+#endif
+      assert (!cb_ev_free_expected);
+      if (last)
+	assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);
+    }
+  assert (!acc_is_present (block1, SIZE));
+  assert (!acc_is_present (block2, SIZE));
+  assert (!acc_is_present (block3, SIZE));
+
+#if POINTERS
+  free (block1);
+  free (block2);
+  free (block3);
+#endif
+
+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);
+}
+
+
+static void
+f3 ()
+{
+  cb_ev_alloc_expected = false;
+  cb_ev_free_expected = false;
+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);
+
+#if POINTERS
+  char *h = (char *) malloc (SIZE);
+#else
+  char h[SIZE];
+#endif
+
+  char *d1;
+  cb_ev_alloc_expected = true;
+#if OPENACC_RUNTIME
+  d1 = (char *) acc_present_or_create (h, SIZE);
+#else
+# if POINTERS
+#  pragma acc enter data present_or_create (h[0:SIZE])
+# else
+#  pragma acc enter data present_or_create (h)
+# endif
+  d1 = (char *) acc_deviceptr (h);
+#endif
+  assert (d1);
+  assert (!cb_ev_alloc_expected);
+  assert (cb_ev_alloc_bytes == aligned_size (SIZE));
+  assert (aligned_address (cb_ev_alloc_device_ptr) == d1);
+  assert (acc_is_present (h, SIZE));
+  assert (acc_is_present (&h[2], SIZE - 2));
+
+  char *d2;
+#if OPENACC_RUNTIME
+  d2 = (char *) acc_present_or_create (&h[2], SIZE - 2);
+#else
+# pragma acc enter data present_or_create (h[2:SIZE - 2])
+  d2 = (char *) acc_deviceptr (&h[2]);
+#endif
+  assert (d2);
+  assert (d1 == d2 - 2);
+  assert (acc_is_present (h, SIZE));
+  assert (acc_is_present (&h[2], SIZE - 2));
+
+  d2 = (char *) acc_deviceptr (&h[2]);
+  assert (d1 == d2 - 2);
+
+#if OPENACC_RUNTIME
+  acc_delete (&h[2], SIZE - 2);
+#else
+# pragma acc exit data delete (h[2:SIZE - 2])
+#endif
+  assert (acc_is_present (h, SIZE));
+  assert (acc_is_present (&h[2], SIZE - 2));
+
+#if 0 //TODO PR92848
+  cb_ev_free_expected = true;
+#endif
+#if OPENACC_RUNTIME
+  acc_delete (h, SIZE);
+#else
+# if POINTERS
+#  pragma acc exit data delete (h[0:SIZE])
+# else
+#  pragma acc exit data delete (h)
+# endif
+#endif
+#if 0 //TODO PR92848
+  assert (!cb_ev_free_expected);
+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);
+#endif
+
+  assert (!acc_is_present (h, SIZE));
+  assert (!acc_is_present (&h[2], SIZE - 2));
+  assert (!acc_is_present (h, 1));
+
+# if POINTERS
+  free (h);
+#endif
+
+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);
+}
+
+
+/* Based on what used to be 'libgomp.oacc-c-c++-common/lib-22.c'.  */
+
+static void
+f_lib_22 (void)
+{
+  cb_ev_alloc_expected = false;
+  cb_ev_free_expected = false;
+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);
+
+  const int c0 = 0;
+  const int c1 = 1;
+
+#if POINTERS
+  char *h = (char *) malloc (SIZE);
+#else
+  char h[SIZE];
+#endif
+
+  memset (h, c0, SIZE);
+  void *d;
+  cb_ev_alloc_expected = true;
+#if OPENACC_RUNTIME
+  d = acc_copyin (h, SIZE);
+#else
+# if POINTERS
+#  pragma acc enter data copyin (h[0:SIZE])
+# else
+#  pragma acc enter data copyin (h)
+# endif
+  d = acc_deviceptr (h);
+#endif
+  assert (d);
+  assert (!cb_ev_alloc_expected);
+  assert (cb_ev_alloc_bytes == aligned_size (SIZE));
+  assert (aligned_address (cb_ev_alloc_device_ptr) == d);
+  /* Overwrite the local memory.  */
+  memset (h, c1, SIZE);
+  /* Now 'copyout' not the whole but only a "subset" subarray, missing one
+     SUBSET at the beginning, and half a SUBSET at the end...  */
+#if 0 //TODO PR92848
+  cb_ev_free_expected = true;
+#endif
+#if OPENACC_RUNTIME
+  acc_copyout (h + SUBSET, SIZE - SUBSET - SUBSET / 2);
+#else
+# pragma acc exit data copyout (h[SUBSET:SIZE - SUBSET - SUBSET / 2])
+#endif
+#if 0 //TODO PR92848
+  /* ..., yet, expect the device memory object to be 'free'd...  */
+  assert (!cb_ev_free_expected);
+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);
+#endif
+  /* ..., and the mapping to be removed...  */
+  assert (!acc_is_present (h, SIZE));
+  assert (!acc_is_present (&h[SUBSET], SIZE - SUBSET - SUBSET / 2));
+  assert (!acc_is_present (h, 1));
+  /* ..., but the 'copyout'ed device memory to correspond to just the "subset"
+     subarray.  */
+  for (size_t i = 0; i < SIZE; ++i)
+    {
+      if (i < SUBSET)
+	assert (h[i] == c1);
+      else if (i < SIZE - SUBSET / 2)
+	assert (h[i] == c0);
+      else if (i < SIZE)
+	assert (h[i] == c1);
+    }
+
+#if POINTERS
+  free (h);
+#endif
+
+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);
+}
+
+
+/* Based on what used to be 'libgomp.oacc-c-c++-common/lib-30.c'.  */
+
+static void
+f_lib_30 (void)
+{
+  cb_ev_alloc_expected = false;
+  cb_ev_free_expected = false;
+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);
+
+#if POINTERS
+  char *h = (char *) malloc (SIZE);
+#else
+  char h[SIZE];
+#endif
+  memset (h, 0, SIZE);
+
+  void *d;
+  cb_ev_alloc_expected = true;
+#if OPENACC_RUNTIME
+  d = acc_create (h, SIZE);
+#else
+# if POINTERS
+#  pragma acc enter data create (h[0:SIZE])
+# else
+#  pragma acc enter data create (h)
+# endif
+  d = acc_deviceptr (h);
+#endif
+  assert (d);
+  assert (!cb_ev_alloc_expected);
+  assert (cb_ev_alloc_bytes == aligned_size (SIZE));
+  assert (aligned_address (cb_ev_alloc_device_ptr) == d);
+
+  /* We 'delete' not the whole but only a "subset" subarray...  */
+#if 0 //TODO PR92848
+  cb_ev_free_expected = true;
+#endif
+#if OPENACC_RUNTIME
+  acc_delete (h, SIZE - SUBSET);
+#else
+# pragma acc exit data delete (h[0:SIZE - SUBSET])
+#endif
+#if 0 //TODO PR92848
+  /* ..., yet, expect the device memory object to be 'free'd...  */
+  assert (!cb_ev_free_expected);
+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);
+#endif
+  /* ..., and the mapping to be removed.  */
+  assert (!acc_is_present (h, SIZE));
+  assert (!acc_is_present (h, SIZE - SUBSET));
+  assert (!acc_is_present (h, 1));
+
+#if POINTERS
+  free (h);
+#endif
+
+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);
+}
+
+
+int
+main ()
+{
+  f1 ();
+  f2 ();
+  f3 ();
+  f_lib_22 ();
+  f_lib_30 ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-2.c
new file mode 100644
index 00000000000..f4e18fa97a7
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-2.c
@@ -0,0 +1,115 @@
+/* Test "subset" subarray mappings.  */
+
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include <openacc.h>
+#include <acc_prof.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <assert.h>
+
+
+static bool cb_ev_alloc_expected;
+static size_t cb_ev_alloc_bytes;
+static const void *cb_ev_alloc_device_ptr;
+static void
+cb_ev_alloc (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  assert (cb_ev_alloc_expected);
+  cb_ev_alloc_expected = false;
+
+  cb_ev_alloc_bytes = event_info->data_event.bytes;
+  cb_ev_alloc_device_ptr = event_info->data_event.device_ptr;
+}
+
+static bool cb_ev_free_expected;
+static const void *cb_ev_free_device_ptr;
+static void
+cb_ev_free (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)
+{
+  assert (cb_ev_free_expected);
+  cb_ev_free_expected = false;
+
+  cb_ev_free_device_ptr = event_info->data_event.device_ptr;
+}
+
+
+/* Match the alignment processing that
+   'libgomp/target.c:gomp_map_vars_internal' is doing; simplified, not
+   considering special alignment requirements of certain data types.  */
+
+static size_t
+aligned_size (size_t tgt_size)
+{
+  size_t tgt_align = sizeof (void *);
+  return tgt_size + tgt_align - 1;
+}
+
+static const void *
+aligned_address (const void *tgt_start)
+{
+  size_t tgt_align = sizeof (void *);
+  return (void *) (((uintptr_t) tgt_start + tgt_align - 1) & ~(tgt_align - 1));
+}
+
+
+#define SIZE 1024
+
+
+int
+main ()
+{
+  cb_ev_alloc_expected = false;
+  cb_ev_free_expected = false;
+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);
+
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+  char *block3 = (char *) malloc (SIZE);
+  cb_ev_alloc_expected = true;
+#pragma acc data create (block1[0:SIZE], block2[0:SIZE], block3[0:SIZE])
+  {
+    void *s_block1_d = acc_deviceptr (&block1[1]);
+    void *s_block2_d = acc_deviceptr (&block2[20]);
+    void *s_block3_d = acc_deviceptr (&block3[300]);
+    assert (!cb_ev_alloc_expected);
+    /* 'block1', 'block2', 'block3' get mapped in one device memory object, in
+       reverse order.  */
+    assert (cb_ev_alloc_bytes == aligned_size (3 * SIZE));
+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 2 * SIZE + 1) == s_block1_d);
+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 1 * SIZE + 20) == s_block2_d);
+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 0 * SIZE + 300) == s_block3_d);
+
+    void *s_block1_p_d = acc_pcopyin (&block1[1], SIZE - 3);
+    void *s_block2_p_d = acc_pcopyin (&block2[20], SIZE - 33);
+    void *s_block3_p_d = acc_pcopyin (&block3[300], SIZE - 333);
+    assert (s_block1_p_d == s_block1_d);
+    assert (s_block2_p_d == s_block2_d);
+    assert (s_block3_p_d == s_block3_d);
+
+    acc_delete (block1, SIZE);
+    acc_delete (block2, SIZE);
+    acc_delete (block3, SIZE);
+    assert (acc_is_present (block1, SIZE));
+    assert (acc_is_present (block2, SIZE));
+    assert (acc_is_present (block3, SIZE));
+
+    cb_ev_free_expected = true;
+  }
+  assert (!cb_ev_free_expected);
+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);
+  assert (!acc_is_present (block1, SIZE));
+  assert (!acc_is_present (block2, SIZE));
+  assert (!acc_is_present (block3, SIZE));
+
+  free (block1);
+  free (block2);
+  free (block3);
+
+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);
+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/tile-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/tile-1.c
index 5130591dd81..c019fe55c7a 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/tile-1.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/tile-1.c
@@ -1,3 +1,6 @@
+/* AMD GCN does not use 32-lane vectors, so the expected use counts mismatch.
+   { dg-skip-if "unsuitable dimensions" { openacc_amdgcn_accel_selected } { "*" } { "" } } */
+
 /* { dg-additional-options "-fopenacc-dim=32" } */
 
 #include <stdio.h>
diff --git a/libgomp/testsuite/libgomp.oacc-c/c.exp b/libgomp/testsuite/libgomp.oacc-c/c.exp
index 55cd40f1e99..7f13242fd59 100644
--- a/libgomp/testsuite/libgomp.oacc-c/c.exp
+++ b/libgomp/testsuite/libgomp.oacc-c/c.exp
@@ -51,6 +51,15 @@ foreach offload_target [concat [split $offload_targets ","] "disable"] {
 	    unsupported "$subdir $offload_target offloading"
 	    continue
 	}
+	gcn {
+	    if { ![check_effective_target_openacc_amdgcn_accel_present] } {
+		# Don't bother; execution testing is going to FAIL.
+		untested "$subdir $offload_target offloading: supported, but hardware not accessible"
+		continue
+	    }
+
+	    set acc_mem_shared 0
+	}
 	host {
 	    set acc_mem_shared 1
 	}
diff --git a/libgomp/testsuite/libgomp.oacc-c/print-1.c b/libgomp/testsuite/libgomp.oacc-c/print-1.c
new file mode 100644
index 00000000000..593885b5c2c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c/print-1.c
@@ -0,0 +1,17 @@
+/* Ensure that printf on the offload device works.  */
+
+/* { dg-do run } */
+/* { dg-output "The answer is 42(\n|\r\n|\r)+" } */
+
+#include <stdio.h>
+
+int var = 42;
+
+int
+main ()
+{
+#pragma acc parallel
+    {
+      printf ("The answer is %d\n", var);
+    }
+}
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/abort-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/abort-1.f90
index fc0af7ff7d8..70c05d7d3c1 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/abort-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/abort-1.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 ! Verify that an unconditional "call abort" inside an OpenACC parallel region
 ! does the right thing.
 
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/abort-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/abort-2.f90
index 97a692ba667..6671d46d8b8 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/abort-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/abort-2.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 ! Verify that a conditional "call abort" inside an OpenACC parallel region does
 ! the right thing.
 
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-1.f90
index d6c67a0c31a..1a8432cfa86 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-1.f90
@@ -1,4 +1,6 @@
+! { dg-do run }
 ! { dg-additional-options "-cpp" }
+!
 ! TODO: Have to disable the acc_on_device builtin for we want to test the
 ! libgomp library function?  The command line option
 ! '-fno-builtin-acc_on_device' is valid for C/C++/ObjC/ObjC++ but not for
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-2.f b/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-2.f
index 75e24509ce9..56f99d4f99b 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-2.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-2.f
@@ -1,4 +1,6 @@
+! { dg-do run }
 ! { dg-additional-options "-cpp" }
+!
 ! TODO: Have to disable the acc_on_device builtin for we want to test
 ! the libgomp library function?  The command line option
 ! '-fno-builtin-acc_on_device' is valid for C/C++/ObjC/ObjC++ but not
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-3.f b/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-3.f
index 908d185f40c..565723851b1 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-3.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/acc_on_device-1-3.f
@@ -1,4 +1,6 @@
+! { dg-do run }
 ! { dg-additional-options "-cpp" }
+!
 ! TODO: Have to disable the acc_on_device builtin for we want to test
 ! the libgomp library function?  The command line option
 ! '-fno-builtin-acc_on_device' is valid for C/C++/ObjC/ObjC++ but not
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/allocatable-1-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/allocatable-1-1.f90
new file mode 100644
index 00000000000..e5981312f14
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/allocatable-1-1.f90
@@ -0,0 +1,68 @@
+! Test 'allocatable' with OpenACC data clauses.
+
+! See also '../libgomp.fortran/target-allocatable-1-1.f90'.
+
+! { dg-do run }
+! { dg-additional-options "-cpp" }
+
+program main
+  implicit none
+  integer, allocatable :: a, b, c, d, e
+
+  allocate (a)
+  a = 11
+
+  b = 25 ! Implicit allocation.
+
+  c = 52 ! Implicit allocation.
+
+  !No 'allocate (d)' here.
+
+  !No 'allocate (e)' here.
+
+  !$acc parallel copyin(a) copy(b, c, d) copyout(e)
+
+  if (.not. allocated (a)) stop 1
+  if (a .ne. 11) stop 2
+  a = 33
+
+  if (.not. allocated (b)) stop 3
+  if (b .ne. 25) stop 4
+
+  if (.not. allocated (c)) stop 5
+  if (c .ne. 52) stop 6
+  c = 10
+
+  if (allocated (d)) stop 7
+  d = 42 ! Implicit allocation, but on device only.
+  if (.not. allocated (d)) stop 8
+  deallocate (d) ! OpenMP requires must be "unallocated upon exit from the region".
+
+  if (allocated (e)) stop 9
+  e = 24 ! Implicit allocation, but on device only.
+  if (.not. allocated (e)) stop 10
+  deallocate (e) ! OpenMP requires must be "unallocated upon exit from the region".
+
+  !$acc end parallel
+
+  if (.not. allocated (a)) stop 20
+#if ACC_MEM_SHARED
+  if (a .ne. 33) stop 21
+#else
+  if (a .ne. 11) stop 22
+#endif
+  deallocate (a)
+
+  if (.not. allocated (b)) stop 23
+  if (b .ne. 25) stop 24
+  deallocate (b)
+
+  if (.not. allocated (c)) stop 25
+  if (c .ne. 10) stop 26
+  deallocate (c)
+
+  if (allocated (d)) stop 27
+
+  if (allocated (e)) stop 28
+
+end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/allocatable-1-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/allocatable-1-2.f90
new file mode 100644
index 00000000000..2faf0f8078f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/allocatable-1-2.f90
@@ -0,0 +1,81 @@
+! Test 'allocatable' with OpenACC data clauses, subroutine in module, pass by
+! reference.
+
+! See also '../libgomp.fortran/target-allocatable-1-2.f90'.
+
+! { dg-do run }
+! { dg-additional-options "-cpp" }
+
+module m
+contains
+  subroutine r (a, b, c, d, e)
+    implicit none
+    integer, allocatable :: a, b, c, d, e
+
+    !$acc parallel copyin(a) copy(b, c, d) copyout(e)
+
+    if (.not. allocated (a)) stop 1
+    if (a .ne. 11) stop 2
+    a = 33
+
+    if (.not. allocated (b)) stop 3
+    if (b .ne. 25) stop 4
+
+    if (.not. allocated (c)) stop 5
+    if (c .ne. 52) stop 6
+    c = 10
+
+    if (allocated (d)) stop 7
+    d = 42 ! Implicit allocation, but on device only.
+    if (.not. allocated (d)) stop 8
+    deallocate (d) ! OpenMP requires must be "unallocated upon exit from the region".
+
+    if (allocated (e)) stop 9
+    e = 24 ! Implicit allocation, but on device only.
+    if (.not. allocated (e)) stop 10
+    deallocate (e) ! OpenMP requires must be "unallocated upon exit from the region".
+
+    !$acc end parallel
+
+  end subroutine r
+end module m
+
+program main
+  use m
+  implicit none
+  integer, allocatable :: a, b, c, d, e
+
+  allocate (a)
+  a = 11
+
+  b = 25 ! Implicit allocation.
+
+  c = 52 ! Implicit allocation.
+
+  !No 'allocate (d)' here.
+
+  !No 'allocate (e)' here.
+
+  call r(a, b, c, d, e)
+
+  if (.not. allocated (a)) stop 20
+#if ACC_MEM_SHARED
+  if (a .ne. 33) stop 21
+#else
+  if (a .ne. 11) stop 22
+#endif
+  deallocate (a)
+
+  if (.not. allocated (b)) stop 23
+  if (b .ne. 25) stop 24
+  deallocate (b)
+
+  if (.not. allocated (c)) stop 25
+  if (c .ne. 10) stop 26
+  deallocate (c)
+
+  if (allocated (d)) stop 27
+
+  if (allocated (e)) stop 28
+
+end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/allocatable-array-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/allocatable-array-1.f90
new file mode 100644
index 00000000000..c9a76385d9f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/allocatable-array-1.f90
@@ -0,0 +1,27 @@
+! { dg-do run }
+
+program main
+  integer, parameter :: n = 40
+  integer, allocatable :: ar(:,:,:)
+  integer :: i
+
+  allocate (ar(1:n,0:n-1,0:n-1))
+  !$acc enter data copyin (ar)
+
+  !$acc update host (ar)
+
+  !$acc update device (ar)
+
+  call update_ar (ar, n)
+
+  !$acc exit data copyout (ar)
+end program main
+
+subroutine update_ar (ar, n)
+  integer :: n
+  integer, dimension (1:n,0:n-1,0:n-1) :: ar
+
+  !$acc update host (ar)
+
+  !$acc update device (ar)
+end subroutine update_ar
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/common-block-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/common-block-1.f90
new file mode 100644
index 00000000000..d77878ede39
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/common-block-1.f90
@@ -0,0 +1,107 @@
+! { dg-do run }
+!
+! Test data located inside common blocks.  This test does not exercise
+! ACC DECLARE.
+
+module const
+  integer, parameter :: n = 100
+end module const
+
+subroutine check
+  use const
+
+  implicit none
+  integer i, x(n), y
+  common /BLOCK/ x, y
+
+  do i = 1, n
+     if (x(i) .ne. y) stop 1
+  end do
+end subroutine check
+
+module m
+  use const
+  integer a(n), b
+  common /BLOCK/ a, b
+
+contains
+  subroutine mod_implicit_incr
+    implicit none
+    integer i
+
+    !$acc parallel loop
+    do i = 1, n
+       a(i) = b
+    end do
+    !$acc end parallel loop
+
+    call check
+  end subroutine mod_implicit_incr
+
+  subroutine mod_explicit_incr
+    implicit none
+    integer i
+
+    !$acc parallel loop copy(a(1:n)) copyin(b)
+    do i = 1, n
+       a(i) = b
+    end do
+    !$acc end parallel loop
+
+    call check
+  end subroutine mod_explicit_incr
+end module m
+
+subroutine sub_implicit_incr
+  use const
+
+  implicit none
+  integer i, x(n), y
+  common /BLOCK/ x, y
+
+  !$acc parallel loop
+  do i = 1, n
+     x(i) = y
+  end do
+  !$acc end parallel loop
+
+  call check
+end subroutine sub_implicit_incr
+
+subroutine sub_explicit_incr
+  use const
+
+  implicit none
+  integer i, x(n), y
+  common /BLOCK/ x, y
+
+  !$acc parallel loop copy(x(1:n)) copyin(y)
+  do i = 1, n
+     x(i) = y
+  end do
+  !$acc end parallel loop
+
+  call check
+end subroutine sub_explicit_incr
+
+program main
+  use m
+
+  implicit none
+
+  a(:) = -1
+  b = 5
+  call mod_implicit_incr
+
+  a(:) = -2
+  b = 6
+  call mod_explicit_incr
+
+  a(:) = -3
+  b = 7
+  call sub_implicit_incr
+
+  a(:) = -4
+  b = 8
+  call sub_explicit_incr
+end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/common-block-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/common-block-2.f90
new file mode 100644
index 00000000000..018b37d00bb
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/common-block-2.f90
@@ -0,0 +1,152 @@
+! { dg-do run }
+!
+! Test data located inside common blocks.  This test does not exercise
+! ACC DECLARE.  All data clauses are explicit.
+
+module consts
+  integer, parameter :: n = 100
+end module consts
+
+subroutine validate
+  use consts
+
+  implicit none
+  integer i, j
+  real*4 x(n), y(n), z
+  common /BLOCK/ x, y, z, j
+
+  do i = 1, n
+     if (abs(x(i) - i - z) .ge. 0.0001) stop 1
+  end do
+end subroutine validate
+
+subroutine incr
+  use consts
+
+  implicit none
+  integer i, j
+  real*4 x(n), y(n), z
+  common /BLOCK/ x, y, z, j
+
+  !$acc parallel loop pcopy(/BLOCK/)
+  do i = 1, n
+     x(i) = x(i) + z
+  end do
+  !$acc end parallel loop
+end subroutine incr
+
+program main
+  use consts
+
+  implicit none
+  integer i, j
+  real*4 a(n), b(n), c
+  common /BLOCK/ a, b, c, j
+
+  ! Test copyout, pcopy, device
+
+  !$acc data copyout(a, c)
+
+  c = 1.0
+
+  !$acc update device(c)
+
+  !$acc parallel loop pcopy(a)
+  do i = 1, n
+     a(i) = i
+  end do
+  !$acc end parallel loop
+
+  call incr
+  call incr
+  call incr
+  !$acc end data
+
+  c = 3.0
+  call validate
+
+  ! Test pcopy without copyout
+
+  c = 2.0
+  call incr
+  c = 5.0
+  call validate
+
+  ! Test create, delete, host, copyout, copyin
+
+  !$acc enter data create(b)
+
+  !$acc parallel loop pcopy(b)
+  do i = 1, n
+     b(i) = i
+  end do
+  !$acc end parallel loop
+
+  !$acc update host (b)
+
+  !$acc parallel loop pcopy(b) copyout(a) copyin(c)
+  do i = 1, n
+     a(i) = b(i) + c
+  end do
+  !$acc end parallel loop
+
+  !$acc exit data delete(b)
+
+  call validate
+
+  a(:) = b(:)
+  c = 0.0
+  call validate
+
+  ! Test copy
+
+  c = 1.0
+  !$acc parallel loop copy(/BLOCK/)
+  do i = 1, n
+     a(i) = b(i) + c
+  end do
+  !$acc end parallel loop
+
+  call validate
+
+  ! Test pcopyin, pcopyout FIXME
+
+  c = 2.0
+  !$acc data copyin(b, c) copyout(a)
+
+  !$acc parallel loop pcopyin(b, c) pcopyout(a)
+  do i = 1, n
+     a(i) = b(i) + c
+  end do
+  !$acc end parallel loop
+
+  !$acc end data
+
+  call validate
+
+  ! Test reduction, private
+
+  j = 0
+
+  !$acc parallel private(i) copy(j)
+  !$acc loop reduction(+:j)
+  do i = 1, n
+     j = j + 1
+  end do
+  !$acc end parallel
+
+  if (j .ne. n) stop 2
+
+  ! Test firstprivate, copy
+
+  a(:) = 0
+  c = j
+
+  !$acc parallel loop firstprivate(c) copyout(a)
+  do i = 1, n
+     a(i) = i + c
+  end do
+  !$acc end parallel loop
+
+  call validate
+end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/common-block-3.f90 b/libgomp/testsuite/libgomp.oacc-fortran/common-block-3.f90
new file mode 100644
index 00000000000..3c59b66246b
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/common-block-3.f90
@@ -0,0 +1,139 @@
+! { dg-do run }
+!
+! Test data located inside common blocks.  This test does not exercise
+! ACC DECLARE.  Most of the data clauses are implicit.
+
+module consts
+  integer, parameter :: n = 100
+end module consts
+
+subroutine validate
+  use consts
+
+  implicit none
+  integer i, j
+  real*4 x(n), y(n), z
+  common /BLOCK/ x, y, z, j
+
+  do i = 1, n
+     if (abs(x(i) - i - z) .ge. 0.0001) stop 1
+  end do
+end subroutine validate
+
+subroutine incr_parallel
+  use consts
+
+  implicit none
+  integer i, j
+  real*4 x(n), y(n), z
+  common /BLOCK/ x, y, z, j
+
+  !$acc parallel loop
+  do i = 1, n
+     x(i) = x(i) + z
+  end do
+  !$acc end parallel loop
+end subroutine incr_parallel
+
+subroutine incr_kernels
+  use consts
+
+  implicit none
+  integer i, j
+  real*4 x(n), y(n), z
+  common /BLOCK/ x, y, z, j
+
+  !$acc kernels
+  do i = 1, n
+     x(i) = x(i) + z
+  end do
+  !$acc end kernels
+end subroutine incr_kernels
+
+program main
+  use consts
+
+  implicit none
+  integer i, j
+  real*4 a(n), b(n), c
+  common /BLOCK/ a, b, c, j
+
+  !$acc data copyout(a, c)
+
+  c = 1.0
+
+  !$acc update device(c)
+
+  !$acc parallel loop
+  do i = 1, n
+     a(i) = i
+  end do
+  !$acc end parallel loop
+
+  call incr_parallel
+  call incr_parallel
+  call incr_parallel
+  !$acc end data
+
+  c = 3.0
+  call validate
+
+  ! Test pcopy without copyout
+
+  c = 2.0
+  call incr_kernels
+  c = 5.0
+  call validate
+
+  !$acc kernels
+  do i = 1, n
+     b(i) = i
+  end do
+  !$acc end kernels
+
+  !$acc parallel loop
+  do i = 1, n
+     a(i) = b(i) + c
+  end do
+  !$acc end parallel loop
+
+  call validate
+
+  a(:) = b(:)
+  c = 0.0
+  call validate
+
+  ! Test copy
+
+  c = 1.0
+  !$acc parallel loop
+  do i = 1, n
+     a(i) = b(i) + c
+  end do
+  !$acc end parallel loop
+
+  call validate
+
+  c = 2.0
+  !$acc data copyin(b, c) copyout(a)
+
+  !$acc kernels
+  do i = 1, n
+     a(i) = b(i) + c
+  end do
+  !$acc end kernels
+
+  !$acc end data
+
+  call validate
+
+  j = 0
+
+  !$acc parallel loop reduction(+:j)
+  do i = 1, n
+     j = j + 1
+  end do
+  !$acc end parallel loop
+
+  if (j .ne. n) stop 2
+end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/data-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/data-1.f90
index bf323b3f540..eeb06f3c84f 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/data-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/data-1.f90
@@ -26,32 +26,32 @@ program main
   j = -2
 
   !$acc data copyin (i, j)
-    if (is_mapped (i) .eqv. .FALSE.) call abort
-    if (is_mapped (j) .eqv. .FALSE.) call abort
+    if (is_mapped (i) .eqv. .FALSE.) stop 1
+    if (is_mapped (j) .eqv. .FALSE.) stop 2
 
-    if (i .ne. -1 .or. j .ne. -2) call abort
+    if (i .ne. -1 .or. j .ne. -2) stop 3
 
     i = 2
     j = 1
 
-    if (i .ne. 2 .or. j .ne. 1) call abort
+    if (i .ne. 2 .or. j .ne. 1) stop 4
   !$acc end data
 
-  if (i .ne. 2 .or. j .ne. 1) call abort
+  if (i .ne. 2 .or. j .ne. 1) stop 5
 
   i = -1
   j = -2
 
   !$acc data copyout (i, j)
-    if (is_mapped (i) .eqv. .FALSE.) call abort
-    if (is_mapped (j) .eqv. .FALSE.) call abort
+    if (is_mapped (i) .eqv. .FALSE.) stop 6
+    if (is_mapped (j) .eqv. .FALSE.) stop 7
 
-    if (i .ne. -1 .or. j .ne. -2) call abort
+    if (i .ne. -1 .or. j .ne. -2) stop 8
 
     i = 2
     j = 1
 
-    if (i .ne. 2 .or. j .ne. 1) call abort
+    if (i .ne. 2 .or. j .ne. 1) stop 9
 
     !$acc parallel present (i, j)
       i = 4
@@ -59,55 +59,55 @@ program main
     !$acc end parallel
   !$acc end data
 
-  if (i .ne. 4 .or. j .ne. 2) call abort
+  if (i .ne. 4 .or. j .ne. 2) stop 10
 
   i = -1
   j = -2
 
   !$acc data create (i, j)
-    if (is_mapped (i) .eqv. .FALSE.) call abort
-    if (is_mapped (j) .eqv. .FALSE.) call abort
+    if (is_mapped (i) .eqv. .FALSE.) stop 11
+    if (is_mapped (j) .eqv. .FALSE.) stop 12
 
-    if (i .ne. -1 .or. j .ne. -2) call abort
+    if (i .ne. -1 .or. j .ne. -2) stop 13
 
     i = 2
     j = 1
 
-    if (i .ne. 2 .or. j .ne. 1) call abort
+    if (i .ne. 2 .or. j .ne. 1) stop 14
   !$acc end data
 
-  if (i .ne. 2 .or. j .ne. 1) call abort
+  if (i .ne. 2 .or. j .ne. 1) stop 15
 
   i = -1
   j = -2
 
   !$acc data present_or_copyin (i, j)
-    if (is_mapped (i) .eqv. .FALSE.) call abort
-    if (is_mapped (j) .eqv. .FALSE.) call abort
+    if (is_mapped (i) .eqv. .FALSE.) stop 16
+    if (is_mapped (j) .eqv. .FALSE.) stop 17
 
-    if (i .ne. -1 .or. j .ne. -2) call abort
+    if (i .ne. -1 .or. j .ne. -2) stop 18
 
     i = 2
     j = 1
 
-    if (i .ne. 2 .or. j .ne. 1) call abort
+    if (i .ne. 2 .or. j .ne. 1) stop 19
   !$acc end data
 
-  if (i .ne. 2 .or. j .ne. 1) call abort
+  if (i .ne. 2 .or. j .ne. 1) stop 20
 
   i = -1
   j = -2
 
   !$acc data present_or_copyout (i, j)
-    if (is_mapped (i) .eqv. .FALSE.) call abort
-    if (is_mapped (j) .eqv. .FALSE.) call abort
+    if (is_mapped (i) .eqv. .FALSE.) stop 21
+    if (is_mapped (j) .eqv. .FALSE.) stop 22
 
-    if (i .ne. -1 .or. j .ne. -2) call abort
+    if (i .ne. -1 .or. j .ne. -2) stop 23
 
     i = 2
     j = 1
 
-    if (i .ne. 2 .or. j .ne. 1) call abort
+    if (i .ne. 2 .or. j .ne. 1) stop 24
 
     !$acc parallel present (i, j)
       i = 4
@@ -115,98 +115,98 @@ program main
     !$acc end parallel
   !$acc end data
 
-  if (i .ne. 4 .or. j .ne. 2) call abort
+  if (i .ne. 4 .or. j .ne. 2) stop 25
 
   i = -1
   j = -2
 
   !$acc data present_or_copy (i, j)
-    if (is_mapped (i) .eqv. .FALSE.) call abort
-    if (is_mapped (j) .eqv. .FALSE.) call abort
+    if (is_mapped (i) .eqv. .FALSE.) stop 26
+    if (is_mapped (j) .eqv. .FALSE.) stop 27
 
-    if (i .ne. -1 .or. j .ne. -2) call abort
+    if (i .ne. -1 .or. j .ne. -2) stop 28
 
     i = 2
     j = 1
 
-    if (i .ne. 2 .or. j .ne. 1) call abort
+    if (i .ne. 2 .or. j .ne. 1) stop 29
   !$acc end data
 
 #if ACC_MEM_SHARED
-  if (i .ne. 2 .or. j .ne. 1) call abort
+  if (i .ne. 2 .or. j .ne. 1) stop 30
 #else
-  if (i .ne. -1 .or. j .ne. -2) call abort
+  if (i .ne. -1 .or. j .ne. -2) stop 31
 #endif
 
   i = -1
   j = -2
 
   !$acc data present_or_create (i, j)
-    if (is_mapped (i) .eqv. .FALSE.) call abort
-    if (is_mapped (j) .eqv. .FALSE.) call abort
+    if (is_mapped (i) .eqv. .FALSE.) stop 32
+    if (is_mapped (j) .eqv. .FALSE.) stop 33
 
     i = 2
     j = 1
 
-    if (i .ne. 2 .or. j .ne. 1) call abort
+    if (i .ne. 2 .or. j .ne. 1) stop 34
   !$acc end data
 
-  if (i .ne. 2 .or. j .ne. 1) call abort
+  if (i .ne. 2 .or. j .ne. 1) stop 35
 
   i = -1
   j = -2
 
   !$acc data copyin (i, j)
     !$acc data present (i, j)
-      if (is_mapped (i) .eqv. .FALSE.) call abort
-      if (is_mapped (j) .eqv. .FALSE.) call abort
+      if (is_mapped (i) .eqv. .FALSE.) stop 36
+      if (is_mapped (j) .eqv. .FALSE.) stop 37
 
-      if (i .ne. -1 .or. j .ne. -2) call abort
+      if (i .ne. -1 .or. j .ne. -2) stop 38
 
       i = 2
       j = 1
 
-      if (i .ne. 2 .or. j .ne. 1) call abort
+      if (i .ne. 2 .or. j .ne. 1) stop 39
     !$acc end data
   !$acc end data
 
-  if (i .ne. 2 .or. j .ne. 1) call abort
+  if (i .ne. 2 .or. j .ne. 1) stop 40
 
   i = -1
   j = -2
 
   !$acc data copyin (i, j)
     !$acc data present (i, j)
-      if (is_mapped (i) .eqv. .FALSE.) call abort
-      if (is_mapped (j) .eqv. .FALSE.) call abort
+      if (is_mapped (i) .eqv. .FALSE.) stop 41
+      if (is_mapped (j) .eqv. .FALSE.) stop 42
 
-      if (i .ne. -1 .or. j .ne. -2) call abort
+      if (i .ne. -1 .or. j .ne. -2) stop 43
 
       i = 2
       j = 1
 
-      if (i .ne. 2 .or. j .ne. 1) call abort
+      if (i .ne. 2 .or. j .ne. 1) stop 44
     !$acc end data
   !$acc end data
 
-  if (i .ne. 2 .or. j .ne. 1) call abort
+  if (i .ne. 2 .or. j .ne. 1) stop 45
 
   i = -1
   j = -2
 
   !$acc data
 #if !ACC_MEM_SHARED
-    if (is_mapped (i) .eqv. .TRUE.) call abort
-    if (is_mapped (j) .eqv. .TRUE.) call abort
+    if (is_mapped (i) .eqv. .TRUE.) stop 46
+    if (is_mapped (j) .eqv. .TRUE.) stop 47
 #endif
-    if (i .ne. -1 .or. j .ne. -2) call abort
+    if (i .ne. -1 .or. j .ne. -2) stop 48
 
     i = 2
     j = 1
 
-    if (i .ne. 2 .or. j .ne. 1) call abort
+    if (i .ne. 2 .or. j .ne. 1) stop 49
   !$acc end data
 
-  if (i .ne. 2 .or. j .ne. 1) call abort
+  if (i .ne. 2 .or. j .ne. 1) stop 50
 
 end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/data-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/data-2.f90
index 83a540070e6..ec206958e23 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/data-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/data-2.f90
@@ -54,7 +54,7 @@ program test
   !$acc wait
 
   do i = 1, N
-    if (d(i) .ne. 4.0) call abort
+    if (d(i) .ne. 4.0) STOP 3
   end do
 
   c(:) = 3.0
@@ -75,7 +75,7 @@ program test
   !$acc wait
 
   do i = 1, N
-    if (d(i) .ne. 4.0) call abort
+    if (d(i) .ne. 4.0) STOP 4
   end do
 
 end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/data-5.f90 b/libgomp/testsuite/libgomp.oacc-fortran/data-5.f90
index a8843dedc22..c68a2795900 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/data-5.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/data-5.f90
@@ -23,8 +23,8 @@ program refcount_test
      if (h(i) .eq. i) c = c + 1
   end do
   ! h[] should be filled with uninitialized device values,
-  ! abort if it's not.
-  if (c .eq. N) call abort
+  ! 'stop' if it's not.
+  if (c .eq. N) stop 1
 
   h(:) = 0
 
@@ -37,20 +37,20 @@ program refcount_test
   ! No actual copyout should happen.
   call acc_copyout (h)
   do i = 1, N
-     if (h(i) .ne. 0) call abort
+     if (h(i) .ne. 0) stop 2
   end do
 
   !$acc exit data delete (h(1:N))
 
   ! This should not actually be deleted yet.
-  if (acc_is_present (h) .eqv. .FALSE.) call abort
+  if (acc_is_present (h) .eqv. .FALSE.) stop 3
 
   !$acc exit data copyout (h(1:N)) finalize
 
   do i = 1, N
-     if (h(i) .ne. 111) call abort
+     if (h(i) .ne. 111) stop 4
   end do
 
-  if (acc_is_present (h) .eqv. .TRUE.) call abort
+  if (acc_is_present (h) .eqv. .TRUE.) stop 5
 
 end program refcount_test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/declare-5.f90 b/libgomp/testsuite/libgomp.oacc-fortran/declare-5.f90
index 3ab91147e07..2fd25d611a9 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/declare-5.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/declare-5.f90
@@ -3,27 +3,105 @@
 module vars
   implicit none
   real b
- !$acc declare device_resident (b)
+  !$acc declare device_resident (b)
+
+  integer :: x, y, z
+  common /block/ x, y, z
+  !$acc declare device_resident (/block/)
 end module vars
 
+subroutine set()
+  use openacc
+  implicit none
+  integer :: a(5), b(1), c, vals(7)
+  common /another/ a, b, c
+  !$acc declare device_resident (/another/)
+  if (.not. acc_is_present (a)) stop 10
+  if (.not. acc_is_present (b)) stop 11
+  if (.not. acc_is_present (c)) stop 12
+
+  vals = 99
+  ! NOTE: The current (Nov 2019) implementation requires the 'present'
+  ! as it tries to otherwises map the device_resident variables;
+  ! following OpenMP 4.0 semantic: 'a' + 'b' are 'copy' (map fromto) and
+  ! 'c' is firstprivate.
+  !$acc parallel copyout(vals) present(a, b, c)
+    a = [11,12,13,14,15]
+    b = 16
+    c = 47
+    vals(1:5) = a
+    vals(6:6) = b
+    vals(7) = c
+  !$acc end parallel
+
+  if (.not. acc_is_present (a)) stop 13
+  if (.not. acc_is_present (b)) stop 14
+  if (.not. acc_is_present (c)) stop 15
+
+  if (any (vals /= [11,12,13,14,15,16,47])) stop 16
+end subroutine set
+
+subroutine check()
+  use openacc
+  implicit none
+  integer :: g, h(3), i(3)
+  common /another/ g, h, i
+  integer :: val(7)
+  !$acc declare device_resident (/another/)
+  if (.not. acc_is_present (g)) stop 20
+  if (.not. acc_is_present (h)) stop 21
+  if (.not. acc_is_present (i)) stop 22
+
+  val = 99
+  !$acc parallel copyout(val) present(g, h, i)
+    val(5:7) = i
+    val(1) = g
+    val(2:4) = h
+  !$acc end parallel
+
+  if (.not. acc_is_present (g)) stop 23
+  if (.not. acc_is_present (h)) stop 24
+  if (.not. acc_is_present (i)) stop 25
+
+
+  !print *, val
+  if (any (val /= [11,12,13,14,15,16,47])) stop 26
+end subroutine check
+
+
 program test
   use vars
   use openacc
   implicit none
   real a
+  integer :: k
 
-  if (acc_is_present (b) .neqv. .true.) STOP 1
+  call set()
+  call check()
+
+  if (.not. acc_is_present (b)) stop 1
+  if (.not. acc_is_present (x)) stop 2
+  if (.not. acc_is_present (y)) stop 3
+  if (.not. acc_is_present (z)) stop 4
 
   a = 2.0
+  k = 42
 
-  !$acc parallel copy (a)
+  !$acc parallel copy (a, k)
     b = a
     a = 1.0
     a = a + b
+    x = k
+    y = 7*k - 2*x
+    z = 3*y
+    k = k - z + y
    !$acc end parallel
 
-  if (acc_is_present (b) .neqv. .true.) STOP 2
-
-  if (a .ne. 3.0) STOP 3
+  if (.not. acc_is_present (b)) stop 5
+  if (.not. acc_is_present (x)) stop 6
+  if (.not. acc_is_present (y)) stop 7
+  if (.not. acc_is_present (z)) stop 8
 
+  if (a /= 3.0) stop 30
+  if (k /= -378) stop 31
 end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/dummy-array.f90 b/libgomp/testsuite/libgomp.oacc-fortran/dummy-array.f90
index e95563cd406..697d94d52aa 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/dummy-array.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/dummy-array.f90
@@ -13,7 +13,7 @@ program main
   call dummy_array (a, n)
   
   do i = 1, n
-     if (a(i) .ne. i) call abort
+     if (a(i) .ne. i) stop 1
   end do
 end program main
 
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-1.f b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-1.f
index 4965e674c27..e7358f4f20d 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-1.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-1.f
@@ -13,8 +13,13 @@
 
 ! { dg-output "CheCKpOInT(\n|\r\n|\r)+" }
 ! { dg-output "ERROR STOP (\n|\r\n|\r)+" }
-! PR85463.  The "minimal" libgfortran implementation used with nvptx
-! offloading is a little bit different.
-! { dg-output "Error termination.*" { target { ! openacc_nvidia_accel_selected } } }
+!
+! In gfortran's main program, libfortran's set_options is called - which sets
+! compiler_options.backtrace = 1 by default.  For an offload libgfortran, this
+! is never called and, hence, "Error termination." is never printed.  Thus:
+! { dg-output "Error termination.*" { target { ! { openacc_nvidia_accel_selected || openacc_amdgcn_accel_selected } } } }
+!
+! PR85463:
 ! { dg-output "libgomp: cuStreamSynchronize error.*" { target openacc_nvidia_accel_selected } }
+!
 ! { dg-shouldfail "" }
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-2.f b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-2.f
index 7103fdb5d8e..fca1d960f66 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-2.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-2.f
@@ -13,8 +13,13 @@
 
 ! { dg-output "CheCKpOInT(\n|\r\n|\r)+" }
 ! { dg-output "ERROR STOP 35(\n|\r\n|\r)+" }
-! PR85463.  The "minimal" libgfortran implementation used with nvptx
-! offloading is a little bit different.
-! { dg-output "Error termination.*" { target { ! openacc_nvidia_accel_selected } } }
+!
+! In gfortran's main program, libfortran's set_options is called - which sets
+! compiler_options.backtrace = 1 by default.  For an offload libgfortran, this
+! is never called and, hence, "Error termination." is never printed.  Thus:
+! { dg-output "Error termination.*" { target { ! { openacc_nvidia_accel_selected || openacc_amdgcn_accel_selected } } } }
+!
+! PR85463:
 ! { dg-output "libgomp: cuStreamSynchronize error.*" { target openacc_nvidia_accel_selected } }
+!
 ! { dg-shouldfail "" }
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-3.f b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-3.f
index 9c217f14ea1..2ae0b0d1602 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-3.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-3.f
@@ -13,8 +13,13 @@
 
 ! { dg-output "CheCKpOInT(\n|\r\n|\r)+" }
 ! { dg-output "ERROR STOP SiGN(\n|\r\n|\r)+" }
-! PR85463.  The "minimal" libgfortran implementation used with nvptx
-! offloading is a little bit different.
-! { dg-output "Error termination.*" { target { ! openacc_nvidia_accel_selected } } }
+!
+! In gfortran's main program, libfortran's set_options is called - which sets
+! compiler_options.backtrace = 1 by default.  For an offload libgfortran, this
+! is never called and, hence, "Error termination." is never printed.  Thus:
+! { dg-output "Error termination.*" { target { ! { openacc_nvidia_accel_selected || openacc_amdgcn_accel_selected } } } }
+!
+! PR85463:
 ! { dg-output "libgomp: cuStreamSynchronize error.*" { target openacc_nvidia_accel_selected } }
+!
 ! { dg-shouldfail "" }
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/fortran.exp b/libgomp/testsuite/libgomp.oacc-fortran/fortran.exp
index af25a22a522..60f0889a07c 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/fortran.exp
+++ b/libgomp/testsuite/libgomp.oacc-fortran/fortran.exp
@@ -56,11 +56,17 @@ if { $lang_test_file_found } {
 	    # Allow for spec subsitution.
 	    lappend ALWAYS_CFLAGS "additional_flags=-B${blddir}/${quadmath_library_path}/"
 	    set ld_library_path "$always_ld_library_path:${blddir}/${lang_library_path}:${blddir}/${quadmath_library_path}"
+	    append lang_link_flags " -lquadmath"
 	} else {
 	    set ld_library_path "$always_ld_library_path:${blddir}/${lang_library_path}"
 	}
     } else {
         set ld_library_path "$always_ld_library_path"
+        if { [check_no_compiler_messages has_libquadmath executable {
+                 int main() {return 0;}
+              } "-lgfortran -lquadmath"] } then {
+            append lang_link_flags " -lquadmath"
+        }
     }
     append ld_library_path [gcc-set-multilib-library-path $GCC_UNDER_TEST]
     set_ld_library_path_env_vars
@@ -76,6 +82,15 @@ if { $lang_test_file_found } {
 		unsupported "$subdir $offload_target offloading"
 		continue
 	    }
+	    gcn {
+		if { ![check_effective_target_openacc_amdgcn_accel_present] } {
+		    # Don't bother; execution testing is going to FAIL.
+		    untested "$subdir $offload_target offloading: supported, but hardware not accessible"
+		    continue
+		}
+
+		set acc_mem_shared 0
+	    }
 	    host {
 		set acc_mem_shared 1
 	    }
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/gemm-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/gemm-2.f90
index fe108732a5f..5fa93642477 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/gemm-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/gemm-2.f90
@@ -74,7 +74,7 @@ program main
 
   do i = 1, m
      do j = 1, n
-        if (c(i,j) /= e(i,j)) call abort
+        if (c(i,j) /= e(i,j)) stop 1
      end do
   end do
 end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/gemm.f90 b/libgomp/testsuite/libgomp.oacc-fortran/gemm.f90
index de78148c7b3..9e8915fbb88 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/gemm.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/gemm.f90
@@ -73,7 +73,7 @@ program main
 
   do i = 1, m
      do j = 1, n
-        if (d(i,j) /= e(i,j)) call abort
+        if (d(i,j) /= e(i,j)) stop 1
      end do
   end do
 end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/host_data-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/host_data-2.f90
index ff0921863f6..ab70e4e8dea 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/host_data-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/host_data-2.f90
@@ -93,6 +93,6 @@ subroutine validate_results (n, a, b)
   real*4 :: a(n), b(n)
 
   do i = 1, N
-     if (abs(a(i) - b(i)) > 0.0001) call abort
+     if (abs(a(i) - b(i)) > 0.0001) stop 1
   end do
 end subroutine validate_results
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/host_data-3.f b/libgomp/testsuite/libgomp.oacc-fortran/host_data-3.f
index 05ed949ee5c..434c18c9889 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/host_data-3.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/host_data-3.f
@@ -79,7 +79,7 @@
       real*4 :: a(n), b(n)
 
       do i = 1, N
-         if (abs(a(i) - b(i)) > 0.0001) call abort
+         if (abs(a(i) - b(i)) > 0.0001) stop 1
       end do
       end subroutine validate_results
 
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/host_data-4.f90 b/libgomp/testsuite/libgomp.oacc-fortran/host_data-4.f90
index 6e379b5485b..e81a8b292c1 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/host_data-4.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/host_data-4.f90
@@ -33,7 +33,7 @@ contains
     real*4 :: a(n), b(n)
 
     do i = 1, N
-       if (abs(a(i) - b(i)) > 0.0001) call abort
+       if (abs(a(i) - b(i)) > 0.0001) stop 1
     end do
   end subroutine validate_results
 end module cublas
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction-2.f90
index fdf9409bde4..0a612a57964 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction-2.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 program foo
 
   IMPLICIT NONE
@@ -5,7 +7,7 @@ program foo
 
   call bar (vol)
 
-  if (vol .ne. 4) call abort
+  if (vol .ne. 4) stop 1
 end program foo
 
 subroutine bar(vol)
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction.f90
index 912a22b5153..0b939c04fbb 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-acc-loop-reduction.f90
@@ -1,10 +1,12 @@
+! { dg-do run }
+!
 program foo
   IMPLICIT NONE
   INTEGER :: vol = 0
 
   call bar (vol)
 
-  if (vol .ne. 2) call abort
+  if (vol .ne. 2) stop 1
 end program foo
 
 subroutine bar(vol)
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-collapse-3.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-collapse-3.f90
index 4ef99cd3475..03b3a115d7b 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-collapse-3.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-collapse-3.f90
@@ -14,7 +14,7 @@ dokk: do kk=1,3
       enddo dokk
 115   continue
   !$acc end kernels
-  if (any(a(1:3,1:3,1:3).ne.1)) call abort
+  if (any(a(1:3,1:3,1:3).ne.1)) stop 1
 
   !$acc kernels
   !$acc loop collapse(3)
@@ -26,5 +26,5 @@ doll: do ll=1,3
       enddo doll
 120 end do dol
   !$acc end kernels
-  if (any(a(1:3,1:3,1:3).ne.2)) call abort
+  if (any(a(1:3,1:3,1:3).ne.2)) stop 2
 end program collapse3
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-collapse-4.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-collapse-4.f90
index db382a7deb6..15e33603adb 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-collapse-4.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-collapse-4.f90
@@ -30,11 +30,11 @@ program collapse4
       end do
     end do
   end do
-  if (l .neqv. r) call abort
+  if (l .neqv. r) stop 1
   do i = 2, 6
     do j = -2, 4
       do k = 13, 18
-         if (a(i, j, k) .ne. b(i, j, k)) call abort
+         if (a(i, j, k) .ne. b(i, j, k)) stop 2
       end do
     end do
   end do
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-independent.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-independent.f90
index a881fbbe5cc..5a47aca2dba 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-independent.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-independent.f90
@@ -26,7 +26,7 @@ subroutine foo (a,  b,  c)
   !$acc end kernels
 
   do i = 1, n
-    if (c(i) .ne. a(i) + b(i)) call abort
+    if (c(i) .ne. a(i) + b(i)) stop 1
   end do
 
 end subroutine
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-loop-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-loop-1.f90
index edcdc56ec1c..37aa0ac4f63 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-loop-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-loop-1.f90
@@ -37,7 +37,7 @@ program loops
   !$acc end kernels
 
   do i = 1, n
-     if (a(i) .ne. b(i)) call abort
+     if (a(i) .ne. b(i)) stop 1
   end do
   call check (a, b, n)
 
@@ -61,6 +61,6 @@ subroutine check (a, b, n)
   integer :: i
 
   do i = 1, n
-     if (a(i) .ne. b(i)) call abort
+     if (a(i) .ne. b(i)) stop 2
   end do
 end subroutine check
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-map-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-map-1.f90
index 704ff622854..736ce1791ae 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-map-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-map-1.f90
@@ -37,7 +37,7 @@ program map
   !$acc end kernels
 
   do i = 1, n
-     if (a(i) .ne. b(i)) call abort
+     if (a(i) .ne. b(i)) stop 1
   end do
   call check (a, b, n)
 
@@ -111,6 +111,6 @@ subroutine check (a, b, n)
   integer :: i
 
   do i = 1, n
-     if (a(i) .ne. b(i)) call abort
+     if (a(i) .ne. b(i)) stop 2
   end do
 end subroutine check
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-parallel-loop-data-enter-exit.f95 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-parallel-loop-data-enter-exit.f95
index fe1088c0d04..0d353e80131 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-parallel-loop-data-enter-exit.f95
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-parallel-loop-data-enter-exit.f95
@@ -30,7 +30,7 @@ program main
   !$acc exit data copyout (a(0:n-1), b(0:n-1), c(0:n-1))
 
   do i = 0, n - 1
-     if (c(i) .ne. a(i) + b(i)) call abort
+     if (c(i) .ne. a(i) + b(i)) stop 1
   end do
 
 end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-1.f90
index 5119fabadaf..bcc0476d665 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-1.f90
@@ -18,6 +18,6 @@ program main
   !$acc end kernels
 
   do i = 1, 32
-     if (arr(i) .ne. i * 3) call abort
+     if (arr(i) .ne. i * 3) stop 1
   end do
 end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-2.f90
index 5e46287497d..5571059588f 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-2.f90
@@ -23,6 +23,6 @@ program main
   !$acc end kernels
 
   do i = 0, 32 * 32 - 1
-     if (arr(i) .ne. i + (i / 32) * 2) call abort
+     if (arr(i) .ne. i + (i / 32) * 2) stop 1
   end do
 end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-3.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-3.f90
index 5cc3378f459..6abbed7f489 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-3.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-3.f90
@@ -23,6 +23,6 @@ program main
   !$acc end kernels
 
   do i = 0, 32 * 32 - 1
-     if (arr(i) .ne. i + (i / 32) * 2) call abort
+     if (arr(i) .ne. i + (i / 32) * 2) stop 1
   end do
 end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-6.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-6.f90
index 1e41555aa1c..d92be2d4f0e 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-6.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-6.f90
@@ -31,6 +31,6 @@ program main
   !$acc end kernels
 
   do i = 0, 32 * 32 - 1
-     if (arr(i) .ne. i + (i / 32) * 13) call abort
+     if (arr(i) .ne. i + (i / 32) * 13) stop 1
   end do
 end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-1.f90
index 3efd9fe473b..e9c0fb3f130 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-1.f90
@@ -33,7 +33,7 @@ program main
         do k = 0, 32 - 1
            idx = i * 1024 + j * 32 + k
            if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then
-              call abort
+              stop 1
            end if
         end do
      end do
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-2.f90
index 1cf3b9818ef..13badb51919 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-2.f90
@@ -30,7 +30,7 @@ program main
         do k = 0, 32 - 1
            idx = i * 1024 + j * 32 + k
            if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then
-              call abort
+              stop 1
            end if
         end do
      end do
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-1.f90
index 55e98e05c03..04d732ef410 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-1.f90
@@ -22,6 +22,6 @@ program main
   !$acc end kernels
 
   do i = 0, 32 * 32 - 1
-     if (arr(i) .ne. i + ieor(i / 32, mod(i, 32) * 3)) call abort
+     if (arr(i) .ne. i + ieor(i / 32, mod(i, 32) * 3)) stop 1
   end do
 end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-2.f90
index 7924e7f13a6..6c9a6b81c8a 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-2.f90
@@ -29,7 +29,7 @@ program main
      do j = 0, 32 -1
         do k = 0, 32 - 1
            idx = i * 1024 + j * 32 + k
-           if (arr(idx) .ne. idx + ieor(i, j * 3) * k) call abort
+           if (arr(idx) .ne. idx + ieor(i, j * 3) * k) stop 1
         end do
      end do
   end do
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-3.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-3.f90
index 598c6fd7226..fab14c3a953 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-3.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-3.f90
@@ -40,7 +40,7 @@ program main
         do k = 0, 32 - 1
            idx = i * 1024 + j * 32 + k
            if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then
-              call abort
+              stop 1
            end if
         end do
      end do
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-4.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-4.f90
index 8512d7c3966..71f4a110acb 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-4.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-4.f90
@@ -37,7 +37,7 @@ program main
         do k = 0, 32 - 1
            idx = i * 1024 + j * 32 + k
            if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then
-              call abort
+              stop 1
            end if
         end do
      end do
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-5.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-5.f90
index c3ebf744578..bb457555a42 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-5.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-5.f90
@@ -40,7 +40,7 @@ program main
         do k = 0, 32 - 1
            idx = i * 1024 + j * 32 + k
            if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then
-              call abort
+              stop 1
            end if
         end do
      end do
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-6.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-6.f90
index 2a8a5905895..e169714dd51 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-6.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-6.f90
@@ -41,7 +41,7 @@ program main
         do k = 0, 32 - 1
            idx = i * 1024 + j * 32 + k
            if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then
-              call abort
+              stop 1
            end if
         end do
      end do
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-7.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-7.f90
index 7dd1d3da7be..e262c02ac00 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-7.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-7.f90
@@ -36,7 +36,7 @@ program main
         do k = 0, 32 - 1
            idx = i * 1024 + j * 32 + k
            if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then
-              call abort
+              stop 1
            end if
         end do
      end do
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/kernels-reduction-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/kernels-reduction-1.f90
index c7a52ed98f6..4b85608f0de 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/kernels-reduction-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/kernels-reduction-1.f90
@@ -15,5 +15,5 @@ program reduction
   end do
   !$acc end kernels
 
-  if (red .ne. n) call abort
+  if (red .ne. n) stop 1
 end program reduction
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/lib-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/lib-1.f90
index 901169aa119..760e21f916f 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/lib-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/lib-1.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 use openacc
 
 if (acc_get_num_devices (acc_device_host) .ne. 1) STOP 1
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/lib-12.f90 b/libgomp/testsuite/libgomp.oacc-fortran/lib-12.f90
index 4cf62f2728a..efb921065ac 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/lib-12.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/lib-12.f90
@@ -18,13 +18,13 @@ program main
   call acc_wait_async (0, 1)
 
   ! Test unseen async-argument.
-  if (acc_async_test (2) .neqv. .TRUE.) call abort
+  if (acc_async_test (2) .neqv. .TRUE.) stop 1
   call acc_wait_async (2, 1)
 
   call acc_wait (1)
 
-  if (acc_async_test (0) .neqv. .TRUE.) call abort
-  if (acc_async_test (1) .neqv. .TRUE.) call abort
-  if (acc_async_test (2) .neqv. .TRUE.) call abort
+  if (acc_async_test (0) .neqv. .TRUE.) stop 2
+  if (acc_async_test (1) .neqv. .TRUE.) stop 3
+  if (acc_async_test (2) .neqv. .TRUE.) stop 4
 
 end program
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/lib-13.f90 b/libgomp/testsuite/libgomp.oacc-fortran/lib-13.f90
index da944c35de9..deb2c288604 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/lib-13.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/lib-13.f90
@@ -25,8 +25,8 @@ program main
 
   call acc_wait (nprocs + 1)
 
-  if (acc_async_test (1) .neqv. .TRUE.) call abort
-  if (acc_async_test (2) .neqv. .TRUE.) call abort
-  if (acc_async_test (nprocs + 1) .neqv. .TRUE.) call abort
+  if (acc_async_test (1) .neqv. .TRUE.) stop 1
+  if (acc_async_test (2) .neqv. .TRUE.) stop 2
+  if (acc_async_test (nprocs + 1) .neqv. .TRUE.) stop 3
 
 end program
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/lib-14.f90 b/libgomp/testsuite/libgomp.oacc-fortran/lib-14.f90
index eb0206ccce1..bf35631c96b 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/lib-14.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/lib-14.f90
@@ -19,14 +19,14 @@ program main
 
   call acc_present_or_copyin (h)
 
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 1
 
   call acc_copyout (h)
 
-  if (acc_is_present (h) .neqv. .FALSE.) call abort
+  if (acc_is_present (h) .neqv. .FALSE.) stop 1
 
   do i = 1, N
-    if (h(i) /= i) call abort
+    if (h(i) /= i) stop 1
   end do
 
   do i = 1, N
@@ -35,19 +35,19 @@ program main
 
   call acc_pcopyin (h, sizeof (h))
 
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 1
 
   call acc_copyout (h)
 
-  if (acc_is_present (h) .neqv. .FALSE.) call abort
+  if (acc_is_present (h) .neqv. .FALSE.) stop 1
 
   do i = 1, N
-    if (h(i) /= i + i) call abort
+    if (h(i) /= i + i) stop 1
   end do
 
   call acc_create (h)
 
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 1
 
   !$acc parallel loop
     do i = 1, N
@@ -57,26 +57,26 @@ program main
 
   call acc_copyout (h)
 
-  if (acc_is_present (h) .neqv. .FALSE.) call abort
+  if (acc_is_present (h) .neqv. .FALSE.) stop 1
 
   do i = 1, N
-    if (h(i) /= i) call abort
+    if (h(i) /= i) stop 1
   end do
 
   call acc_present_or_create (h, sizeof (h))
 
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 1
 
   call acc_delete (h)
 
-  if (acc_is_present (h) .neqv. .FALSE.) call abort
+  if (acc_is_present (h) .neqv. .FALSE.) stop 1
 
   call acc_pcreate (h)
 
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 1
 
   call acc_delete (h)
 
-  if (acc_is_present (h) .neqv. .FALSE.) call abort
+  if (acc_is_present (h) .neqv. .FALSE.) stop 1
 
 end program
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/lib-15.f90 b/libgomp/testsuite/libgomp.oacc-fortran/lib-15.f90
index 3a834dbb22a..8b9bbd94cbc 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/lib-15.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/lib-15.f90
@@ -23,14 +23,14 @@ program main
 
   call acc_update_device (h, sizeof (h))
 
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 1
 
   h(:) = 0
 
   call acc_copyout (h, sizeof (h))
 
   do i = 1, N
-    if (h(i) /= i + i) call abort
+    if (h(i) /= i + i) stop 2
   end do 
 
   call acc_copyin (h, sizeof (h))
@@ -39,14 +39,14 @@ program main
 
   call acc_update_self (h, sizeof (h))
   
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 3
 
   do i = 1, N
-    if (h(i) /= i + i) call abort
+    if (h(i) /= i + i) stop 4
   end do 
 
   call acc_delete (h)
 
-  if (acc_is_present (h) .neqv. .FALSE.) call abort
+  if (acc_is_present (h) .neqv. .FALSE.) stop 5
   
 end program
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/lib-16-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/lib-16-2.f90
index fa76f65912f..ddd557d3be0 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/lib-16-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/lib-16-2.f90
@@ -25,7 +25,7 @@ program main
 
   call acc_update_device_async (h, sizeof (h), async)
 
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 1
 
   h(:) = 0
 
@@ -34,7 +34,7 @@ program main
   call acc_wait (async)
 
   do i = 1, N
-    if (h(i) /= i + i) call abort
+    if (h(i) /= i + i) stop 2
   end do 
 
   call acc_copyin (h, sizeof (h))
@@ -43,16 +43,16 @@ program main
 
   call acc_update_self_async (h, sizeof (h), async)
   
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 3
 
   do i = 1, N
-    if (h(i) /= i + i) call abort
+    if (h(i) /= i + i) stop 4
   end do 
 
   call acc_delete_async (h, async)
 
   call acc_wait (async)
 
-  if (acc_is_present (h) .neqv. .FALSE.) call abort
+  if (acc_is_present (h) .neqv. .FALSE.) stop 5
   
 end program
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/lib-16.f90 b/libgomp/testsuite/libgomp.oacc-fortran/lib-16.f90
index 011f9cf31db..ccd1ce6ee18 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/lib-16.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/lib-16.f90
@@ -25,7 +25,7 @@ program main
 
   call acc_update_device_async (h, sizeof (h), async)
 
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 1
 
   h(:) = 0
 
@@ -34,7 +34,7 @@ program main
   call acc_wait (async)
 
   do i = 1, N
-    if (h(i) /= i + i) call abort
+    if (h(i) /= i + i) stop 2
   end do 
 
   call acc_copyin (h, sizeof (h))
@@ -43,16 +43,16 @@ program main
 
   call acc_update_self_async (h, sizeof (h), async)
   
-  if (acc_is_present (h) .neqv. .TRUE.) call abort
+  if (acc_is_present (h) .neqv. .TRUE.) stop 3
 
   do i = 1, N
-    if (h(i) /= i + i) call abort
+    if (h(i) /= i + i) stop 4
   end do 
 
   call acc_delete_async (h, async)
 
   call acc_wait (async)
 
-  if (acc_is_present (h) .neqv. .FALSE.) call abort
+  if (acc_is_present (h) .neqv. .FALSE.) stop 5
   
 end program
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/lib-2.f b/libgomp/testsuite/libgomp.oacc-fortran/lib-2.f
index 069e07ec035..3c8d8dba3e7 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/lib-2.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/lib-2.f
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
       USE OPENACC
 
       IF (ACC_GET_NUM_DEVICES (ACC_DEVICE_HOST) .NE. 1) STOP 1
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/lib-3.f b/libgomp/testsuite/libgomp.oacc-fortran/lib-3.f
index 47424f14a15..54a781eae69 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/lib-3.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/lib-3.f
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
       INCLUDE "openacc_lib.h"
 
       IF (ACC_GET_NUM_DEVICES (ACC_DEVICE_HOST) .NE. 1) STOP 1
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/map-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/map-1.f90
index 47859508c8f..c0e8f8f540c 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/map-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/map-1.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 program map
   integer, parameter     :: n = 20, c = 10
   integer                :: i, a(n), b(n)
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-cache.f95 b/libgomp/testsuite/libgomp.oacc-fortran/optional-cache.f95
new file mode 100644
index 00000000000..0d48e2bd786
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-cache.f95
@@ -0,0 +1,24 @@
+! { dg-do run }
+! Test that the cache directives work with optional arguments.  The effect
+! of giving a non-present argument to the cache directive is not tested as
+! it is undefined.  The test is based on gfortran.dg/goacc/cache-1.f95.
+
+! { dg-additional-options "-std=f2008" }
+
+program cache_test
+  implicit none
+  integer :: d(10), e(7,13)
+
+  call do_test(d, e)
+contains
+  subroutine do_test(d, e)
+    integer, optional :: d(10), e(7,13)
+    integer :: i
+    do concurrent (i=1:5)
+      !$acc cache (d(1:3))
+      !$acc cache (d(i:i+2))
+      !$acc cache (e(1:3,2:4))
+      !$acc cache (e(i:i+2,i+1:i+3))
+    enddo
+  end
+end
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyin-by-value.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyin-by-value.f90
new file mode 100644
index 00000000000..8e842980863
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyin-by-value.f90
@@ -0,0 +1,29 @@
+! Test OpenACC data regions with optional arguments passed by value.
+
+! { dg-do run }
+
+program test
+  implicit none
+
+  integer :: res
+
+  if (foo(27) .ne. 27) stop 1
+  if (foo(16, 18) .ne. 288) stop 2
+contains
+  function foo(x, y)
+    integer, value :: x
+    integer, value, optional :: y
+    integer :: res, foo
+
+    !$acc data copyin(x, y) copyout(res)
+    !$acc parallel
+    res = x
+    if (present(y)) then
+      res = res * y
+    end if
+    !$acc end parallel
+    !$acc end data
+
+    foo = res
+  end function foo
+end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyin.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyin.f90
new file mode 100644
index 00000000000..a30908d61a5
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyin.f90
@@ -0,0 +1,140 @@
+! Test OpenACC data regions with a copy-in of optional arguments.
+
+! { dg-do run }
+
+program test
+  implicit none
+
+  integer, parameter :: n = 64
+  integer :: i
+  integer :: a_int, b_int, c_int, res_int
+  integer :: a_arr(n), b_arr(n), c_arr(n), res_arr(n)
+  integer, allocatable :: a_alloc(:), b_alloc(:), c_alloc(:), res_alloc(:)
+
+  a_int = 7
+  b_int = 3
+  c_int = 11
+
+  call test_int(res_int, a_int)
+  if (res_int .ne. a_int) stop 1
+
+  call test_int(res_int, a_int, b_int)
+  if (res_int .ne. a_int * b_int) stop 2
+
+  call test_int(res_int, a_int, b_int, c_int)
+  if (res_int .ne. a_int * b_int + c_int) stop 3
+
+  do i = 1, n
+    a_arr(i) = i
+    b_arr(i) = n - i + 1
+    c_arr(i) = i * 3
+  end do
+
+  call test_array(res_arr, a_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i)) stop 4
+  end do
+
+  call test_array(res_arr, a_arr, b_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 5
+  end do
+
+  call test_array(res_arr, a_arr, b_arr, c_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_arr(i) + c_arr(i)) stop 6
+  end do
+
+  allocate (a_alloc(n))
+  allocate (b_alloc(n))
+  allocate (c_alloc(n))
+  allocate (res_alloc(n))
+
+  do i = 1, n
+    a_alloc(i) = i
+    b_alloc(i) = n - i + 1
+    c_alloc(i) = i * 3
+  end do
+
+  call test_allocatable(res_alloc, a_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. a_alloc(i)) stop 7
+  end do
+
+  call test_allocatable(res_alloc, a_alloc, b_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i)) stop 8
+  end do
+
+  call test_allocatable(res_alloc, a_alloc, b_alloc, c_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i) + c_alloc(i)) stop 9
+  end do
+
+  deallocate (a_alloc)
+  deallocate (b_alloc)
+  deallocate (c_alloc)
+  deallocate (res_alloc)
+contains
+  subroutine test_int(res, a, b, c)
+    integer :: res
+    integer :: a
+    integer, optional :: b, c
+
+    !$acc data copyin(a, b, c) copyout(res)
+    !$acc parallel
+    res = a
+
+    if (present(b)) res = res * b
+
+    if (present(c)) res = res + c
+    !$acc end parallel
+    !$acc end data
+  end subroutine test_int
+
+  subroutine test_array(res, a, b, c)
+    integer :: res(n)
+    integer :: a(n)
+    integer, optional :: b(n), c(n)
+
+    !$acc data copyin(a, b, c) copyout(res)
+    !$acc parallel loop
+    do i = 1, n
+      res(i) = a(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(b)) res(i) = res(i) * b(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(c)) res(i) = res(i) + c(i)
+    end do
+    !$acc end data
+  end subroutine test_array
+
+  subroutine test_allocatable(res, a, b, c)
+    integer, allocatable :: res(:)
+    integer, allocatable  :: a(:)
+    integer, allocatable, optional :: b(:), c(:)
+
+    !$acc data copyin(a, b, c) copyout(res)
+    !$acc parallel loop
+    do i = 1, n
+      res(i) = a(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(b)) res(i) = res(i) * b(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(c)) res(i) = res(i) + c(i)
+    end do
+    !$acc end data
+  end subroutine test_allocatable
+end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyout.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyout.f90
new file mode 100644
index 00000000000..feaa31fa423
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-data-copyout.f90
@@ -0,0 +1,96 @@
+! Test OpenACC data regions with a copy-out of optional arguments.
+
+! { dg-do run }
+
+program test
+  implicit none
+
+  integer, parameter :: n = 64
+  integer :: i
+  integer :: a_int, b_int, res_int
+  integer :: a_arr(n), b_arr(n), res_arr(n)
+  integer, allocatable :: a_alloc(:), b_alloc(:), res_alloc(:)
+
+  res_int = 0
+
+  call test_int(a_int, b_int)
+  if (res_int .ne. 0) stop 1
+
+  call test_int(a_int, b_int, res_int)
+  if (res_int .ne. a_int * b_int) stop 2
+
+  res_arr(:) = 0
+  do i = 1, n
+    a_arr(i) = i
+    b_arr(i) = n - i + 1
+  end do
+
+  call test_array(a_arr, b_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. 0) stop 3
+  end do
+
+  call test_array(a_arr, b_arr, res_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 4
+  end do
+
+  allocate (a_alloc(n))
+  allocate (b_alloc(n))
+  allocate (res_alloc(n))
+
+  res_alloc(:) = 0
+  do i = 1, n
+    a_alloc(i) = i
+    b_alloc(i) = n - i + 1
+  end do
+
+  call test_allocatable(a_alloc, b_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. 0) stop 5
+  end do
+
+  call test_allocatable(a_alloc, b_alloc, res_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i)) stop 6
+  end do
+
+  deallocate (a_alloc)
+  deallocate (b_alloc)
+  deallocate (res_alloc)
+contains
+  subroutine test_int(a, b, res)
+    integer :: a, b
+    integer, optional :: res
+
+    !$acc data copyin(a, b) copyout(res)
+    !$acc parallel
+    if (present(res)) res = a * b
+    !$acc end parallel
+    !$acc end data
+  end subroutine test_int
+
+  subroutine test_array(a, b, res)
+    integer :: a(n), b(n)
+    integer, optional :: res(n)
+
+    !$acc data copyin(a, b) copyout(res)
+    !$acc parallel loop
+    do i = 1, n
+      if (present(res)) res(i) = a(i) * b(i)
+    end do
+    !$acc end data
+  end subroutine test_array
+
+  subroutine test_allocatable(a, b, res)
+    integer, allocatable :: a(:), b(:)
+    integer, allocatable, optional :: res(:)
+
+    !$acc data copyin(a, b) copyout(res)
+    !$acc parallel loop
+    do i = 1, n
+      if (present(res)) res(i) = a(i) * b(i)
+    end do
+    !$acc end data
+  end subroutine test_allocatable
+end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-data-enter-exit.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-data-enter-exit.f90
new file mode 100644
index 00000000000..9ed0f753ea5
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-data-enter-exit.f90
@@ -0,0 +1,91 @@
+! Test OpenACC unstructured enter data/exit data regions with optional
+! arguments.
+
+! { dg-do run }
+
+program test
+  implicit none
+
+  integer, parameter :: n = 64
+  integer :: a(n), b(n), c(n), res(n)
+  integer :: x, y, z, r, i
+
+  do i = 1, n
+    a(i) = i
+    b(i) = n - i + 1
+    c(i) = i * 3
+  end do
+
+  res = test_array(a)
+  do i = 1, n
+    if (res(i) .ne. a(i)) stop 1
+  end do
+
+  res = test_array(a, b)
+  do i = 1, n
+    if (res(i) .ne. a(i) * b(i)) stop 2
+  end do
+
+  res = test_array(a, b, c)
+  do i = 1, n
+    if (res(i) .ne. a(i) * b(i) + c(i)) stop 3
+  end do
+
+  x = 7
+  y = 3
+  z = 11
+
+  r = test_int(x)
+  if (r .ne. x) stop 4
+
+  r = test_int(x, y)
+  if (r .ne. x * y) stop 5
+
+  r = test_int(x, y, z)
+  if (r .ne. x * y + z) stop 6
+contains
+  function test_array(a, b, c)
+    integer :: a(n)
+    integer, optional :: b(n), c(n)
+    integer :: test_array(n), res(n)
+
+    !$acc enter data copyin(a, b, c) create(res)
+    !$acc parallel loop
+    do i = 1, n
+      res(i) = a(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(b)) then
+        res(i) = res(i) * b(i)
+      end if
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(c)) then
+        res(i) = res(i) + c(i)
+      end if
+    end do
+    !$acc exit data copyout(res) delete(a, b, c)
+
+    test_array = res
+  end function test_array
+
+  function test_int(a, b, c)
+    integer :: a
+    integer, optional :: b, c
+    integer :: test_int, res
+
+    !$acc enter data copyin(a, b, c) create(res)
+    !$acc parallel present(a, b, c, res)
+    res = a
+    if (present(b)) res = res * b
+    if (present(c)) res = res + c
+    !$acc end parallel
+    !$acc exit data copyout(res) delete(a, b, c)
+
+    test_int = res
+  end function test_int
+end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-declare.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-declare.f90
new file mode 100644
index 00000000000..074e5a2abb6
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-declare.f90
@@ -0,0 +1,87 @@
+! Test OpenACC declare directives with optional arguments.
+
+! { dg-do run }
+
+program test
+  implicit none
+
+  integer, parameter :: n = 64
+  integer :: i
+  integer :: a_int, b_int, c_int, res_int
+  integer :: a_arr(n), b_arr(n), c_arr(n), res_arr(n)
+
+  a_int = 7
+  b_int = 3
+  c_int = 11
+
+  call test_int(res_int, a_int)
+  if (res_int .ne. a_int) stop 1
+
+  call test_int(res_int, a_int, b_int)
+  if (res_int .ne. a_int * b_int) stop 2
+
+  call test_int(res_int, a_int, b_int, c_int)
+  if (res_int .ne. a_int * b_int + c_int) stop 3
+
+  do i = 1, n
+    a_arr(i) = i
+    b_arr(i) = n - i + 1
+    c_arr(i) = i * 3
+  end do
+
+  call test_array(res_arr, a_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i)) stop 4
+  end do
+
+  call test_array(res_arr, a_arr, b_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 5
+  end do
+
+  call test_array(res_arr, a_arr, b_arr, c_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_arr(i) + c_arr(i)) stop 6
+  end do
+contains
+  subroutine test_int(res, a, b, c)
+    integer :: a
+    integer, optional :: b, c
+    !$acc declare present_or_copyin(a, b, c)
+    integer :: res
+    !$acc declare present_or_copyout(res)
+
+    !$acc parallel
+    res = a
+    if (present(b)) res = res * b
+    if (present(c)) res = res + c
+    !$acc end parallel
+  end subroutine test_int
+
+  subroutine test_array(res, a, b, c)
+    integer :: a(n)
+    integer, optional :: b(n), c(n)
+    !$acc declare present_or_copyin(a, b, c)
+    integer :: res(n)
+    !$acc declare present_or_copyout(res)
+
+    !$acc parallel loop
+    do i = 1, n
+      res(i) = a(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(b)) then
+        res(i) = res(i) * b(i)
+      end if
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(c)) then
+        res(i) = res(i) + c(i)
+      end if
+    end do
+  end subroutine test_array
+end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-firstprivate.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-firstprivate.f90
new file mode 100644
index 00000000000..b8ebd6e277e
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-firstprivate.f90
@@ -0,0 +1,112 @@
+! Test that optional arguments work in firstprivate clauses.  The effect of
+! non-present arguments in firstprivate clauses is undefined, and is not
+! tested for.
+
+! { dg-do run }
+
+program test_firstprivate
+  implicit none
+  integer, parameter :: n = 64
+
+  integer :: i, j
+  integer :: a_int, b_int, c_int, res_int
+  integer :: a_arr(n), b_arr(n), c_arr(n), res_arr(n)
+  integer, allocatable :: a_alloc(:), b_alloc(:), c_alloc(:), res_alloc(:)
+
+  a_int = 14
+  b_int = 5
+  c_int = 12
+
+  call test_int(res_int, a_int, b_int, c_int)
+  if (res_int .ne. a_int * b_int + c_int) stop 1
+
+  do i = 1, n
+    a_arr(i) = i
+    b_arr(i) = n - i + 1
+    c_arr(i) = i * 3
+  end do
+
+  call test_array(res_arr, a_arr, b_arr, c_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_arr(i) + c_arr(i)) stop 2
+  end do
+
+  allocate(a_alloc(n))
+  allocate(b_alloc(n))
+  allocate(c_alloc(n))
+  allocate(res_alloc(n))
+
+  do i = 1, n
+    a_arr(i) = i
+    b_arr(i) = n - i + 1
+    c_arr(i) = i * 3
+  end do
+
+  call test_allocatable(res_alloc, a_alloc, b_alloc, c_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i) + c_alloc(i)) stop 3
+  end do
+
+  deallocate(a_alloc)
+  deallocate(b_alloc)
+  deallocate(c_alloc)
+  deallocate(res_alloc)
+contains
+  subroutine test_int(res, a, b, c)
+    integer :: a
+    integer, optional :: b, c
+    integer :: res
+
+    !$acc parallel firstprivate(a, b, c) copyout(res)
+    res = a
+    if (present(b)) res = res * b
+    if (present(c)) res = res + c
+    !$acc end parallel
+  end subroutine test_int
+
+  subroutine test_array(res, a, b, c)
+    integer :: a(n)
+    integer, optional :: b(n), c(n)
+    integer :: res(n)
+
+    !$acc data copyin(a, b, c) copyout(res)
+    !$acc parallel loop firstprivate(a)
+    do i = 1, n
+      res(i) = a(i)
+    end do
+
+    !$acc parallel loop firstprivate(b)
+    do i = 1, n
+      if (present(b)) res(i) = res(i) * b(i)
+    end do
+
+    !$acc parallel loop firstprivate(c)
+    do i = 1, n
+      if (present(c)) res(i) = res(i) + c(i)
+    end do
+    !$acc end data
+  end subroutine test_array
+
+  subroutine test_allocatable(res, a, b, c)
+    integer, allocatable :: a(:)
+    integer, allocatable, optional :: b(:), c(:)
+    integer, allocatable :: res(:)
+
+    !$acc data copyin(a, b, c) copyout(res)
+    !$acc parallel loop firstprivate(a)
+    do i = 1, n
+      res(i) = a(i)
+    end do
+
+    !$acc parallel loop firstprivate(b)
+    do i = 1, n
+      if (present(b)) res(i) = res(i) * b(i)
+    end do
+
+    !$acc parallel loop firstprivate(c)
+    do i = 1, n
+      if (present(c)) res(i) = res(i) + c(i)
+    end do
+    !$acc end data
+  end subroutine test_allocatable
+end program test_firstprivate
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-host_data.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-host_data.f90
new file mode 100644
index 00000000000..a6e41e28b0b
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-host_data.f90
@@ -0,0 +1,39 @@
+! Test the host_data construct with optional arguments.
+! Based on host_data-1.f90.
+
+! { dg-do run }
+! { dg-additional-options "-cpp" }
+
+program test
+  implicit none
+
+  integer, target :: i
+  integer, pointer :: ip, iph
+
+  ! Assign the same targets
+  ip => i
+  iph => i
+
+  call foo(iph)
+  call foo(iph, ip)
+contains
+  subroutine foo(iph, ip)
+    integer, pointer :: iph
+    integer, pointer, optional :: ip
+
+    !$acc data copyin(i)
+    !$acc host_data use_device(ip)
+
+    ! Test how the pointers compare inside a host_data construct
+    if (present(ip)) then
+#if ACC_MEM_SHARED
+      if (.not. associated(ip, iph)) STOP 1
+#else
+      if (associated(ip, iph)) STOP 2
+#endif
+    end if
+
+    !$acc end host_data
+    !$acc end data
+  end subroutine foo
+end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-nested-calls.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-nested-calls.f90
new file mode 100644
index 00000000000..279139f7c59
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-nested-calls.f90
@@ -0,0 +1,135 @@
+! Test propagation of optional arguments from within an OpenACC parallel region.
+
+! { dg-do run }
+
+program test
+  implicit none
+
+  integer, parameter :: n = 64
+  integer :: i
+  integer :: res_int
+  integer :: a_arr(n), b_arr(n), res_arr(n)
+  integer, allocatable :: a_alloc(:), b_alloc(:), res_alloc(:)
+
+  call test_int_caller(res_int, 5)
+  if (res_int .ne. 10) stop 1
+
+  call test_int_caller(res_int, 2, 3)
+  if (res_int .ne. 11) stop 2
+
+  do i = 1, n
+    a_arr(i) = i
+    b_arr(i) = n - i + 1
+  end do
+
+  call test_array_caller(res_arr, a_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. 2 * a_arr(i)) stop 3
+  end do
+
+  call test_array_caller(res_arr, a_arr, b_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_arr(i) + a_arr(i) + b_arr(i)) stop 4
+  end do
+
+  allocate(a_alloc(n))
+  allocate(b_alloc(n))
+  allocate(res_alloc(n))
+
+  do i = 1, n
+    a_alloc(i) = i
+    b_alloc(i) = n - i + 1
+  end do
+
+  call test_array_caller(res_arr, a_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. 2 * a_alloc(i)) stop 5
+  end do
+
+  call test_array_caller(res_arr, a_arr, b_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_alloc(i) + a_alloc(i) + b_alloc(i)) stop 6
+  end do
+
+  deallocate(a_alloc)
+  deallocate(b_alloc)
+  deallocate(res_alloc)
+contains
+  subroutine test_int_caller(res, a, b)
+    integer :: res, a
+    integer, optional :: b
+
+    !$acc data copyin(a, b) copyout (res)
+    !$acc parallel
+    res = a
+    if (present(b)) res = res * b
+    call test_int_callee(res, a, b)
+    !$acc end parallel
+    !$acc end data
+  end subroutine test_int_caller
+
+  subroutine test_int_callee(res, a, b)
+    !$acc routine seq
+    integer :: res, a
+    integer, optional :: b
+
+    res = res + a
+    if (present(b)) res = res + b
+  end subroutine test_int_callee
+
+  subroutine test_array_caller(res, a, b)
+    integer :: res(n), a(n), i
+    integer, optional :: b(n)
+
+    !$acc data copyin(a, b) copyout(res)
+    !$acc parallel
+    !$acc loop seq
+    do i = 1, n
+      res(i) = a(i)
+      if (present(b)) res(i) = res(i) * b(i)
+    end do
+    call test_array_callee(res, a, b)
+    !$acc end parallel
+    !$acc end data
+  end subroutine test_array_caller
+
+  subroutine test_array_callee(res, a, b)
+    !$acc routine seq
+    integer :: res(n), a(n), i
+    integer, optional :: b(n)
+
+    do i = 1, n
+      res(i) = res(i) + a(i)
+      if (present(b)) res(i) = res(i) + b(i)
+    end do
+  end subroutine test_array_callee
+
+  subroutine test_allocatable_caller(res, a, b)
+    integer :: i
+    integer, allocatable :: res(:), a(:)
+    integer, allocatable, optional :: b(:)
+
+    !$acc data copyin(a, b) copyout(res)
+    !$acc parallel
+    !$acc loop seq
+    do i = 1, n
+      res(i) = a(i)
+      if (present(b)) res(i) = res(i) * b(i)
+    end do
+    call test_array_callee(res, a, b)
+    !$acc end parallel
+    !$acc end data
+  end subroutine test_allocatable_caller
+
+  subroutine test_allocatable_callee(res, a, b)
+    !$acc routine seq
+    integer :: i
+    integer, allocatable :: res(:), a(:)
+    integer, allocatable, optional :: b(:)
+
+    do i = 1, n
+      res(i) = res(i) + a(i)
+      if (present(b)) res(i) = res(i) + b(i)
+    end do
+  end subroutine test_allocatable_callee
+end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-private.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-private.f90
new file mode 100644
index 00000000000..0320bbb3bc9
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-private.f90
@@ -0,0 +1,115 @@
+! Test that optional arguments work in private clauses.  The effect of
+! non-present arguments in private clauses is undefined, and is not tested
+! for.  The tests are based on those in private-variables.f90.
+
+! { dg-do run }
+
+program main
+  implicit none
+
+  type vec3
+     integer x, y, z, attr(13)
+  end type vec3
+  integer :: x
+  type(vec3) :: pt
+  integer :: arr(2)
+
+  call t1(x)
+  call t2(pt)
+  call t3(arr)
+contains
+
+  ! Test of gang-private variables declared on loop directive.
+
+  subroutine t1(x)
+    integer, optional :: x
+    integer :: i, arr(32)
+
+    do i = 1, 32
+       arr(i) = i
+    end do
+
+    !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)
+    !$acc loop gang private(x)
+    do i = 1, 32
+       x = i * 2;
+       arr(i) = arr(i) + x
+    end do
+    !$acc end parallel
+
+    do i = 1, 32
+       if (arr(i) .ne. i * 3) STOP 1
+    end do
+  end subroutine t1
+
+
+  ! Test of gang-private addressable variable declared on loop directive, with
+  ! broadcasting to partitioned workers.
+
+  subroutine t2(pt)
+    integer i, j, arr(0:32*32)
+    type(vec3), optional :: pt
+
+    do i = 0, 32*32-1
+       arr(i) = i
+    end do
+
+    !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)
+    !$acc loop gang private(pt)
+    do i = 0, 31
+       pt%x = i
+       pt%y = i * 2
+       pt%z = i * 4
+       pt%attr(5) = i * 6
+
+       !$acc loop vector
+       do j = 0, 31
+          arr(i * 32 + j) = arr(i * 32 + j) + pt%x + pt%y + pt%z + pt%attr(5);
+       end do
+    end do
+    !$acc end parallel
+
+    do i = 0, 32 * 32 - 1
+       if (arr(i) .ne. i + (i / 32) * 13) STOP 2
+    end do
+  end subroutine t2
+
+  ! Test of vector-private variables declared on loop directive. Array type.
+
+  subroutine t3(pt)
+    integer, optional :: pt(2)
+    integer :: i, j, k, idx, arr(0:32*32*32)
+
+    do i = 0, 32*32*32-1
+       arr(i) = i
+    end do
+
+    !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)
+    !$acc loop gang
+    do i = 0, 31
+       !$acc loop worker
+       do j = 0, 31
+          !$acc loop vector private(pt)
+          do k = 0, 31
+             pt(1) = ieor(i, j * 3)
+             pt(2) = ior(i, j * 5)
+             arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(1) * k
+             arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(2) * k
+          end do
+       end do
+    end do
+    !$acc end parallel
+
+    do i = 0, 32 - 1
+       do j = 0, 32 -1
+          do k = 0, 32 - 1
+             idx = i * 1024 + j * 32 + k
+             if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then
+                STOP 3
+             end if
+          end do
+       end do
+    end do
+  end subroutine t3
+
+end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-reduction.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-reduction.f90
new file mode 100644
index 00000000000..29f92c0d4c3
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-reduction.f90
@@ -0,0 +1,68 @@
+! Test optional arguments in reduction clauses.  The effect of
+! non-present arguments in reduction clauses is undefined, and is not tested
+! for.  The tests are based on those in reduction-1.f90.
+
+! { dg-do run }
+
+program optional_reduction
+  implicit none
+
+  integer :: rg, rw, rv, rc
+
+  rg = 0
+  rw = 0
+  rv = 0
+  rc = 0
+
+  call do_test(rg, rw, rv, rc)
+contains
+  subroutine do_test(rg, rw, rv, rc)
+    integer, parameter     :: n = 10, ng = 8, nw = 4, vl = 32
+    integer, optional      :: rg, rw, rv, rc
+    integer                :: i, vresult
+    integer, dimension (n) :: array
+
+    vresult = 0
+    do i = 1, n
+       array(i) = i
+    end do
+
+    !$acc parallel num_gangs(ng) copy(rg)
+    !$acc loop reduction(+:rg) gang
+    do i = 1, n
+       rg = rg + array(i)
+    end do
+    !$acc end parallel
+
+    !$acc parallel num_workers(nw) copy(rw)
+    !$acc loop reduction(+:rw) worker
+    do i = 1, n
+       rw = rw + array(i)
+    end do
+    !$acc end parallel
+
+    !$acc parallel vector_length(vl) copy(rv)
+    !$acc loop reduction(+:rv) vector
+    do i = 1, n
+       rv = rv + array(i)
+    end do
+    !$acc end parallel
+
+    !$acc parallel num_gangs(ng) num_workers(nw) vector_length(vl) copy(rc)
+    !$acc loop reduction(+:rc) gang worker vector
+    do i = 1, n
+       rc = rc + array(i)
+    end do
+    !$acc end parallel
+
+    ! Verify the results
+    do i = 1, n
+       vresult = vresult + array(i)
+    end do
+
+    if (rg .ne. vresult) STOP 1
+    if (rw .ne. vresult) STOP 2
+    if (rv .ne. vresult) STOP 3
+    if (rc .ne. vresult) STOP 4
+  end subroutine do_test
+end program optional_reduction
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-update-device.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-update-device.f90
new file mode 100644
index 00000000000..57f69001d3d
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-update-device.f90
@@ -0,0 +1,121 @@
+! Test OpenACC update to device with an optional argument.
+
+! { dg-do run }
+
+program optional_update_device
+  implicit none
+
+  integer, parameter :: n = 64
+  integer :: i
+  integer :: a_int, b_int, res_int
+  integer :: a_arr(n), b_arr(n), res_arr(n)
+  integer, allocatable :: a_alloc(:), b_alloc(:), res_alloc(:)
+
+  a_int = 5
+  b_int = 11
+
+  call test_int(res_int, a_int)
+  if (res_int .ne. a_int) stop 1
+
+  call test_int(res_int, a_int, b_int)
+  if (res_int .ne. a_int * b_int) stop 2
+
+  res_arr(:) = 0
+  do i = 1, n
+    a_arr(i) = i
+    b_arr(i) = n - i + 1
+  end do
+
+  call test_array(res_arr, a_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i)) stop 3
+  end do
+
+  call test_array(res_arr, a_arr, b_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 4
+  end do
+
+  allocate (a_alloc(n))
+  allocate (b_alloc(n))
+  allocate (res_alloc(n))
+
+  res_alloc(:) = 0
+  do i = 1, n
+    a_alloc(i) = i
+    b_alloc(i) = n - i + 1
+  end do
+
+  call test_allocatable(res_alloc, a_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. a_alloc(i)) stop 5
+  end do
+
+  call test_allocatable(res_alloc, a_alloc, b_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i)) stop 6
+  end do
+
+  deallocate (a_alloc)
+  deallocate (b_alloc)
+  deallocate (res_alloc)
+contains
+  subroutine test_int(res, a, b)
+    integer :: res
+    integer :: a
+    integer, optional :: b
+
+    !$acc data create(a, b, res)
+    !$acc update device(a, b)
+    !$acc parallel
+    res = a
+    if (present(b)) res = res * b
+    !$acc end parallel
+    !$acc update self(res)
+    !$acc end data
+  end subroutine test_int
+
+  subroutine test_array(res, a, b)
+    integer :: res(n)
+    integer :: a(n)
+    integer, optional :: b(n)
+
+    !$acc data create(a, b, res)
+    !$acc update device(a, b)
+    !$acc parallel loop
+    do i = 1, n
+      res(i) = a(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(b)) then
+        res(i) = res(i) * b(i)
+      end if
+    end do
+    !$acc update self(res)
+    !$acc end data
+  end subroutine test_array
+
+  subroutine test_allocatable(res, a, b)
+    integer, allocatable :: res(:)
+    integer, allocatable :: a(:)
+    integer, allocatable, optional :: b(:)
+
+    !$acc data create(a, b, res)
+    !$acc update device(a, b)
+    !$acc parallel loop
+    do i = 1, n
+      res(i) = a(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(b)) then
+        res(i) = res(i) * b(i)
+      end if
+    end do
+    !$acc update self(res)
+    !$acc end data
+  end subroutine test_allocatable
+end program optional_update_device
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/optional-update-host.f90 b/libgomp/testsuite/libgomp.oacc-fortran/optional-update-host.f90
new file mode 100644
index 00000000000..dc2b5da3a63
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/optional-update-host.f90
@@ -0,0 +1,115 @@
+! Test OpenACC update to host with an optional argument.
+
+! { dg-do run }
+
+program optional_update_host
+  implicit none
+
+  integer, parameter :: n = 64
+  integer :: i
+  integer :: a_int, b_int, res_int
+  integer :: a_arr(n), b_arr(n), res_arr(n)
+  integer, allocatable :: a_alloc(:), b_alloc(:), res_alloc(:)
+
+  a_int = 5
+  b_int = 11
+  res_int = 0
+
+  call test_int(a_int, b_int)
+  if (res_int .ne. 0) stop 1
+
+  call test_int(a_int, b_int, res_int)
+  if (res_int .ne. a_int * b_int) stop 2
+
+  res_arr(:) = 0
+  do i = 1, n
+    a_arr(i) = i
+    b_arr(i) = n - i + 1
+  end do
+
+  call test_array(a_arr, b_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. 0) stop 3
+  end do
+
+  call test_array(a_arr, b_arr, res_arr)
+  do i = 1, n
+    if (res_arr(i) .ne. a_arr(i) * b_arr(i)) stop 4
+  end do
+
+  allocate(a_alloc(n))
+  allocate(b_alloc(n))
+  allocate(res_alloc(n))
+
+  res_alloc(:) = 0
+  do i = 1, n
+    a_alloc(i) = i
+    b_alloc(i) = n - i + 1
+  end do
+
+  call test_allocatable(a_alloc, b_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. 0) stop 5
+  end do
+
+  call test_allocatable(a_alloc, b_alloc, res_alloc)
+  do i = 1, n
+    if (res_alloc(i) .ne. a_alloc(i) * b_alloc(i)) stop 6
+  end do
+
+  deallocate(a_alloc)
+  deallocate(b_alloc)
+  deallocate(res_alloc)
+contains
+  subroutine test_int(a, b, res)
+    integer :: a, b
+    integer, optional :: res
+
+    !$acc data create(a, b, res)
+    !$acc update device(a, b)
+    !$acc parallel
+    if (present(res)) res = a
+    if (present(res)) res = res * b
+    !$acc end parallel
+    !$acc update self(res)
+    !$acc end data
+  end subroutine test_int
+
+  subroutine test_array(a, b, res)
+    integer :: a(n), b(n)
+    integer, optional :: res(n)
+
+    !$acc data create(a, b, res)
+    !$acc update device(a, b)
+    !$acc parallel loop
+    do i = 1, n
+      if (present(res)) res(i) = a(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(res)) res(i) = res(i) * b(i)
+    end do
+    !$acc update self(res)
+    !$acc end data
+  end subroutine test_array
+
+  subroutine test_allocatable(a, b, res)
+    integer, allocatable :: a(:), b(:)
+    integer, allocatable, optional :: res(:)
+
+    !$acc data create(a, b, res)
+    !$acc update device(a, b)
+    !$acc parallel loop
+    do i = 1, n
+      if (present(res)) res(i) = a(i)
+    end do
+
+    !$acc parallel loop
+    do i = 1, n
+      if (present(res)) res(i) = res(i) * b(i)
+    end do
+    !$acc update self(res)
+    !$acc end data
+  end subroutine test_allocatable
+end program optional_update_host 
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/parallel-dims-aux.c b/libgomp/testsuite/libgomp.oacc-fortran/parallel-dims-aux.c
new file mode 100644
index 00000000000..b5986f4afef
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/parallel-dims-aux.c
@@ -0,0 +1,45 @@
+/* OpenACC parallelism dimensions clauses: num_gangs, num_workers,
+   vector_length.  */
+
+/* Copied from '../libgomp.oacc-c-c++-common/parallel-dims.c'.  */
+
+/* Used by 'parallel-dims.f90'.  */
+
+#include <limits.h>
+#include <openacc.h>
+#include <gomp-constants.h>
+
+/* TODO: "(int) acc_device_*" casts because of the C++ acc_on_device wrapper
+   not behaving as expected for -O0.  */
+#pragma acc routine seq
+/* static */ unsigned int __attribute__ ((optimize ("O2"))) acc_gang ()
+{
+  if (acc_on_device ((int) acc_device_host))
+    return 0;
+  else if (acc_on_device ((int) acc_device_nvidia))
+    return __builtin_goacc_parlevel_id (GOMP_DIM_GANG);
+  else
+    __builtin_abort ();
+}
+
+#pragma acc routine seq
+/* static */ unsigned int __attribute__ ((optimize ("O2"))) acc_worker ()
+{
+  if (acc_on_device ((int) acc_device_host))
+    return 0;
+  else if (acc_on_device ((int) acc_device_nvidia))
+    return __builtin_goacc_parlevel_id (GOMP_DIM_WORKER);
+  else
+    __builtin_abort ();
+}
+
+#pragma acc routine seq
+/* static */ unsigned int __attribute__ ((optimize ("O2"))) acc_vector ()
+{
+  if (acc_on_device ((int) acc_device_host))
+    return 0;
+  else if (acc_on_device ((int) acc_device_nvidia))
+    return __builtin_goacc_parlevel_id (GOMP_DIM_VECTOR);
+  else
+    __builtin_abort ();
+}
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/parallel-dims.f90 b/libgomp/testsuite/libgomp.oacc-fortran/parallel-dims.f90
new file mode 100644
index 00000000000..1bfcd6ce099
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/parallel-dims.f90
@@ -0,0 +1,120 @@
+! OpenACC parallelism dimensions clauses: num_gangs, num_workers,
+! vector_length.
+
+! { dg-additional-sources parallel-dims-aux.c }
+! { dg-do run }
+! { dg-prune-output "command-line option '-fintrinsic-modules-path=.*' is valid for Fortran but not for C" }
+
+! See also '../libgomp.oacc-c-c++-common/parallel-dims.c'.
+
+module acc_routines
+  implicit none (type, external)
+
+  interface
+    integer function acc_gang() bind(C)
+      !$acc routine seq
+    end function acc_gang
+
+    integer function acc_worker() bind(C)
+      !$acc routine seq
+    end function acc_worker
+
+    integer function acc_vector() bind(C)
+      !$acc routine seq
+    end function acc_vector
+  end interface
+end module acc_routines
+
+program main
+  use iso_c_binding
+  use openacc
+  use acc_routines
+  implicit none (type, external)
+
+  integer :: gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max
+  integer :: vectors_actual
+  integer :: i, j, k
+
+  call acc_init (acc_device_default)
+
+  ! OpenACC parallel construct.
+
+  !TODO
+
+
+  ! OpenACC kernels construct.
+
+  !TODO
+
+
+  ! OpenACC serial construct.
+
+  ! GR, WS, VS.
+
+  gangs_min = huge(gangs_min) ! INT_MAX
+  workers_min = huge(workers_min) ! INT_MAX
+  vectors_min = huge(vectors_min) ! INT_MAX
+  gangs_max = -huge(gangs_max) - 1  ! INT_MIN
+  workers_max = -huge(gangs_max) - 1 ! INT_MIN
+  vectors_max = -huge(gangs_max) - 1 ! INT_MIN
+  !$acc serial &
+  !$acc   reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max) ! { dg-warning "using vector_length \\(32\\), ignoring 1" "" { target openacc_nvidia_accel_selected } }
+  do i = 100, -99, -1
+     gangs_min = acc_gang ();
+     gangs_max = acc_gang ();
+     workers_min = acc_worker ();
+     workers_max = acc_worker ();
+     vectors_min = acc_vector ();
+     vectors_max = acc_vector ();
+  end do
+  !$acc end serial
+  if (gangs_min /= 0 .or. gangs_max /= 1 - 1 &
+      .or. workers_min /= 0 .or. workers_max /= 1 - 1 &
+      .or. vectors_min /= 0 .or. vectors_max /= 1 - 1) &
+    stop 1
+
+  ! Composition of GP, WP, VP.
+
+  vectors_actual = 1 ! Implicit 'vector_length (1)' clause.
+  gangs_min = huge(gangs_min) ! INT_MAX
+  workers_min = huge(workers_min) ! INT_MAX
+  vectors_min = huge(vectors_min) ! INT_MAX
+  gangs_max = -huge(gangs_max) - 1  ! INT_MIN
+  workers_max = -huge(gangs_max) - 1 ! INT_MIN
+  vectors_max = -huge(gangs_max) - 1 ! INT_MIN
+  !$acc serial copy (vectors_actual) &
+  !$acc   copy (gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max) ! { dg-warning "using vector_length \\(32\\), ignoring 1" "" { target openacc_nvidia_accel_selected } }
+  if (acc_on_device (acc_device_nvidia)) then
+     ! The GCC nvptx back end enforces vector_length (32).
+     ! It's unclear if that's actually permissible here;
+     ! <https://github.com/OpenACC/openacc-spec/issues/238> "OpenACC 'serial'
+     ! construct might not actually be serial".
+   vectors_actual = 32
+  end if
+  !$acc loop gang reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)
+  do i = 100, -99, -1
+     !$acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)
+     do j = 100, -99, -1
+        !$acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)
+        do k = 100 * vectors_actual, -99 * vectors_actual, -1
+           gangs_min = acc_gang ();
+           gangs_max = acc_gang ();
+           workers_min = acc_worker ();
+           workers_max = acc_worker ();
+           vectors_min = acc_vector ();
+           vectors_max = acc_vector ();
+        end do
+     end do
+  end do
+  !$acc end serial
+  if (acc_get_device_type () .eq. acc_device_nvidia) then
+     if (vectors_actual /= 32) stop 2
+  else
+     if (vectors_actual /= 1) stop 3
+  end if
+  if (gangs_min /= 0 .or. gangs_max /= 1 - 1 &
+      .or. workers_min /= 0 .or. workers_max /= 1 - 1 &
+      .or. vectors_min /= 0 .or. vectors_max /= vectors_actual - 1) &
+    stop 4
+
+end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/parallel-loop-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/parallel-loop-1.f90
index 754b833a4ba..676417cfecf 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/parallel-loop-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/parallel-loop-1.f90
@@ -37,7 +37,7 @@ program loops
   !$acc end parallel
 
   do i = 1, n
-     if (a(i) .ne. b(i)) call abort
+     if (a(i) .ne. b(i)) stop 1
   end do
   call check (a, b, n)
 
@@ -72,6 +72,6 @@ subroutine check (a, b, n)
   integer :: i
 
   do i = 1, n
-     if (a(i) .ne. b(i)) call abort
+     if (a(i) .ne. b(i)) stop 2
   end do
 end subroutine check
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/pointer-align-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/pointer-align-1.f90
index 3f4b9fe070e..d0e7aa1c81b 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/pointer-align-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/pointer-align-1.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 ! PR middle-end/63247
 
 program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/pr68813.f90 b/libgomp/testsuite/libgomp.oacc-fortran/pr68813.f90
index 735350f6aac..c4552053e28 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/pr68813.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/pr68813.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 program foo
   implicit none
   integer, parameter :: n = 100
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/pr70289.f90 b/libgomp/testsuite/libgomp.oacc-fortran/pr70289.f90
index 63bde44100d..a516f9f32f6 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/pr70289.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/pr70289.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 program foo
   implicit none
   integer :: i
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/pr70643.f90 b/libgomp/testsuite/libgomp.oacc-fortran/pr70643.f90
index c8a7922a415..42dc3193546 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/pr70643.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/pr70643.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 MODULE reduction_test
 
 CONTAINS
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/print-1-nvptx.f90 b/libgomp/testsuite/libgomp.oacc-fortran/print-1-nvptx.f90
new file mode 100644
index 00000000000..866c8654355
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/print-1-nvptx.f90
@@ -0,0 +1,11 @@
+! Ensure that write on the offload device works, nvptx offloading variant.
+
+! This doesn't compile: for nvptx offloading we're using a minimal libgfortran
+! configuration.
+! { dg-do link } ! ..., but still apply 'dg-do run' options.
+! { dg-xfail-if "minimal libgfortran" { offload_target_nvptx } }
+
+! Skip duplicated testing.
+! { dg-skip-if "separate file" { ! offload_target_nvptx } }
+
+include 'print-1.f90'
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/print-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/print-1.f90
new file mode 100644
index 00000000000..7b7f73741fe
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/print-1.f90
@@ -0,0 +1,17 @@
+! Ensure that write on the offload device works.
+
+! { dg-do run }
+! { dg-output "The answer is 42(\n|\r\n|\r)+" }
+
+! Separate file 'print-1-nvptx.f90' for nvptx offloading.
+! { dg-skip-if "separate file" { offload_target_nvptx } }
+
+program main
+  implicit none
+  integer :: var = 42
+
+!$acc parallel
+  write (0, '("The answer is ", I2)') var
+!$acc end parallel
+
+end program main
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/pset-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/pset-1.f90
index c3a8a9cac1c..3cf7eb5987d 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/pset-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/pset-1.f90
@@ -9,7 +9,7 @@ program test
   integer, allocatable :: c3(:,:,:)
 
   allocate (a1(5))
-  if (.not.allocated (a1)) STOP 1
+  if (.not.allocated (a1)) STOP 49
 
   a1 = 10
 
@@ -30,7 +30,7 @@ program test
   deallocate(a1)
 
   allocate (a1(0:4))
-  if (.not.allocated (a1)) STOP 2
+  if (.not.allocated (a1)) STOP 50
 
   a1 = 10
 
@@ -51,7 +51,7 @@ program test
   deallocate(a1)
 
   allocate (b2(5,5))
-  if (.not.allocated (b2)) STOP 3
+  if (.not.allocated (b2)) STOP 51
 
   b2 = 11
 
@@ -72,7 +72,7 @@ program test
   deallocate(b2)
 
   allocate (b2(0:4,0:4))
-  if (.not.allocated (b2)) STOP 4
+  if (.not.allocated (b2)) STOP 52
 
   b2 = 11
 
@@ -93,7 +93,7 @@ program test
   deallocate(b2)
 
   allocate (c3(5,5,5))
-  if (.not.allocated (c3)) STOP 5
+  if (.not.allocated (c3)) STOP 53
 
   c3 = 12
 
@@ -114,7 +114,7 @@ program test
   deallocate(c3)
 
   allocate (c3(0:4,0:4,0:4))
-  if (.not.allocated (c3)) STOP 6
+  if (.not.allocated (c3)) STOP 54
 
   c3 = 12
 
@@ -135,13 +135,13 @@ program test
   deallocate(c3)
 
   allocate (a1(5))
-  if (.not.allocated (a1)) STOP 7
+  if (.not.allocated (a1)) STOP 55
 
   allocate (b1(5))
-  if (.not.allocated (b1)) STOP 8
+  if (.not.allocated (b1)) STOP 56
 
   allocate (c1(5))
-  if (.not.allocated (c1)) STOP 9
+  if (.not.allocated (c1)) STOP 57
 
   a1 = 10
   b1 = 3
@@ -172,13 +172,13 @@ program test
   deallocate(c1)
 
   allocate (a1(0:4))
-  if (.not.allocated (a1)) STOP 10
+  if (.not.allocated (a1)) STOP 58
 
   allocate (b1(0:4))
-  if (.not.allocated (b1)) STOP 11
+  if (.not.allocated (b1)) STOP 59
 
   allocate (c1(0:4))
-  if (.not.allocated (c1)) STOP 12
+  if (.not.allocated (c1)) STOP 60
 
   a1 = 10
   b1 = 3
@@ -209,7 +209,7 @@ program test
   deallocate(c1)
 
   allocate (a1(5))
-  if (.not.allocated (a1)) STOP 13
+  if (.not.allocated (a1)) STOP 61
 
   a1 = 10
 
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/reference-reductions.f90 b/libgomp/testsuite/libgomp.oacc-fortran/reference-reductions.f90
index a684d07977c..b25430e59ed 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/reference-reductions.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/reference-reductions.f90
@@ -34,5 +34,5 @@ program test
   r=10.0
   call param_reduction (r)
 
-  if (r .ne. 1010) call abort ()
+  if (r .ne. 1010) stop 1
 end program test
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90 b/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90
index f58a95fe670..1009f4a81e5 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90
@@ -109,7 +109,7 @@ end subroutine gang
 
 subroutine seq (a)
   !$acc routine seq
-  integer, intent (inout) :: a(M)
+  integer, intent (inout) :: a(N)
   integer :: i
 
   do i = 1, N
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/subarrays-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/subarrays-1.f90
index 8a2ec2cc97e..b67a8f482f4 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/subarrays-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/subarrays-1.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 program subarrays
   integer, parameter     :: n = 20, c = 10
   integer                :: i, a(n), b(n)
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/subarrays-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/subarrays-2.f90
index 914da5b4062..1cc6dd68820 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/subarrays-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/subarrays-2.f90
@@ -1,3 +1,5 @@
+! { dg-do run }
+!
 program subarrays
   integer, parameter     :: n = 20, c = 10, low = 5, high = 10
   integer                :: i, a(n), b(n)
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/vector-routine.f90 b/libgomp/testsuite/libgomp.oacc-fortran/vector-routine.f90
index 1edcee48677..88b9ab411d4 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/vector-routine.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/vector-routine.f90
@@ -21,7 +21,7 @@ program main
   !$acc end parallel
 
   do i = 1, N
-    if (a(i) .ne. 0) call abort
+    if (a(i) .ne. 0) stop 1
   end do
 
 contains
diff --git a/libgomp/work.c b/libgomp/work.c
index a589b8b5231..28bb0c11255 100644
--- a/libgomp/work.c
+++ b/libgomp/work.c
@@ -120,7 +120,7 @@ gomp_init_work_share (struct gomp_work_share *ws, size_t ordered,
       else
 	ordered = nthreads * sizeof (*ws->ordered_team_ids);
       if (ordered > INLINE_ORDERED_TEAM_IDS_SIZE)
-	ws->ordered_team_ids = gomp_malloc (ordered);
+	ws->ordered_team_ids = team_malloc (ordered);
       else
 	ws->ordered_team_ids = ws->inline_ordered_team_ids;
       memset (ws->ordered_team_ids, '\0', ordered);
@@ -142,7 +142,7 @@ gomp_fini_work_share (struct gomp_work_share *ws)
 {
   gomp_mutex_destroy (&ws->lock);
   if (ws->ordered_team_ids != ws->inline_ordered_team_ids)
-    free (ws->ordered_team_ids);
+    team_free (ws->ordered_team_ids);
   gomp_ptrlock_destroy (&ws->next_ws);
 }
 
