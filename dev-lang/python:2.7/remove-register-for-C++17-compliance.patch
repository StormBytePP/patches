--- a/Include/stringobject.h	2019-08-31 14:56:04.473084341 +0200
+++ b/Include/stringobject.h	2019-08-31 14:59:39.840089681 +0200
@@ -170,9 +170,9 @@
    cause an exception).  */
 
 PyAPI_FUNC(int) PyString_AsStringAndSize(
-    register PyObject *obj,	/* string or Unicode object */
-    register char **s,		/* pointer to buffer variable */
-    register Py_ssize_t *len	/* pointer to length variable or NULL
+    PyObject *obj,	/* string or Unicode object */
+    char **s,		/* pointer to buffer variable */
+    Py_ssize_t *len	/* pointer to length variable or NULL
 				   (only possible for 0-terminated
 				   strings) */
     );
--- a/Include/unicodeobject.h	2019-08-31 14:56:04.474084341 +0200
+++ b/Include/unicodeobject.h	2019-08-31 14:59:39.844089681 +0200
@@ -531,7 +531,7 @@
 */
 
 PyAPI_FUNC(PyObject*) PyUnicode_FromEncodedObject(
-    register PyObject *obj,     /* Object */
+    PyObject *obj,     /* Object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
     );
@@ -550,7 +550,7 @@
 */
 
 PyAPI_FUNC(PyObject*) PyUnicode_FromObject(
-    register PyObject *obj      /* Object */
+    PyObject *obj      /* Object */
     );
 
 PyAPI_FUNC(PyObject *) PyUnicode_FromFormatV(const char*, va_list);
@@ -572,7 +572,7 @@
    The buffer is copied into the new object. */
 
 PyAPI_FUNC(PyObject*) PyUnicode_FromWideChar(
-    register const wchar_t *w,  /* wchar_t buffer */
+    const wchar_t *w,  /* wchar_t buffer */
     Py_ssize_t size             /* size of buffer */
     );
 
@@ -590,7 +590,7 @@
 
 PyAPI_FUNC(Py_ssize_t) PyUnicode_AsWideChar(
     PyUnicodeObject *unicode,   /* Unicode object */
-    register wchar_t *w,        /* wchar_t buffer */
+    wchar_t *w,        /* wchar_t buffer */
     Py_ssize_t size             /* size of buffer */
     );
 
--- a/Python/bltinmodule.c	2019-08-31 14:56:04.476084341 +0200
+++ b/Python/bltinmodule.c	2019-08-31 14:59:39.850089681 +0200
@@ -244,7 +244,7 @@
 {
     PyObject *func, *seq, *result, *it, *arg;
     Py_ssize_t len;   /* guess for result list size */
-    register Py_ssize_t j;
+    Py_ssize_t j;
 
     if (!PyArg_UnpackTuple(args, "filter", 2, 2, &func, &seq))
         return NULL;
@@ -948,7 +948,7 @@
     PyObject *func, *result;
     sequence *seqs = NULL, *sqp;
     Py_ssize_t n, len;
-    register int i, j;
+    int i, j;
 
     n = PyTuple_Size(args);
     if (n < 2) {
@@ -2971,7 +2971,7 @@
 filterunicode(PyObject *func, PyObject *strobj)
 {
     PyObject *result;
-    register Py_ssize_t i, j;
+    Py_ssize_t i, j;
     Py_ssize_t len = PyUnicode_GetSize(strobj);
     Py_ssize_t outlen = len;
 
--- a/Python/ceval.c	2019-08-31 14:56:04.477084341 +0200
+++ b/Python/ceval.c	2019-08-31 14:59:39.854089681 +0200
@@ -38,7 +38,7 @@
 static void
 ppc_getcounter(uint64 *v)
 {
-    register unsigned long tbu, tb, tbu2;
+    unsigned long tbu, tb, tbu2;
 
   loop:
     asm volatile ("mftbu %0" : "=r" (tbu) );
@@ -793,19 +793,19 @@
 #ifdef DXPAIRS
     int lastopcode = 0;
 #endif
-    register PyObject **stack_pointer;  /* Next free slot in value stack */
-    register unsigned char *next_instr;
-    register int opcode;        /* Current opcode */
-    register int oparg;         /* Current opcode argument, if any */
-    register enum why_code why; /* Reason for block stack unwind */
-    register int err;           /* Error status -- nonzero if error */
-    register PyObject *x;       /* Result object -- NULL if error */
-    register PyObject *v;       /* Temporary objects popped off stack */
-    register PyObject *w;
-    register PyObject *u;
-    register PyObject *t;
-    register PyObject *stream = NULL;    /* for PRINT opcodes */
-    register PyObject **fastlocals, **freevars;
+    PyObject **stack_pointer;  /* Next free slot in value stack */
+    unsigned char *next_instr;
+    int opcode;        /* Current opcode */
+    int oparg;         /* Current opcode argument, if any */
+    enum why_code why; /* Reason for block stack unwind */
+    int err;           /* Error status -- nonzero if error */
+    PyObject *x;       /* Result object -- NULL if error */
+    PyObject *v;       /* Temporary objects popped off stack */
+    PyObject *w;
+    PyObject *u;
+    PyObject *t;
+    PyObject *stream = NULL;    /* for PRINT opcodes */
+    PyObject **fastlocals, **freevars;
     PyObject *retval = NULL;            /* Return value */
     PyThreadState *tstate = PyThreadState_GET();
     PyCodeObject *co;
@@ -1479,7 +1479,7 @@
             v = TOP();
             if (PyInt_CheckExact(v) && PyInt_CheckExact(w)) {
                 /* INLINE: int + int */
-                register long a, b, i;
+                long a, b, i;
                 a = PyInt_AS_LONG(v);
                 b = PyInt_AS_LONG(w);
                 /* cast to avoid undefined behaviour
@@ -1513,7 +1513,7 @@
             v = TOP();
             if (PyInt_CheckExact(v) && PyInt_CheckExact(w)) {
                 /* INLINE: int - int */
-                register long a, b, i;
+                long a, b, i;
                 a = PyInt_AS_LONG(v);
                 b = PyInt_AS_LONG(w);
                 /* cast to avoid undefined behaviour
@@ -1727,7 +1727,7 @@
             v = TOP();
             if (PyInt_CheckExact(v) && PyInt_CheckExact(w)) {
                 /* INLINE: int + int */
-                register long a, b, i;
+                long a, b, i;
                 a = PyInt_AS_LONG(v);
                 b = PyInt_AS_LONG(w);
                 i = a + b;
@@ -1759,7 +1759,7 @@
             v = TOP();
             if (PyInt_CheckExact(v) && PyInt_CheckExact(w)) {
                 /* INLINE: int - int */
-                register long a, b, i;
+                long a, b, i;
                 a = PyInt_AS_LONG(v);
                 b = PyInt_AS_LONG(w);
                 i = a - b;
@@ -2569,8 +2569,8 @@
             v = TOP();
             if (PyInt_CheckExact(w) && PyInt_CheckExact(v)) {
                 /* INLINE: cmp(int, int) */
-                register long a, b;
-                register int res;
+                long a, b;
+                int res;
                 a = PyInt_AS_LONG(v);
                 b = PyInt_AS_LONG(w);
                 switch (oparg) {
@@ -3372,9 +3372,9 @@
            PyObject **args, int argcount, PyObject **kws, int kwcount,
            PyObject **defs, int defcount, PyObject *closure)
 {
-    register PyFrameObject *f;
-    register PyObject *retval = NULL;
-    register PyObject **fastlocals, **freevars;
+    PyFrameObject *f;
+    PyObject *retval = NULL;
+    PyObject **fastlocals, **freevars;
     PyThreadState *tstate = PyThreadState_GET();
     PyObject *x, *u;
 
@@ -4038,7 +4038,7 @@
 call_trace(Py_tracefunc func, PyObject *obj, PyFrameObject *frame,
            int what, PyObject *arg)
 {
-    register PyThreadState *tstate = frame->f_tstate;
+    PyThreadState *tstate = frame->f_tstate;
     int result;
     if (tstate->tracing)
         return 0;
@@ -4824,7 +4824,7 @@
                          "BaseException is not allowed in 3.x"
 
 static PyObject *
-cmp_outcome(int op, register PyObject *v, register PyObject *w)
+cmp_outcome(int op, PyObject *v, PyObject *w)
 {
     int res = 0;
     switch (op) {
--- a/Python/marshal.c	2019-08-31 14:56:04.478084341 +0200
+++ b/Python/marshal.c	2019-08-31 14:59:39.841089681 +0200
@@ -513,7 +513,7 @@
 static int
 r_short(RFILE *p)
 {
-    register short x;
+    short x;
     x = r_byte(p);
     x |= r_byte(p) << 8;
     /* Sign-extension, in case short greater than 16 bits */
@@ -524,8 +524,8 @@
 static long
 r_long(RFILE *p)
 {
-    register long x;
-    register FILE *fp = p->fp;
+    long x;
+    FILE *fp = p->fp;
     if (fp) {
         x = getc(fp);
         x |= (long)getc(fp) << 8;
--- a/Python/codecs.c	2019-08-31 14:56:04.478084341 +0200
+++ b/Python/codecs.c	2019-08-31 14:59:39.841089681 +0200
@@ -51,7 +51,7 @@
 static
 PyObject *normalizestring(const char *string)
 {
-    register size_t i;
+    size_t i;
     size_t len = strlen(string);
     char *p;
     PyObject *v;
@@ -66,7 +66,7 @@
         return NULL;
     p = PyString_AS_STRING(v);
     for (i = 0; i < len; i++) {
-        register char ch = string[i];
+        char ch = string[i];
         if (ch == ' ')
             ch = '-';
         else
--- a/Python/strtod.c	2019-08-31 14:56:04.479084341 +0200
+++ b/Python/strtod.c	2019-08-31 14:59:39.841089681 +0200
@@ -67,8 +67,8 @@
     int sign, scale, dotseen;
     int esign, expt;
     char *save;
-    register char *sp, *dp;
-    register int c;
+    char *sp, *dp;
+    int c;
     char *buforg, *buflim;
     char buffer[64];                    /* 45-digit significant + */
                     /* 13-digit exponent */
--- a/Python/dynload_aix.c	2019-08-31 14:56:04.479084341 +0200
+++ b/Python/dynload_aix.c	2019-08-31 14:59:39.841089681 +0200
@@ -35,11 +35,11 @@
 static int
 aix_getoldmodules(void **modlistptr)
 {
-    register ModulePtr       modptr, prevmodptr;
-    register struct ld_info  *ldiptr;
-    register char            *ldibuf;
-    register int             errflag, bufsize = 1024;
-    register unsigned int    offset;
+    ModulePtr       modptr, prevmodptr;
+    struct ld_info  *ldiptr;
+    char            *ldibuf;
+    int             errflag, bufsize = 1024;
+    unsigned int    offset;
     char *progname = Py_GetProgramName();
 
     /*
@@ -109,7 +109,7 @@
 {
 
     char *message[1024], errbuf[1024];
-    register int i,j;
+    int i,j;
 
     struct errtab {
         int errNo;
--- a/Python/mystrtoul.c	2019-08-31 14:56:04.480084341 +0200
+++ b/Python/mystrtoul.c	2019-08-31 14:59:39.842089681 +0200
@@ -92,11 +92,11 @@
 **              exceptions - we don't check for them.
 */
 unsigned long
-PyOS_strtoul(register char *str, char **ptr, int base)
+PyOS_strtoul(char *str, char **ptr, int base)
 {
-    register unsigned long result = 0; /* return value of the function */
-    register int c;             /* current input character */
-    register int ovlimit;       /* required digits to overflow */
+    long result = 0; /* return value of the function */
+    int c;             /* current input character */
+    int ovlimit;       /* required digits to overflow */
 
     /* skip leading white space */
     while (*str && isspace(Py_CHARMASK(*str)))
@@ -207,7 +207,7 @@
         if (ovlimit > 0) /* no overflow check required */
             result = result * base + c;
         else { /* requires overflow check */
-            register unsigned long temp_result;
+            long temp_result;
 
             if (ovlimit < 0) /* guaranteed overflow */
                 goto overflowed;
--- a/Objects/stringlib/split.h	2019-08-31 14:56:04.482084341 +0200
+++ b/Objects/stringlib/split.h	2019-08-31 14:59:39.845089681 +0200
@@ -348,8 +348,8 @@
        and the appends only done when the prealloc buffer is full.
        That's too much work for little gain.*/
 
-    register Py_ssize_t i;
-    register Py_ssize_t j;
+    Py_ssize_t i;
+    Py_ssize_t j;
     PyObject *list = PyList_New(0);
     PyObject *sub;
 
--- a/Objects/bufferobject.c	2019-08-31 14:56:04.482084341 +0200
+++ b/Objects/bufferobject.c	2019-08-31 14:59:39.842089681 +0200
@@ -309,9 +309,9 @@
 {
     void *ptr;
     Py_ssize_t size;
-    register Py_ssize_t len;
-    register unsigned char *p;
-    register long x;
+    Py_ssize_t len;
+    unsigned char *p;
+    long x;
 
     if ( self->b_hash != -1 )
         return self->b_hash;
@@ -432,7 +432,7 @@
 buffer_repeat(PyBufferObject *self, Py_ssize_t count)
 {
     PyObject *ob;
-    register char *p;
+    char *p;
     void *ptr;
     Py_ssize_t size;
 
--- a/Objects/setobject.c	2019-08-31 14:56:04.483084341 +0200
+++ b/Objects/setobject.c	2019-08-31 14:59:39.842089681 +0200
@@ -70,15 +70,15 @@
 */
 
 static setentry *
-set_lookkey(PySetObject *so, PyObject *key, register long hash)
+set_lookkey(PySetObject *so, PyObject *key, long hash)
 {
-    register Py_ssize_t i;
-    register size_t perturb;
-    register setentry *freeslot;
-    register size_t mask = so->mask;
+    Py_ssize_t i;
+    size_t perturb;
+    setentry *freeslot;
+    size_t mask = so->mask;
     setentry *table = so->table;
-    register setentry *entry;
-    register int cmp;
+    setentry *entry;
+    int cmp;
     PyObject *startkey;
 
     i = hash & mask;
@@ -152,14 +152,14 @@
  * see if the comparison altered the table.
  */
 static setentry *
-set_lookkey_string(PySetObject *so, PyObject *key, register long hash)
+set_lookkey_string(PySetObject *so, PyObject *key, long hash)
 {
-    register Py_ssize_t i;
-    register size_t perturb;
-    register setentry *freeslot;
-    register size_t mask = so->mask;
+    Py_ssize_t i;
+    size_t perturb;
+    setentry *freeslot;
+    size_t mask = so->mask;
     setentry *table = so->table;
-    register setentry *entry;
+    setentry *entry;
 
     /* Make sure this function doesn't have to handle non-string keys,
        including subclasses of str; e.g., one reason to subclass
@@ -206,9 +206,9 @@
 Eats a reference to key.
 */
 static int
-set_insert_key(register PySetObject *so, PyObject *key, long hash)
+set_insert_key(PySetObject *so, PyObject *key, long hash)
 {
-    register setentry *entry;
+    setentry *entry;
 
     assert(so->lookup != NULL);
     entry = so->lookup(so, key, hash);
@@ -242,13 +242,13 @@
 is responsible for incref'ing `key`.
 */
 static void
-set_insert_clean(register PySetObject *so, PyObject *key, long hash)
+set_insert_clean(PySetObject *so, PyObject *key, long hash)
 {
-    register size_t i;
-    register size_t perturb;
-    register size_t mask = (size_t)so->mask;
+    size_t i;
+    size_t perturb;
+    size_t mask = (size_t)so->mask;
     setentry *table = so->table;
-    register setentry *entry;
+    setentry *entry;
 
     i = hash & mask;
     entry = &table[i];
@@ -355,9 +355,9 @@
 /* CAUTION: set_add_key/entry() must guarantee it won't resize the table */
 
 static int
-set_add_entry(register PySetObject *so, setentry *entry)
+set_add_entry(PySetObject *so, setentry *entry)
 {
-    register Py_ssize_t n_used;
+    Py_ssize_t n_used;
     PyObject *key = entry->key;
     long hash = entry->hash;
 
@@ -374,10 +374,10 @@
 }
 
 static int
-set_add_key(register PySetObject *so, PyObject *key)
+set_add_key(PySetObject *so, PyObject *key)
 {
-    register long hash;
-    register Py_ssize_t n_used;
+    long hash;
+    Py_ssize_t n_used;
 
     if (!PyString_CheckExact(key) ||
         (hash = ((PyStringObject *) key)->ob_shash) == -1) {
@@ -402,7 +402,7 @@
 
 static int
 set_discard_entry(PySetObject *so, setentry *oldentry)
-{       register setentry *entry;
+{       setentry *entry;
     PyObject *old_key;
 
     entry = (so->lookup)(so, oldentry->key, oldentry->hash);
@@ -421,8 +421,8 @@
 static int
 set_discard_key(PySetObject *so, PyObject *key)
 {
-    register long hash;
-    register setentry *entry;
+    long hash;
+    setentry *entry;
     PyObject *old_key;
 
     assert (PyAnySet_Check(so));
@@ -527,7 +527,7 @@
 {
     Py_ssize_t i;
     Py_ssize_t mask;
-    register setentry *table;
+    setentry *table;
 
     assert (PyAnySet_Check(so));
     i = *pos_ptr;
@@ -547,7 +547,7 @@
 static void
 set_dealloc(PySetObject *so)
 {
-    register setentry *entry;
+    setentry *entry;
     Py_ssize_t fill = so->fill;
     /* bpo-31095: UnTrack is needed before calling any callbacks */
     PyObject_GC_UnTrack(so);
@@ -648,8 +648,8 @@
     PySetObject *other;
     PyObject *key;
     long hash;
-    register Py_ssize_t i;
-    register setentry *entry;
+    Py_ssize_t i;
+    setentry *entry;
 
     assert (PyAnySet_Check(so));
     assert (PyAnySet_Check(otherset));
@@ -717,8 +717,8 @@
 static PyObject *
 set_pop(PySetObject *so)
 {
-    register Py_ssize_t i = 0;
-    register setentry *entry;
+    Py_ssize_t i = 0;
+    setentry *entry;
     PyObject *key;
 
     assert (PyAnySet_Check(so));
@@ -844,8 +844,8 @@
 static PyObject *setiter_iternext(setiterobject *si)
 {
     PyObject *key;
-    register Py_ssize_t i, mask;
-    register setentry *entry;
+    Py_ssize_t i, mask;
+    setentry *entry;
     PySetObject *so = si->si_set;
 
     if (so == NULL)
@@ -999,7 +999,7 @@
 static PyObject *
 make_new_set(PyTypeObject *type, PyObject *iterable)
 {
-    register PySetObject *so = NULL;
+    PySetObject *so = NULL;
 
     if (dummy == NULL) { /* Auto-initialize dummy */
         dummy = PyString_FromString("<dummy key>");
--- a/Objects/unicodeobject.c	2019-08-31 14:56:04.483084341 +0200
+++ b/Objects/unicodeobject.c	2019-08-31 14:59:39.859089681 +0200
@@ -257,7 +257,7 @@
 /* --- a/Unicode Object ----------------------------------------------------- a/*/
 
 static
-int unicode_resize(register PyUnicodeObject *unicode,
+int unicode_resize(PyUnicodeObject *unicode,
                    Py_ssize_t length)
 {
     void *oldstr;
@@ -316,7 +316,7 @@
 static
 PyUnicodeObject *_PyUnicode_New(Py_ssize_t length)
 {
-    register PyUnicodeObject *unicode;
+    PyUnicodeObject *unicode;
 
     /* Optimization for empty strings */
     if (length == 0 && unicode_empty != NULL) {
@@ -385,7 +385,7 @@
 }
 
 static
-void unicode_dealloc(register PyUnicodeObject *unicode)
+void unicode_dealloc(PyUnicodeObject *unicode)
 {
     if (PyUnicode_CheckExact(unicode) &&
         numfree < PyUnicode_MAXFREELIST) {
@@ -413,7 +413,7 @@
 static
 int _PyUnicode_Resize(PyUnicodeObject **unicode, Py_ssize_t length)
 {
-    register PyUnicodeObject *v;
+    PyUnicodeObject *v;
 
     /* Argument checks */
     if (unicode == NULL) {
@@ -605,11 +605,11 @@
 /* Here sizeof(wchar_t) is 4 but Py_UNICODE_SIZE == 2, so we need
    to convert from UTF32 to UTF16. */
 
-PyObject *PyUnicode_FromWideChar(register const wchar_t *w,
+PyObject *PyUnicode_FromWideChar(const wchar_t *w,
                                  Py_ssize_t size)
 {
     PyUnicodeObject *unicode;
-    register Py_ssize_t i;
+    y_ssize_t i;
     Py_ssize_t alloc;
     const wchar_t *orig_w;
 
@@ -632,7 +632,7 @@
 
     /* Copy the wchar_t data into the new object */
     {
-        register Py_UNICODE *u;
+        Py_UNICODE *u;
         u = PyUnicode_AS_UNICODE(unicode);
         for (i = size; i > 0; i--) {
             if (*w > 0xFFFF) {
@@ -650,7 +650,7 @@
 
 #else
 
-PyObject *PyUnicode_FromWideChar(register const wchar_t *w,
+PyObject *PyUnicode_FromWideChar(const wchar_t *w,
                                  Py_ssize_t size)
 {
     PyUnicodeObject *unicode;
@@ -669,8 +669,8 @@
     memcpy(unicode->str, w, size * sizeof(wchar_t));
 #else
     {
-        register Py_UNICODE *u;
-        register Py_ssize_t i;
+        Py_UNICODE *u;
+        Py_ssize_t i;
         u = PyUnicode_AS_UNICODE(unicode);
         for (i = size; i > 0; i--)
             *u++ = *w++;
@@ -1120,8 +1120,8 @@
     memcpy(w, unicode->str, size * sizeof(wchar_t));
 #else
     {
-        register Py_UNICODE *u;
-        register Py_ssize_t i;
+        Py_UNICODE *u;
+        Py_ssize_t i;
         u = PyUnicode_AS_UNICODE(unicode);
         for (i = size; i > 0; i--)
             *w++ = *u++;
@@ -1160,7 +1160,7 @@
     return PyUnicode_FromUnicode(s, 1);
 }
 
-PyObject *PyUnicode_FromObject(register PyObject *obj)
+PyObject *PyUnicode_FromObject(PyObject *obj)
 {
     /* XXX Perhaps we should make this API an alias of
        PyObject_Unicode() instead ?! */
@@ -1177,7 +1177,7 @@
     return PyUnicode_FromEncodedObject(obj, NULL, "strict");
 }
 
-PyObject *PyUnicode_FromEncodedObject(register PyObject *obj,
+PyObject *PyUnicode_FromEncodedObject(PyObject *obj,
                                       const char *encoding,
                                       const char *errors)
 {
@@ -3865,7 +3865,7 @@
     p = PyUnicode_AS_UNICODE(v);
     e = s + size;
     while (s < e) {
-        register unsigned char c = (unsigned char)*s;
+        unsigned char c = (unsigned char)*s;
         if (c < 128) {
             *p++ = c;
             ++s;
@@ -5255,7 +5255,7 @@
     p = s;
     end = s + length;
     while (p < end) {
-        register Py_UNICODE ch = *p;
+        Py_UNICODE ch = *p;
         int decimal;
         PyObject *repunicode;
         Py_ssize_t repsize;
@@ -5540,7 +5540,7 @@
     int status = 0;
 
     while (len-- > 0) {
-        register Py_UNICODE ch;
+        Py_UNICODE ch;
 
         ch = Py_UNICODE_TOUPPER(*s);
         if (ch != *s) {
@@ -5561,7 +5561,7 @@
     int status = 0;
 
     while (len-- > 0) {
-        register Py_UNICODE ch;
+        Py_UNICODE ch;
 
         ch = Py_UNICODE_TOLOWER(*s);
         if (ch != *s) {
@@ -5622,8 +5622,8 @@
 static
 int fixtitle(PyUnicodeObject *self)
 {
-    register Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register Py_UNICODE *e;
+    Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    Py_UNICODE *e;
     int previous_is_cased;
 
     /* Shortcut for single character strings */
@@ -5640,7 +5640,7 @@
     e = p + PyUnicode_GET_SIZE(self);
     previous_is_cased = 0;
     for (; p < e; p++) {
-        register const Py_UNICODE ch = *p;
+        const Py_UNICODE ch = *p;
 
         if (previous_is_cased)
             *p = Py_UNICODE_TOLOWER(ch);
@@ -6205,7 +6205,7 @@
 static int
 unicode_compare(PyUnicodeObject *str1, PyUnicodeObject *str2)
 {
-    register Py_ssize_t len1, len2;
+    Py_ssize_t len1, len2;
 
     Py_UNICODE *s1 = str1->str;
     Py_UNICODE *s2 = str2->str;
@@ -6659,9 +6659,9 @@
        strings and Unicode objects behave in the same way as
        dictionary keys. */
 
-    register Py_ssize_t len;
-    register Py_UNICODE *p;
-    register long x;
+    Py_ssize_t len;
+    Py_UNICODE *p;
+    long x;
 
 #ifdef Py_DEBUG
     assert(_Py_HashSecret_Initialized);
@@ -6732,8 +6732,8 @@
 static PyObject*
 unicode_islower(PyUnicodeObject *self)
 {
-    register const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register const Py_UNICODE *e;
+    const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    const Py_UNICODE *e;
     int cased;
 
     /* Shortcut for single character strings */
@@ -6747,7 +6747,7 @@
     e = p + PyUnicode_GET_SIZE(self);
     cased = 0;
     for (; p < e; p++) {
-        register const Py_UNICODE ch = *p;
+        const Py_UNICODE ch = *p;
 
         if (Py_UNICODE_ISUPPER(ch) || Py_UNICODE_ISTITLE(ch))
             return PyBool_FromLong(0);
@@ -6766,8 +6766,8 @@
 static PyObject*
 unicode_isupper(PyUnicodeObject *self)
 {
-    register const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register const Py_UNICODE *e;
+    const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    const Py_UNICODE *e;
     int cased;
 
     /* Shortcut for single character strings */
@@ -6781,7 +6781,7 @@
     e = p + PyUnicode_GET_SIZE(self);
     cased = 0;
     for (; p < e; p++) {
-        register const Py_UNICODE ch = *p;
+        const Py_UNICODE ch = *p;
 
         if (Py_UNICODE_ISLOWER(ch) || Py_UNICODE_ISTITLE(ch))
             return PyBool_FromLong(0);
@@ -6802,8 +6802,8 @@
 static PyObject*
 unicode_istitle(PyUnicodeObject *self)
 {
-    register const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register const Py_UNICODE *e;
+    const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    const Py_UNICODE *e;
     int cased, previous_is_cased;
 
     /* Shortcut for single character strings */
@@ -6819,7 +6819,7 @@
     cased = 0;
     previous_is_cased = 0;
     for (; p < e; p++) {
-        register const Py_UNICODE ch = *p;
+        const Py_UNICODE ch = *p;
 
         if (Py_UNICODE_ISUPPER(ch) || Py_UNICODE_ISTITLE(ch)) {
             if (previous_is_cased)
@@ -6848,8 +6848,8 @@
 static PyObject*
 unicode_isspace(PyUnicodeObject *self)
 {
-    register const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register const Py_UNICODE *e;
+    const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    const Py_UNICODE *e;
 
     /* Shortcut for single character strings */
     if (PyUnicode_GET_SIZE(self) == 1 &&
@@ -6877,8 +6877,8 @@
 static PyObject*
 unicode_isalpha(PyUnicodeObject *self)
 {
-    register const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register const Py_UNICODE *e;
+    const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    const Py_UNICODE *e;
 
     /* Shortcut for single character strings */
     if (PyUnicode_GET_SIZE(self) == 1 &&
@@ -6906,8 +6906,8 @@
 static PyObject*
 unicode_isalnum(PyUnicodeObject *self)
 {
-    register const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register const Py_UNICODE *e;
+    const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    const Py_UNICODE *e;
 
     /* Shortcut for single character strings */
     if (PyUnicode_GET_SIZE(self) == 1 &&
@@ -6935,8 +6935,8 @@
 static PyObject*
 unicode_isdecimal(PyUnicodeObject *self)
 {
-    register const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register const Py_UNICODE *e;
+    const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    const Py_UNICODE *e;
 
     /* Shortcut for single character strings */
     if (PyUnicode_GET_SIZE(self) == 1 &&
@@ -6964,8 +6964,8 @@
 static PyObject*
 unicode_isdigit(PyUnicodeObject *self)
 {
-    register const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register const Py_UNICODE *e;
+    const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    const Py_UNICODE *e;
 
     /* Shortcut for single character strings */
     if (PyUnicode_GET_SIZE(self) == 1 &&
@@ -6993,8 +6993,8 @@
 static PyObject*
 unicode_isnumeric(PyUnicodeObject *self)
 {
-    register const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
-    register const Py_UNICODE *e;
+    const Py_UNICODE *p = PyUnicode_AS_UNICODE(self);
+    const Py_UNICODE *e;
 
     /* Shortcut for single character strings */
     if (PyUnicode_GET_SIZE(self) == 1 &&
@@ -8145,7 +8145,7 @@
 static Py_ssize_t
 strtounicode(Py_UNICODE *buffer, const char *charbuffer)
 {
-    register Py_ssize_t i;
+    Py_ssize_t i;
     Py_ssize_t len = strlen(charbuffer);
     for (i = len - 1; i >= 0; i--)
         buffer[i] = (Py_UNICODE) charbuffer[i];
--- a/Objects/longobject.c	2019-08-31 14:56:04.484084341 +0200
+++ b/Objects/longobject.c	2019-08-31 14:59:39.851089681 +0200
@@ -44,7 +44,7 @@
    of the algorithms used, this could save at most be one word anyway. */
 
 static PyLongObject *
-long_normalize(register PyLongObject *v)
+long_normalize(PyLongObject *v)
 {
     Py_ssize_t j = ABS(Py_SIZE(v));
     Py_ssize_t i = j;
@@ -232,7 +232,7 @@
 PyLong_AsLongAndOverflow(PyObject *vv, int *overflow)
 {
     /* This version by Tim Peters */
-    register PyLongObject *v;
+    PyLongObject *v;
     unsigned long x, prev;
     long res;
     Py_ssize_t i;
@@ -362,7 +362,7 @@
 
 Py_ssize_t
 PyLong_AsSsize_t(PyObject *vv) {
-    register PyLongObject *v;
+    PyLongObject *v;
     size_t x, prev;
     Py_ssize_t i;
     int sign;
@@ -408,7 +408,7 @@
 unsigned long
 PyLong_AsUnsignedLong(PyObject *vv)
 {
-    register PyLongObject *v;
+    PyLongObject *v;
     unsigned long x, prev;
     Py_ssize_t i;
 
@@ -452,7 +452,7 @@
 unsigned long
 PyLong_AsUnsignedLongMask(PyObject *vv)
 {
-    register PyLongObject *v;
+    PyLongObject *v;
     unsigned long x;
     Py_ssize_t i;
     int sign;
@@ -1015,7 +1015,7 @@
 unsigned PY_LONG_LONG
 PyLong_AsUnsignedLongLongMask(PyObject *vv)
 {
-    register PyLongObject *v;
+    PyLongObject *v;
     unsigned PY_LONG_LONG x;
     Py_ssize_t i;
     int sign;
@@ -1050,7 +1050,7 @@
 PyLong_AsLongLongAndOverflow(PyObject *vv, int *overflow)
 {
     /* This version by Tim Peters */
-    register PyLongObject *v;
+    PyLongObject *v;
     unsigned PY_LONG_LONG x, prev;
     PY_LONG_LONG res;
     Py_ssize_t i;
@@ -1454,7 +1454,7 @@
 PyAPI_FUNC(PyObject *)
 _PyLong_Format(PyObject *aa, int base, int addL, int newstyle)
 {
-    register PyLongObject *a = (PyLongObject *)aa;
+    PyLongObject *a = (PyLongObject *)aa;
     PyStringObject *str;
     Py_ssize_t i, sz;
     Py_ssize_t size_a;
@@ -1850,7 +1850,7 @@
 just 1 digit at the start, so that the copying code was exercised for every
 digit beyond the first.
 ***/
-        register twodigits c;           /* current input character */
+        twodigits c;           /* current input character */
         Py_ssize_t size_z;
         int i;
         int convwidth;
--- a/Objects/listobject.c	2019-08-31 14:56:04.484084341 +0200
+++ b/Objects/listobject.c	2019-08-31 14:59:39.843089681 +0200
@@ -196,11 +196,11 @@
 }
 
 int
-PyList_SetItem(register PyObject *op, register Py_ssize_t i,
-               register PyObject *newitem)
+PyList_SetItem(PyObject *op, Py_ssize_t i,
+               PyObject *newitem)
 {
-    register PyObject *olditem;
-    register PyObject **p;
+    PyObject *olditem;
+    PyObject **p;
     if (!PyList_Check(op)) {
         Py_XDECREF(newitem);
         PyErr_BadInternalCall();
@@ -1052,9 +1052,9 @@
 binarysort(PyObject **lo, PyObject **hi, PyObject **start, PyObject *compare)
      /* compare -- comparison function object, or NULL for default */
 {
-    register Py_ssize_t k;
-    register PyObject **l, **p, **r;
-    register PyObject *pivot;
+    Py_ssize_t k;
+    PyObject **l, **p, **r;
+    PyObject *pivot;
 
     assert(lo <= start && start <= hi);
     /* assert [lo, start) is sorted */
--- a/Objects/unicodetype_db.h	2019-08-31 14:56:04.485084341 +0200
+++ b/Objects/unicodetype_db.h	2019-08-31 14:59:39.855089681 +0200
@@ -3271,7 +3271,7 @@
 /* Returns 1 for Unicode characters having the bidirectional
  * type 'WS', 'B' or 'S' or the category 'Zs', 0 otherwise.
  */
-int _PyUnicode_IsWhitespace(register const Py_UNICODE ch)
+int _PyUnicode_IsWhitespace(const Py_UNICODE ch)
 {
 #ifdef WANT_WCTYPE_FUNCTIONS
     return iswspace(ch);
@@ -3317,7 +3317,7 @@
  * property 'BK', 'CR', 'LF' or 'NL' or having bidirectional
  * type 'B', 0 otherwise.
  */
-int _PyUnicode_IsLinebreak(register const Py_UNICODE ch)
+int _PyUnicode_IsLinebreak(const Py_UNICODE ch)
 {
     switch (ch) {
     case 0x000A:
--- a/Objects/bytes_methods.c	2019-08-31 14:56:04.486084341 +0200
+++ b/Objects/bytes_methods.c	2019-08-31 14:59:39.843089681 +0200
@@ -10,9 +10,9 @@
 PyObject*
 _Py_bytes_isspace(const char *cptr, Py_ssize_t len)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) cptr;
-    register const unsigned char *e;
+    const unsigned char *e;
 
     /* Shortcut for single character strings */
     if (len == 1 && Py_ISSPACE(*p))
@@ -40,9 +40,9 @@
 PyObject*
 _Py_bytes_isalpha(const char *cptr, Py_ssize_t len)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) cptr;
-    register const unsigned char *e;
+    const unsigned char *e;
 
     /* Shortcut for single character strings */
     if (len == 1 && Py_ISALPHA(*p))
@@ -70,9 +70,9 @@
 PyObject*
 _Py_bytes_isalnum(const char *cptr, Py_ssize_t len)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) cptr;
-    register const unsigned char *e;
+    const unsigned char *e;
 
     /* Shortcut for single character strings */
     if (len == 1 && Py_ISALNUM(*p))
@@ -100,9 +100,9 @@
 PyObject*
 _Py_bytes_isdigit(const char *cptr, Py_ssize_t len)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) cptr;
-    register const unsigned char *e;
+    const unsigned char *e;
 
     /* Shortcut for single character strings */
     if (len == 1 && Py_ISDIGIT(*p))
@@ -130,9 +130,9 @@
 PyObject*
 _Py_bytes_islower(const char *cptr, Py_ssize_t len)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) cptr;
-    register const unsigned char *e;
+    const unsigned char *e;
     int cased;
 
     /* Shortcut for single character strings */
@@ -164,9 +164,9 @@
 PyObject*
 _Py_bytes_isupper(const char *cptr, Py_ssize_t len)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) cptr;
-    register const unsigned char *e;
+    const unsigned char *e;
     int cased;
 
     /* Shortcut for single character strings */
@@ -200,9 +200,9 @@
 PyObject*
 _Py_bytes_istitle(const char *cptr, Py_ssize_t len)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) cptr;
-    register const unsigned char *e;
+    const unsigned char *e;
     int cased, previous_is_cased;
 
     /* Shortcut for single character strings */
@@ -217,7 +217,7 @@
     cased = 0;
     previous_is_cased = 0;
     for (; p < e; p++) {
-        register const unsigned char ch = *p;
+        const unsigned char ch = *p;
 
         if (Py_ISUPPER(ch)) {
             if (previous_is_cased)
--- a/Objects/bytearrayobject.c	2019-08-31 14:56:04.486084341 +0200
+++ b/Objects/bytearrayobject.c	2019-08-31 14:59:39.843089681 +0200
@@ -961,9 +961,9 @@
         return NULL;
     }
     else {
-        register Py_ssize_t i;
-        register char c;
-        register char *p;
+        Py_ssize_t i;
+        char c;
+        char *p;
         int quote;
 
         /* Figure out which quote to use; single is preferred */
@@ -1464,9 +1464,9 @@
 static PyObject *
 bytearray_translate(PyByteArrayObject *self, PyObject *args)
 {
-    register char *input, *output;
-    register const char *table;
-    register Py_ssize_t i, c;
+    char *input, *output;
+    const char *table;
+    Py_ssize_t i, c;
     PyObject *input_obj = (PyObject*)self;
     const char *output_start;
     Py_ssize_t inlen;
--- a/Objects/intobject.c	2019-08-31 14:56:04.487084341 +0200
+++ b/Objects/intobject.c	2019-08-31 14:59:39.843089681 +0200
@@ -86,7 +86,7 @@
 PyObject *
 PyInt_FromLong(long ival)
 {
-    register PyIntObject *v;
+    PyIntObject *v;
 #if NSMALLNEGINTS + NSMALLPOSINTS > 0
     if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) {
         v = small_ints[ival + NSMALLNEGINTS];
@@ -140,7 +140,7 @@
 }
 
 long
-PyInt_AsLong(register PyObject *op)
+PyInt_AsLong(PyObject *op)
 {
     PyNumberMethods *nb;
     PyIntObject *io;
@@ -200,7 +200,7 @@
 }
 
 Py_ssize_t
-PyInt_AsSsize_t(register PyObject *op)
+PyInt_AsSsize_t(PyObject *op)
 {
 #if SIZEOF_SIZE_T != SIZEOF_LONG
     PyNumberMethods *nb;
@@ -259,7 +259,7 @@
 }
 
 unsigned long
-PyInt_AsUnsignedLongMask(register PyObject *op)
+PyInt_AsUnsignedLongMask(PyObject *op)
 {
     PyNumberMethods *nb;
     PyIntObject *io;
@@ -304,7 +304,7 @@
 
 #ifdef HAVE_LONG_LONG
 unsigned PY_LONG_LONG
-PyInt_AsUnsignedLongLongMask(register PyObject *op)
+PyInt_AsUnsignedLongLongMask(PyObject *op)
 {
     PyNumberMethods *nb;
     PyIntObject *io;
@@ -449,8 +449,8 @@
 static int
 int_compare(PyIntObject *v, PyIntObject *w)
 {
-    register long i = v->ob_ival;
-    register long j = w->ob_ival;
+    long i = v->ob_ival;
+    long j = w->ob_ival;
     return (i < j) ? -1 : (i > j) ? 1 : 0;
 }
 
@@ -468,7 +468,7 @@
 static PyObject *
 int_add(PyIntObject *v, PyIntObject *w)
 {
-    register long a, b, x;
+    long a, b, x;
     CONVERT_TO_LONG(v, a);
     CONVERT_TO_LONG(w, b);
     /* casts in the line below avoid undefined behaviour on overflow */
@@ -481,7 +481,7 @@
 static PyObject *
 int_sub(PyIntObject *v, PyIntObject *w)
 {
-    register long a, b, x;
+    long a, b, x;
     CONVERT_TO_LONG(v, a);
     CONVERT_TO_LONG(w, b);
     /* casts in the line below avoid undefined behaviour on overflow */
@@ -576,7 +576,7 @@
 };
 
 static enum divmod_result
-i_divmod(register long x, register long y,
+i_divmod(long x, long y,
          long *p_xdivy, long *p_xmody)
 {
     long xdivy, xmody;
@@ -725,7 +725,7 @@
 static PyObject *
 int_pow(PyIntObject *v, PyIntObject *w, PyIntObject *z)
 {
-    register long iv, iw, iz=0, ix, temp, prev;
+    long iv, iw, iz=0, ix, temp, prev;
     CONVERT_TO_LONG(v, iv);
     CONVERT_TO_LONG(w, iw);
     if (iw < 0) {
@@ -810,7 +810,7 @@
 static PyObject *
 int_neg(PyIntObject *v)
 {
-    register long a;
+    long a;
     a = v->ob_ival;
     /* check for overflow */
     if (UNARY_NEG_WOULD_OVERFLOW(a)) {
@@ -895,7 +895,7 @@
 static PyObject *
 int_rshift(PyIntObject *v, PyIntObject *w)
 {
-    register long a, b;
+    long a, b;
     CONVERT_TO_LONG(v, a);
     CONVERT_TO_LONG(w, b);
     if (b < 0) {
@@ -919,7 +919,7 @@
 static PyObject *
 int_and(PyIntObject *v, PyIntObject *w)
 {
-    register long a, b;
+    long a, b;
     CONVERT_TO_LONG(v, a);
     CONVERT_TO_LONG(w, b);
     return PyInt_FromLong(a & b);
@@ -928,7 +928,7 @@
 static PyObject *
 int_xor(PyIntObject *v, PyIntObject *w)
 {
-    register long a, b;
+    long a, b;
     CONVERT_TO_LONG(v, a);
     CONVERT_TO_LONG(w, b);
     return PyInt_FromLong(a ^ b);
@@ -937,7 +937,7 @@
 static PyObject *
 int_or(PyIntObject *v, PyIntObject *w)
 {
-    register long a, b;
+    long a, b;
     CONVERT_TO_LONG(v, a);
     CONVERT_TO_LONG(w, b);
     return PyInt_FromLong(a | b);
--- a/Objects/object.c	2019-08-31 14:56:04.487084341 +0200
+++ b/Objects/object.c	2019-08-31 14:59:39.843089681 +0200
@@ -1616,8 +1616,8 @@
 int
 PyNumber_CoerceEx(PyObject **pv, PyObject **pw)
 {
-    register PyObject *v = *pv;
-    register PyObject *w = *pw;
+    PyObject *v = *pv;
+    PyObject *w = *pw;
     int res;
 
     /* Shortcut only for old-style types */
@@ -2235,10 +2235,10 @@
 }
 
 void
-_Py_ForgetReference(register PyObject *op)
+_Py_ForgetReference(PyObject *op)
 {
 #ifdef SLOW_UNREF_CHECK
-    register PyObject *p;
+    *p;
 #endif
     if (op->ob_refcnt < 0)
         Py_FatalError("UNREF negative refcnt");
--- a/Objects/classobject.c	2019-08-31 14:56:04.488084341 +0200
+++ b/Objects/classobject.c	2019-08-31 14:59:39.852089681 +0200
@@ -222,10 +222,10 @@
 }
 
 static PyObject *
-class_getattr(register PyClassObject *op, PyObject *name)
+class_getattr(PyClassObject *op, PyObject *name)
 {
-    register PyObject *v;
-    register char *sname;
+    PyObject *v;
+    char *sname;
     PyClassObject *klass;
     descrgetfunc f;
 
@@ -548,7 +548,7 @@
 PyObject *
 PyInstance_New(PyObject *klass, PyObject *arg, PyObject *kw)
 {
-    register PyInstanceObject *inst;
+    PyInstanceObject *inst;
     PyObject *init;
     static PyObject *initstr;
 
@@ -627,7 +627,7 @@
 
 
 static void
-instance_dealloc(register PyInstanceObject *inst)
+instance_dealloc(PyInstanceObject *inst)
 {
     PyObject *error_type, *error_value, *error_traceback;
     PyObject *del;
@@ -705,10 +705,10 @@
 }
 
 static PyObject *
-instance_getattr1(register PyInstanceObject *inst, PyObject *name)
+instance_getattr1(PyInstanceObject *inst, PyObject *name)
 {
-    register PyObject *v;
-    register char *sname;
+    PyObject *v;
+    char *sname;
 
     if (!PyString_Check(name)) {
         PyErr_SetString(PyExc_TypeError, "attribute name must be a string");
@@ -741,9 +741,9 @@
 }
 
 static PyObject *
-instance_getattr2(register PyInstanceObject *inst, PyObject *name)
+instance_getattr2(PyInstanceObject *inst, PyObject *name)
 {
-    register PyObject *v;
+    PyObject *v;
     PyClassObject *klass;
     descrgetfunc f;
 
@@ -767,9 +767,9 @@
 }
 
 static PyObject *
-instance_getattr(register PyInstanceObject *inst, PyObject *name)
+instance_getattr(PyInstanceObject *inst, PyObject *name)
 {
-    register PyObject *func, *res;
+    PyObject *func, *res;
     res = instance_getattr1(inst, name);
     if (res == NULL && (func = inst->in_class->cl_getattr) != NULL) {
         PyObject *args;
@@ -2250,7 +2250,7 @@
 PyObject *
 PyMethod_New(PyObject *func, PyObject *self, PyObject *klass)
 {
-    register PyMethodObject *im;
+    PyMethodObject *im;
     im = free_list;
     if (im != NULL) {
         free_list = (PyMethodObject *)(im->im_self);
@@ -2377,7 +2377,7 @@
 }
 
 static void
-instancemethod_dealloc(register PyMethodObject *im)
+instancemethod_dealloc(PyMethodObject *im)
 {
     _PyObject_GC_UNTRACK(im);
     if (im->im_weakreflist != NULL)
--- a/Objects/dictobject.c	2019-08-31 14:56:04.489084341 +0200
+++ b/Objects/dictobject.c	2019-08-31 14:59:39.852089681 +0200
@@ -240,7 +240,7 @@
 PyObject *
 PyDict_New(void)
 {
-    register PyDictObject *mp;
+    PyDictObject *mp;
     if (dummy == NULL) { /* Auto-initialize dummy */
         dummy = PyString_FromString("<dummy key>");
         if (dummy == NULL)
@@ -317,15 +317,15 @@
 PyDictEntry*.
 */
 static PyDictEntry *
-lookdict(PyDictObject *mp, PyObject *key, register long hash)
+lookdict(PyDictObject *mp, PyObject *key, long hash)
 {
-    register size_t i;
-    register size_t perturb;
-    register PyDictEntry *freeslot;
-    register size_t mask = (size_t)mp->ma_mask;
+    size_t i;
+    size_t perturb;
+    PyDictEntry *freeslot;
+    size_t mask = (size_t)mp->ma_mask;
     PyDictEntry *ep0 = mp->ma_table;
-    register PyDictEntry *ep;
-    register int cmp;
+    PyDictEntry *ep;
+    int cmp;
     PyObject *startkey;
 
     i = (size_t)hash & mask;
@@ -405,14 +405,14 @@
  * This is valuable because dicts with only string keys are very common.
  */
 static PyDictEntry *
-lookdict_string(PyDictObject *mp, PyObject *key, register long hash)
+lookdict_string(PyDictObject *mp, PyObject *key, long hash)
 {
-    register size_t i;
-    register size_t perturb;
-    register PyDictEntry *freeslot;
-    register size_t mask = (size_t)mp->ma_mask;
+    size_t i;
+    size_t perturb;
+    PyDictEntry *freeslot;
+    size_t mask = (size_t)mp->ma_mask;
     PyDictEntry *ep0 = mp->ma_table;
-    register PyDictEntry *ep;
+    PyDictEntry *ep;
 
     /* Make sure this function doesn't have to handle non-string keys,
        including subclasses of str; e.g., one reason to subclass
@@ -507,7 +507,7 @@
 Used by insertdict.
 */
 static int
-insertdict_by_entry(register PyDictObject *mp, PyObject *key, long hash,
+insertdict_by_entry( PyDictObject *mp, PyObject *key, long hash,
                     PyDictEntry *ep, PyObject *value)
 {
     PyObject *old_value;
@@ -542,9 +542,9 @@
 Returns -1 if an error occurred, or 0 on success.
 */
 static int
-insertdict(register PyDictObject *mp, PyObject *key, long hash, PyObject *value)
+insertdict(PyDictObject *mp, PyObject *key, long hash, PyObject *value)
 {
-    register PyDictEntry *ep;
+    PyDictEntry *ep;
 
     assert(mp->ma_lookup != NULL);
     ep = mp->ma_lookup(mp, key, hash);
@@ -565,14 +565,14 @@
 is responsible for incref'ing `key` and `value`.
 */
 static void
-insertdict_clean(register PyDictObject *mp, PyObject *key, long hash,
+insertdict_clean(PyDictObject *mp, PyObject *key, long hash,
                  PyObject *value)
 {
-    register size_t i;
-    register size_t perturb;
-    register size_t mask = (size_t)mp->ma_mask;
+    size_t i;
+    size_t perturb;
+    size_t mask = (size_t)mp->ma_mask;
     PyDictEntry *ep0 = mp->ma_table;
-    register PyDictEntry *ep;
+    PyDictEntry *ep;
 
     MAINTAIN_TRACKING(mp, key, value);
     i = hash & mask;
@@ -780,11 +780,11 @@
 }
 
 static int
-dict_set_item_by_hash_or_entry(register PyObject *op, PyObject *key,
+dict_set_item_by_hash_or_entry(PyObject *op, PyObject *key,
                                long hash, PyDictEntry *ep, PyObject *value)
 {
-    register PyDictObject *mp;
-    register Py_ssize_t n_used;
+    PyDictObject *mp;
+    Py_ssize_t n_used;
 
     mp = (PyDictObject *)op;
     assert(mp->ma_fill <= mp->ma_mask);  /* at least one empty slot */
@@ -825,9 +825,9 @@
  * remove them.
  */
 int
-PyDict_SetItem(register PyObject *op, PyObject *key, PyObject *value)
+PyDict_SetItem(PyObject *op, PyObject *key, PyObject *value)
 {
-    register long hash;
+    long hash;
 
     if (!PyDict_Check(op)) {
         PyErr_BadInternalCall();
@@ -867,9 +867,9 @@
 int
 PyDict_DelItem(PyObject *op, PyObject *key)
 {
-    register PyDictObject *mp;
-    register long hash;
-    register PyDictEntry *ep;
+    PyDictObject *mp;
+    long hash;
+    PyDictEntry *ep;
 
     if (!PyDict_Check(op)) {
         PyErr_BadInternalCall();
@@ -898,9 +898,9 @@
 _PyDict_DelItemIf(PyObject *op, PyObject *key,
                   int (*predicate)(PyObject *value))
 {
-    register PyDictObject *mp;
-    register long hash;
-    register PyDictEntry *ep;
+    PyDictObject *mp;
+    long hash;
+    PyDictEntry *ep;
     int res;
 
     if (!PyDict_Check(op)) {
@@ -1018,9 +1018,9 @@
 int
 PyDict_Next(PyObject *op, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue)
 {
-    register Py_ssize_t i;
-    register Py_ssize_t mask;
-    register PyDictEntry *ep;
+    Py_ssize_t i;
+    Py_ssize_t mask;
+    PyDictEntry *ep;
 
     if (!PyDict_Check(op))
         return 0;
@@ -1045,9 +1045,9 @@
 int
 _PyDict_Next(PyObject *op, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue, long *phash)
 {
-    register Py_ssize_t i;
-    register Py_ssize_t mask;
-    register PyDictEntry *ep;
+    Py_ssize_t i;
+    Py_ssize_t mask;
+    PyDictEntry *ep;
 
     if (!PyDict_Check(op))
         return 0;
@@ -1072,9 +1072,9 @@
 /* Methods */
 
 static void
-dict_dealloc(register PyDictObject *mp)
+dict_dealloc(PyDictObject *mp)
 {
-    register PyDictEntry *ep;
+    PyDictEntry *ep;
     Py_ssize_t fill = mp->ma_fill;
     /* bpo-31095: UnTrack is needed before calling any callbacks */
     PyObject_GC_UnTrack(mp);
@@ -1096,10 +1096,10 @@
 }
 
 static int
-dict_print(register PyDictObject *mp, register FILE *fp, register int flags)
+dict_print(PyDictObject *mp, FILE *fp, int flags)
 {
-    register Py_ssize_t i;
-    register Py_ssize_t any;
+    Py_ssize_t i;
+    Py_ssize_t any;
     int status;
 
     status = Py_ReprEnter((PyObject*)mp);
@@ -1237,7 +1237,7 @@
 }
 
 static PyObject *
-dict_subscript(PyDictObject *mp, register PyObject *key)
+dict_subscript(PyDictObject *mp, PyObject *key)
 {
     PyObject *v;
     long hash;
@@ -1294,10 +1294,10 @@
 };
 
 static PyObject *
-dict_keys(register PyDictObject *mp)
+dict_keys(PyDictObject *mp)
 {
-    register PyObject *v;
-    register Py_ssize_t i, j;
+    PyObject *v;
+    Py_ssize_t i, j;
     PyDictEntry *ep;
     Py_ssize_t mask, n;
 
@@ -1328,10 +1328,10 @@
 }
 
 static PyObject *
-dict_values(register PyDictObject *mp)
+dict_values(PyDictObject *mp)
 {
-    register PyObject *v;
-    register Py_ssize_t i, j;
+    PyObject *v;
+    Py_ssize_t i, j;
     PyDictEntry *ep;
     Py_ssize_t mask, n;
 
@@ -1362,10 +1362,10 @@
 }
 
 static PyObject *
-dict_items(register PyDictObject *mp)
+dict_items(PyDictObject *mp)
 {
-    register PyObject *v;
-    register Py_ssize_t i, j, n;
+    PyObject *v;
+    Py_ssize_t i, j, n;
     Py_ssize_t mask;
     PyObject *item, *key, *value;
     PyDictEntry *ep;
@@ -1632,8 +1632,8 @@
 int
 PyDict_Merge(PyObject *a, PyObject *b, int override)
 {
-    register PyDictObject *mp, *other;
-    register Py_ssize_t i;
+    PyDictObject *mp, *other;
+    Py_ssize_t i;
     PyDictEntry *entry;
 
     /* We accept for the argument either a concrete dictionary object,
@@ -1727,7 +1727,7 @@
 }
 
 static PyObject *
-dict_copy(register PyDictObject *mp)
+dict_copy(PyDictObject *mp)
 {
     return PyDict_Copy((PyObject*)mp);
 }
@@ -1989,7 +1989,7 @@
  }
 
 static PyObject *
-dict_contains(register PyDictObject *mp, PyObject *key)
+dict_contains(PyDictObject *mp, PyObject *key)
 {
     long hash;
     PyDictEntry *ep;
@@ -2007,7 +2007,7 @@
 }
 
 static PyObject *
-dict_has_key(register PyDictObject *mp, PyObject *key)
+dict_has_key(PyDictObject *mp, PyObject *key)
 {
     if (PyErr_WarnPy3k("dict.has_key() not supported in 3.x; "
                        "use the in operator", 1) < 0)
@@ -2016,7 +2016,7 @@
 }
 
 static PyObject *
-dict_get(register PyDictObject *mp, PyObject *args)
+dict_get(PyDictObject *mp, PyObject *args)
 {
     PyObject *key;
     PyObject *failobj = Py_None;
@@ -2045,7 +2045,7 @@
 
 
 static PyObject *
-dict_setdefault(register PyDictObject *mp, PyObject *args)
+dict_setdefault(PyDictObject *mp, PyObject *args)
 {
     PyObject *key;
     PyObject *failobj = Py_None;
@@ -2077,7 +2077,7 @@
 
 
 static PyObject *
-dict_clear(register PyDictObject *mp)
+dict_clear(PyDictObject *mp)
 {
     PyDict_Clear((PyObject *)mp);
     Py_RETURN_NONE;
@@ -2611,8 +2611,8 @@
 static PyObject *dictiter_iternextkey(dictiterobject *di)
 {
     PyObject *key;
-    register Py_ssize_t i, mask;
-    register PyDictEntry *ep;
+    Py_ssize_t i, mask;
+    PyDictEntry *ep;
     PyDictObject *d = di->di_dict;
 
     if (d == NULL)
@@ -2683,8 +2683,8 @@
 static PyObject *dictiter_iternextvalue(dictiterobject *di)
 {
     PyObject *value;
-    register Py_ssize_t i, mask;
-    register PyDictEntry *ep;
+    Py_ssize_t i, mask;
+    PyDictEntry *ep;
     PyDictObject *d = di->di_dict;
 
     if (d == NULL)
@@ -2755,8 +2755,8 @@
 static PyObject *dictiter_iternextitem(dictiterobject *di)
 {
     PyObject *key, *value, *result;
-    register Py_ssize_t i, mask;
-    register PyDictEntry *ep;
+    Py_ssize_t i, mask;
+    PyDictEntry *ep;
     PyDictObject *d = di->di_dict;
 
     if (d == NULL)
--- a/Objects/tupleobject.c	2019-08-31 14:56:04.490084341 +0200
+++ b/Objects/tupleobject.c	2019-08-31 14:59:39.844089681 +0200
@@ -46,9 +46,9 @@
 
 
 PyObject *
-PyTuple_New(register Py_ssize_t size)
+PyTuple_New(Py_ssize_t size)
 {
-    register PyTupleObject *op;
+    PyTupleObject *op;
     Py_ssize_t i;
     if (size < 0) {
         PyErr_BadInternalCall();
@@ -108,7 +108,7 @@
 }
 
 Py_ssize_t
-PyTuple_Size(register PyObject *op)
+PyTuple_Size(PyObject *op)
 {
     if (!PyTuple_Check(op)) {
         PyErr_BadInternalCall();
@@ -119,7 +119,7 @@
 }
 
 PyObject *
-PyTuple_GetItem(register PyObject *op, register Py_ssize_t i)
+PyTuple_GetItem(PyObject *op, Py_ssize_t i)
 {
     if (!PyTuple_Check(op)) {
         PyErr_BadInternalCall();
@@ -133,10 +133,10 @@
 }
 
 int
-PyTuple_SetItem(register PyObject *op, register Py_ssize_t i, PyObject *newitem)
+PyTuple_SetItem(PyObject *op, Py_ssize_t i, PyObject *newitem)
 {
-    register PyObject *olditem;
-    register PyObject **p;
+    PyObject *olditem;
+    PyObject **p;
     if (!PyTuple_Check(op) || op->ob_refcnt != 1) {
         Py_XDECREF(newitem);
         PyErr_BadInternalCall();
@@ -210,10 +210,10 @@
 /* Methods */
 
 static void
-tupledealloc(register PyTupleObject *op)
+tupledealloc(PyTupleObject *op)
 {
-    register Py_ssize_t i;
-    register Py_ssize_t len =  Py_SIZE(op);
+    Py_ssize_t i;
+    Py_ssize_t len =  Py_SIZE(op);
     PyObject_GC_UnTrack(op);
     Py_TRASHCAN_SAFE_BEGIN(op)
     if (len > 0) {
@@ -338,9 +338,9 @@
 static long
 tuplehash(PyTupleObject *v)
 {
-    register long x, y;
-    register Py_ssize_t len = Py_SIZE(v);
-    register PyObject **p;
+    long x, y;
+    Py_ssize_t len = Py_SIZE(v);
+    PyObject **p;
     long mult = 1000003L;
     x = 0x345678L;
     p = v->ob_item;
@@ -377,7 +377,7 @@
 }
 
 static PyObject *
-tupleitem(register PyTupleObject *a, register Py_ssize_t i)
+tupleitem(PyTupleObject *a, Py_ssize_t i)
 {
     if (i < 0 || i >= Py_SIZE(a)) {
         PyErr_SetString(PyExc_IndexError, "tuple index out of range");
@@ -388,12 +388,12 @@
 }
 
 static PyObject *
-tupleslice(register PyTupleObject *a, register Py_ssize_t ilow,
-           register Py_ssize_t ihigh)
+tupleslice(PyTupleObject *a, Py_ssize_t ilow,
+           Py_ssize_t ihigh)
 {
-    register PyTupleObject *np;
+    PyTupleObject *np;
     PyObject **src, **dest;
-    register Py_ssize_t i;
+    Py_ssize_t i;
     Py_ssize_t len;
     if (ilow < 0)
         ilow = 0;
@@ -430,10 +430,10 @@
 }
 
 static PyObject *
-tupleconcat(register PyTupleObject *a, register PyObject *bb)
+tupleconcat(PyTupleObject *a, PyObject *bb)
 {
-    register Py_ssize_t size;
-    register Py_ssize_t i;
+    Py_ssize_t size;
+    Py_ssize_t i;
     PyObject **src, **dest;
     PyTupleObject *np;
     if (!PyTuple_Check(bb)) {
@@ -833,8 +833,8 @@
 int
 _PyTuple_Resize(PyObject **pv, Py_ssize_t newsize)
 {
-    register PyTupleObject *v;
-    register PyTupleObject *sv;
+    PyTupleObject *v;
+    PyTupleObject *sv;
     Py_ssize_t i;
     Py_ssize_t oldsize;
 
--- a/Objects/stringobject.c	2019-08-31 14:56:04.491084341 +0200
+++ b/Objects/stringobject.c	2019-08-31 15:00:24.843090797 +0200
@@ -56,7 +56,7 @@
 PyObject *
 PyString_FromStringAndSize(const char *str, Py_ssize_t size)
 {
-    register PyStringObject *op;
+    PyStringObject *op;
     if (size < 0) {
         PyErr_SetString(PyExc_SystemError,
             "Negative size passed to PyString_FromStringAndSize");
@@ -114,8 +114,8 @@
 PyObject *
 PyString_FromString(const char *str)
 {
-    register size_t size;
-    register PyStringObject *op;
+    size_t size;
+    PyStringObject *op;
 
     assert(str != NULL);
     size = strlen(str);
@@ -772,7 +772,7 @@
 /* object api */
 
 static Py_ssize_t
-string_getsize(register PyObject *op)
+string_getsize(PyObject *op)
 {
     char *s;
     Py_ssize_t len;
@@ -782,7 +782,7 @@
 }
 
 static /*const*/ char *
-string_getbuffer(register PyObject *op)
+string_getbuffer(PyObject *op)
 {
     char *s;
     Py_ssize_t len;
@@ -792,7 +792,7 @@
 }
 
 Py_ssize_t
-PyString_Size(register PyObject *op)
+PyString_Size(PyObject *op)
 {
     if (!PyString_Check(op))
         return string_getsize(op);
@@ -800,7 +800,7 @@
 }
 
 /*const*/ char *
-PyString_AsString(register PyObject *op)
+PyString_AsString(PyObject *op)
 {
     if (!PyString_Check(op))
         return string_getbuffer(op);
@@ -808,9 +808,9 @@
 }
 
 int
-PyString_AsStringAndSize(register PyObject *obj,
-                         register char **s,
-                         register Py_ssize_t *len)
+PyString_AsStringAndSize(PyObject *obj,
+                         char **s,
+                         Py_ssize_t *len)
 {
     if (s == NULL) {
         PyErr_BadInternalCall();
@@ -937,7 +937,7 @@
 PyObject *
 PyString_Repr(PyObject *obj, int smartquotes)
 {
-    register PyStringObject* op = (PyStringObject*) obj;
+    PyStringObject* op = (PyStringObject*) obj;
     size_t newsize;
     PyObject *v;
     if (Py_SIZE(op) > (PY_SSIZE_T_MAX - 2)/4) {
@@ -951,9 +951,9 @@
         return NULL;
     }
     else {
-        register Py_ssize_t i;
-        register char c;
-        register char *p;
+        Py_ssize_t i;
+        char c;
+        char *p;
         int quote;
 
         /* figure out which quote to use; single is preferred */
@@ -1025,10 +1025,10 @@
 }
 
 static PyObject *
-string_concat(register PyStringObject *a, register PyObject *bb)
+string_concat(PyStringObject *a, PyObject *bb)
 {
-    register Py_ssize_t size;
-    register PyStringObject *op;
+    Py_ssize_t size;
+    PyStringObject *op;
     if (!PyString_Check(bb)) {
 #ifdef Py_USING_UNICODE
         if (PyUnicode_Check(bb))
@@ -1084,12 +1084,12 @@
 }
 
 static PyObject *
-string_repeat(register PyStringObject *a, register Py_ssize_t n)
+string_repeat(PyStringObject *a, Py_ssize_t n)
 {
-    register Py_ssize_t i;
-    register Py_ssize_t j;
-    register Py_ssize_t size;
-    register PyStringObject *op;
+    Py_ssize_t i;
+    Py_ssize_t j;
+    Py_ssize_t size;
+    PyStringObject *op;
     size_t nbytes;
     if (n < 0)
         n = 0;
@@ -1139,8 +1139,8 @@
 /* String slice a[i:j] consists of characters a[i] ... a[j-1] */
 
 static PyObject *
-string_slice(register PyStringObject *a, register Py_ssize_t i,
-             register Py_ssize_t j)
+string_slice(PyStringObject *a, Py_ssize_t i,
+             Py_ssize_t j)
      /* j -- may be negative! */
 {
     if (i < 0)
@@ -1179,7 +1179,7 @@
 }
 
 static PyObject *
-string_item(PyStringObject *a, register Py_ssize_t i)
+string_item(PyStringObject *a, Py_ssize_t i)
 {
     char pchar;
     PyObject *v;
@@ -1274,9 +1274,9 @@
 static long
 string_hash(PyStringObject *a)
 {
-    register Py_ssize_t len;
-    register unsigned char *p;
-    register long x;
+    Py_ssize_t len;
+    unsigned char *p;
+    long x;
 
 #ifdef Py_DEBUG
     assert(_Py_HashSecret_Initialized);
@@ -1987,14 +1987,10 @@
 \n\
 Return a copy of the string S converted to lowercase.");
 
-static int
-tolower_C_locale(int c)
-{
-    if (c >= 'A' && c <= 'Z')
-        return c + 0x20;
-    else
-        return c;
-}
+/* _tolower and _toupper are defined by SUSv2, but they're not ISO C */
+#ifndef _tolower
+#define _tolower tolower
+#endif
 
 static PyObject *
 string_lower(PyStringObject *self)
@@ -2014,7 +2010,7 @@
     for (i = 0; i < n; i++) {
         int c = Py_CHARMASK(s[i]);
         if (isupper(c))
-            s[i] = tolower_C_locale(c);
+            s[i] = _tolower(c);
     }
 
     return newobj;
@@ -2025,14 +2021,9 @@
 \n\
 Return a copy of the string S converted to uppercase.");
 
-static int
-toupper_C_locale(int c)
-{
-    if (c >= 'a' && c <= 'z')
-        return c - 0x20;
-    else
-        return c;
-}
+#ifndef _toupper
+#define _toupper toupper
+#endif
 
 static PyObject *
 string_upper(PyStringObject *self)
@@ -2052,7 +2043,7 @@
     for (i = 0; i < n; i++) {
         int c = Py_CHARMASK(s[i]);
         if (islower(c))
-            s[i] = toupper_C_locale(c);
+            s[i] = _toupper(c);
     }
 
     return newobj;
@@ -2080,11 +2071,11 @@
         int c = Py_CHARMASK(*s++);
         if (islower(c)) {
             if (!previous_is_cased)
-                c = toupper_C_locale(c);
+                c = toupper(c);
             previous_is_cased = 1;
         } else if (isupper(c)) {
             if (previous_is_cased)
-                c = tolower_C_locale(c);
+                c = tolower(c);
             previous_is_cased = 1;
         } else
             previous_is_cased = 0;
@@ -2113,7 +2104,7 @@
     if (0 < n) {
         int c = Py_CHARMASK(*s++);
         if (islower(c))
-            *s_new = toupper_C_locale(c);
+            *s_new = toupper(c);
         else
             *s_new = c;
         s_new++;
@@ -2121,7 +2112,7 @@
     for (i = 1; i < n; i++) {
         int c = Py_CHARMASK(*s++);
         if (isupper(c))
-            *s_new = tolower_C_locale(c);
+            *s_new = tolower(c);
         else
             *s_new = c;
         s_new++;
@@ -2192,10 +2183,10 @@
     for (i = 0; i < n; i++) {
         int c = Py_CHARMASK(*s++);
         if (islower(c)) {
-            *s_new = toupper_C_locale(c);
+            *s_new = toupper(c);
         }
         else if (isupper(c)) {
-            *s_new = tolower_C_locale(c);
+            *s_new = tolower(c);
         }
         else
             *s_new = c;
@@ -2218,9 +2209,9 @@
 static PyObject *
 string_translate(PyStringObject *self, PyObject *args)
 {
-    register char *input, *output;
+    char *input, *output;
     const char *table;
-    register Py_ssize_t i, c, changed = 0;
+    Py_ssize_t i, c, changed = 0;
     PyObject *input_obj = (PyObject*)self;
     const char *output_start, *del_table=NULL;
     Py_ssize_t inlen, tablen, dellen = 0;
@@ -2229,7 +2220,7 @@
     PyObject *tableobj, *delobj = NULL;
 
     if (!PyArg_UnpackTuple(args, "translate", 1, 2,
-                          &tableobj, &delobj))
+                 &tableobj, &delobj))
         return NULL;
 
     if (PyString_Check(tableobj)) {
@@ -3330,18 +3321,18 @@
 static PyObject*
 string_isspace(PyStringObject *self)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) PyString_AS_STRING(self);
-    register const unsigned char *e;
+    const unsigned char *e;
 
     /* Shortcut for single character strings */
     if (PyString_GET_SIZE(self) == 1 &&
         isspace(*p))
         return PyBool_FromLong(1);
 
-    /* Special case for empty strings */
+    /* Special case for empty strings */
     if (PyString_GET_SIZE(self) == 0)
-        return PyBool_FromLong(0);
+        return PyBool_FromLong(0);
 
     e = p + PyString_GET_SIZE(self);
     for (; p < e; p++) {
@@ -3361,18 +3352,18 @@
 static PyObject*
 string_isalpha(PyStringObject *self)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) PyString_AS_STRING(self);
-    register const unsigned char *e;
+    const unsigned char *e;
 
     /* Shortcut for single character strings */
     if (PyString_GET_SIZE(self) == 1 &&
         isalpha(*p))
         return PyBool_FromLong(1);
 
-    /* Special case for empty strings */
+    /* Special case for empty strings */
     if (PyString_GET_SIZE(self) == 0)
-        return PyBool_FromLong(0);
+        return PyBool_FromLong(0);
 
     e = p + PyString_GET_SIZE(self);
     for (; p < e; p++) {
@@ -3392,18 +3383,18 @@
 static PyObject*
 string_isalnum(PyStringObject *self)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) PyString_AS_STRING(self);
-    register const unsigned char *e;
+    const unsigned char *e;
 
     /* Shortcut for single character strings */
     if (PyString_GET_SIZE(self) == 1 &&
         isalnum(*p))
         return PyBool_FromLong(1);
 
-    /* Special case for empty strings */
+    /* Special case for empty strings */
     if (PyString_GET_SIZE(self) == 0)
-        return PyBool_FromLong(0);
+        return PyBool_FromLong(0);
 
     e = p + PyString_GET_SIZE(self);
     for (; p < e; p++) {
@@ -3423,18 +3414,18 @@
 static PyObject*
 string_isdigit(PyStringObject *self)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) PyString_AS_STRING(self);
-    register const unsigned char *e;
+    const unsigned char *e;
 
     /* Shortcut for single character strings */
     if (PyString_GET_SIZE(self) == 1 &&
         isdigit(*p))
         return PyBool_FromLong(1);
 
-    /* Special case for empty strings */
+    /* Special case for empty strings */
     if (PyString_GET_SIZE(self) == 0)
-        return PyBool_FromLong(0);
+        return PyBool_FromLong(0);
 
     e = p + PyString_GET_SIZE(self);
     for (; p < e; p++) {
@@ -3454,18 +3445,18 @@
 static PyObject*
 string_islower(PyStringObject *self)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) PyString_AS_STRING(self);
-    register const unsigned char *e;
+    const unsigned char *e;
     int cased;
 
     /* Shortcut for single character strings */
     if (PyString_GET_SIZE(self) == 1)
         return PyBool_FromLong(islower(*p) != 0);
 
-    /* Special case for empty strings */
+    /* Special case for empty strings */
     if (PyString_GET_SIZE(self) == 0)
-        return PyBool_FromLong(0);
+        return PyBool_FromLong(0);
 
     e = p + PyString_GET_SIZE(self);
     cased = 0;
@@ -3488,18 +3479,18 @@
 static PyObject*
 string_isupper(PyStringObject *self)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) PyString_AS_STRING(self);
-    register const unsigned char *e;
+    const unsigned char *e;
     int cased;
 
     /* Shortcut for single character strings */
     if (PyString_GET_SIZE(self) == 1)
         return PyBool_FromLong(isupper(*p) != 0);
 
-    /* Special case for empty strings */
+    /* Special case for empty strings */
     if (PyString_GET_SIZE(self) == 0)
-        return PyBool_FromLong(0);
+        return PyBool_FromLong(0);
 
     e = p + PyString_GET_SIZE(self);
     cased = 0;
@@ -3524,24 +3515,24 @@
 static PyObject*
 string_istitle(PyStringObject *self, PyObject *uncased)
 {
-    register const unsigned char *p
+    const unsigned char *p
         = (unsigned char *) PyString_AS_STRING(self);
-    register const unsigned char *e;
+    const unsigned char *e;
     int cased, previous_is_cased;
 
     /* Shortcut for single character strings */
     if (PyString_GET_SIZE(self) == 1)
         return PyBool_FromLong(isupper(*p) != 0);
 
-    /* Special case for empty strings */
+    /* Special case for empty strings */
     if (PyString_GET_SIZE(self) == 0)
-        return PyBool_FromLong(0);
+        return PyBool_FromLong(0);
 
     e = p + PyString_GET_SIZE(self);
     cased = 0;
     previous_is_cased = 0;
     for (; p < e; p++) {
-        register const unsigned char ch = *p;
+        const unsigned char ch = *p;
 
         if (isupper(ch)) {
             if (previous_is_cased)
@@ -3550,7 +3541,7 @@
             cased = 1;
         }
         else if (islower(ch)) {
-            if (!previous_is_cased)
+            if (!previous_is_cased)
                 return PyBool_FromLong(0);
             previous_is_cased = 1;
             cased = 1;
@@ -3867,21 +3858,21 @@
 };
 
 void
-PyString_Concat(register PyObject **pv, register PyObject *w)
+PyString_Concat(PyObject **pv, PyObject *w)
 {
-    register PyObject *v;
+    PyObject *v;
     if (*pv == NULL)
         return;
     if (w == NULL || !PyString_Check(*pv)) {
         Py_CLEAR(*pv);
         return;
     }
-    v = string_concat((PyStringObject *) *pv, w);
+    v = string_concat((PyStringObject *) *pv, w);
     Py_SETREF(*pv, v);
 }
 
 void
-PyString_ConcatAndDel(register PyObject **pv, register PyObject *w)
+PyString_ConcatAndDel(PyObject **pv, PyObject *w)
 {
     PyString_Concat(pv, w);
     Py_XDECREF(w);
@@ -3890,7 +3881,7 @@
 
 /* The following function breaks the notion that strings are immutable:
    it changes the size of a string.  We get away with this only if there
-   is only one module referencing the object.  You can also think of it
+   is only one module referencing the object.  You can also think of it
    as creating a new string object and destroying the old one, only
    more efficiently.  In any case, don't use this if the string may
    already be known to some other part of the code...
@@ -3905,8 +3896,8 @@
 int
 _PyString_Resize(PyObject **pv, Py_ssize_t newsize)
 {
-    register PyObject *v;
-    register PyStringObject *sv;
+    PyObject *v;
+    PyStringObject *sv;
     v = *pv;
     if (!PyString_Check(v) || newsize < 0) {
         *pv = 0;
@@ -3914,8 +3905,8 @@
         PyErr_BadInternalCall();
         return -1;
     }
-    if (Py_SIZE(v) == 0) {
-        if (newsize == 0) {
+    if (Py_SIZE(v) == 0) {
+        if (newsize == 0) {
             return 0;
         }
         *pv = PyString_FromStringAndSize(NULL, newsize);
@@ -4776,7 +4767,7 @@
 void
 PyString_InternInPlace(PyObject **p)
 {
-    register PyStringObject *s = (PyStringObject *)(*p);
+    PyStringObject *s = (PyStringObject *)(*p);
     PyObject *t;
     if (s == NULL || !PyString_Check(s))
         Py_FatalError("PyString_InternInPlace: strings only please!");
@@ -4785,7 +4776,7 @@
     if (!PyString_CheckExact(s))
         return;
     if (PyString_CHECK_INTERNED(s))
-        return;
+        return;
     if (interned == NULL) {
         interned = PyDict_New();
         if (interned == NULL) {
--- a/Objects/floatobject.c	2019-08-31 14:56:04.491084341 +0200
+++ b/Objects/floatobject.c	2019-08-31 15:00:11.329090462 +0200
@@ -140,7 +140,7 @@
 PyObject *
 PyFloat_FromDouble(double fval)
 {
-    register PyFloatObject *op;
+    PyFloatObject *op;
     if (free_list == NULL) {
         if ((free_list = fill_free_list()) == NULL)
             return NULL;
@@ -309,7 +309,7 @@
 static int
 convert_to_double(PyObject **v, double *dbl)
 {
-    register PyObject *obj = *v;
+    PyObject *obj = *v;
 
     if (PyInt_Check(obj)) {
         *dbl = (double)PyInt_AS_LONG(obj);
@@ -1858,18 +1858,9 @@
 /* this is for the benefit of the pack/unpack routines below */
 
 typedef enum {
-    unknown_format,
-    ieee_big_endian_format,
-    ieee_little_endian_format,
-    ieee_arm_mixed_endian_format
+    unknown_format, ieee_big_endian_format, ieee_little_endian_format
 } float_format_type;
 
-/* byte order of a C double for each of the recognised IEEE formats */
-
-static const unsigned char BIG_ENDIAN_BYTEORDER[8] = {7,6,5,4,3,2,1,0};
-static const unsigned char LITTLE_ENDIAN_BYTEORDER[8] = {0,1,2,3,4,5,6,7};
-static const unsigned char ARM_MIXED_ENDIAN_BYTEORDER[8] = {4,5,6,7,0,1,2,3};
-
 static float_format_type double_format, float_format;
 static float_format_type detected_double_format, detected_float_format;
 
@@ -1906,8 +1897,6 @@
         return PyString_FromString("IEEE, little-endian");
     case ieee_big_endian_format:
         return PyString_FromString("IEEE, big-endian");
-    case ieee_arm_mixed_endian_format:
-        return PyString_FromString("IEEE, ARM mixed-endian");
     default:
         Py_FatalError("insane float_format or double_format");
         return NULL;
@@ -1921,9 +1910,8 @@
 "used in Python's test suite.\n"
 "\n"
 "typestr must be 'double' or 'float'.  This function returns whichever of\n"
-"'unknown', 'IEEE, big-endian', 'IEEE, little-endian' or\n"
-"'IEEE, ARM mixed-endian' best describes the format of floating-point\n"
-"numbers used by the C type named by typestr.");
+"'unknown', 'IEEE, big-endian' or 'IEEE, little-endian' best describes the\n"
+"format of floating point numbers used by the C type named by typestr.");
 
 static PyObject *
 float_setformat(PyTypeObject *v, PyObject* args)
@@ -1961,15 +1949,11 @@
     else if (strcmp(format, "IEEE, big-endian") == 0) {
         f = ieee_big_endian_format;
     }
-    else if (strcmp(format, "IEEE, ARM mixed-endian") == 0 &&
-             p == &double_format) {
-        f = ieee_arm_mixed_endian_format;
-    }
     else {
         PyErr_SetString(PyExc_ValueError,
                         "__setformat__() argument 2 must be "
-                        "'unknown', 'IEEE, little-endian', "
-                        "'IEEE, big-endian' or 'IEEE, ARM mixed-endian'");
+                        "'unknown', 'IEEE, little-endian' or "
+                        "'IEEE, big-endian'");
         return NULL;
 
     }
@@ -1992,10 +1976,8 @@
 "used in Python's test suite.\n"
 "\n"
 "typestr must be 'double' or 'float'.  fmt must be one of 'unknown',\n"
-"'IEEE, big-endian', 'IEEE, little-endian' or 'IEEE, ARM mixed-endian'\n"
-"and in addition can only be one of the last three if it appears to\n"
-"match the underlying C reality.  Note that the ARM mixed-endian\n"
-"format can only be set for the 'double' type, not for 'float'.\n"
+"'IEEE, big-endian' or 'IEEE, little-endian', and in addition can only be\n"
+"one of the latter two if it appears to match the underlying C reality.\n"
 "\n"
 "Override the automatic determination of C-level floating point type.\n"
 "This affects how floats are converted to and from binary strings.");
@@ -2190,11 +2172,7 @@
        Note that if we're on some whacked-out platform which uses
        IEEE formats but isn't strictly little-endian or big-
        endian, we will fall back to the portable shifts & masks
-       method.
-
-       Addendum: We also attempt to detect the mixed-endian IEEE format
-       used by the ARM old ABI (OABI) and also used by the FPA
-       floating-point unit on some older ARM processors. */
+       method. */
 
 #if SIZEOF_DOUBLE == 8
     {
@@ -2203,8 +2181,6 @@
             detected_double_format = ieee_big_endian_format;
         else if (memcmp(&x, "\x05\x04\x03\x02\x01\xff\x3f\x43", 8) == 0)
             detected_double_format = ieee_little_endian_format;
-        else if (memcmp(&x, "\x01\xff\x3f\x43\x05\x04\x03\x02", 8) == 0)
-            detected_double_format = ieee_arm_mixed_endian_format;
         else
             detected_double_format = unknown_format;
     }
@@ -2550,31 +2526,17 @@
     }
     else {
         const char *s = (char*)&x;
-        int i;
-        const unsigned char *byteorder;
+        int i, incr = 1;
 
-        switch (double_format) {
-        case ieee_little_endian_format:
-            byteorder = LITTLE_ENDIAN_BYTEORDER;
-            break;
-        case ieee_big_endian_format:
-            byteorder = BIG_ENDIAN_BYTEORDER;
-            break;
-        case ieee_arm_mixed_endian_format:
-            byteorder = ARM_MIXED_ENDIAN_BYTEORDER;
-            break;
-        default:
-            Py_FatalError("insane float_format or double_format");
-            return -1;
+        if ((double_format == ieee_little_endian_format && !le)
+            || (double_format == ieee_big_endian_format && le)) {
+            p += 7;
+            incr = -1;
         }
 
-        if (le) {
-            for (i = 0; i < 8; i++)
-                p[byteorder[i]] = *s++;
-        }
-        else {
-            for (i = 0; i < 8; i++)
-                p[7-byteorder[i]] = *s++;
+        for (i = 0; i < 8; i++) {
+            *p = *s++;
+            p += incr;
         }
         return 0;
     }
@@ -2733,33 +2695,22 @@
     }
     else {
         double x;
-        char *s = (char*)&x;
-        const unsigned char *byteorder;
-        int i;
-
-        switch (double_format) {
-        case ieee_little_endian_format:
-            byteorder = LITTLE_ENDIAN_BYTEORDER;
-            break;
-        case ieee_big_endian_format:
-            byteorder = BIG_ENDIAN_BYTEORDER;
-            break;
-        case ieee_arm_mixed_endian_format:
-            byteorder = ARM_MIXED_ENDIAN_BYTEORDER;
-            break;
-        default:
-            Py_FatalError("insane float_format or double_format");
-            return -1.0;
-        }
 
-        if (le) {
-            for (i=0; i<8; i++)
-                *s++ = p[byteorder[i]];
+        if ((double_format == ieee_little_endian_format && !le)
+            || (double_format == ieee_big_endian_format && le)) {
+            char buf[8];
+            char *d = &buf[7];
+            int i;
+
+            for (i = 0; i < 8; i++) {
+                *d-- = *p++;
+            }
+            memcpy(&x, buf, 8);
         }
         else {
-            for (i=0; i<8; i++)
-                *s++ = p[7-byteorder[i]];
+            memcpy(&x, p, 8);
         }
+
         return x;
     }
 }
--- a/Parser/tokenizer.c	2019-08-31 14:56:04.493084341 +0200
+++ b/Parser/tokenizer.c	2019-08-31 14:59:39.842089681 +0200
@@ -854,7 +854,7 @@
 /* Get next char, updating state; error code goes into tok->done */
 
 static int
-tok_nextc(register struct tok_state *tok)
+tok_nextc(struct tok_state *tok)
 {
     for (;;) {
         if (tok->cur != tok->inp) {
@@ -1027,7 +1027,7 @@
 /* Back-up one character */
 
 static void
-tok_backup(register struct tok_state *tok, register int c)
+tok_backup(struct tok_state *tok, int c)
 {
     if (c != EOF) {
         if (--tok->cur < tok->buf)
@@ -1213,9 +1213,9 @@
 /* Get next token, after space stripping etc. */
 
 static int
-tok_get(register struct tok_state *tok, char **p_start, char **p_end)
+tok_get(struct tok_state *tok, char **p_start, char **p_end)
 {
-    register int c;
+    int c;
     int blankline;
 
     *p_start = *p_end = NULL;
@@ -1225,8 +1225,8 @@
 
     /* Get indentation level */
     if (tok->atbol) {
-        register int col = 0;
-        register int altcol = 0;
+        int col = 0;
+        int altcol = 0;
         tok->atbol = 0;
         for (;;) {
             c = tok_nextc(tok);
--- a/Parser/grammar1.c	2019-08-31 14:56:04.493084341 +0200
+++ b/Parser/grammar1.c	2019-08-31 14:59:39.842089681 +0200
@@ -9,9 +9,9 @@
 /* Return the DFA for the given type */
 
 dfa *
-PyGrammar_FindDFA(grammar *g, register int type)
+PyGrammar_FindDFA(grammar *g, int type)
 {
-    register dfa *d;
+    dfa *d;
 #if 1
     /* Massive speed-up */
     d = &g->g_dfa[type - NT_OFFSET];
@@ -19,7 +19,7 @@
     return d;
 #else
     /* Old, slow version */
-    register int i;
+    int i;
 
     for (i = g->g_ndfas, d = g->g_dfa; --i >= 0; d++) {
         if (d->d_type == type)
--- a/Parser/parser.c	2019-08-31 14:56:04.494084341 +0200
+++ b/Parser/parser.c	2019-08-31 14:59:39.843089681 +0200
@@ -35,9 +35,9 @@
 #define s_empty(s) ((s)->s_top == &(s)->s_base[MAXSTACK])
 
 static int
-s_push(register stack *s, dfa *d, node *parent)
+s_push(stack *s, dfa *d, node *parent)
 {
-    register stackentry *top;
+    stackentry *top;
     if (s->s_top == s->s_base) {
         fprintf(stderr, "s_push: parser stack overflow\n");
         return E_NOMEM;
@@ -52,7 +52,7 @@
 #ifdef Py_DEBUG
 
 static void
-s_pop(register stack *s)
+s_pop(stack *s)
 {
     if (s_empty(s))
         Py_FatalError("s_pop: parser stack underflow -- FATAL");
@@ -105,7 +105,7 @@
 /* PARSER STACK OPERATIONS */
 
 static int
-shift(register stack *s, int type, char *str, int newstate, int lineno, int col_offset)
+shift(stack *s, int type, char *str, int newstate, int lineno, int col_offset)
 {
     int err;
     assert(!s_empty(s));
@@ -117,10 +117,10 @@
 }
 
 static int
-push(register stack *s, int type, dfa *d, int newstate, int lineno, int col_offset)
+push(stack *s, int type, dfa *d, int newstate, int lineno, int col_offset)
 {
     int err;
-    register node *n;
+    node *n;
     n = s->s_top->s_parent;
     assert(!s_empty(s));
     err = PyNode_AddChild(n, type, (char *)NULL, lineno, col_offset);
@@ -137,12 +137,12 @@
 classify(parser_state *ps, int type, char *str)
 {
     grammar *g = ps->p_grammar;
-    register int n = g->g_ll.ll_nlabels;
+    int n = g->g_ll.ll_nlabels;
 
     if (type == NAME) {
-        register char *s = str;
-        register label *l = g->g_ll.ll_label;
-        register int i;
+        char *s = str;
+        label *l = g->g_ll.ll_label;
+        int i;
         for (i = n; i > 0; i--, l++) {
             if (l->lb_type != NAME || l->lb_str == NULL ||
                 l->lb_str[0] != s[0] ||
@@ -160,8 +160,8 @@
     }
 
     {
-        register label *l = g->g_ll.ll_label;
-        register int i;
+        label *l = g->g_ll.ll_label;
+        int i;
         for (i = n; i > 0; i--, l++) {
             if (l->lb_type == type && l->lb_str == NULL) {
                 D(printf("It's a token we know\n"));
@@ -217,10 +217,10 @@
 #endif /* future keyword */
 
 int
-PyParser_AddToken(register parser_state *ps, register int type, char *str,
+PyParser_AddToken(parser_state *ps, int type, char *str,
                   int lineno, int col_offset, int *expected_ret)
 {
-    register int ilabel;
+    int ilabel;
     int err;
 
     D(printf("Token %s/'%s' ... ", _PyParser_TokenNames[type], str));
@@ -233,15 +233,15 @@
     /* Loop until the token is shifted or an error occurred */
     for (;;) {
         /* Fetch the current dfa and state */
-        register dfa *d = ps->p_stack.s_top->s_dfa;
-        register state *s = &d->d_state[ps->p_stack.s_top->s_state];
+        dfa *d = ps->p_stack.s_top->s_dfa;
+        state *s = &d->d_state[ps->p_stack.s_top->s_state];
 
         D(printf(" DFA '%s', state %d:",
             d->d_name, ps->p_stack.s_top->s_state));
 
         /* Check accelerator */
         if (s->s_lower <= ilabel && ilabel < s->s_upper) {
-            register int x = s->s_accel[ilabel - s->s_lower];
+            int x = s->s_accel[ilabel - s->s_lower];
             if (x != -1) {
                 if (x & (1<<7)) {
                     /* Push non-terminal */
--- a/Modules/dbmmodule.c	2019-08-31 14:56:04.495084341 +0200
+++ b/Modules/dbmmodule.c	2019-08-31 14:59:39.844089681 +0200
@@ -66,7 +66,7 @@
 /* Methods */
 
 static void
-dbm_dealloc(register dbmobject *dp)
+dbm_dealloc(dbmobject *dp)
 {
     if ( dp->di_dbm )
         dbm_close(dp->di_dbm);
@@ -94,7 +94,7 @@
 }
 
 static PyObject *
-dbm_subscript(dbmobject *dp, register PyObject *key)
+dbm_subscript(dbmobject *dp, PyObject *key)
 {
     datum drec, krec;
     int tmp_size;
@@ -165,7 +165,7 @@
 }
 
 static int
-dbm_contains(register dbmobject *dp, PyObject *v)
+dbm_contains(dbmobject *dp, PyObject *v)
 {
     datum key, val;
     char *ptr;
@@ -205,7 +205,7 @@
 };
 
 static PyObject *
-dbm__close(register dbmobject *dp, PyObject *unused)
+dbm__close(dbmobject *dp, PyObject *unused)
 {
     if (dp->di_dbm)
         dbm_close(dp->di_dbm);
@@ -215,9 +215,9 @@
 }
 
 static PyObject *
-dbm_keys(register dbmobject *dp, PyObject *unused)
+dbm_keys(dbmobject *dp, PyObject *unused)
 {
-    register PyObject *v, *item;
+    PyObject *v, *item;
     datum key;
     int err;
 
@@ -243,7 +243,7 @@
 }
 
 static PyObject *
-dbm_has_key(register dbmobject *dp, PyObject *args)
+dbm_has_key(dbmobject *dp, PyObject *args)
 {
     char *tmp_ptr;
     datum key, val;
@@ -259,7 +259,7 @@
 }
 
 static PyObject *
-dbm_get(register dbmobject *dp, PyObject *args)
+dbm_get(dbmobject *dp, PyObject *args)
 {
     datum key, val;
     PyObject *defvalue = Py_None;
@@ -282,7 +282,7 @@
 }
 
 static PyObject *
-dbm_setdefault(register dbmobject *dp, PyObject *args)
+dbm_setdefault(dbmobject *dp, PyObject *args)
 {
     datum key, val;
     PyObject *defvalue = NULL;
--- a/Modules/arraymodule.c	2019-08-31 14:56:04.496084341 +0200
+++ b/Modules/arraymodule.c	2019-08-31 14:59:39.845089681 +0200
@@ -452,7 +452,7 @@
 static PyObject *
 getarrayitem(PyObject *op, Py_ssize_t i)
 {
-    register arrayobject *ap;
+    arrayobject *ap;
     assert(array_Check(op));
     ap = (arrayobject *)op;
     assert(i>=0 && i<Py_SIZE(ap));
@@ -1181,8 +1181,8 @@
 static PyObject *
 array_reverse(arrayobject *self, PyObject *unused)
 {
-    register Py_ssize_t itemsize = self->ob_descr->itemsize;
-    register char *p, *q;
+    Py_ssize_t itemsize = self->ob_descr->itemsize;
+    char *p, *q;
     /* little buffer to hold items while swapping */
     char tmp[256];      /* 8 is probably enough -- but why skimp */
     assert((size_t)itemsize <= sizeof(tmp));
--- a/Modules/_ctypes/_ctypes.c	2019-08-31 14:56:04.497084341 +0200
+++ b/Modules/_ctypes/_ctypes.c	2019-08-31 14:59:39.856089681 +0200
@@ -5869,7 +5869,7 @@
 #if (PY_VERSION_HEX < 0x02040000)
 #ifdef HAVE_WCHAR_H
 
-PyObject *My_PyUnicode_FromWideChar(register const wchar_t *w,
+PyObject *My_PyUnicode_FromWideChar(const wchar_t *w,
                                     Py_ssize_t size)
 {
     PyUnicodeObject *unicode;
@@ -5888,8 +5888,8 @@
     memcpy(unicode->str, w, size * sizeof(wchar_t));
 #else
     {
-        register Py_UNICODE *u;
-        register int i;
+        Py_UNICODE *u;
+        int i;
         u = PyUnicode_AS_UNICODE(unicode);
         /* In Python, the following line has a one-off error */
         for (i = size; i > 0; i--)
@@ -5901,7 +5901,7 @@
 }
 
 Py_ssize_t My_PyUnicode_AsWideChar(PyUnicodeObject *unicode,
-                            register wchar_t *w,
+                            wchar_t *w,
                             Py_ssize_t size)
 {
     if (unicode == NULL) {
@@ -5914,8 +5914,8 @@
     memcpy(w, unicode->str, size * sizeof(wchar_t));
 #else
     {
-        register Py_UNICODE *u;
-        register int i;
+        Py_UNICODE *u;
+        int i;
         u = PyUnicode_AS_UNICODE(unicode);
         /* In Python, the following line has a one-off error */
         for (i = size; i > 0; i--)
--- a/Modules/stropmodule.c	2019-08-31 14:56:04.499084341 +0200
+++ b/Modules/stropmodule.c	2019-08-31 14:59:39.845089681 +0200
@@ -946,7 +946,7 @@
 static PyObject *
 strop_translate(PyObject *self, PyObject *args)
 {
-    register char *input, *table, *output;
+    char *input, *table, *output;
     Py_ssize_t i;
     int c, changed = 0;
     PyObject *input_obj;
@@ -1027,7 +1027,7 @@
 static Py_ssize_t
 mymemfind(const char *mem, Py_ssize_t len, const char *pat, Py_ssize_t pat_len)
 {
-    register Py_ssize_t ii;
+    Py_ssize_t ii;
 
     /* pattern can not occur in the last pat_len-1 chars */
     len -= pat_len;
@@ -1052,7 +1052,7 @@
 static Py_ssize_t
 mymemcnt(const char *mem, Py_ssize_t len, const char *pat, Py_ssize_t pat_len)
 {
-    register Py_ssize_t offset = 0;
+    Py_ssize_t offset = 0;
     Py_ssize_t nfound = 0;
 
     while (len >= 0) {
--- a/Modules/cgensupport.c	2019-08-31 14:56:04.500084342 +0200
+++ b/Modules/cgensupport.c	2019-08-31 14:59:39.845089681 +0200
@@ -11,7 +11,7 @@
    one argument. */
 
 int
-PyArg_GetObject(register PyObject *args, int nargs, int i, PyObject **p_arg)
+PyArg_GetObject(PyObject *args, int nargs, int i, PyObject **p_arg)
 {
     if (nargs != 1) {
         if (args == NULL || !PyTuple_Check(args) ||
@@ -31,7 +31,7 @@
 }
 
 int
-PyArg_GetLong(register PyObject *args, int nargs, int i, long *p_arg)
+PyArg_GetLong(PyObject *args, int nargs, int i, long *p_arg)
 {
     if (nargs != 1) {
         if (args == NULL || !PyTuple_Check(args) ||
@@ -49,7 +49,7 @@
 }
 
 int
-PyArg_GetShort(register PyObject *args, int nargs, int i, short *p_arg)
+PyArg_GetShort(PyObject *args, int nargs, int i, short *p_arg)
 {
     long x;
     if (!PyArg_GetLong(args, nargs, i, &x))
@@ -59,7 +59,7 @@
 }
 
 static int
-extractdouble(register PyObject *v, double *p_arg)
+extractdouble(PyObject *v, double *p_arg)
 {
     if (v == NULL) {
         /* Fall through to error return at end of function */
@@ -80,7 +80,7 @@
 }
 
 static int
-extractfloat(register PyObject *v, float *p_arg)
+extractfloat(PyObject *v, float *p_arg)
 {
     if (v == NULL) {
         /* Fall through to error return at end of function */
@@ -101,7 +101,7 @@
 }
 
 int
-PyArg_GetFloat(register PyObject *args, int nargs, int i, float *p_arg)
+PyArg_GetFloat(PyObject *args, int nargs, int i, float *p_arg)
 {
     PyObject *v;
     float x;
--- a/Modules/glmodule.c	2019-08-31 14:56:04.501084342 +0200
+++ b/Modules/glmodule.c	2019-08-31 14:59:39.853089681 +0200
@@ -733,10 +733,10 @@
     char *s;
     PyObject *unpacked, *packed;
     int pixcount, packedcount;
-    register unsigned char *p;
-    register unsigned long *parray;
+    unsigned char *p;
+    unsigned long *parray;
     if (!unpacktab_inited) {
-        register int white;
+        int white;
         for (white = 256; --white >= 0; )
             unpacktab[white] = white * 0x010101L;
         unpacktab_inited++;
@@ -770,21 +770,21 @@
     p = (unsigned char *) PyString_AsString(packed);
     if (packfactor == 1 && width*height > 0) {
         /* Just expand bytes to longs */
-        register int x = width * height;
+        int x = width * height;
         do {
             *parray++ = unpacktab[*p++];
         } while (--x >= 0);
     }
     else {
-        register int y;
+        int y;
         for (y = 0; y < height-packfactor+1;
              y += packfactor, parray += packfactor*width) {
-            register int x;
+            int x;
             for (x = 0; x < width-packfactor+1; x += packfactor) {
-                register unsigned long pixel = unpacktab[*p++];
-                register int i;
+                unsigned long pixel = unpacktab[*p++];
+                int i;
                 for (i = packfactor*width; (i-=width) >= 0;) {
-                    register int j;
+                    int j;
                     for (j = packfactor; --j >= 0; )
                         parray[i+x+j] = pixel;
                 }
--- a/Modules/gdbmmodule.c	2019-08-31 14:56:04.502084342 +0200
+++ b/Modules/gdbmmodule.c	2019-08-31 14:59:39.845089681 +0200
@@ -79,7 +79,7 @@
 /* Methods */
 
 static void
-dbm_dealloc(register dbmobject *dp)
+dbm_dealloc(dbmobject *dp)
 {
     if (dp->di_dbm)
         gdbm_close(dp->di_dbm);
@@ -112,7 +112,7 @@
 }
 
 static PyObject *
-dbm_subscript(dbmobject *dp, register PyObject *key)
+dbm_subscript(dbmobject *dp, PyObject *key)
 {
     PyObject *v;
     datum drec, krec;
@@ -179,7 +179,7 @@
 }
 
 static int
-dbm_contains(register dbmobject *dp, PyObject *arg)
+dbm_contains(dbmobject *dp, PyObject *arg)
 {
     datum key;
 
@@ -223,7 +223,7 @@
 Closes the database.");
 
 static PyObject *
-dbm_close(register dbmobject *dp, PyObject *unused)
+dbm_close(dbmobject *dp, PyObject *unused)
 {
     if (dp->di_dbm)
         gdbm_close(dp->di_dbm);
@@ -237,9 +237,9 @@
 Get a list of all keys in the database.");
 
 static PyObject *
-dbm_keys(register dbmobject *dp, PyObject *unused)
+dbm_keys(dbmobject *dp, PyObject *unused)
 {
-    register PyObject *v, *item;
+    PyObject *v, *item;
     datum key, nextkey;
     int err;
 
@@ -280,7 +280,7 @@
 Find out whether or not the database contains a given key.");
 
 static PyObject *
-dbm_has_key(register dbmobject *dp, PyObject *args)
+dbm_has_key(dbmobject *dp, PyObject *args)
 {
     datum key;
 
@@ -298,9 +298,9 @@
 returns the starting key.");
 
 static PyObject *
-dbm_firstkey(register dbmobject *dp, PyObject *unused)
+dbm_firstkey(dbmobject *dp, PyObject *unused)
 {
-    register PyObject *v;
+    PyObject *v;
     datum key;
 
     check_dbmobject_open(dp);
@@ -328,9 +328,9 @@
           k = db.nextkey(k)");
 
 static PyObject *
-dbm_nextkey(register dbmobject *dp, PyObject *args)
+dbm_nextkey(dbmobject *dp, PyObject *args)
 {
-    register PyObject *v;
+    PyObject *v;
     datum key, nextkey;
 
     if (!PyArg_ParseTuple(args, "s#:nextkey", &key.dptr, &key.dsize))
@@ -357,7 +357,7 @@
 kept and reused as new (key,value) pairs are added.");
 
 static PyObject *
-dbm_reorganize(register dbmobject *dp, PyObject *unused)
+dbm_reorganize(dbmobject *dp, PyObject *unused)
 {
     check_dbmobject_open(dp);
     errno = 0;
@@ -378,7 +378,7 @@
 any unwritten data to be written to the disk.");
 
 static PyObject *
-dbm_sync(register dbmobject *dp, PyObject *unused)
+dbm_sync(dbmobject *dp, PyObject *unused)
 {
     check_dbmobject_open(dp);
     gdbm_sync(dp->di_dbm);
